<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[nodejs初级教程]]></title>
      <url>/nodejs%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[RESTful API设计最佳实践]]></title>
      <url>/RESTful-API%E8%AE%BE%E8%AE%A1%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="RESTful-API-设计最佳实践"><a href="#RESTful-API-设计最佳实践" class="headerlink" title="RESTful API 设计最佳实践"></a>RESTful API 设计最佳实践</h2><p>项目资源的URL应该如何设计？用名词复数还是用名词单数？一个资源需要多少个URL？用哪种HTTP方法来创建一个新的资源？可选参数应该放在哪里？那些不涉及资源操作的URL呢？实现分页和版本控制的最好方法是什么？因为有太多的疑问，设计RESTful API变得很棘手。</p>
<h3 id="每个资源使用两个URL"><a href="#每个资源使用两个URL" class="headerlink" title="每个资源使用两个URL"></a>每个资源使用两个URL</h3><p>资源集合用一个URL，具体某个资源用一个URL：</p>
<pre><code>
/employees         #资源集合的URL

/employees/56      #具体某个资源的URL
</code></pre><h3 id="用名词代替动词表示资源"><a href="#用名词代替动词表示资源" class="headerlink" title="用名词代替动词表示资源"></a>用名词代替动词表示资源</h3><p>这让你的API更简洁，URL数目更少。不要这么设计：</p>
<pre><code>
/getAllEmployees

/getAllExternalEmployees

/createEmployee

/updateEmployee
</code></pre><p>更好的设计：</p>
<pre><code>
GET /employees

GET /employees?state=external

POST /employees

PUT /employees/56
</code></pre><h3 id="用HTTP方法操作资源"><a href="#用HTTP方法操作资源" class="headerlink" title="用HTTP方法操作资源"></a>用HTTP方法操作资源</h3><p>使用URL指定你要用的资源。使用HTTP方法来指定怎么处理这个资源。使用四种HTTP方法POST，GET，PUT，DELETE可以提供CRUD功能（创建，获取，更新，删除）。</p>
<ul>
<li><p>获取：使用GET方法获取资源。GET请求从不改变资源的状态。无副作用。GET方法是幂等的。GET方法具有只读的含义。因此，你可以完美的使用缓存。</p>
</li>
<li><p>创建：使用POST创建新的资源。</p>
</li>
<li><p>更新：使用PUT更新现有资源。</p>
</li>
<li><p>删除：使用DELETE删除现有资源。</p>
</li>
</ul>
<p>2个URL乘以4个HTTP方法就是一组很好的功能。看看这个表格：<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fkkbpxeexvj30j803cdfw.jpg" alt=""></p>
<h3 id="对资源集合的URL使用POST方法，创建新资源"><a href="#对资源集合的URL使用POST方法，创建新资源" class="headerlink" title="对资源集合的URL使用POST方法，创建新资源"></a>对资源集合的URL使用POST方法，创建新资源</h3><p>创建一个新资源的时，客户端与服务器是怎么交互的呢？</p>
<p>在资源集合URL上使用POST来创建新的资源过程： </p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkkbsd2qs5j30gh0akt90.jpg" alt=""></p>
<ol>
<li><p>客户端向资源集合URL<code>/employees</code>发送POST请求。HTTP body 包含新资源的属性 “Albert Stark”。</p>
</li>
<li><p>RESTful Web服务器为新员工生成ID，在其内部模型中创建员工，并向客户端发送响应。这个响应的HTTP头部包含一个Location字段，指示创建资源可访问的URL。</p>
</li>
</ol>
<h3 id="对具体资源的URL使用PUT方法，来更新资源"><a href="#对具体资源的URL使用PUT方法，来更新资源" class="headerlink" title="对具体资源的URL使用PUT方法，来更新资源"></a>对具体资源的URL使用PUT方法，来更新资源</h3><p>使用PUT更新已有资源： </p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkkbt00kzkj30gp0ao74j.jpg" alt=""></p>
<ol>
<li><p>客户端向具体资源的URL发送PUT请求<code>/employee/21</code>。请求的HTTP body中包含要更新的属性值（21号员工的新名称“Bruce Wayne”）。</p>
</li>
<li><p>REST服务器更新ID为21的员工名称，并使用HTTP状态码200表示更改成功。</p>
</li>
</ol>
<h3 id="推荐用复数名词"><a href="#推荐用复数名词" class="headerlink" title="推荐用复数名词"></a>推荐用复数名词</h3><p>推荐：</p>
<pre><code>
/employees

/employees/21
</code></pre><p>不推荐：</p>
<pre><code>
/employee

/employee/21
</code></pre><p>事实上，这是个人爱好问题，但复数形式更为常见。此外，在资源集合URL上用GET方法，它更直观，特别是<code>GET /employees?state=external</code>、<code>POST /employees</code>、<code>PUT /employees/56</code>。但最重要的是：避免复数和单数名词混合使用，这显得非常混乱且容易出错。</p>
<p>对可选的、复杂的参数，使用查询字符串（？）。</p>
<p>不推荐做法：</p>
<pre><code>
GET /employees

GET /externalEmployees

GET /internalEmployees

GET /internalAndSeniorEmployees
</code></pre><p>为了让你的URL更小、更简洁。为资源设置一个基本URL，将可选的、复杂的参数用查询字符串表示。</p>
<pre><code>
GET /employees?state=internal&amp;maturity=senior
</code></pre><h3 id="使用HTTP状态码"><a href="#使用HTTP状态码" class="headerlink" title="使用HTTP状态码"></a>使用HTTP状态码</h3><p>RESTful Web服务应使用合适的HTTP状态码来响应客户端请求</p>
<ul>
<li><p>2xx - 成功 - 一切都很好</p>
</li>
<li><p>4xx - 客户端错误 - 如果客户端发生错误（例如客户端发送无效请求或未被授权）</p>
</li>
<li><p>5xx – 服务器错误 - 如果服务器发生错误（例如，尝试处理请求时出错）<br>参考维基百科上的HTTP状态代码。但是，其中的大部分HTTP状态码都不会被用到，只会用其中的一小部分。通常会用到一下几个：</p>
</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkkbtr8ez8j30ir0503ym.jpg" alt=""></p>
<p>除了合适的状态码之外，还应该在HTTP响应正文中提供有用的错误提示和详细的描述。这是一个例子。<br>请求：</p>
<pre><code>
GET /employees?state=super
</code></pre><p>响应：</p>
<pre><code>
// 400 Bad Request

{

    &quot;message&quot;: &quot;You submitted an invalid state. Valid state values are &#39;internal&#39; or &#39;external&#39;&quot;,

    &quot;errorCode&quot;: 352,

    &quot;additionalInformation&quot; : 

    &quot;http://www.domain.com/rest/errorcode/352&quot;

}
</code></pre><h3 id="使用小驼峰命名法"><a href="#使用小驼峰命名法" class="headerlink" title="使用小驼峰命名法"></a>使用小驼峰命名法</h3><p>使用小驼峰命名法作为属性标识符。</p>
<pre><code>
{&quot;yearOfBirth&quot;:1982}
</code></pre><p>不要使用下划线（<code>year_of_birth</code>）或大驼峰命名法（<code>YearOfBirth</code>）。通常，RESTful Web服务将被JavaScript编写的客户端使用。客户端会将JSON响应转换为JavaScript对象（通过调用<code>var person = JSON.parse(response)</code>），然后调用其属性。因此，最好遵循JavaScript代码通用规范。<br>对比：</p>
<pre><code>
person.year_of_birth // 不推荐，违反JavaScript代码通用规范

person.YearOfBirth // 不推荐，JavaScript构造方法命名

person.yearOfBirth // 推荐
</code></pre><h3 id="在URL中强制加入版本号"><a href="#在URL中强制加入版本号" class="headerlink" title="在URL中强制加入版本号"></a>在URL中强制加入版本号</h3><p>从始至终，都使用版本号发布您的RESTful API。将版本号放在URL中以是必需的。如果您有不兼容和破坏性的更改，版本号将让你能更容易的发布API。发布新API时，只需在增加版本号中的数字。这样的话，客户端可以自如的迁移到新API，不会因调用完全不同的新API而陷入困境。<br>使用直观的 “v” 前缀来表示后面的数字是版本号。</p>
<pre><code>
/v1/employees
</code></pre><p>你不需要使用次级版本号（“v1.2”），因为你不应该频繁的去发布API版本。</p>
<p>提供分页信息</p>
<p>一次性返回数据库所有资源不是一个好主意。因此，需要提供分页机制。通常使用数据库中众所周知的参数offset和limit。</p>
<pre><code>
/employees?offset=30&amp;limit=15       #返回30 到 45的员工
</code></pre><p>如果客户端没有传这些参数，则应使用默认值。通常默认值是<code>offset = 0</code>和<code>limit = 10</code>。如果数据库检索很慢，应当减小<code>limit</code>值。</p>
<pre><code>
/employees       #返回0 到 10的员工
</code></pre><p>此外，如果您使用分页，客户端需要知道资源总数。例：<br>请求：</p>
<pre><code>
GET /employees
</code></pre><p>响应：</p>
<pre><code>
{

  &quot;offset&quot;:0,

  &quot;limit&quot;:10,

  &quot;total&quot;:3465,

  &quot;employees&quot;:[

    //...

  ]

}
</code></pre><h3 id="非资源请求用动词"><a href="#非资源请求用动词" class="headerlink" title="非资源请求用动词"></a>非资源请求用动词</h3><p>有时API调用并不涉及资源（如计算，翻译或转换）。例：</p>
<pre><code>
GET /translate?from=de_DE&amp;to=en_US&amp;text=Hallo

GET/calculate?para2=23&amp;para2=432
</code></pre><p>在这种情况下，API响应不会返回任何资源。而是执行一个操作并将结果返回给客户端。因此，您应该在URL中使用动词而不是名词，来清楚的区分资源请求和非资源请求。</p>
<h3 id="考虑特定资源搜索和跨资源搜索"><a href="#考虑特定资源搜索和跨资源搜索" class="headerlink" title="考虑特定资源搜索和跨资源搜索"></a>考虑特定资源搜索和跨资源搜索</h3><p>提供对特定资源的搜索很容易。只需使用相应的资源集合URL，并将搜索字符串附加到查询参数中即可。</p>
<pre><code>
GET /employees?query=Paul
</code></pre><p>如果要对所有资源提供全局搜索，则需要用其他方法。前文提到，对于非资源请求URL，使用动词而不是名词。因此，您的搜索网址可能如下所示：</p>
<pre><code>
GET /search?query=Paul   //返回 employees, customers, suppliers 等等.
</code></pre><h3 id="在响应参数中添加浏览其它API的链接"><a href="#在响应参数中添加浏览其它API的链接" class="headerlink" title="在响应参数中添加浏览其它API的链接"></a>在响应参数中添加浏览其它API的链接</h3><p>理想情况下，不会让客户端自己构造使用REST API的URL。让我们思考一个例子。<br>客户端想要访问员工的薪酬表。为此，他必须知道他可以通过在员工URL（例如<code>/employees/21/salaryStatements</code>）中附加字符串“salaryStatements”来访问薪酬表。这个字符串连接很容易出错，且难以维护。如果你更改了访问薪水表的REST API的方式（例如变成了<code>/employees/21/salary-statement</code>或<code>/employees/21/paySlips</code>），所有客户端都将中断。<br>更好的方案是在响应参数中添加一个<code>links</code>字段，让客户端可以自动变更。<br>请求：</p>
<pre><code>
GET /employees/
</code></pre><p>响应：</p>
<pre><code>
//...

   {

      &quot;id&quot;:1,

      &quot;name&quot;:&quot;Paul&quot;,

      &quot;links&quot;: [

         {

            &quot;rel&quot;: &quot;salary&quot;,

            &quot;href&quot;: &quot;/employees/1/salaryStatements&quot;

         }

      ]

   },

//...
</code></pre><p>如果客户端完全依靠<code>links</code>中的字段获得薪资表，你更改了API，客户端将始终获得一个有效的URL（只要你更改了<code>link</code>字段，请求的URL会自动更改），不会中断。另一个好处是，你的API变得可以自我描述，需要写的文档更少。<br>在分页时，您还可以添加获取下一页或上一页的链接示例。只需提供适当的偏移和限制的链接示例。</p>
<pre><code>
GET /employees?offset=20&amp;limit=10
</code></pre><pre><code>
{

  &quot;offset&quot;:20,

  &quot;limit&quot;:10,

  &quot;total&quot;:3465,

  &quot;employees&quot;:[

    //...

  ],

  &quot;links&quot;: [

     {

        &quot;rel&quot;: &quot;nextPage&quot;,

        &quot;href&quot;: &quot;/employees?offset=30&amp;limit=10&quot;

     },

     {

        &quot;rel&quot;: &quot;previousPage&quot;,

        &quot;href&quot;: &quot;/employees?offset=10&amp;limit=10&quot;

     }

  ]

}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>RESTful api设计可以极大地提高项目管理效率，提高开发</p>
]]></content>
      
        <categories>
            
            <category> 前端架构设计 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端架构设计 </tag>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[三种web会话管理的方式]]></title>
      <url>/%E4%B8%89%E7%A7%8Dweb%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="3-种-web-会话管理的方式"><a href="#3-种-web-会话管理的方式" class="headerlink" title="3 种 web 会话管理的方式"></a>3 种 web 会话管理的方式</h2><p>http是无状态的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。当然它知道是哪个客户端地址发过来的，但是对于我们的应用来说，我们是靠用户来管理，而不是靠客户端。所以对我们的应用而言，它是需要有状态管理的，以便服务端能够准确的知道http请求是哪个用户发起的，从而判断他是否有权限继续这个请求。这个过程就是常说的会话管理。它也可以简单理解为一个用户从登录到退出应用的一段期间。本文总结了3种常见的实现web应用会话管理的方式：</p>
<ol>
<li><p>基于server端session的管理方式</p>
</li>
<li><p>cookie-base的管理方式</p>
</li>
<li><p>token-base的管理方式</p>
</li>
</ol>
<p>这些内容可以帮助加深对web中用户登录机制的理解，对实际项目开发也有参考价值，欢迎阅读与指正。</p>
<h3 id="基于server端session的管理"><a href="#基于server端session的管理" class="headerlink" title="基于server端session的管理"></a>基于server端session的管理</h3><p>在早期web应用中，通常使用服务端session来管理用户的会话。快速了解服务端session:</p>
<ol>
<li><p>服务端session是用户第一次访问应用时，服务器就会创建的对象，代表用户的一次会话过程，可以用来存放数据。服务器为每一个session都分配一个唯一的sessionid，以保证每个用户都有一个不同的session对象。</p>
</li>
<li><p>服务器在创建完session后，会把sessionid通过cookie返回给用户所在的浏览器，这样当用户第二次及以后向服务器发送请求的时候，就会通过cookie把sessionid传回给服务器，以便服务器能够根据sessionid找到与该用户对应的session对象。</p>
</li>
<li><p>session通常有失效时间的设定，比如2个小时。当失效时间到，服务器会销毁之前的session，并创建新的session返回给用户。但是只要用户在失效时间内，有发送新的请求给服务器，通常服务器都会把他对应的session的失效时间根据当前的请求时间再延长2个小时。</p>
</li>
<li><p>session在一开始并不具备会话管理的作用。它只有在用户登录认证成功之后，并且往sesssion对象里面放入了用户登录成功的凭证，才能用来管理会话。管理会话的逻辑也很简单，只要拿到用户的session对象，看它里面有没有登录成功的凭证，就能判断这个用户是否已经登录。当用户主动退出的时候，会把它的session对象里的登录凭证清掉。所以在用户登录前或退出后或者session对象失效时，肯定都是拿不到需要的登录凭证的。</p>
</li>
</ol>
<p>以上过程可简单使用流程图描述如下：<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fkk5mboalij30e2087t8y.jpg" alt=""></p>
<p>主流的web开发平台（java,.net,php）都原生支持这种会话管理的方式，而且开发起来很简单，相信大部分后端开发人员在入门的时候都了解并使用过它。它还有一个比较大的优点就是安全性好，因为在浏览器端与服务器端保持会话状态的媒介始终只是一个sessionid串，只要这个串够随机，攻击者就不能轻易冒充他人的sessionid进行操作；除非通过CSRF或http劫持的方式，才有可能冒充别人进行操作；即使冒充成功，也必须被冒充的用户session里面包含有效的登录凭证才行。但是在真正决定用它管理会话之前，也得根据自己的应用情况考虑以下几个问题：</p>
<ol>
<li><p>这种方式将会话信息存储在web服务器里面，所以在用户同时在线量比较多时，这些会话信息会占据比较多的内存；</p>
</li>
<li><p>当应用采用集群部署的时候，会遇到多台web服务器之间如何做session共享的问题。因为session是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建session的服务器，这样他就拿不到之前已经放入到session中的登录凭证之类的信息了；</p>
</li>
<li><p>多个应用要共享session时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好cookie跨域的处理。</p>
</li>
</ol>
<p>针对问题1和问题2，我见过的解决方案是采用redis这种中间服务器来管理session的增删改查，一来减轻web服务器的负担，二来解决不同web服务器共享session的问题。针对问题3，由于服务端的session依赖cookie来传递sessionid，所以在实际项目中，只要解决各个项目里面如何实现sessionid的cookie跨域访问即可，这个是可以实现的，就是比较麻烦，前后端有可能都要做处理。</p>
<p>如果不考虑以上三个问题，这种管理方式比较值得使用，尤其是一些小型的web应用。但是一旦应用将来有扩展的必要，那就得谨慎对待前面的三个问题。如果真要在项目中使用这种方式，推荐结合单点登录框架如CAS一起用，这样会使应用的扩展性更强。</p>
<h3 id="cookie-based的管理方式"><a href="#cookie-based的管理方式" class="headerlink" title="cookie-based的管理方式"></a>cookie-based的管理方式</h3><p>由于前一种方式会增加服务器的负担和架构的复杂性，所以后来就有人想出直接把用户的登录凭证直接存到客户端的方案，当用户登录成功之后，把登录凭证写到cookie里面，并给cookie设置有效期，后续请求直接验证存有登录凭证的cookie是否存在以及凭证是否有效，即可判断用户的登录状态。使用它来实现会话管理的整体流程如下：</p>
<ol>
<li><p>用户发起登录请求，服务端根据传入的用户密码之类的身份信息，验证用户是否满足登录条件，如果满足，就根据用户信息创建一个登录凭证，这个登录凭证简单来说就是一个对象，最简单的形式可以只包含用户id，凭证创建时间和过期时间三个值。</p>
</li>
<li><p>服务端把上一步创建好的登录凭证，先对它做数字签名，然后再用对称加密算法做加密处理，将签名、加密后的字串，写入cookie。cookie的名字必须固定（如ticket），因为后面再获取的时候，还得根据这个名字来获取cookie值。这一步添加数字签名的目的是防止登录凭证里的信息被篡改，因为一旦信息被篡改，那么下一步做签名验证的时候肯定会失败。做加密的目的，是防止cookie被别人截取的时候，无法轻易读到其中的用户信息。</p>
</li>
<li><p>用户登录后发起后续请求，服务端根据上一步存登录凭证的cookie名字，获取到相关的cookie值。然后先做解密处理，再做数字签名的认证，如果这两步都失败，说明这个登录凭证非法；如果这两步成功，接着就可以拿到原始存入的登录凭证了。然后用这个凭证的过期时间和当前时间做对比，判断凭证是否过期，如果过期，就需要用户再重新登录；如果未过期，则允许请求继续。</p>
</li>
</ol>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fkk5n047egj30e108fglt.jpg" alt=""></p>
<p>这种方式最大的优点就是实现了服务端的无状态化，彻底移除了服务端对会话的管理的逻辑，服务端只需要负责创建和验证登录cookie即可，无需保持用户的状态信息。对于第一种方式的第二个问题，用户会话信息共享的问题，它也能很好解决：因为如果只是同一个应用做集群部署，由于验证登录凭证的代码都是一样的，所以不管是哪个服务器处理用户请求，总能拿到cookie中的登录凭证来进行验证；如果是不同的应用，只要每个应用都包含相同的登录逻辑，那么他们也是能轻易实现会话共享的，不过这种情况下，登录逻辑里面数字签名以及加密解密要用到的密钥文件或者密钥串，需要在不同的应用里面共享，总而言之，就是需要算法完全保持一致。</p>
<p>这种方式由于把登录凭证直接存放客户端，并且需要cookie传来传去，所以它的缺点也比较明显：</p>
<ol>
<li><p>cookie有大小限制，存储不了太多数据，所以要是登录凭证存的消息过多，导致加密签名后的串太长，就会引发别的问题，比如其它业务场景需要cookie的时候，就有可能没那么多空间可用了；所以用的时候得谨慎，得观察实际的登录cookie的大小；比如太长，就要考虑是非是数字签名的算法太严格，导致签名后的串太长，那就适当调整签名逻辑；比如如果一开始用4096位的RSA算法做数字签名，可以考虑换成1024、2048位；</p>
</li>
<li><p>每次传送cookie，增加了请求的数量，对访问性能也有影响；</p>
</li>
<li><p>也有跨域问题，毕竟还是要用cookie。</p>
</li>
</ol>
<p>相比起第一种方式，cookie-based方案明显还是要好一些，目前好多web开发平台或框架都默认使用这种方式来做会话管理，比如php里面yii框架，这是我们团队后端目前用的，它用的就是这个方案，以上提到的那些登录逻辑，框架也都已经封装好了，实际用起来也很简单；asp.net里面forms身份认证，也是这个思路，这里有一篇好文章把它的实现细节都说的很清楚：</p>
<p><a href="http://www.cnblogs.com/fish-li/archive/2012/04/15/2450571.html" target="_blank" rel="external">http://www.cnblogs.com/fish-li/archive/2012/04/15/2450571.html</a></p>
<p>前面两种会话管理方式因为都用到cookie，不适合用在native app里面：native app不好管理cookie，毕竟它不是浏览器。这两种方案都不适合用来做纯api服务的登录认证。要实现api服务的登录认证，就要考虑下面要介绍的第三种会话管理方式。</p>
<h3 id="token-based的管理方式"><a href="#token-based的管理方式" class="headerlink" title="token-based的管理方式"></a>token-based的管理方式</h3><p>这种方式从流程和实现上来说，跟cookie-based的方式没有太多区别，只不过cookie-based里面写到cookie里面的ticket在这种方式下称为token，这个token在返回给客户端之后，后续请求都必须通过url参数或者是http header的形式，主动带上token，这样服务端接收到请求之后就能直接从http header或者url里面取到token进行验证：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkk5o3um32j30ef07bq34.jpg" alt=""></p>
<p>这种方式不通过cookie进行token的传递，而是每次请求的时候，主动把token加到http header里面或者url后面，所以即使在native app里面也能使用它来调用我们通过web发布的api接口。app里面还要做两件事情：</p>
<ol>
<li><p>有效存储token，得保证每次调接口的时候都能从同一个位置拿到同一个token；</p>
</li>
<li><p>每次调接口的的代码里都得把token加到header或者接口地址里面。</p>
</li>
</ol>
<p>看起来麻烦，其实也不麻烦，这两件事情，对于app来说，很容易做到，只要对接口调用的模块稍加封装即可。</p>
<p>这种方式同样适用于网页应用，token可以存于localStorage或者sessionStorage里面，然后每发ajax请求的时候，都把token拿出来放到ajax请求的header里即可。不过如果是非接口的请求，比如直接通过点击链接请求一个页面这种，是无法自动带上token的。所以这种方式也仅限于走纯接口的web应用。</p>
<p>这种方式用在web应用里也有跨域的问题，比如应用如果部署在a.com，api服务部署在b.com，从a.com里面发出ajax请求到b.com，默认情况下是会报跨域错误的，这种问题可以用CORS（跨域资源共享）的方式来快速解决，相关细节可去阅读前面给出的CORS文章详细了解。</p>
<p>这种方式跟cookie-based的方式同样都还有的一个问题就是ticket或者token刷新的问题。有的产品里面，你肯定不希望用户登录后，操作了半个小时，结果ticket或者token到了过期时间，然后用户又得去重新登录的情况出现。这个时候就得考虑ticket或token的自动刷新的问题，简单来说，可以在验证ticket或token有效之后，自动把ticket或token的失效时间延长，然后把它再返回给客户端；客户端如果检测到服务器有返回新的ticket或token，就替换原来的ticket或token。</p>
<h3 id="安全问题在web应用里面，会话管理的安全性始终是最重要的安全问题，这个对用户的影响极大。"><a href="#安全问题在web应用里面，会话管理的安全性始终是最重要的安全问题，这个对用户的影响极大。" class="headerlink" title="安全问题在web应用里面，会话管理的安全性始终是最重要的安全问题，这个对用户的影响极大。"></a>安全问题在web应用里面，会话管理的安全性始终是最重要的安全问题，这个对用户的影响极大。</h3><p>首先从会话管理凭证来说，第一种方式的会话凭证仅仅是一个session id，所以只要这个session id足够随机，而不是一个自增的数字id值，那么其它人就不可能轻易地冒充别人的session id进行操作；第二种方式的凭证（ticket）以及第三种方式的凭证（token）都是一个在服务端做了数字签名，和加密处理的串，所以只要密钥不泄露，别人也无法轻易地拿到这个串中的有效信息并对它进行篡改。总之，这三种会话管理方式的凭证本身是比较安全的。</p>
<p>然后从客户端和服务端的http过程来说，当别人截获到客户端请求中的会话凭证，就能拿这个凭证冒充原用户，做一些非法操作，而服务器也认不出来。这种安全问题，可以简单采用https来解决，虽然可能还有http劫持这种更高程度的威胁存在，但是我们从代码能做的防范，确实也就是这个层次了。</p>
<p>最后的安全问题就是CSRF（跨站请求伪造）。这个跟代码有很大关系，本质上它就是代码的漏洞，只不过一般情况下这些漏洞，作为开发人员都不容易发现，只有那些一门心思想搞些事情的人才会专门去找这些漏洞，所以这种问题的防范更多地还是依赖于开发人员对这种攻击方式的了解，包括常见的攻击形式和应对方法。不管凭证信息本身多么安全，别人利用CSRF，就能拿到别人的凭证，然后用它冒充别人进行非法操作，所以有时间还真得多去了解下它的相关资料才行。举例来说，假如我们把凭证直接放到url后面进行传递，就有可能成为一个CSRF的漏洞：当恶意用户在我们的应用内上传了1张引用了他自己网站的图片，当正常的用户登录之后访问的页面里面包含这个图片的时候，由于这个图片加载的时候会向恶意网站发送get请求；当恶意网站收到请求的时候，就会从这个请求的Reffer header里面看到包含这个图片的页面地址，而这个地址正好包含了正常用户的会话凭证；于是恶意用户就拿到了正常用户的凭证；只要这个凭证还没失效，他就能用它冒充用户进行非法操作。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>总结前面这三种方式，各自有各自的优点及使用场景，我觉得没有哪个是最好的，做项目的时候，根据项目将来的扩展情况和架构情况，才能决定用哪个是最合适的。本文的目的也就是想介绍这几种方式的原理，以便掌握web应用中登录验证的关键因素。</p>
<p>作为一个前端开发人员，本文虽然介绍了3种会话管理的方式，但是与前端关系最紧密的还是第三种方式，毕竟现在前端开发SPA应用以及hybrid应用已经非常流行了，所以掌握好这个方式的认证过程和使用方式，对前端来说，显然是很有帮助的。好在这个方式的技术其实早就有很多实现了，而且还有现成的标准可用，这个标准就是JWT(json-web-token)。</p>
<p>JWT本身并没有做任何技术实现，它只是定义了token-based的管理方式该如何实现，它规定了token的应该包含的标准内容以及token的生成过程和方法。目前实现了这个标准的技术已经有非常多。</p>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[react实战--打造画廊项目]]></title>
      <url>/react%E5%AE%9E%E6%88%98-%E6%89%93%E9%80%A0%E7%94%BB%E5%BB%8A%E9%A1%B9%E7%9B%AE.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用yeoman+bower+gulp+webpack等前端自动化解决方案来构建react+sass的前端画廊应用。<br><em>这是画廊项目的效果图，点击相应的图片，图片会居中显示</em></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fkncvudbztj30zb0jpac2.jpg" alt=""></p>
<p><img src="http://ww4.sinaimg.cn/mw690/e75a115bgw1f3rrbzv1m8g209v0diqv7.gif" alt=""></p>
<h2 id="yeoman脚手架生成项目初始的代码结构"><a href="#yeoman脚手架生成项目初始的代码结构" class="headerlink" title="yeoman脚手架生成项目初始的代码结构"></a>yeoman脚手架生成项目初始的代码结构</h2><ul>
<li>首先安装nodejs环境，请自行百度～ </li>
<li>安装yeoman<pre><code>npm install yo -g
</code></pre>如果有童鞋对yeoman不是很了解，请看我以前的博客<a href="http://pancakeawesome.ink/2017/09/29/yeoman+bower+gulp-grunt%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/">yeoman+bower+gulp-grunt构建现代化前端项目</a></li>
<li>去yeoman官网去搜寻基于webpack的react的项目生成器（generator）<br>安装generator:<pre><code>npm install -g generator-react-webpack
</code></pre><strong>TIPS：如何查看全局环境下npm安装的模块</strong><pre><code>npm ls -g --depth=1 2&gt;/dev/null | grep generator-
</code></pre><em>depth=1：因为npm中各个模块都是有依赖关系的，所以npm会以树状图的形式显示所有模块</em><br><em>2&gt;/dev/null:表示将执行bash命令过程中的错误输出到null设备中，<strong>注意：npm经常会报错。</strong>这里的设备是null，也就是空设备，意思是错误将不会展现出来。</em><br><em>grep generator：表示输出的内容仅显示generator开头的内容</em></li>
<li>在github等代码托管平台中生成一个仓库，将项目down下来。</li>
<li>进入项目的文件夹，用yeoman生成react的初始项目结构：</li>
</ul>
<pre><code>yo react-webpack &lt;项目名称&gt;
</code></pre><p><em>国内使用npm下载包实在太慢，建议使用淘宝源下载软件</em><br><strong>使用cnpm替换npm下载包：</strong></p>
<pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fkkfh53akkj31340k3jt2.jpg" alt=""></p>
<p><strong>通常生成项目初始结构很慢，耐心等待</strong></p>
<h3 id="项目根目录结构："><a href="#项目根目录结构：" class="headerlink" title="项目根目录结构："></a>项目根目录结构：</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkkfz14akcj30460anjre.jpg" alt=""></p>
<ul>
<li>babelrc: es6相关的配置。</li>
<li>node_modules:项目编译所需的node组件所在的目录。</li>
<li>cfg:<strong>类比于webpack.config文件中的webpack配置信息：</strong></li>
</ul>
<pre><code>/**
 * Build the webpack configuration
 * @param  {String} wantedEnv The wanted environment
 * @return {Object} Webpack config
 */
function buildConfig(wantedEnv) {
  let isValid = wantedEnv &amp;&amp; wantedEnv.length &gt; 0 &amp;&amp; allowedEnvs.indexOf(wantedEnv) !== -1;
  let validEnv = isValid ? wantedEnv : &#39;dev&#39;;
  let config = require(path.join(__dirname, &#39;cfg/&#39; + validEnv));
  return config;
}

module.exports = buildConfig(env);
</code></pre><p><em>这段webpack.config.js文件中的代码表明用cfg文件夹中相应环境的代码去完成webpack的配置</em></p>
<ul>
<li>dist: dist环境的目录。</li>
<li>src：源代码所在目录。</li>
<li>test：测试代码所在目录。</li>
<li>editorconfig：用来统一不同编辑器，ide的代码编辑风格。写代码的同时，自动将你的代码格式统一为editorconfig支持的编辑器的格式。<em>支持很多编辑器和ide，<a href="http://editorconfig.org/" target="_blank" rel="external">官网</a></em></li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fkkgqbin8cj30lr0hdgme.jpg" alt=""></p>
<ul>
<li>gitignore:git仓库相关的配置文件。</li>
<li>eslintrc/jshintrc:代码风格检测工具🔧，eslint比jshint多支持jsx语法。</li>
<li>yo-rc.json：yeoman的配置文件，用来记录当前项目的信息。</li>
<li>karma.conf.js:karma测试框架的配置文件。</li>
<li>package.json:node项目的配置文件，声明当前的项目的信息，依赖了哪些npm包等等。</li>
<li>webpack.config.js：webpack的配置文件。</li>
</ul>
<h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>在pacakge.json文件中已经配置好了：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fkkh9uo9w3j30ka03bt8u.jpg" alt=""></p>
<pre><code>npm start 或者
npm run serve
</code></pre><p><strong>源代码结构</strong></p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkkhfhh7c7j304506nt8l.jpg" alt=""></p>
<ul>
<li>favicon.ico:项目首页的图标，通常放在项目根目录。</li>
<li>index.html:项目的入口文件。<br>在index页面中有这么一个脚本，这个脚本和chrome的扩展插件 react developer tools有关。<br><em>react developer tools：是chrome浏览器的一款扩展插件，可以很方便地用来调试react代码。下载地址：chrome应用商店搜索<strong>react developer tools</strong></em></li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fkmho8iwabj30ol07cq36.jpg" alt=""></p>
<p><strong>而react developer tools的工作原理是页面加载的时候，通过<code>__REACT_DEVTOOLS_GLOBAL_HOOK__</code>这个全局变量和页面通信。而我们项目的真实代码其实是写在一个yeoman自带的框架页面之中，也就是一个iframe，这个<code>__REACT_DEVTOOLS_GLOBAL_HOOK__</code>变量其实是存在顶层的框架页面中，如果我们需要在我们的iframe页面中使用这个这个插件，就得重新取得这个全局变量，以供插件来通信。</strong></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fkmhtkh4kuj30mc07bglx.jpg" alt=""></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fkkhieotwnj30mh01zt8p.jpg" alt="这里的parent代表的顶层页面window变量"></p>
<h3 id="webpack配置详解"><a href="#webpack配置详解" class="headerlink" title="webpack配置详解"></a>webpack配置详解</h3><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> react </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 前端工具 </tag>
            
            <tag> react </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[compass重要功能之精灵图合图]]></title>
      <url>/compass%E9%87%8D%E8%A6%81%E5%8A%9F%E8%83%BD%E4%B9%8B%E7%B2%BE%E7%81%B5%E5%9B%BE%E5%90%88%E5%9B%BE.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>精灵图合图相关功能集合。可以说是compass在日常工程中的最佳实践，非常实用也非常重要。<br><strong>想象一下设计人员（通常是漂亮的小姐姐们～不好意思责怪人家呀=。=）将sprites图中的一个图标，并且很有可能影响到了其他的图标，开发人员就要吐血地在项目中修改所有被影响的样式代码，这真的是巨痛苦无比呀</strong><br><strong>而有了compass的精灵图合图功能，我们只需要将项目中用想要合图的图片文件（现在只支持png格式的文件）放到一个相应的目录下，compass将会自动帮我们把图片文件生成为一个雪碧图，无论这些文件怎么变化，我们都不需要再去更改代码中的内容！</strong><br>精灵图合图可以说是compass的最重要的功能模块，我这里说下我的理解。<br>compass相关的知识请进<a href="http://pancakeawesome.ink/2017/09/28/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E4%B9%8Bcompass/">传送门</a></p>
<h2 id="在compass项目中使用精灵合图功能"><a href="#在compass项目中使用精灵合图功能" class="headerlink" title="在compass项目中使用精灵合图功能"></a>在compass项目中使用精灵合图功能</h2><h3 id="在项目中引入sprites模块"><a href="#在项目中引入sprites模块" class="headerlink" title="在项目中引入sprites模块"></a>在项目中引入sprites模块</h3><ul>
<li>在scss目录下新建一个_icons.scss文件来专门处理项目的雪碧图（个人习惯，也可以写在screen.scss中）</li>
<li>在screen.scss文件中引入_icons.scss，不知道screen.scss文件作用的同学请看我的上一篇<a href="http://pancakeawesome.ink/2017/09/28/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E4%B9%8Bcompass/">博客</a><br>引入sprites模块<pre><code>_icons.scss文件中：
@import &#39;compass/utilities/sprites&#39;;
</code></pre></li>
<li>将一些logo文件放入images文件夹下的logo文件夹，用来作为合图的资源。并在_icons.scss文件中引入。<br><strong>compass会在合图文件夹下生成一个不被写入硬盘的隐藏SCss文件</strong>引这种入方式在compass中被称为<strong>compass import</strong><pre><code>@import &quot;logo/*.png&quot;;
</code></pre><em>意思是引入logo文件夹下的所有格式是png的图片文件，后面字符是compass为合图文件添加的cache-buster</em><br>编译项目，可以看见images文件夹下生成了一张合图文件。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fkfqhk9vakj306w04zmx5.jpg" alt=""></li>
<li>调用all-<code>合图文件的最后一级目录名</code>-sprites这个mixin<pre><code>@include all-logo-sprites()
</code></pre>编译之后，我们会发现相应的css文件中会自动根据合图文件生成一个一个对应的样式类。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fkfqmypiezj30nh0hzaat.jpg" alt=""><br><strong>那么这个mixin是从哪来的呢？</strong><br>其实就是在上面那句<strong>magic import生成的隐藏scss文件中</strong><h3 id="使用合图"><a href="#使用合图" class="headerlink" title="使用合图"></a>使用合图</h3>在index文件中给元素添加生成的相应的css样式即可。<h4 id="其他样式类的元素应用特定的图片样式？"><a href="#其他样式类的元素应用特定的图片样式？" class="headerlink" title="其他样式类的元素应用特定的图片样式？"></a>其他样式类的元素应用特定的图片样式？</h4>只需给相应的样式引入logo-sprite(<code>$图片名</code>)<pre><code>/*
  其余类想使用某张图片，可以不使用这个类名，直接引入图片类即可
*/
.main-logo {
  @include logo-sprite(&#39;btn&#39;);
}
</code></pre><h4 id="元素不同状态下显示不同的图片？"><a href="#元素不同状态下显示不同的图片？" class="headerlink" title="元素不同状态下显示不同的图片？"></a>元素不同状态下显示不同的图片？</h4>只要将合图资源文件命名为<code>文件名_hover</code>的格式（或者<code>active</code>），compass就会自动生成图片设置为<code>文件名</code>样式的不同状态的css。<br><strong><code>-</code>也可以</strong><br><strong>以下代码可以消除以上伪类形容不同状态样式的功能</strong><pre><code>/*
  是否关闭精灵图合图模块默认的伪类样式
*/
$disable-magic-sprite-selectors: true;
</code></pre><h4 id="设置精灵合的排列布局"><a href="#设置精灵合的排列布局" class="headerlink" title="设置精灵合的排列布局"></a>设置精灵合的排列布局</h4>设置<code>logo-layout</code>变量</li>
<li>vertical(垂直（默认布局方式）)</li>
<li>horizontal(水平)</li>
<li>diagonal(斜对角线)</li>
<li>smart(最节省空间的布局方式)<pre><code>/*
  精灵合图的默认排列方式
*/
$logo-layout: smart;
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>compass的精灵图合图功能在实际项目过程中时非常有用的功能，希望大家都能掌握这种技能～谢谢🙏观看～</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端工具，前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[yeoman+bower+gulp/grunt构建现代化前端项目]]></title>
      <url>/yeoman+bower+gulp-grunt%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE.html</url>
      <content type="html"><![CDATA[<p><del>待更新</del></p>
]]></content>
      
        <categories>
            
            <category> 前端工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端必备技能之compass]]></title>
      <url>/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E4%B9%8Bcompass.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先介绍下<a href="http://compass-style.org/" target="_blank" rel="external">compass</a>，compass是一款优秀的开源的<strong>css书写框架</strong>，什么叫书写框架呢？众所周知，<code>sass</code>中有很多便捷的语法特性，比如<code>mixin</code>,<code>function</code>等，<code>compass</code>正是一个强大的函数仓库，compass封装了很多在平常工程过程中能用到的css效果的函数，比如清楚浮动，设置表格样式等等。<br><em>至于sass和css之间的关系请看我的上篇<a href="http://pancakeawesome.ink/2017/09/18/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8sass/">博客</a></em>，讲的很详细。<br><strong>这里是我写的一个compass的demo，可以对照着看</strong><br><strong>如果把<code>sass</code>必做钉子，那么<code>compass</code>就是一个锤子🔨，可以方便快捷地构建你的<code>css</code>工程化代码</strong></p>
<h2 id="compass的安装-amp-amp-项目的构建"><a href="#compass的安装-amp-amp-项目的构建" class="headerlink" title="compass的安装&amp;&amp;项目的构建"></a>compass的安装&amp;&amp;项目的构建</h2><h3 id="compass的安装"><a href="#compass的安装" class="headerlink" title="compass的安装"></a>compass的安装</h3><p>如果你是<code>Mac os</code>系统，那么你的电脑预装了ruby的环境，那么就会有<code>gem</code>这个ruby的包管理器。如果你的电脑是windows的，那么请先安装<code>ruby</code>，具体安装方法我就不赘述了，请大家自行谷歌。</p>
<pre><code>gem install compass
</code></pre><p><em>如果大家在gem install过程中发现速度很慢，甚至卡住了</em>，请谷歌：<strong>gem源</strong>，具体原因我就不说了=,=</p>
<h3 id="compass项目的运行"><a href="#compass项目的运行" class="headerlink" title="compass项目的运行"></a>compass项目的运行</h3><ul>
<li>正式编译，<strong>会将项目目录下的<code>scss</code>文件编译成<code>css</code>文件并执行scss文件中的函数在</strong>命令行环境下：<pre><code>compass compile
</code></pre><em>加上<code>--force</code>会强制编译</em></li>
<li>自动编译，会自动监听文件的更改而随之编译文件。<pre><code>compass watch
</code></pre><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3>下面通过compass搭建你的项目：<pre><code>compass create &lt;project name&gt;
</code></pre>成功之后你会在命令行中查看到compass项目成功搭建的提示：<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fk0rttcy1sj30z70k4ack.jpg" alt=""><br>看一下项目的目录:<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fk0rv00m1dj308b04t0sk.jpg" alt=""><br>这就是compass构建的项目初始目录<h2 id="compass的各大模块"><a href="#compass的各大模块" class="headerlink" title="compass的各大模块"></a>compass的各大模块</h2>compass中有各个功能不一的模块，每个模块都封装了大量的minxin和function。<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fk0s3r3nlpj30ry0dfjrx.jpg" alt=""><br><strong>其中reset模块和layout模块是特殊的核心模块，需要单独制定引入</strong>，<strong>而其他五大模块则只需要引入compass，就自动引入了</strong><pre><code>@import &#39;compass&#39;;
</code></pre><em>下面就分别介绍一下各个核心模块，但是由于精力有限，每个模块我只会介绍一些项目开发过程中常见的功能函数，其他的函数，请直接移步compass的 api <a href="http://compass-style.org/reference/compass/css3/" target="_blank" rel="external">doc</a></em><h2 id="reset模块"><a href="#reset模块" class="headerlink" title="reset模块"></a>reset模块</h2>reset模块是负责将浏览器默认样式统一，以减少浏览器之间差异性。<h3 id="reset模块引入"><a href="#reset模块引入" class="headerlink" title="reset模块引入"></a>reset模块引入</h3>/sass/screen.ccss文件中：<br><strong>screen.scss文件负责站点主体的样式</strong><pre><code>@import &quot;compass/reset&quot;;
</code></pre><h3 id="css样式效果展示"><a href="#css样式效果展示" class="headerlink" title="css样式效果展示"></a>css样式效果展示</h3><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fk0sic433gj30vb0izwg9.jpg" alt=""><h3 id="normalize模块"><a href="#normalize模块" class="headerlink" title="normalize模块"></a>normalize模块</h3><strong>用normalize模块来代替compass默认的reset模块</strong><br>其实可以看出reset模块很粗暴，它会把所有浏览器默认属性重置，这样在实际工程中回造成很多麻烦，我们可以很方便的normalize模块来替代reset,normalize模块会将大多数常用到的标签属性重置。<h4 id="normalize模块-1"><a href="#normalize模块-1" class="headerlink" title="normalize模块"></a>normalize模块</h4>normalize常用的子模块有：</li>
<li>html5模块：用来统一html5属性</li>
<li>base：用来统一一般的html属性</li>
<li>links:用来统一<code>&lt;a&gt;</code>标签相关的属性<h4 id="normalize的安装"><a href="#normalize的安装" class="headerlink" title="normalize的安装"></a>normalize的安装</h4><pre><code>gem install normalize
</code></pre><em>用homebrew，npm也可以安装</em></li>
</ul>
<h4 id="normalize的引入"><a href="#normalize的引入" class="headerlink" title="normalize的引入"></a>normalize的引入</h4><ul>
<li>在工程目录下的<code>config.rb</code>下将normalize通过require语法引入<pre><code>require &#39;compass-normalize&#39;
</code></pre></li>
<li>在screen.scss文件中将normalize模块引入<pre><code>/*
  引入normalize模块
*/
@import &quot;normalize&quot;;
</code></pre><strong>screen.css文件中的生成效果</strong><br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fk0t5ugeiaj30us0gqaat.jpg" alt=""><br>你也可以根据需求分别引入normalize的各个子模块:<br><strong>注意：如果要引入子模块，必须要先引入normalize-version模块</strong><pre><code>/*
  引入normalize子模块之前需要引入normalize-version
*/
@import &quot;normalize-version&quot;;
/*
  normalize子模块一
*/
@import &quot;normalize/html5&quot;;
/*
  normalize子模块二
*/
@import &quot;normalize/base&quot;;
/*
  normalize子模块三
*/
@import &quot;normalize/links&quot;;
</code></pre>具体这些子模块的作用可以去去normalize的官网去查看<a href="https://necolas.github.io/normalize.css/" target="_blank" rel="external">doc</a><br><code>screen.css</code>文件的显示效果:(以html5模块举例)<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fk0tb4jv4lj30vi0ie0tp.jpg" alt=""><h2 id="layout模块"><a href="#layout模块" class="headerlink" title="layout模块"></a>layout模块</h2>如果说reset模块事使用起来最简单的模块（因为只需引进来即可，不需要多余操作），那么layout模块就是使用率最低的模块。layout模块提供页面的布局控制能力。<br><strong>layout模块不属于compass自带的模块，需要在scss文件中单独引入</strong><br>layout模块又分为三个子模块：</li>
<li>grid-background</li>
<li>sticky-footer</li>
<li>stretching<h3 id="grid-background模块："><a href="#grid-background模块：" class="headerlink" title="grid-background模块："></a>grid-background模块：</h3>提供为元素提供定宽定高或者自适应格式宽高的背景的功能。<br><strong>这个功能不常用，在webapp电子书在线阅读等场景需求下可以用到，有需要的去doc仔细看看</strong></li>
<li>引入：<pre><code>@import &#39;compass/layout/grid-background&#39;;
</code></pre></li>
<li>相关mixin：<ul>
<li><strong>grid-background($total, $column, $gutter, $baseline, $offset, $column-color, $gutter-color, $baseline-color, $force-fluid)</strong><ul>
<li>功能：提供为元素提供定宽定高或者自适应格式宽高的背景的功能</li>
<li>参数：</li>
<li>示例：<pre><code>screen.scss文件:
/*
grid-background模块
*/
#root {
@include grid-background();
}
</code></pre>screen.css文件中:<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fk5dydolwaj30tu0gugoy.jpg" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="stretching模块："><a href="#stretching模块：" class="headerlink" title="stretching模块："></a>stretching模块：</h3><p>提供子元素拉伸填满整个父元素的能力。</p>
<ul>
<li>引入：<pre><code>@import &#39;compass/layout/stetching&#39;;
</code></pre></li>
<li>相关mixin：<ul>
<li><strong>stretch($offset-top, $offset-right, $offset-bottom, $offset-left)</strong><ul>
<li>功能：将子元素填满父元素</li>
<li>参数：绝对定位上右下左的位置</li>
<li>示例：<pre><code>screen.scss文件:
/*
stretching模块
*/
.stretch-full {
@include stretch();
}
screen.css文件中:
/* line 119, ../sass/screen.scss */
.stretch-full {
position: absolute;
top: 0;
bottom: 0;
left: 0;
right: 0;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="sticky-footer模块"><a href="#sticky-footer模块" class="headerlink" title="sticky-footer模块"></a>sticky-footer模块</h3><p>提供页面中的页脚始终在页面最底部的功能：<br>提供子元素拉伸填满整个父元素的能力。</p>
<ul>
<li>引入：<ul>
<li>在html文件中引入以下标签：<pre><code>&lt;body&gt;
&lt;div id=&quot;root&quot;&gt;
&lt;div id=&quot;root_footer&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;footer&quot;&gt;
Footer content goes here.
&lt;/div&gt;
&lt;/body&gt;
</code></pre></li>
<li>在screen.scss文件中引入footer模块<pre><code>@import &#39;compass/layout/sticky-footer&#39;;
</code></pre></li>
</ul>
</li>
<li>相关mixin：<ul>
<li><strong>sticky-footer($footer-height, $root-selector, $root-footer-selector, $footer-selector)</strong><ul>
<li>功能：当主体内容不超过浏览器窗口大小时，页脚始终在窗口底部；当主体内容超过浏览器窗口大小时，页脚将随浏览器内容在页面底部</li>
<li>参数：footer的高度</li>
<li>示例：<pre><code>screen.scss文件:
/*
sticky-footer模块
*/
@include sticky-footer(30px);
screen.css文件中:
html, body {
height: 100%;
}
#root {
clear: both;
min-height: 100%;
height: auto !important;
height: 100%;
margin-bottom: -30px;
}
#root #root_footer {
height: 30px;
}
#footer {
clear: both;
position: relative;
height: 30px;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="css3-amp-amp-browser-support模块"><a href="#css3-amp-amp-browser-support模块" class="headerlink" title="css3&amp;&amp;browser support模块"></a>css3&amp;&amp;browser support模块</h2><p>css3模块:提供css3特性的一些功能函数，support模块提供规定compass支持哪些浏览器的功能。如果说layout模块使用率最低，那么css3一定是主动使用率最高的模块，因为我们在使用css特性时，都会用到browser support模块来做浏览器的兼容,配置compass模块默认支持哪些浏览器。<br>引入css3模块：</p>
<pre><code>@import &quot;compass/css3&quot;;
</code></pre><p>引入browser support模块：<br><em>其实可以不用引入，因为css3模块自动引入support模块</em></p>
<pre><code>@import &quot;compass/support&quot;;
</code></pre><h3 id="常用的browser-support子功能："><a href="#常用的browser-support子功能：" class="headerlink" title="常用的browser support子功能："></a>常用的browser support子功能：</h3><p><strong>介绍一些常用的，其他的请看官网的doc</strong></p>
<ul>
<li><strong>browsers()</strong><ul>
<li>返回值是compass目前版本支持的浏览器list</li>
</ul>
</li>
<li><strong>$supported-browsers: chrome,ie</strong><ul>
<li>功能：声明compass支持的浏览器list</li>
<li>参数：浏览器的list（逗号分隔）</li>
</ul>
</li>
<li><strong>$browser-minimum-versions: (“ie”: “8”);</strong><ul>
<li>功能：声明compass支持的最低浏览器版本</li>
<li>参数：浏览器和版本号对应的键值对（map形式）</li>
</ul>
</li>
</ul>
<h3 id="常用的css3子功能："><a href="#常用的css3子功能：" class="headerlink" title="常用的css3子功能："></a>常用的css3子功能：</h3><p><strong>介绍一些常用的，其他的请看官网的doc</strong><br><strong>所有的css属性的编译结果（css文件中）都是依照support模块设置的浏览器版本</strong><br><em>我的实例结果都是在没有设置support中的功能前提下而得出的</em></p>
<ul>
<li><p><strong>box-shadow</strong></p>
<ul>
<li>box-shadow()<ul>
<li>功能：添加元素的box-shadow样式，并自动根据browsersupport中的浏览器，添加浏览器前缀</li>
<li>参数：上右下左边框阴影样式的高度和颜色</li>
<li>示例：<pre><code>screen.scss文件:
.webdemo-sec {
@include box-shadow(1px 2px 3px 4px #cfcecf);
}
screen.css文件中:
.webdemo-sec {
-moz-box-shadow: 1px 2px 3px 4px #cfcecf;
-webkit-box-shadow: 1px 2px 3px 4px #cfcecf;
box-shadow: 1px 2px 3px 4px #cfcecf;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>opacity</strong></p>
<ul>
<li>opacity($opacity)<ul>
<li>功能：提供元素透明度样式的功能</li>
<li>参数：透明度</li>
<li>示例：<pre><code>screen.scss文件:
.opacity-test {
@include opacity(.5);
}
screen.css文件中:
.opacity-test {
filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=50);
opacity: 0.5;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>inline-block</strong></p>
<ul>
<li>inline-block($alignment, $ie-alignment)<ul>
<li>功能：提供元素display是inline-block的功能（兼容）</li>
<li>参数：</li>
<li>示例：<pre><code>screen.scss文件:
.inlineblock-test {
@include inline-block();
}
screen.css文件中:
.inlineblock-test {
display: inline-block;
vertical-align: middle;
*vertical-align: auto;
*zoom: 1;
*display: inline;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>flex</strong><br><strong>提供相关flexbox布局特性的功能并做浏览器兼容，这个我经常用到很好用</strong></p>
<ul>
<li>相关mixin<ul>
<li>display-flex($display)</li>
<li>flex-direction($direction)</li>
<li>justify-content($justify-content)</li>
<li>align-items($align-items)</li>
<li>功能：提供相关flexbox布局特性的功能并做浏览器兼容</li>
<li>参数：</li>
<li>示例：<pre><code>screen.scss文件:
.flex-test {
@include display-flex();
@include flex-direction(row);
@include justify-content(center);
@include align-items(center);
}
screen.css文件中:
.flex-test {
display: -webkit-flex;
display: flex;
-webkit-flex-direction: row;
flex-direction: row;
-webkit-justify-content: center;
justify-content: center;
-webkit-align-items: center;
align-items: center;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="typography模块"><a href="#typography模块" class="headerlink" title="typography模块"></a>typography模块</h2><p>typography模块主要用来修饰文本样式，垂直韵律等。<br>typography又分为四个子模块：</p>
<ul>
<li>links</li>
<li>list</li>
<li>text</li>
<li>vertical rhythm</li>
</ul>
<p>引入typography模块：</p>
<pre><code>@import &quot;compass/typography&quot;;
</code></pre><h3 id="links子模块："><a href="#links子模块：" class="headerlink" title="links子模块："></a>links子模块：</h3><p>修饰<code>&lt;a&gt;</code>标签超链接的样式。<br>我们对<code>&lt;a&gt;</code>标签通常有两种场景修饰它的样式：</p>
<ul>
<li><p><strong>hover-link()</strong></p>
<ul>
<li>功能：正常状态下掉下划线，hover和focus状态下才显示a标签的下划线<ul>
<li>参数：</li>
<li>示例：<pre><code>screen.scss文件:
a {
@include hover-link(); 
}
screen.css文件中:
a {
text-decoration: none;
}
a:hover, a:focus {
text-decoration: underline;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>不同状态下改变a标签的颜色</p>
<ul>
<li><strong>link-colors($normal, $hover, $active, $visited, $focus)</strong><ul>
<li>功能：修改不同状态下超链接的颜色</li>
<li>参数：不同状态下超链接的颜色，只有第一个参数是必须的</li>
<li>示例：<pre><code>screen.scss文件:
a {
@include link-colors(#cc0, #c0c, #0cc, #00c, #c00);
}
screen.css文件中:
a {
color: #cc0;
}
a:visited {
color: #00c;
}
a:focus {
color: #c00;
}
a:hover {
color: #c0c;
}
a:active {
color: #0cc;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>unstyled-link()</strong></p>
<pre><code>  -     功能：消除超链接原来的样式，让其在非正常状态的样式和其所在文本一样
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
a {
  @include unstyled-link();
}
screen.css文件中:
a {
color: inherit;
text-decoration: inherit;
cursor: inherit;
}
a:active, a:focus {
outline: none;
}
</code></pre></li>
</ul>
<h3 id="list子模块"><a href="#list子模块" class="headerlink" title="list子模块"></a>list子模块</h3><p>修饰<code>ul</code>和<code>ol</code>列表的样式。</p>
<ul>
<li><p><strong>no-bullets()</strong></p>
<pre><code>  -     功能：消除`ul`和`ol`元素之前所有`li`的默认点的样式。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.list-unstyled {
  @include no-bullets();
}
screen.css文件中:
.list-unstyled {
list-style: none;
}
.list-unstyled li {
list-style-image: none;
list-style-type: none;
margin-left: 0;
}
</code></pre></li>
<li><p><strong>no-bullet()</strong></p>
<pre><code>  -     功能：消除`ul`和`ol`元素之前单个`li`的默认点的样式。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.list-unstyled-list {
  @include no-bullet();
}
screen.css文件中:
.list-unstyled-list {
list-style-image: none;
list-style-type: none;
margin-left: 0;
}
</code></pre></li>
<li><p><strong>inline-list()</strong></p>
<pre><code>  -     功能：通过设置`li`元素的display值为inline,实现横向`ul`或`ol`列表的样式。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.list-inline {
  @include inline-list();
}
screen.css文件中:
.list-inline {
list-style-type: none;
}
.list-inline, .list-inline li {
margin: 0;
padding: 0;
display: inline;
}
</code></pre></li>
<li><p><strong>horizontal-list(0, right)</strong></p>
<pre><code>  -     功能：相比于上例，我们要实现横向list时，由于上例的li都是inline的样式，所有没有高度，这样我们想给li设置一些必须有高度的样式修饰时，就会出现麻烦，horizontal-list()这个mixin可以通过浮动的方式实现横向list且每个li都有高度。
  -     参数：第一个参数时li元素padding的值，第二个元素浮动的方向，设置成false，不设置padding值以兼容ie
  -     示例：
</code></pre><pre><code>screen.scss文件:
.list-horizontal {
  @include horizontal-list(0, right);
}
screen.css文件中:
.list-horizontal {
margin: 0;
padding: 0;
border: 0;
overflow: hidden;
*zoom: 1;
}
.list-horizontal li {
list-style-image: none;
list-style-type: none;
margin-left: 0;
white-space: nowrap;
float: right;
display: inline;
padding-left: 0;
padding-right: 0;
}
.list-horizontal li:first-child, .list-horizontal li.first {
padding-right: 0;
}
.list-horizontal li:last-child {
padding-left: 0;
}
.list-horizontal li.last {
padding-left: 0;
}
</code></pre></li>
<li><p><strong>horizontal-list(0, right)</strong></p>
<pre><code>  -     功能：通过设置li元素为的display属性为inline-block来实现横向list。
  -     参数：li的padding值
  -     示例：
</code></pre><pre><code>screen.scss文件:
.list-inline-block {
  @include inline-block(7px);
}
screen.css文件中:
.list-inline-block {
display: inline-block;
vertical-align: 7px;
*vertical-align: auto;
*zoom: 1;
*display: inline;
}
</code></pre></li>
</ul>
<h3 id="text子模块"><a href="#text子模块" class="headerlink" title="text子模块"></a>text子模块</h3><p>文本操作，操作过长文本的样式。</p>
<ul>
<li><p><strong>force-wrap()</strong></p>
<pre><code>  -     功能：强行使长文本换行。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.wrap-text {
  @include force-wrap();
}
screen.css文件中:
.wrap-text {
white-space: pre;
white-space: pre-wrap;
white-space: pre-line;
white-space: -pre-wrap;
white-space: -o-pre-wrap;
white-space: -moz-pre-wrap;
white-space: -hp-pre-wrap;
word-wrap: break-word;
}
</code></pre></li>
<li><p><strong>nowrap()</strong></p>
<pre><code>  -     功能：无论何时都不换行。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.nowrap-text {
  @include nowrap();
}
screen.css文件中:
.nowrap-text {
white-space: nowrap;
}
</code></pre></li>
<li><p><strong>ellipsis()</strong></p>
<pre><code>  -     功能：不换行的时候文本超出容器的宽度，出现省略号。
</code></pre><ul>
<li>引入： firefox不能很好的支持text-overflow属性，所以需要相关的xml文件来hack，compass已经封装好了，直接引用就好</li>
</ul>
</li>
</ul>
<pre><code>compass install compass/ellipsis
</code></pre><pre><code>    -     参数：
    -     示例：
</code></pre><pre><code>screen.scss文件:
$use-mozilla-ellipsis-binding: true;
.text-ellipsis {
    @include ellipsis();
}
screen.css文件中:
.text-ellipsis {
  white-space: nowrap;
  overflow: hidden;
  -ms-text-overflow: ellipsis;
  -o-text-overflow: ellipsis;
  text-overflow: ellipsis;
  -moz-binding: url(&#39;xml/ellipsis.xml#ellipsis&#39;);
}
</code></pre><ul>
<li><p><strong>hide-text()</strong></p>
<pre><code>  -     功能：背景图片和标签文本重复时，隐藏标签文本，用图片替换文本内容，这个mixin用来隐藏文字。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.text-hide {
  @include hide-text();
}
screen.css文件中:
.text-hide {
text-indent: -119988px;
overflow: hidden;
text-align: left;
text-transform: capitalize;
}
</code></pre></li>
<li><p><strong>squish-text()</strong></p>
<pre><code>  -     功能：功能同上，字体设置为透明，来隐藏文字。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.text-hide {
  @include squish-text();
}
screen.css文件中:
.text-hide {
font: 0/0 serif;
text-shadow: none;
color: transparent;
}
</code></pre></li>
<li><p><strong>replace-text()</strong></p>
<pre><code>  -     功能：隐藏文字后，添加背景图片。
  -     参数：第一个参数是图片的url地址（可以使服务器资源的地址也可以是本地图片的地址），第二个和第三个参数是图片的background-position的值。
  -     示例：
</code></pre><pre><code>screen.scss文件:
.bind-img {
  @include replace-text(&quot;http://img3.mukewang.com/5452ffeb0001b82401000100-40-40.jpg&quot;, 50%, .50%);
}
screen.css文件中:
.bind-img {
text-indent: -119988px;
overflow: hidden;
text-align: left;
text-transform: capitalize;
background-image: url(http://img3.mukewang.com/5452ffeb0001b82401000100-40-40.jpg);
background-repeat: no-repeat;
background-position: 50% 0.5%;
}
</code></pre></li>
<li><p><strong>replace-text-with-dimensions()</strong></p>
<pre><code>  -     功能：功能同上，但是会自动隐藏超出容器的多余图片的边框。
  -     参数：第一个参数是图片的url地址（可以使服务器资源的地址也可以是本地图片的地址）
  -     示例：
</code></pre><pre><code>screen.scss文件:
.bind-img {
  @include replace-text-with-dimensions(image-url(&#39;1503616769997479025.jpg&#39;));
}
screen.css文件中:
.bind-img {
text-indent: -119988px;
overflow: hidden;
text-align: left;
text-transform: capitalize;
background-image: url(http://img3.mukewang.com/5452ffeb0001b82401000100-40-40.jpg);
background-repeat: no-repeat;
background-position: 50% 0.5%;
}
</code></pre></li>
</ul>
<h3 id="vertical-rythm子模块"><a href="#vertical-rythm子模块" class="headerlink" title="vertical rythm子模块"></a>vertical rythm子模块</h3><p>修饰文本的垂直韵律。修饰文本行与行之间的样式。<br><em>这个功能不是很长用到，如果做页面大段文本布局的童鞋可以深入理解一下，请入doc <a href="http://compass-style.org/reference/compass/typography/" target="_blank" rel="external">api</a></em></p>
<h2 id="helpers模块"><a href="#helpers模块" class="headerlink" title="helpers模块"></a>helpers模块</h2><p>helpers模块是用来提供许多工具function的内部模块。<br><strong>helpers模块中有很多不适很常用的function，这里不多讲，如果有需要的童鞋请进入doc <a href="http://compass-style.org/reference/compass/typography/" target="_blank" rel="external">api</a></strong><br><strong>这里只介绍常用的功能</strong><br><strong>安装</strong>：</p>
<pre><code>compass install helpers
</code></pre><p><strong>引入</strong>：</p>
<pre><code>@import &#39;compass/helpers&#39;;
</code></pre><h3 id="inline-image"><a href="#inline-image" class="headerlink" title="inline-image()"></a>inline-image()</h3><pre><code>    -     功能：将图片base64编码压缩。
    -     参数：图片本地地址
    -     示例：
</code></pre><pre><code>screen.scss文件:
.analyze-logo {    
    background-image: inline-image(&#39;1503616769997479025.jpg&#39;);
}
</code></pre><p><em>screen.css</em>文件中:<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fkdgggqdmxj30zk0ewn0k.jpg" alt=""><br><strong>这种方法会很消耗内存，在项目中不适很常用到，compass的另一个比较常用的模块–精灵合图绘很适合这样的场景，大力推荐！</strong></p>
<h3 id="image-url"><a href="#image-url" class="headerlink" title="image-url()"></a>image-url()</h3><pre><code>    -     功能：直接使用文件的名称来代替文件的本地路径，compass会直接根据config.rb文件中配置来寻路，并且可以给生成css文件中图片地址加上cache-buster（时间戳和版本号，通常在图片路径中问号的后面。图片每次更新都会更改这个值。会造成大量的缓存垃圾。）
    -     参数：图片本地地址
    -     注意：这里的参数直接使用了图片的文件名称，相对路径图片的引用自动根据图片改变而改变,URL后面的cache会据config中的httppath配置项去自动加上http域名,config文件中的relative-assets配置项来配置是否使用相对路径来引用资源文件。
</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fkdgorxruoj30ma07eq3c.jpg" alt=""></p>
<pre><code>    -     示例：
</code></pre><pre><code>screen.scss文件:
.analyze-logo {
    background-image: image-url(&#39;1503616769997479025.jpg&#39;);
}
screen.css文件中:
.analyze-logo {
  background-image: url(&#39;../images/1503616769997479025.jpg?1506223791&#39;);
}
</code></pre><p><strong>功能类似的还有stylesheet-url和font-url用来指向css目录和font目录，可以查询doc api</strong></p>
<h3 id="font-files"><a href="#font-files" class="headerlink" title="font-files()"></a>font-files()</h3><pre><code>    -     功能：在项目目录中寻路font字体文件，并加上cache-buster
    -     参数：font字体文件的文件名列表
    -     注意：**在config.rb文件中配置font字体文件的路径。**
</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fkdh3hrs8kj309u0drjrq.jpg" alt=""></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fkdgorxruoj30ma07eq3c.jpg" alt=""></p>
<pre><code>    -     示例：
</code></pre><pre><code>screen.scss文件:
@debug font-files(&quot;fontawesome-webfont.eot&quot;, &quot;fontawesome-webfont.ttf&quot;, &quot;fontawesome-webfont.svg&quot;, &quot;fontawesome-webfont.woff&quot;, &quot;FontAwesome.otf&quot;);
</code></pre><p>命令行中：<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fkdgzlxvuaj313h046t9h.jpg" alt=""></p>
<h3 id="font-face"><a href="#font-face" class="headerlink" title="font-face()"></a>font-face()</h3><pre><code>    -     功能：相比于font-url，font-face会额外根据字体文件帮我们生成对应的format的值
    -     参数：字体文件的url，可以和font-files配合
    -     示例：
</code></pre><pre><code>screen.scss文件:
@include font-face(&quot;FontAwesome&quot;,
font-files(&quot;fontawesome-webfont.eot&quot;, &quot;fontawesome-webfont.ttf&quot;, &quot;fontawesome-webfont.svg&quot;, &quot;fontawesome-webfont.woff&quot;, &quot;FontAwesome.otf&quot;));
screen.css文件中:
@font-face {
  font-family: &quot;FontAwesome&quot;;
  src: url(&#39;../fonts/fontawesome-webfont.eot?1478142484&#39;) format(&#39;embedded-opentype&#39;), url(&#39;../fonts/fontawesome-webfont.ttf?1478142484&#39;) format(&#39;truetype&#39;), url(&#39;../fonts/fontawesome-webfont.svg?1478142484&#39;) format(&#39;svg&#39;), url(&#39;../fonts/fontawesome-webfont.woff?1478142484&#39;) format(&#39;woff&#39;), url(&#39;../fonts/FontAwesome.otf?1478142484&#39;) format(&#39;opentype&#39;);
}
</code></pre><p>命令行中：<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fkdgzlxvuaj313h046t9h.jpg" alt="3123"></p>
<h3 id="append-selector"><a href="#append-selector" class="headerlink" title="append-selector()"></a>append-selector()</h3><pre><code>    -     功能：将选择器嵌套起来
    -     参数： 将第二个选择弃嵌套到第一个参数的选择器中
    -     注意：**在选择器里面要引用sass的变量需要加上#{}sass的变量包裹器**
    -     示例：
</code></pre><pre><code>screen.scss文件:
#{append-selector(&#39;p, span, div&#39;, &#39;.bar&#39;)} {
    color: #000;
}
screen.css文件中:
p.bar, span.bar, div.bar {
  color: #000;
}
</code></pre><h2 id="utilities模块"><a href="#utilities模块" class="headerlink" title="utilities模块"></a>utilities模块</h2><p>辅助工具类🔧的模块。与helpers模块不同的是，utilities模块都是mixin。<br><em>引入：</em></p>
<pre><code>@import &#39;compass/utilities&#39;;
</code></pre><p>utilities模块又分为以下5个子模块：</p>
<ul>
<li>color</li>
<li>generak</li>
<li>print</li>
<li>tables</li>
<li><strong>sprites</strong>（精灵图合图相关工具的集合,<strong>这个功能模块是使用compass的重中之重！</strong>详见我的另一篇博客）</li>
</ul>
<h3 id="color子模块"><a href="#color子模块" class="headerlink" title="color子模块"></a>color子模块</h3><p>颜色相关的模块。</p>
<ul>
<li><strong>brightness()</strong><pre><code>  -     功能：返回相关颜色的亮度值，计算hsl的亮度值（l）
  -     参数：色值
</code></pre></li>
</ul>
<h3 id="print子模块"><a href="#print子模块" class="headerlink" title="print子模块"></a>print子模块</h3><p>打印场景下相关功能的模块。这个场景很少见，估计是打印页面相关的样式。</p>
<ul>
<li><strong>print-utilities();</strong><pre><code>  -     功能：适配打印页面。产生打印页面才显示的样式。
  -     参数：media文件，默认print.
  -     注意：**需要print.scss中做适配**
</code></pre><ul>
<li>引入    ：</li>
</ul>
</li>
</ul>
<pre><code>index.html文件中：
&lt;link href=&quot;stylesheets/print.css&quot; media=&quot;print&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;
</code></pre><pre><code>-     示例
</code></pre><pre><code>print.scss文件中：
@import &quot;compass/utilities/print&quot;;

@include print-utilities();
screen.scss文件:
@include print-utilities(screen);
screen.css文件中:
.print-only {
  display: none;
}
</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fkdhvt5ihdj31240lemzn.jpg" alt="print.css文件"></p>
<h3 id="tables子模块"><a href="#tables子模块" class="headerlink" title="tables子模块"></a>tables子模块</h3><p>table样式的相关样式集合。<br><em>用一个实例来说明这些mixin</em><br><strong>需要在index.html文件中引入相关格式的html代码：</strong></p>
<pre><code>index.html文件中：
&lt;div class=&#39;example&#39;&gt;
    &lt;table class=&quot;good-price&quot; cellspacing=&#39;0&#39;&gt;
        &lt;thead&gt;
            &lt;tr class=&#39;odd&#39;&gt;
                &lt;th&gt;Title&lt;/th&gt;
                &lt;th&gt;One&lt;/th&gt;
                &lt;th&gt;Two&lt;/th&gt;
                &lt;th&gt;Three&lt;/th&gt;
                &lt;th&gt;Four&lt;/th&gt;
                &lt;th&gt;Row Total&lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            &lt;tr class=&#39;even&#39;&gt;
                &lt;th&gt;Single&lt;/th&gt;
                &lt;td class=&#39;numeric&#39;&gt;1.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;2.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;3.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;4.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;10.0&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr class=&#39;odd&#39;&gt;
                &lt;th&gt;Tens&lt;/th&gt;
                &lt;td class=&#39;numeric&#39;&gt;10.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;20.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;30.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;40.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;100.0&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/tbody&gt;
        &lt;tfoot&gt;
            &lt;tr class=&#39;even&#39;&gt;
                &lt;th&gt;Total&lt;/th&gt;
                &lt;td class=&#39;numeric&#39;&gt;11.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;22.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;33.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;44.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;110.0&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/tfoot&gt;
    &lt;/table&gt;
&lt;/div&gt;
</code></pre><pre><code>screen.scss文件中：
.good-price {
    $table-color: #7a98c6;

    @include outer-table-borders();
    @include inner-table-borders(1px,darken($table-color, 40%)); 
    // th标题居中对齐，普通文本左对齐，竖直右对齐，并填充padding
    @include table-scaffolding(); 
    // 奇偶行不同色，相邻纵列不同色
    @include alternating-rows-and-columns($table-color,adjust-hue($table-color, -120deg),#222222);
}
screen.css文件中：
.good-price {
  border: 2px solid black;
}
.good-price thead th {
  border-bottom: 2px solid black;
}
.good-price tfoot th, .good-price tfoot td {
  border-top: 2px solid black;
}
.good-price th:first-child, .good-price th.first {
  border-right: 2px solid black;
}
.good-price th, .good-price td {
  border-right: 1px solid #233551;
  border-bottom: 1px solid #233551;
  border-left-width: 0;
  border-top-width: 0;
}
.good-price th:last-child, .good-price td:last-child {
  border-right-width: 0;
}
.good-price th.last, .good-price td.last {
  border-right-width: 0;
}
.good-price tbody tr:last-child th, .good-price tbody tr:last-child td, .good-price tfoot tr:last-child th, .good-price tfoot tr:last-child td {
  border-bottom-width: 0;
}
.good-price tbody tr.last th, .good-price tbody tr.last td, .good-price tfoot tr.last th, .good-price tfoot tr.last td {
  border-bottom-width: 0;
}
.good-price th {
  text-align: center;
  font-weight: bold;
}
.good-price td,
.good-price th {
  padding: 2px;
}
.good-price td.numeric,
.good-price th.numeric {
  text-align: right;
}
.good-price th {
  background-color: white;
}
.good-price th.even, .good-price th:nth-child(2n) {
  background-color: #dddddd;
}
.good-price tr.odd td, .good-price tr:nth-child(2n+1) td {
  background-color: #98c67a;
}
.good-price tr.odd td.even, .good-price tr.odd td:nth-child(2n), .good-price tr:nth-child(2n+1) td.even, .good-price tr:nth-child(2n+1) td:nth-child(2n) {
  background-color: #76a458;
}
.good-price tr.even td {
  background-color: #7a98c6;
}
.good-price tr.even td.even, .good-price tr.even td:nth-child(2n) {
  background-color: #5876a4;
}
.good-price tfoot th, .good-price tfoot td {
  background-color: white;
}
.good-price tfoot th.even, .good-price tfoot th:nth-child(2n), .good-price tfoot td.even, .good-price tfoot td:nth-child(2n) {
  background-color: #dddddd;
}
</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fkdic3j8rmj30cp04iq34.jpg" alt="table样式"></p>
<h3 id="general子模块"><a href="#general子模块" class="headerlink" title="general子模块"></a>general子模块</h3><p>一些常见的样式的相关样式集合。</p>
<ul>
<li><p><strong>clearfix()</strong></p>
<pre><code>  -     功能：overflow:hidden的方法清除浮动。
  -     示例
</code></pre><pre><code>screen.scss文件:
.clearfix {
  @include pie-clearfix();
}
screen.css文件中:
.clearfix {
  /*
      子元素超出父元素会overflow: hidden
   */
overflow: hidden;
*zoom: 1;
}
</code></pre></li>
<li><p><strong>pie-clearfix()</strong></p>
<pre><code>  -     功能：伪类的方法清除浮动。
  -     示例
</code></pre><pre><code>screen.scss文件:
.clearfix {
  @include pie-clearfix();
}
screen.css文件中:
.clearfix {
*zoom: 1;
}
.clearfix:after {
content: &quot;&quot;;
display: table;
clear: both;
}
</code></pre></li>
<li><p><strong>float()</strong></p>
<pre><code>  -     功能：根据你在browser support中配置的浏览器环境，兼容ie6浮动布局。
</code></pre><ul>
<li>注意：需要在browser support中配置</li>
</ul>
</li>
</ul>
<pre><code>$browser-minimum-versions: (&quot;ie&quot;: &quot;6&quot;);
</code></pre><pre><code>- 参数：浮动的方向
    -     示例
</code></pre><pre><code>screen.scss文件:
.pull-left {
    @include float(left);
}
screen.css文件中:
.pull-left {
  float: left;
  display: inline;
}
</code></pre><h4 id="hacks子模块"><a href="#hacks子模块" class="headerlink" title="hacks子模块"></a>hacks子模块</h4><p>很多兼容ie的hack集合。</p>
<ul>
<li><p><strong>has-layout()</strong></p>
<pre><code>  -     功能：激活兼容ie属性。
</code></pre><ul>
<li>参数：激活ie的方式，推荐zoom         <ul>
<li>示例<pre><code>screen.scss文件:
.need-has-layout {
@include has-layout();
}
screen.css文件中:
.need-has-layout {
*zoom: 1;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>underscore-hack()</strong></p>
<pre><code>  -     功能：正常情况下属性是某种值，ie下hack成另一种值。
</code></pre><ul>
<li>参数：第一个参数是属性的key，第二个是正常情况下的value，第三个是hack情况下的value        <ul>
<li>示例：<pre><code>screen.scss文件:
.underscore-hack-display {
@include underscore-hack(display,block,inline);
}
screen.css文件中:
.underscore-hack-display {
display: block;
_display: inline;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>min-height()</strong></p>
<pre><code>  -     功能：下划线的方式hack min-height和min-width属性。
</code></pre><ul>
<li>参数：相应的height或者width值<ul>
<li>示例：<pre><code>screen.scss文件:
.test-min-height {
@include min-height(10px);
}
screen.css文件中:
.test-min-height {
min-height: 10px;
height: auto;
_height: 10px;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="标签云模块"><a href="#标签云模块" class="headerlink" title="标签云模块"></a>标签云模块</h4><p>compass封装了一个简单的标签云功能模块，以一个例子来说明：</p>
<pre><code>screen.scss文件:
.tag-cloud-container {
    @include tag-cloud(24px);
}
screen.css文件中:
.tag-cloud-container {
  font-size: 24px;
  line-height: 28.8px;
}
.tag-cloud-container .xxs, .tag-cloud-container .xs, .tag-cloud-container .s, .tag-cloud-container .l, .tag-cloud-container .xl, .tag-cloud-container .xxl {
  line-height: 28.8px;
}
.tag-cloud-container .xxs {
  font-size: 12px;
}
.tag-cloud-container .xs {
  font-size: 16px;
}
.tag-cloud-container .s {
  font-size: 18px;
}
.tag-cloud-container .l {
  font-size: 32px;
}
.tag-cloud-container .xl {
  font-size: 36px;
}
.tag-cloud-container .xxl {
  font-size: 48px;
}
</code></pre><p><strong>在index.html文件中不同的标签加上不同的类，从而实现一个简单的标签云，效果如下：</strong><br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fkdj3zidjrj316c0qp0uz.jpg" alt="index.html"></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fkdj344tjyj30lp017q2v.jpg" alt="标签云效果demo"></p>
<h2 id="sprites模块"><a href="#sprites模块" class="headerlink" title="sprites模块"></a>sprites模块</h2><p>精灵图合图相关功能集合。可以说是compass在日常工程中的最佳实践，非常实用也非常重要。<br><strong>想象一下设计人员（通常是漂亮的小姐姐们～不好意思责怪人家呀=。=）将sprites图中的一个图标，并且很有可能影响到了其他的图标，开发人员就要吐血地在项目中修改所有被影响的样式代码，这真的是巨痛苦无比呀</strong><br>由于sprites模块很重要，我将它放到了另外一个博客中，以便详细讲解～<a href="http://pancakeawesome.ink/2017/10/10/compass%E9%87%8D%E8%A6%81%E5%8A%9F%E8%83%BD%E4%B9%8B%E7%B2%BE%E7%81%B5%E5%9B%BE%E5%90%88%E5%9B%BE/">传送门</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>compass是一个很好用的前端自动化工具，它给sass插上了一双翅膀，极大地提高了我们的开发效率！<br><strong>这里是我写的一个compass的demo，可以对照着看</strong></p>
]]></content>
      
        <categories>
            
            <category> 前端工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> css </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo+githubio+material搭建你的个人博客网站（优化篇）]]></title>
      <url>/hexo+githubio+material%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99(%E4%BC%98%E5%8C%96%E7%AF%87).html</url>
      <content type="html"><![CDATA[<h2 id="网站-SEO-优化—如何让你的博客在搜索结果中排名第一"><a href="#网站-SEO-优化—如何让你的博客在搜索结果中排名第一" class="headerlink" title="网站 SEO 优化—如何让你的博客在搜索结果中排名第一"></a>网站 SEO 优化—如何让你的博客在搜索结果中排名第一</h2><p>关于网站 SEO 这一块我主要参考了这位小姐姐的<a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F590b451a0ce46300588c43a0" target="_blank" rel="external">这篇文章</a>,但是有些发现她有些地方写的不是很清楚,自己也在这一块设置时也摸索了半天,所以直接像大家分享一下我的踩坑经验.</p>
<h3 id="让百度收录你的站点"><a href="#让百度收录你的站点" class="headerlink" title="让百度收录你的站点"></a>让百度收录你的站点</h3><p>我们直接在百度中搜索<code>site:你的域名</code>就可以查看百度是否已经收录你的网站,如果没有收录的话,你就要去去登录<a href="https://link.juejin.im?target=http%3A%2F%2Fzhanzhang.baidu.com" target="_blank" rel="external">百度站长平台</a>在站点管理中点击添加网站,然后输入你的站点地址, 注意,这里需要输入我们自己购买的域名,不能使用<code>xxx.github.io</code>之类域名.</p>
<p>步骤如下:</p>
<ol>
<li>输入网站: 添加域名时建议是不带上<code>www</code>的前缀</li>
<li>站点属性: 选择自己网站类型</li>
<li><p>验证网站: 验证网站的所有权,这里主要有以下三种</p>
<ul>
<li>文件验证: 文件验证文件存放的位置需要放在source文件夹下,txt 格式的不会被 hexo 预编译,其他格式要在头部加上<code>layout: false</code></li>
<li>HTML 标签验证: 将他给你的代码添加到网站首页的 head 标签内</li>
<li>CNAME 验证: <strong>推荐使用</strong>,将对应的 CNAME 文件放在你的 source 文件夹中即可,只要在其中写上你的域名地址就行;除此之外还会要求你到自己的域名提供商(我的是万网)上添加 CNAME 的解析(会面在国内外分流这一块会与更详细的解析说明);</li>
</ul>
</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2017/7/12/ee30fa072724e1141dfae134f4693f86?imageView2/0/w/1280/h/960" alt=""><br><strong>你需要到你的域名管理商那里更改百度的域名解析如：(以<a href="https://netcn.console.aliyun.com/core/domain/tclist" target="_blank" rel="external">万网</a>举例)</strong><br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fk1jiu2w2gj30ou01umx0.jpg" alt=""></p>
<h3 id="生成网站地图-—-sitemap"><a href="#生成网站地图-—-sitemap" class="headerlink" title="生成网站地图 — sitemap"></a>生成网站地图 — sitemap</h3><p> 这里需要我们安装下面两个插件,先执行下面命令</p>
<pre><code> npm i hexo-generator-sitemap hexo-generator-baidu-sitemap -S
</code></pre><p> 再在你的站点配置文件中修改 URL 为你的站点地址<br> <img src="https://ws2.sinaimg.cn/large/006tNc79gy1fjtqfn861bj30mk0953z5.jpg" alt=""></p>
<p> 当你在 <code>hexo g</code> 时,会在<code>public</code>文件夹中生成<code>sitemap.xml</code> 和<code>baidusitemap.xml</code> 两个文件,如果你已经提前将你的 hexo 部署到网上,这是可以直接打开<code>http://yoururl/sitemap.xml</code>和<code>http://yoururl/baidusitemap.xml</code>来查看.(这两者的区别在于 <code>baidusitemap.xml</code>        是百度搜索引擎的专用文件,另一个是通用).</p>
<h3 id="向百度提交链接"><a href="#向百度提交链接" class="headerlink" title="向百度提交链接"></a>向百度提交链接</h3><p><strong>现在百度好像不能抓去github上面的数据了</strong><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fk3qrgy8egj30oy0233yi.jpg" alt=""></p>
<blockquote>
<p>如何选择链接提交方式</p>
<p>   1、主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。</p>
<p>   2、自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。</p>
<p>   3、sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。</p>
<p>  4、手动提交：一次性提交链接给百度，可以使用此种方式。</p>
</blockquote>
<p>这里我推荐大家<strong>使用主动推送</strong>,当你主动推送时,可以缩短百度爬虫发现您站点新链接的时间,使新发布的页面可以在第一时间被百度收录;对于网站的最新原创内容，使用主动推送功能可以快速通知到百度，使内容可以在转发之前被百度发现.</p>
<h4 id="使用主动推送"><a href="#使用主动推送" class="headerlink" title="使用主动推送"></a>使用主动推送</h4><ul>
<li>需要先安装插件<code>npm i hexo-baidu-url-submit -S</code></li>
<li>然后再在站点配置文件中按如下方式新增字段<pre><code>baidu_url_submit:
count: 100 # 提交最新的链接数
host: pancakeawesome.com # 在百度站长平台中注册的域名,虽然官方推荐要带有 www, 但可以不带.
token:  XXXXX # 你的秘钥,每个人都不一样,获取方法在下面
path: baidu_urls.txt # 文本文档的地址,新链接会保存在此文本文档里
</code></pre></li>
<li>然后加入新的 </li>
</ul>
<pre><code>deploydeploy:
     - type:baidu_url_submitter
</code></pre><p><strong>注意</strong>,这里多个 type 的写法应该这么写,前面那个 type 是我推送到 <code>Gitub</code> 与 <code>Coding</code> 的<code>page</code>页面的配置,后面再讲这个.</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fjtqhkscohj30qp0inmyv.jpg" alt=""></p>
<p>密钥的获取位置在<code>网页抓取</code>中的<code>链接提交</code>这一块,如下所示:<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/0995148de59688b95330f5e2c99daa58?imageView2/0/w/1280/h/960" alt=""></p>
<ul>
<li>最后当你执行<code>hexo d</code>时新的连接就会被推送上去.</li>
<li>推送成功时,会有如下终端提示,各种不同的推送反馈字段说明在<a href="https://link.juejin.im?target=http%3A%2F%2Fzhanzhang.baidu.com%2Fcollege%2Fcourseinfo%3Fid%3D267%26amp%3Bpage%3D2%23h2_article_title8" target="_blank" rel="external">这里</a>查看,一般来说,推送失败都是地址不相符造成的,我们只需对比<code>baidu_url_submit</code>在<code>public</code>中生成的<code>baidu_urls.txt</code>的地址,与自己填写在<code>host</code>字段中是否一样即可,这里需要注意的是,多加<code>www</code>会导致上传失败(血的教训…)</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fjttndgvr1j30uw0icmzj.jpg" alt=""></p>
<h3 id="让-Google-收录你的网站"><a href="#让-Google-收录你的网站" class="headerlink" title="让 Google 收录你的网站"></a>让 Google 收录你的网站</h3><ul>
<li><p>登录 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.google.com%2Fwebmasters%2F%23%3Fmodal_active%3Dnone" target="_blank" rel="external">Google 网络站长</a>,点击<code>添加属性</code>按要求添加你的网站</p>
</li>
<li><p>验证你的网站所有权,我推荐使用 HTML 文件上传的方式,将他给你的html 文件放入 <code>sources</code> 文件夹下,但 html 文件默认会被 hexo 预编译,所以这里,我们要手动设置让 hexo 不要编译该文件,在文件开始添加<code>layout:false</code>即可.<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/d08c34f269cb81e388eeef1e70a5d2bc?imageView2/0/w/1280/h/960" alt=""></p>
</li>
<li><p>添加 sitemap : 进入 Google Search Console - 抓取 - 站点地图,点击「添加/测试站点地图」,输入你的博客网址. 若无报错则站点地图提交成功<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fjtuhe4at2j30xj0c0jrn.jpg" alt="">)</p>
</li>
<li>提交 robots.txt:<blockquote>
<p>robots.txt 是一种存放于网站根目录下的 ASCII 编码的文本文件，它的作用是告诉搜索引擎此网站中哪些内容是可以被爬取的，哪些是禁止爬取的。robots.txt 放在博客目录下的 source 文件夹中，博客生成后在站点目录 /public/ 下。</p>
</blockquote>
</li>
</ul>
<p>我的 robots.txt 文件内容如下：</p>
<pre><code>    User-agent: *
    Allow: /
    Allow: /archives/
    Allow: /categories/
    Allow: /about/
    Disallow: /vendors/
    Disallow: /js/
    Disallow: /css/
    Disallow: /fonts/
    Disallow: /vendors/
    Disallow: /fancybox/
</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fjtuilil2dj30w90dc0tc.jpg" alt="">)</p>
<ul>
<li><em>提交谷歌索引</em><br>在这里我们填上我们需要抓取的url,不填这表示抓取首页，抓取方式可以选择桌面，智能手机等等，自行根据需要选择。填好url之后，点击抓取。然后可能会出现几种情况，如:完成、部分完成、重定向等，自由这三种情况是可以提交的。<br>提交完成后，提交至索引，根据提示操作就可以了，我的提交：<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fjtukpj4edj30x90bw0tg.jpg" alt="">)<h3 id="优化你的-URL"><a href="#优化你的-URL" class="headerlink" title="优化你的 URL"></a>优化你的 URL</h3></li>
</ul>
<blockquote>
<p>这段话参考自<a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F590b451a0ce46300588c43a0" target="_blank" rel="external">上面那个小姐姐的文章</a>,写的很好,这里我直接拿来用下<br>seo搜索引擎优化认为，网站的最佳结构是用户<strong>从首页点击三次就可以到达任何一个页面</strong>，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，所以我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下：</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2017/7/12/7f12922620fc0c865bffafd8ce4a2f97?imageView2/0/w/1280/h/960" alt=""></p>
<h2 id="将你的网站同时托管到-Github-和-Coding-上-国内外分流"><a href="#将你的网站同时托管到-Github-和-Coding-上-国内外分流" class="headerlink" title="将你的网站同时托管到 Github 和 Coding 上,国内外分流"></a>将你的网站同时托管到 Github 和 Coding 上,国内外分流</h2><p>Coding 类似于中国的 Github 一样,也提供了 Pages 服务,但对我们而言,跟 Github 不同的地方在于免费用户能拥有五个私人仓库,这个可以用来部署自己的一些私人代码,而且配合 Github 可以做到国内IP 访问 Coding 的 Pages 页面,国外访问 Github 上面的 Pages 页面.大致配置过程如下:</p>
<ul>
<li>在 Coding 上创建仓库: 这里注意要去创建一个公有的仓库,私有仓库是没有 pages 服务的.</li>
<li>将你的公钥传上去.这里网上关于自己公钥的相关教程很多,我就不多叙述了.</li>
<li><p>修改 hexo 的站点配置文件中的 deploy 选项,配置你的 Github 与 Coding 仓库,需要注意的是其中 Github 的仓库名<code>xxx.github.io</code>必须跟你的 Github 名称一样:<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/395865e456887d0a62adc65769fdb73b?imageView2/0/w/1280/h/960" alt=""><br>每次上传的时候都需要输入你的账号密码之类的信息,可以直接将你账号密码写在上传地址中,这样就不用每次更新都输入你的账号密码了例如你的账号为<span class="hljs-selector-pseudo">:crown3,密码为 BBB;<br>那你的repo填写为下面这样即可</span></p>
<pre><code>github: https://crown3:BBB@github.com/crown3/crown3.github.io.git
coding: https://crown3:BBB@git.coding.net/crown3/仓库名.git
</code></pre></li>
<li><p>设置 coding 的 pages 服务:在pages页面将部署来源选择为master分支，然后将自定义域名填写自己购买的域名就可以了</p>
</li>
<li>设置域名解析: 在你的域名提供商那里修改你的域名解析就行,例如我的是万网,按照下图所示,添加这五条解析即可做到国内外访问分流.<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/f1bbfa32ee6b74ef8d1d3e87bd25083c?imageView2/0/w/1280/h/960" alt=""></li>
</ul>
<h2 id="将自己的代码托管到私有仓库"><a href="#将自己的代码托管到私有仓库" class="headerlink" title="将自己的代码托管到私有仓库"></a>将自己的代码托管到私有仓库</h2><p>当我们将自己的代码托管到<strong>私有仓库</strong>后,就可以在任何一台电脑上将你的 hexo 部署代码下载下来进行编辑,而且可以将你的一些个人密钥什么的直接推送到你的代码仓库去,这样更便利于我们的管理维护.</p>
<p>在上文我已经说过了,国内 Coding 的免费用户可以创建五个私有仓库,这是可以直接拿来使用,但是如果你对国内的私有仓库安全性存有怀疑,也可以去使用国外专门做私有仓库托管的<a href="https://link.juejin.im?target=https%3A%2F%2Fbitbucket.org%2F" target="_blank" rel="external">bitbucket</a>,在这里私有仓库是可以免费使用的.具体上传之类的使用方法我就不再细述了,都是基于 git 做的代码管理,使用方法都大同小异.</p>
<h2 id="使用-Gulp-压缩你的代码"><a href="#使用-Gulp-压缩你的代码" class="headerlink" title="使用 Gulp 压缩你的代码"></a>使用 Gulp 压缩你的代码</h2><p>代码压缩可以明显减小我们的文件大小,加载速度,这里我会直接提供我使用的脚本,大家可以直接拿来使用,有需要了解相关知识的可以去<code>gulp</code>官网去做相关了解.</p>
<ul>
<li><p>先安装<code>Gulp</code>以及我们需要使用的一系列插件:</p>
<pre><code>npm i gulp gulp-clean-css gulp-htmlclean gulp-htmlmin gulp-imagemin gulp-uglify del run-sequence -S
</code></pre></li>
<li><p>接着创建<code>gulpfile.js</code>: 在你的博客根目录(跟你站点配置文件同一层)下创建<code>gulpfile.js</code>这个文件,然后在里面填入如下脚本即可,里面有相关注释,感兴趣的可以去了解一下.</p>
</li>
</ul>
<pre><code>var gulp = require(&#39;gulp&#39;);
    var minifycss = require(&#39;gulp-clean-css&#39;);
    var uglify = require(&#39;gulp-uglify&#39;);
    var htmlmin = require(&#39;gulp-htmlmin&#39;);
    var htmlclean = require(&#39;gulp-htmlclean&#39;);
    var imagemin = require(&#39;gulp-imagemin&#39;);
    var del = require(&#39;del&#39;);
    var runSequence = require(&#39;run-sequence&#39;);
    var Hexo = require(&#39;hexo&#39;);
    // 清除public文件夹
    gulp.task(&#39;clean&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return del([&#39;public/**/*&#39;]);
    });
    // 利用Hexo API 来生成博客内容， 效果和在命令行运行： hexo g 一样
    // generate html with &#39;hexo generate&#39;
    var hexo = new Hexo(process.cwd(), {});
    gulp.task(&#39;generate&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;(cb) {
        hexo.init().then(&lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
            return hexo.call(&#39;generate&#39;, {
                watch: false
            });
        }).then(&lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
            return hexo.exit();
        }).then(&lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
            return cb()
        }).catch(&lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;(err) {
            console.log(err);
            hexo.exit(err);
            return cb(err);
        })
    })
    // 压缩public目录下的所有css
    gulp.task(&#39;minify-css&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return gulp.src(&#39;./public/**/*.css&#39;)
            .pipe(minifycss({
                compatibility: &#39;ie8&#39;
            }))
            .pipe(gulp.dest(&#39;./public&#39;));
    });
    // 压缩public目录下的所有html
    gulp.task(&#39;minify-html&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return gulp.src(&#39;./public/**/*.html&#39;)
            .pipe(htmlclean())
            .pipe(htmlmin({
                removeComments: true,
                minifyJS: true,
                minifyCSS: true,
                minifyURLs: true,
            }))
            .pipe(gulp.dest(&#39;./public&#39;))
    });
    // 压缩public目录下的所有js
    gulp.task(&#39;minify-js&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return gulp.src(&#39;./public/**/*.js&#39;)
            .pipe(uglify())
            .pipe(gulp.dest(&#39;./public&#39;));
    });
    // 压缩public目录下的所有img： 这个采用默认配置
    gulp.task(&#39;minify-img&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return gulp.src(&#39;./public/images/**/*.*&#39;)
            .pipe(imagemin())
            .pipe(gulp.dest(&#39;./public/images&#39;))
    })
    // 同上，压缩图片，这里采用了： 最大化压缩效果。
    gulp.task(&#39;minify-img-aggressive&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return gulp.src(&#39;./public/images/**/*.*&#39;)
            .pipe(imagemin(
            [imagemin.gifsicle({&#39;optimizationLevel&#39;: &lt;span class=&quot;hljs-number&quot;&gt;3}), 
            imagemin.jpegtran({&#39;progressive&#39;: true}), 
            imagemin.optipng({&#39;optimizationLevel&#39;: &lt;span class=&quot;hljs-number&quot;&gt;7}), 
            imagemin.svgo()],
            {&#39;verbose&#39;: true}))
            .pipe(gulp.dest(&#39;./public/images&#39;))
    })
    // 用run-sequence并发执行，同时处理html，css，js，img
    gulp.task(&#39;compress&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;(cb) {
        runSequence([&#39;minify-html&#39;, &#39;minify-css&#39;, &#39;minify-js&#39;, &#39;minify-img-aggressive&#39;], cb);
    });
    // 执行顺序： 清除public目录 -&amp;gt; 产生原始博客内容 -&amp;gt; 执行压缩混淆
    gulp.task(&#39;build&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;(cb) {
        runSequence(&#39;clean&#39;, &#39;generate&#39;, &#39;compress&#39;, cb)
    });
    gulp.task(&#39;default&#39;, [&#39;build&#39;])
</code></pre><ul>
<li>执行<code>gulp</code>: 在命令行中输入<code>gulp build</code>即可<br>这里要说明的是,这里利用Hexo API 来生成博客内容,效果和在命令行运行： <code>hexo g</code> 一样,所以当我们在执行<code>gulp build</code>时,会根据我们的相关博文来直接生成相应的<code>public</code>文件夹中的内容,并直接进行压缩,接下来我们运行<code>hexo d</code>上传上去的代码会是已经进行相应压缩了的.</li>
</ul>
<h2 id="使用七牛图床来处理我们的图片"><a href="#使用七牛图床来处理我们的图片" class="headerlink" title="使用七牛图床来处理我们的图片"></a>使用七牛图床来处理我们的图片</h2><p><strong>推荐使用<code>智图+ipic+七牛</code>来管理博客的图床</strong></p>
<p>选中一张图片 =&gt; 用智图进行相应压缩处理 =&gt; 使用 iPic 快捷键一键上传到七牛云(cmd + u) =&gt; 在文章中直接粘贴已经复制到剪贴板的图片地址</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/7/12/1bdc660c52243514a6d7a96a5f7624ae?imageView2/0/w/1280/h/960" alt=""></p>
<p><em>选择智图来压缩是因为<code>iPic</code>这个软件自带的上传压缩效果没有智图的好</em><br><strong>具体使用七牛的方法：</strong></p>
<h3 id="增加七牛图床"><a href="#增加七牛图床" class="headerlink" title="增加七牛图床"></a>增加七牛图床</h3><p>增加七牛图床就是要将我们电脑上的图片上传至七牛，然后获得外链，在我们使用md写博客的时候直接插入外链，更方便的是可以直接获取带水印、压缩、剪裁过后的图片~</p>
<h4 id="注册七牛"><a href="#注册七牛" class="headerlink" title="注册七牛"></a>注册七牛</h4><p>万年不变的第一步，注册。官网：<a href="https://link.juejin.im?target=https%3A%2F%2Fportal.qiniu.com%2Fsignup%3Fcode%3D3lnd6wvc103f6" target="_blank" rel="external">七牛云</a></p>
<h4 id="上传资源"><a href="#上传资源" class="headerlink" title="上传资源"></a>上传资源</h4><p>在登录成功之后，点击对象存储</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/5/5/1c58d10d6b4022bb745c679f6e34a447?imageView2/0/w/1280/h/960" alt="上传资源至七牛"><br>上传完图片之后，关闭上传页面，可以在图片列表的最后面有一个眼睛的icon，点击之后就会在右下角找到该图片的外链，在用md写博客的时候就可以直接加入外链就好~也可以对上传的源文件进行重命名，因为大部分我上传到七牛上的图片都是相册中使用的，所以我将源文件的名字都改成统一的形式，在引用的时候只需要修改最后的数字就可以~<br><img src="https://user-gold-cdn.xitu.io/2017/5/5/e748be6d8cd158b3529748beae2082ad?imageView2/0/w/1280/h/960" alt="上传资源至七牛"></p>
<h4 id="添加水印"><a href="#添加水印" class="headerlink" title="添加水印"></a>添加水印</h4><p>使用七牛图床最棒的地方在于可以对图片进行处理，我就只拿添加水印来举例。<br>七牛可以对上传的图片添加图片样式</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/5/5/32770706a230e5f50687ce8f301a28ff?imageView2/0/w/1280/h/960" alt="增加图片样式"><br>增加图片样式就是对图片进行处理，这里的处理方式有很多，比如缩放方式、裁剪、增加图片水印、设置输出格式。<br><img src="https://user-gold-cdn.xitu.io/2017/5/5/54bd4a7d42e7179e2ced2db70325b638?imageView2/0/w/1280/h/960" alt="增加图片样式"><br>在设置了图片样式之后我们要怎么使用呢，开始我也是一脸懵逼的，不知道怎么使用，百度之后才知道，你直接访问获取的外链就是你上传的原图，在外链的后面加上连接符和你的样式名称访问的就是经过处理后的图片，有没有很赞~既可以访问到你的原图片，也可以访问到经过处理后的图片，只不过是连接不同，还可以给一个图片增加多个样式访问，就不需要我们一张一张对图片进行处理了~简直不能太赞~(～￣▽￣)～比如:我的原图地址是：<a href="https://link.juejin.im?target=http%3A%2F%2Foova2i5xh.bkt.clouddn.com%2FIMG49.jpg" target="_blank" rel="external">oova2i5xh.bkt.clouddn.com/IMG49.jpg</a> ，可以看到是一张很大的不带水印的图片<br><img src="https://user-gold-cdn.xitu.io/2017/5/5/7304dbe593b950f42197dbc5e364cdcb?imageView2/0/w/1280/h/960" alt="这里写图片描述"><br>然后在该地址后加上我设置的连接符,”-“和我的样式名称：<a href="https://link.juejin.im?target=http%3A%2F%2Foova2i5xh.bkt.clouddn.com%2FIMG49.jpg-cherryblogImg" target="_blank" rel="external">oova2i5xh.bkt.clouddn.com/IMG49.jpg-c…</a> ，就可以看到是一张带水印的小图，我进行了缩放和加水印<br><img src="https://user-gold-cdn.xitu.io/2017/5/5/0f6012ba8e1ee3bf84eb53a9f6793ffa?imageView2/0/w/1280/h/960" alt="这里写图片描述"></p>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo+githubio+material搭建你的个人博客网站（主题篇）]]></title>
      <url>/hexo+githubio+material%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99(%E4%B8%BB%E9%A2%98%E7%AF%87).html</url>
      <content type="html"><![CDATA[<h1 id="Hexo博客搭建详细教程-从搭建-SEO-国内外分流到部署"><a href="#Hexo博客搭建详细教程-从搭建-SEO-国内外分流到部署" class="headerlink" title="Hexo博客搭建详细教程 : 从搭建 , SEO , 国内外分流到部署"></a>Hexo博客搭建详细教程 : 从搭建 , SEO , 国内外分流到部署</h1><blockquote>
<p>本文主要包括以下内容:</p>
<ul>
<li>Hexo 博客搭建</li>
<li>Hexo 主题选择以及应用</li>
<li>关于 Hexo Meterial 主题的相关配置</li>
<li>网站 SEO 优化</li>
<li>将你的网站同时托管到 Github 和 Coding 上,国内外分流</li>
<li>将自己的代码托管到私有仓库</li>
<li>使用 Gulp 来压缩你的代码</li>
<li>如何简单高效地使用七牛图床</li>
</ul>
<p>主题这里我选择的是 Hexo Meterial 主题( Github Hexo 主题中 star 数排第三,前两名分别是 next 和 yilia).</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="为什么写这篇文章"><a href="#为什么写这篇文章" class="headerlink" title="为什么写这篇文章?"></a>为什么写这篇文章?</h3><p>我发现网上关于 Next 主题的相关配置比较多,但是关于这个 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fviosey%2Fhexo-theme-material" target="_blank" rel="external">Meterial</a> 主题的完整配置过程文档却相当难找,但这个主题在我看来,不管是颜值,还是功能来说,都明显不该被埋没在next的大海之中,所以在自己折腾了一整子后,将自己记录的相关过程整理分享给大家,毕竟这个主题颜值辣么高,功能辣么强……(除了主题不通之外,其他相关配置都是可以拿来参考的,甚至直接拿来用的,所以其他主题的童靴先不要逃…)</p>
</blockquote>
<p><a href="http://pancakeawesome.ink/">Demo演示</a></p>
<h2 id="Hexo-博客搭建"><a href="#Hexo-博客搭建" class="headerlink" title="Hexo 博客搭建"></a>Hexo 博客搭建</h2><h3 id="Hexo-安装环境"><a href="#Hexo-安装环境" class="headerlink" title="Hexo 安装环境"></a>Hexo 安装环境</h3><p>Hexo 是基于<code>Node.js</code>,所以不管是 mac 还是 win 都需要提前安装好<code>Node.js</code>以及<code>NPM</code>才能进行下一步,这里关于 Node 与 NPM 的安装我就不在这里多说了,请大家自行 Google 解决.</p>
<h3 id="Hexo-的相关安装搭建"><a href="#Hexo-的相关安装搭建" class="headerlink" title="Hexo 的相关安装搭建"></a>Hexo 的相关安装搭建</h3><h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>首先我们要在命令行里直接执行如下命令,全局安装<code>Hexo</code>.</p>
<pre><code>npm install -g hexo
</code></pre><h4 id="初始化你的-Hexo-博客"><a href="#初始化你的-Hexo-博客" class="headerlink" title="初始化你的 Hexo 博客"></a>初始化你的 Hexo 博客</h4><p>然后需要你去找到一个你想要安装的文件夹,在里面执行如下命令来进行安装初始化你的hexo博客.</p>
<pre><code>hexo init hexo_blog   //在当前目录下新建一个叫 `hexo_blog`文件夹并在其中初始化生成 `Hexo `相关代码
cd `hexo_blog`//进入到 `hexo_blog `这个文件夹中并安装相关依赖包
npm install
</code></pre><p>生成的相关目录如下:</p>
<pre><code>-- hexo_blog
    ├── node_modules//NPM安装依赖包
    ├── scaffolds
    ├── source
    |   └── _posts//新建文件存放位置
    ├── themes//相关主题存放位置
    ├── _config.yml//Hexo 博客站点配置文件
    ├── .gitignore
    ├── db.json
    └── package.json
</code></pre><p>这里需要下载速度比较慢的童鞋需要注意一下, npm 中默认使用的是国外的 npm 源,这意味着你在你执行 npm install 相关命令式会有比较高的延迟,甚至部分包下载不下来的情况,所以这里推荐国内用户用<code>nrm</code>切换成淘宝的镜像源来使用(但还是会有部分依赖包必须从国外下载,所以还是推荐自己去学会科学上网),使用方法如下:</p>
<pre><code>npm i nrm -g//全局安装 nrm 这个插件
nrm test //测试哪个镜像源跟自己的延迟比较低,我的是 taobao
nrm use taobao //切换到taobao 这个镜像源上
npm i ...//之后继续使用 npm 来安装相关依赖就行
</code></pre><p><img src="https://user-gold-cdn.xitu.io/2017/7/12/b363cb55a2f09865dcb715e2cf4e2860?imageView2/0/w/1280/h/960" alt=""></p>
<p>之后你就可以在当前文件夹下执行<code>hexo server --debug</code>来让你的博客进入<code>debug</code>模式,一般默认是在<code>4000</code>这个端口下执行,直接在浏览器输入<code>localhost:4000</code>就可以查看自己本地生成的<code>Hexo</code>博客了.</p>
<pre><code>在`debug`模式下,你可以直接对你的博客进行相关修改,刷新网页来查看效果.
</code></pre><h2 id="Hexo-主题选择以及应用"><a href="#Hexo-主题选择以及应用" class="headerlink" title="Hexo 主题选择以及应用"></a>Hexo 主题选择以及应用</h2><p>现在网上关于 <code>Hexo</code> 的主题一搜一大把,这里推荐大家在选择主题时可以去选择一些关注度比较高的主题,这种主题一般相应的配套使用插件和文档比较丰富,使用起来也比较方便,主题选择的话可以去一些<a href="https://hexo.io/themes/" target="_blank" rel="external">主题库</a>中查找,也可以直接去<code>Github</code>中搜索<code>hexo theme</code>等关键字来查找— <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fsearch%3Fo%3Ddesc%26amp%3Bq%3Dhexo%2Btheme%26amp%3Bs%3Dstars%26amp%3Btype%3DRepositories%26amp%3Butf8%3D%25E2%259C%2593" target="_blank" rel="external">点击查看搜索结果</a>.</p>
<pre><code>这里我们要注意的一点是在 Hexo 中,通常有两份配置文件,一个是站点根目录下(例如我的就是`.../hexo_blog/_config.yml`)的 `_config.yml`;另外一个是主题目录(例如我的就是`.../hexo_blog/themes/material/_config.yml`)下的 `_config.yml`.为了描述方便,在以下说明中,将前者称为 `站点配置文件`,后者称为`主题配置文件`.
</code></pre><ol>
<li>去找到你喜欢的主题,然后将其下载下来存放到你的 Themes 这个文件夹下,可以使用<code>NPM</code>,<code>Git</code>等一系列方法下载下来,一般主题的文档里面都会有其下载方法的介绍,例如我使用的 <code>Material</code> 主题的<a href="https://material.viosey.com/start/#install-material" target="_blank" rel="external">下载方法</a>.</li>
<li>复制完成后,修改主题文件夹名称,将其修改为 <code>AAA</code>(你的主题名称),然后打开<code>站点配置文件</code>,找到<code>theme</code>字段,并将其值更改为<code>AAA</code>.</li>
<li>运行<code>hexo s --debug</code> 并访问<code>http://localhost:4000</code>即可查看你的主题修改效果.<pre><code>文件夹名称可自由修改,并不是唯一的,只需要 `theme` 字段与之对应即可.这里有一点必须要注意,**配置项之间必须要有一个空格**,例如`theme:material`这种情况是会报错的,要向下面这样.
</code></pre><img src="https://user-gold-cdn.xitu.io/2017/7/12/536f099650be34b06798a19f8ea24cb1?imageView2/0/w/1280/h/960" alt=""></li>
</ol>
<h2 id="关于-Hexo-Material-主题的相关配置"><a href="#关于-Hexo-Material-主题的相关配置" class="headerlink" title="关于 Hexo Material 主题的相关配置"></a>关于 Hexo Material 主题的相关配置</h2><p>这里我会将分享我关于<code>Material</code>配置时的一些踩坑经验,使用其他主题的童鞋可以直接跳过这一段,去看后面的其他优化配置.</p>
<p><code>Material</code>的相关配置文档可以直接查看<a href="https://link.juejin.im?target=https%3A%2F%2Fmaterial.viosey.com%2F" target="_blank" rel="external">官网配置文档</a>,但是我在配置的一些过程中发现该网站中的文档部分没有跟上最新发布的版本,例如关于文章评论这一块,并没有网易云跟帖的相关说明,但是在最新的版本中,已经跟新了对网易云跟帖的支持.推荐大家直接去查看其 Github 上面的文档—<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fviosey%2Fmaterial-theme-docs" target="_blank" rel="external">material-theme-docs</a>,这里更新的比较及时.</p>
<ul>
<li><code>站点配置文件</code>:<code>.../hexo_blog/_config.yml</code></li>
<li><code>主题配置文件</code>: <code>.../hexo_blog/themes/material/_config.yml</code></li>
</ul>
<h3 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h3><p>这里我主要介绍一下关于博客使用语言的设置,其默认的是英语,我们可以编辑<code>站点配置文件</code>,将<code>language</code>设置成你想要的语言,常用的几种如下:</p>
<ul>
<li>英语: <code>en</code></li>
<li>简体中文: <code>zh-CN</code></li>
<li>繁体中文: <code>zh-TW</code></li>
<li>language: zh-CN</li>
</ul>
<h4 id="代码高亮设置"><a href="#代码高亮设置" class="headerlink" title="代码高亮设置"></a>代码高亮设置</h4><p>这里可以使用 <code>hexo-prism-plugin</code>这个插件来让我们文章中的代码实现高亮，具体文档官方已经写得很详细了,这里我就不再多说,大家直接去参考 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fele828%2Fhexo-prism-plugin" target="_blank" rel="external">Hexo-Prism-Plugin 插件文档</a>即可.</p>
<h3 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h3><p>这里我直接贴出我的配置文件,大家可以结合官方文档参考下,但我会在下面一些有可能踩坑的地方做出一些相关注释,大家可以配合着一起看下.</p>
<pre><code># .../hexo_blog/themes/material/_config.yml
---------------------------------------------------------------
# Site Information Settings
#---------------------------------------------------------------

# Head info
head:
    favicon: &quot;/img/favicon_c.png&quot;//网站的 favicon
    high_res_favicon: &quot;/img/favicon_c.png&quot;//高清 favicon
    apple_touch_icon: &quot;/img/favicon_c.png&quot;  //IOS 主屏按钮图标
    keywords: 前端,全栈,Web,自学编程,学习分享  //网站关键词,文章的关键字会结合你对文章打上的相应标签来一起显示
    site_verification:  //向搜索引擎验证你对站点的所有权,后面会专门做这方面的 SEO
        google:
        baidu:

    # Enable generate structured-data as JSON+LD for SEO or not.
    #        Set as &#39;false&#39; if it cause some wrong when `hexo g`.
    structured_data: true  //用于改善搜索引擎对你网站的 SEO, 建议开启

# Jump Links Settings
url:
    rss:  //设置生成的 rss 或 atom url
    daily_pic: &quot;#&quot; //设置 daily_pic 模块 点击时跳转的 url
    logo: &quot;#&quot; //设置 logo 点击时跳转的 url

# ---------------------------------------------------------------
# Style Settings
# ---------------------------------------------------------------

# Shemes  //主题选择设置,现在只有默认的 Paradox 和至简模式的 Isolation,去掉对应的 # 号就可使用
scheme: Paradox
#scheme: Isolation

# UI &amp;amp; UX: slogan, color, effect
uiux:
    slogan: &quot;XXXXXXXXXXX&quot;
    theme_color: &quot;#607D8B&quot;
    theme_sub_color: &quot;#00838F&quot;
    hyperlink_color: &quot;#00838F&quot;
    button_color: &quot;#757575&quot;
    android_chrome_color: &quot;#607D8B&quot;
    nprogress_color: &quot;#29d&quot;
    nprogress_buffer: &quot;800&quot;
</code></pre><h4 id="slogan-—-网站标语"><a href="#slogan-—-网站标语" class="headerlink" title="slogan — 网站标语"></a>slogan — 网站标语</h4><p><code>slogan</code>: 显示在<code>blog_info</code>模块中的标语,我们可以将其可以设置成单行或者多行,支持 HTML 标签.</p>
<ul>
<li>单行格式: <code>slogan: &quot;我爱吃土豆&quot;</code></li>
<li>多行格式:(注意缩进)</li>
</ul>
<pre><code>    slogan: 
        - &quot;我爱吃土豆&quot;
        - &quot;我爱吃番茄&quot;
</code></pre><p>我继续接上面开始说明 <code>.../hexo_blog/themes/material/_config.yml</code>中的相关代码.</p>
<pre><code># JS Effect Switches --- 用来控制 Material 主题中自带的多种 js 特性
js_effect:
    fade: true
    smoothscroll: false
# Reading experience --- 首页文章输出摘要的字符长度
reading:
    entry_excerpt: 80

# Thumbnail Settings --- 用于设置文章缩略图相关
thumbnail:
    purecolor:
    random_amount: 19

# Background Settings
# bing available parameter:
#     new | color= | type=
#         color available value: black, blue, brown, green, multi, orange, pink, purple, red, white, yellow
#         type available value: A (animal), C (culture), N (nature), S (space), T (travel)
background:
    purecolor: &quot;#F5F5F5&quot;
    #bgimg: &quot;/img/bg.png&quot;
#   开启bing随机背景
    bing:
        enable: false
        parameter:

# Images Settings
img:
    logo: &quot;/img/logo_c.png&quot;
    avatar: &quot;/img/avatar.JPG&quot;
    daily_pic: &quot;/img/daily_pic.jpg&quot;
    sidebar_header: &quot;/img/sidebar_header.jpg&quot;
    random_thumbnail: &quot;/img/random/material-&quot;
    footer_image:
        #upyun_logo:
            #link: &quot;https://www.upyun.com/&quot;
            #src: &quot;/img/upyun_logo.svg&quot;

# Custom Fonts
#   family: the font-family which will be used in the theme
#   host: uri of fonts host.
#       Available value of &quot;host&quot;: google | baomitu | ustc | custom
fonts:
    family: Roboto, &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;微软雅黑&quot;, Arial, sans-serif
    use: baomitu
    custom_font_host:

# Card Elevation Level
card_elevation: 2

# Code highlight#代码高亮提示
# You can only enable one of them to avoid issues.
# Also you need to disable highlight option in hexo&#39;s _config.yml.
#
#    Prettify
#        theme: # Available value in /source/css/prettify/[theme].min.css
prettify:
    enable: false
    theme: &quot;github-v2&quot;

#    Hanabi (https://github.com/egoist/hanabi)
#        line_number: [true/false] # Show line number for code block
#        includeDefaultColors: [true/false] # Use default hanabi colors
#        customColors: This value accept a string or am array to setting for hanabi colors.
#                    - If `includeDefaultColors` is true, this will append colors to the color pool
#                    - If `includeDefaultColors` is false, this will instead default color pool
hanabi:
    enable: true
    line_number: true
    includeDefaultColors: true
    customColors: 

# Copyright
# Specify the date when the site was setup.
#   For example, if you set it as 2015, then footer will show &#39;© 2015 - 2017&#39;
copyright_since: 2017

# Qrcode for redirect at other device
#   use: choose which method to generate the qrcode for each posts.
#       Available value of &quot;use&quot;: plugin | online
#           - When use &quot;plugin&quot;, you need to install the hexo-helper-qrcode.
#           - When use &quot;online&quot;, the qrcode will be generated by &#39;pan.baidu.com&#39; in China.
qrcode:
    enable: true
    use: plugin

# ---------------------------------------------------------------
# Menu Settings
# ---------------------------------------------------------------

# TOC Button

toc:
#   use: choose whether the line_number of toc will show or not.
#       Available value of &quot;linenumber&quot;: true | false
    linenumber: true

# SNS Menu
sns:
    email: xxx@email.com
    facebook: 
    twitter: 
    googleplus: 
    weibo:
    instagram:
    tumblr:
    github: &quot;https://www.github.com/xxx&quot;
    linkedin: &quot;https://www.linkedin.com/in/xxx/&quot;
    zhihu: &quot;https://www.zhihu.com/people/xxx&quot;
    bilibili:
    telegram:

# SNS Share Switch
sns_share:
    twitter: true
    facebook: true
    googleplus: true
    weibo: true
    linkedin: true
    qq: true
    telegram: false

# Sidebar Customize
sidebar:
    dropdown:
        Email Me:
            link: &quot;mailto:xxx@email.com&quot;
            icon: email
    homepage:
        use: true
        icon: home
        divider: false
    categories:
        use: true
        icon: chrome_reader_mode
        divider: false
    tags:
        use: true
        icon: chrome_reader_mode
        divider: false
    archives:
        use: true
        icon: timeline
        divider: false
    pages:
        标签云:
            link: &quot;/tags&quot;
            icon: cloud_circle
            divider: true
        Timeline:
            link: &quot;/timeline&quot;
            icon: send
            divider: false
        Gallery:
            link: &quot;/gallery&quot;
            icon: photo_library
            divider: false
        About Me:
            link: &quot;/test&quot;
            icon: person_pin
            divider: true
    article_num:
        use: true
        divider: false
    footer:
        divider: false
        theme: false
        support: false
        feedback: false
        material: false
</code></pre><h4 id="code-highlight"><a href="#code-highlight" class="headerlink" title="code highlight"></a>code highlight</h4><p>代码高亮提示，有两种方法，pretify和hanbi，推荐hanbi，彩色的代码提示，很美观<br> <img src="https://ws2.sinaimg.cn/large/006tNc79gy1fjtty8bs0aj30lh07jt8v.jpg" alt=""><br> <img src="https://ws2.sinaimg.cn/large/006tNc79gy1fjttythnfsj30is0e70t7.jpg" alt=""></p>
<h4 id="sidebar-—-侧边栏"><a href="#sidebar-—-侧边栏" class="headerlink" title="sidebar — 侧边栏"></a>sidebar — 侧边栏</h4><p>关于侧边栏的一些相关配置这里有些部分我需要说明一下: 图标选择网站是<a href="https://link.juejin.im?target=https%3A%2F%2Fmaterial.io%2Ficons%2F" target="_blank" rel="external">这个</a>(需要翻墙),只需要向下面一样把 icon 对应的配置项换掉就可以切换图标.</p>
<ul>
<li><code>homepage</code>: 主页</li>
<li><code>catagories</code>: 文章分类</li>
<li><code>tags</code>: 文章打上的标签</li>
<li><code>archives</code>: 文章按时间归档</li>
<li><code>pages</code>: 用于设置一些独立页面的<strong>入口</strong>(相关页面需要自己开启,后面后有相关说明),格式如下:</li>
</ul>
<pre><code>链接名称:
    link: &quot;/xxx&quot; //url 地址
    icon: xxxx   // 图标样式
    divider: true/false //是否显示下划线
</code></pre><ul>
<li><code>article_num</code>: 是否显示文章数目统计</li>
<li><code>footer</code>: 配置侧边栏的底部</li>
</ul>
<pre><code># ---------------------------------------------------------------
# Integrated Services
# ---------------------------------------------------------------

# MaterialCDN
# When you set &#39;use&#39; as true, the needed css, js, font file will have a new src.
# The new src will have the base domain you configured in &#39;base&#39;.
materialcdn: 
    use: false 
    base: xxxx

# Comment Systems
# Available value of &quot;use&quot;:
#     disqus | disqus_click | changyan | livere | gitment | valine
# If you want to use gitment,you should get the client_id and client_secret form https://github.com/settings/applications/new
# If you want to use valine,you should get the app_id and app_key form https://leancloud.cn ,more setting please see https://github.com/xCss/Valine
comment:
    use: changyan
    shortname: # duoshuo or disqus shortname
    changyan_appid: xxxxxxx
    changyan_conf: xxxxxxxxxx
    changyan_thread_key_type: path
    livere_data_uid:
    gitment_repo:   # git repo of the hexo
    gitment_owner:  # git repo&#39;s owner
    gitment_client_id:  # github app client id 
    gitment_client_secret :  # github app client secret 
    valine_leancloud_appId: # leancloud application app id
    valine_leancloud_appKey: # leancloud application app key

# Search Systems
# Available value:
#     swiftype | google | local
search:
    use: swiftype
    swiftype_key: xxxxxxxxx

# Analytics Systems
# Available value:
#     baidu | google | cnzz
analytics:
    google_site_id: 
    baidu_site_id: xxxxxxxxxx
    cnzz_site_id:

# Leancloud Views
leancloud:
    enable: false
    app_id: #你的 app_id
    app_key: #你的 app_key
    av_core_mini: &quot;xxxxxxxxxxxxxxxxxxx&quot;

# Busuanzi 不蒜子 Views
busuanzi:
    enable: true
    all_site_uv: true
    post_pv: true
    busuanzi_pure_mini_js: &quot;xxxxxxxxxxxx&quot;

sitemap: 
  path: sitemap.xml
baidusitemap:
  path: baidusitemap.xml
</code></pre><h4 id="集成服务"><a href="#集成服务" class="headerlink" title="集成服务"></a>集成服务</h4><ul>
<li><code>materialcdn</code>: 使用 cdn 来加速 Material 主题需要使用到的一些静态资源,例如 jq 等,但我感觉效果不是很明显,所以没有使用.</li>
<li><p><code>comment</code>: 文章使用的评论系统,内置的目前有四种</p>
<ul>
<li><code>Disqus/Disqus_click</code>: 这两个区别不是很大,后者需要点击才显示评论,但在国内环境下,<strong>加载速度很慢</strong>,不建议使用<ul>
<li><code>changyan</code>: 畅言,推荐使用。唯一缺点就是<em>国内使用需要域名提前备案<strong>,</strong></em>但是备案的话可以随便先填一个正规的（百度搜）等通过审核了，再把域名改成自己的**，是不是很机智～</li>
<li><del><code>163gentie</code>: 网易云跟帖,这个配置起来很简单,不关风格还是功能都比较完善,推荐使用,只需要去注册一下<a href="https://link.juejin.im?target=https%3A%2F%2Fgentie.163.com%2F" target="_blank" rel="external">网易云跟帖</a>,然后设置好自己的评论格式,再在<code>gentie_productKey</code>这一栏当中填入你的 key 就行.这个 key 在<code>获取代码</code>中的 <code>WEB 代码</code>当中,如下图:</del><strong>网易跟贴不幸被封了</strong>～<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/177c5e346a95cf5d2118b83cec24cb51?imageView2/0/w/1280/h/960" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><code>search</code>: 推荐使用swiftype，搜索界面比百度谷歌搜索美观，搜索速度很快，且配置简单。<br>¬去swiftype官网注册账号，创建引擎，按照步骤把域名填入，swiftype的爬虫会自动抓取你当前域名下的页面，点击安装搜索，在代码中找到图下这段代码，填入主题配置文件中的swiftype_key中，如下。即可配置成功。<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fjttehawrtj30hb05ct8u.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fjttflowokj30ob04l0sw.jpg" alt=""><br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fjttgg2l7hj309g05j0sp.jpg" alt="效果图"></li>
<li><p><code>analytics</code>: 网站的数据统计与分析,关于这一块推荐使用国内的<code>baidu</code>,百度在这一方面确实做得更加符合国情一些,而且我们还可以绑定微信公众号,随时了解自己网站的相关统计数据.</p>
</li>
<li><p>百度统计: 只需要登录<a href="https://link.juejin.im?target=http%3A%2F%2Ftongji.baidu.com%2F" target="_blank" rel="external">百度统计</a>,在站点的代码获取页面复制<code>hm.js?</code>后面那串统计脚本id,填入<code>site_id</code>即可.<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/516434ae0998dc249bf5b2e14dcafc9b?imageView2/0/w/1280/h/960" alt=""></p>
</li>
<li><code>Leancloud</code>/<code>busuanzi</code>: <code>Pv&amp;amp;UV</code>统计,这里我偷懒直接使用的不蒜子的服务,使用不蒜子仅需在<strong>主题配置文件</strong>中将<code>busuanzi: enable:</code> 的值设置为 <code>true</code><ul>
<li>enable: 默认为 false。</li>
<li>all_site_uv: 默认为 false,可统计全站的独立访客人数，即可在 <code>blog_info</code> 模块的 <code>Menu</code> 菜单中看到</li>
<li>post_pv: 默认为 false,统计每篇文章的页面浏览次数，在文章页的 <strong>分享按钮</strong> 菜单中可看到</li>
<li>busuanzi_pure_mini_js: 统计 <code>js</code>,调用不蒜子统计<code>js</code>文件，可将该文件保存至你的 WebServer 或 CDN 中，然后在这里填入 URL</li>
</ul>
</li>
<li><code>sitemap</code>/<code>baidusitemap</code>: 关于搜索引擎优化,会在下面进行说明.<br>以下页面配置好后只是已经存在于你的博客里面了,可以直接输入相应地址查看,但是要想在侧边栏新建快捷入口,<strong>请参考该文<code>侧边栏</code>中<code>pages</code>的相关配置.</strong></li>
</ul>
<h4 id="创建友情链接页面"><a href="#创建友情链接页面" class="headerlink" title="创建友情链接页面"></a>创建<code>友情链接</code>页面</h4><h5 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h5><p>在 hexo 目录下的 <code>source</code> 文件夹中内创建一个名为 <code>links</code>的文件夹。</p>
<p>然后在文件内创建一个名为 <code>index.md</code> 的 Markdown 文件。</p>
<p>最后在 <code>index.md</code> 文件内写入如下内容即可。</p>
<pre><code>    ---
    title: links
    date:
    layout: links
    ---
</code></pre><p>这里要注意的是<code>title</code>(对应的链接名称) 可修改，<code>layout</code> 不可修改。</p>
<h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5><p>只需我们同样在 hexo 目录下的 <code>source</code> 文件夹内创建一个名为 <code>_data</code>（禁止改名）的文件夹。</p>
<p>然后在文件内创建一个名为 <code>links.yml</code> 的文件,在其中添加相关数据即可。</p>
<p>这里单个友情链接的格式为：</p>
<pre><code>    Name:
        link: http://example.com
        avatar: http://example.com/avatar.png
        descr: &quot;这是一个描述&quot;
</code></pre><p>添加多个友情链接，我们只需要根据上面的格式重复填写即可。</p>
<ul>
<li>将 <code>Name</code> 改为友情链接的名字，例如 <code>Viosey</code>。</li>
<li><code>http://example.com</code> 为友情链接的地址。</li>
<li><code>http://example.com/avatar.png</code> 为友情链接的头像。</li>
<li><code>这是一个描述</code> 为友情链接描述。</li>
</ul>
<h4 id="创建「图库」页面"><a href="#创建「图库」页面" class="headerlink" title="创建「图库」页面"></a>创建「图库」页面</h4><h5 id="创建页面-1"><a href="#创建页面-1" class="headerlink" title="创建页面"></a>创建页面</h5><p>在 hexo 目录下的 <code>source</code> 文件夹内创建一个名为 <code>gallery</code>的文件夹。</p>
<p>然后在文件内创建一个名为 <code>index.md</code> 的 Markdown 文件。</p>
<p>在 <code>index.md</code> 文件内写入如下内容即可。</p>
<pre><code>    ---
    title: gallery
    date:
    layout: gallery
    ---
</code></pre><p><code>title</code> 可修改，<code>layout</code> 不可修改(同上)。</p>
<h5 id="添加数据-1"><a href="#添加数据-1" class="headerlink" title="添加数据"></a>添加数据</h5><p>在 hexo 目录下的 <code>source</code> 文件夹内创建一个名为 <code>_data</code>（禁止改名）的文件夹。</p>
<p>然后在文件内创建一个名为 <code>gallery.yml</code> 的文件,在其中添加如下格式的数据即可。</p>
<p>其中单个图片的格式为：</p>
<pre><code>    Name:
        full_link: http://example.com/full-image.png
        thumb_link: http://example.com/thumb-image.png
        descr: &quot;这是一个描述&quot;
</code></pre><p>添加多张图片，只需要根据上面的格式重复填写即可。</p>
<ul>
<li>将 <code>Name</code> 改为图片名字，例如 <code>Material</code>。</li>
<li><code>http://example.com/full-image.png</code> 为完整图片的地址。</li>
<li><code>http://example.com/thumb-image.png</code> 为图片缩略图的地址，如果没有缩略图也可使用完整图片的地址。</li>
<li><code>这是一个描述</code> 为图片描述。</li>
</ul>
<h4 id="创建「标签云」页面"><a href="#创建「标签云」页面" class="headerlink" title="创建「标签云」页面"></a>创建「标签云」页面</h4><h5 id="创建页面-2"><a href="#创建页面-2" class="headerlink" title="创建页面"></a>创建页面</h5><p>在 hexo 目录下的 <code>source</code> 文件夹内创建一个名为 <code>tags</code>（只是建议，可根据自己喜好修改）的文件夹。</p>
<p>然后在文件内创建一个名为 <code>index.md</code> 的 Markdown 文件。</p>
<p>在 <code>index.md</code> 文件内写入如下内容。</p>
<pre><code>    ---
    title: tags
    date:
    layout: tags
    ---
</code></pre><p><code>title</code> 可修改，<code>layout</code> 不可修改。</p>
<h4 id="创建「时间轴」页面"><a href="#创建「时间轴」页面" class="headerlink" title="创建「时间轴」页面"></a>创建「时间轴」页面</h4><h5 id="创建页面-3"><a href="#创建页面-3" class="headerlink" title="创建页面"></a>创建页面</h5><p>在 hexo 目录下的 <code>source</code> 文件夹内创建一个名为 <code>timeline</code>（只是建议，可根据自己喜好修改）的文件夹。</p>
<p>然后在文件内创建一个名为 <code>index.md</code> 的 Markdown 文件。</p>
<p>在 <code>index.md</code> 文件内写入如下内容即可。</p>
<pre><code>    ---
    title: timeline
    date:
    layout: timeline
    ---
</code></pre><p><code>title</code> 可修改，<code>layout</code> 不可修改。</p>
<p>到此,关于<code>Material</code>主题的相关配置我觉得已经说得算是比较清楚了,至于上面提到的blog网站的seo优化在我的另一篇博客中有详细阐述.<a href="http://pancakeawesome.ink/2017/09/23/%E7%BD%91%E7%AB%99%20SEO%20%E4%BC%98%E5%8C%96/">传送门</a></p>
<h2 id="如何操作该博客"><a href="#如何操作该博客" class="headerlink" title="如何操作该博客"></a>如何操作该博客</h2><p>相信应该有部分童鞋看完前面所有的配置估计已经被绕的云里雾里的,但不要担心不要害怕,当你配置好后接下来的使用简便.这里我简单的说下按照我这个流程配置完后,日常的使用操作吧.</p>
<h3 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h3><ol>
<li><del><code>hexo g</code>: 生成当前博客</del> 重新编写后的 gulp 任务可以直接生成完成<code>public</code>文件夹中的生成以及压缩.</li>
<li><code>gulp build~~</code>: 生成文件后再压缩已生成的代码,图片等</li>
<li><code>hexo d</code>: 将最终代码推送上去</li>
</ol>
<h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><h4 id="使用命令行"><a href="#使用命令行" class="headerlink" title="使用命令行"></a>使用命令行</h4><pre><code>    hexo new &lt;你的文章名&gt;
</code></pre><h4 id="手动创建"><a href="#手动创建" class="headerlink" title="手动创建"></a>手动创建</h4><p>在 hexo 主目录下 <code>source／_posts</code> 新建以 <code>.md</code> 为后缀的文件。</p>
<h4 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h4><p>Front-matter 是文件最上方以 <code>---</code> 分隔的一块区域,主要用于指定个别文件的变量来设置我们的相关文章等页面,具体位置如下</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fhexo.io%2Fzh-cn%2Fdocs%2Ffront-matter.html" target="_blank" rel="external">Front-matter - 官方介绍</a></p>
<table><br>    <thead><br>        <tr><br>            <th>参数</th><br>            <th>描述</th><br>            <th>默认值</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td><code>layout</code></td><br>            <td>布局</td><br>            <td>post</td><br>        </tr><br>        <tr><br>            <td><code>title</code></td><br>            <td>标题</td><br>            <td>文件名</td><br>        </tr><br>        <tr><br>            <td><code>date</code></td><br>            <td>建立日期</td><br>            <td>文件建立日期</td><br>        </tr><br>        <tr><br>            <td><code>updated</code></td><br>            <td>更新日期</td><br>            <td>文件更新日期</td><br>        </tr><br>        <tr><br>            <td><code>tags</code></td><br>            <td>标签（不适用于分页）</td><br>            <td></td><br>        </tr><br>        <tr><br>            <td><code>categories</code></td><br>            <td>分类（不适用于分页）</td><br>            <td></td><br>        </tr><br>        <tr><br>            <td><code>permalink</code></td><br>            <td>覆盖文章网址</td><br>            <td></td><br>        </tr><br>        <tr><br>            <td><code>thumbnail</code></td><br>            <td>缩略图地址</td><br>            <td></td><br>        </tr><br>        <tr><br>            <td><code>toc</code></td><br>            <td>显示 TOC 按钮</td><br>            <td>true</td><br>        </tr><br>        <tr><br>            <td><code>comment</code></td><br>            <td>显示评论</td><br>            <td>true</td><br>        </tr><br>        <tr><br>            <td><code>notag</code></td><br>            <td>不生成标签按钮</td><br>            <td>false</td><br>        </tr><br>        <tr><br>            <td><code>top</code></td><br>            <td>置顶</td><br>            <td>false</td><br>        </tr><br>        <tr><br>            <td><code>mathJax</code></td><br>            <td>启用 Mathjax</td><br>            <td>false</td><br>        </tr><br>        <tr><br>            <td><strong>description</strong></td><br>            <td><strong>每篇文章在搜索结果中显示的链接描述</strong></td><br>            <td>站点配置文件中的 description</td><br>        </tr><br>    </tbody><br></table>

<h4 id="缩略图功能"><a href="#缩略图功能" class="headerlink" title="缩略图功能"></a>缩略图功能</h4><p>在 Material 主题中，每个 Scheme 都有缩略图功能。<br>    只需要在 <code>Front-matter</code> 中添加参数 <code>thumbnail:</code>，然后填入缩略图地址即可。</p>
<h3 id="修改你的文章模板"><a href="#修改你的文章模板" class="headerlink" title="修改你的文章模板"></a>修改你的文章模板</h3><p>当你每次使用<code>hexo new 你的文章名</code>时,默认生成的模板是这个样子的</p>
<pre><code>    ---
    title: XXXX
    tag: XXXX
    date: XXXX
    ---
</code></pre><p>但这种这种文章模板没有一大堆描述属性,例如<code>description</code>,<code>thumbnail</code>等,明显不能满足我们的日常需求,所以我们这是一般会去修改我们的默认模板来满足我们的需求.这是我们只需修改<code>/scaffolds/</code>下相应的文件即可.</p>
<pre><code>    post.md  =&gt;  对应hexo new 生成的md模板
    page.md  =&gt;  对应hexo new page生成的categories模板
</code></pre><p>例如我修改的就是<code>/scaffolds/post.md</code>:</p>
<pre><code>    ---
    title: {{ title }} //文章标题
    tags: [] //文章的标签
    categories: 文章的分类
    description: 文章的搜索结果描述
    thumbnail: &#39;文章缩略图位置&#39;
    date: {{ date }} //时间
    ---
</code></pre><p>这里还可以添加一些文章公共的开头等文字</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后,关于我自己这篇博客的折腾过程基本上是说清楚了,如果那里有写的不够清楚或者有问题的地方,欢迎大家来邮箱或者qq（<a href="http://pancakeawesome.ink/">博客网站首页</a>有)交流指正.</p>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[系统入门sass（语法篇）]]></title>
      <url>/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8sass(%E8%AF%AD%E6%B3%95%E7%AF%87).html</url>
      <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>定义变量的语法：<br>在有些编程语言中（如，JavaScript）声明变量都是使用关键词“var”开头，但是在 Sass 不使用这个关键词，而是使用大家都喜欢的美元符号<code>“$”</code>开头。我想用一张图来解释，我一直坚信，一图胜千言万语：<br><img src="http://img.mukewang.com/551e065c0001435e07870307.jpg" alt=""><br>上图非常清楚告诉了大家，Sass 的变量包括三个部分：</p>
<ul>
<li>声明变量的符号“$”</li>
<li>变量名称</li>
<li>赋予变量的值<br>来看一个简单的示例，假设你的按钮颜色可以给其声明几个变量：<pre><code>$brand-primary : darken(#428bca, 6.5%) !default; // #337ab7
$btn-primary-color : #fff !default;
$btn-primary-bg : $brand-primary !default;
$btn-primary-border : darken($btn-primary-bg, 5%) !default;
</code></pre>如果值后面加上!default则表示默认值。<br>注：了解 Bootstrap 的 Sass 版本的同学，就一眼能看出，上面的示例代码是 Bootstrap 定义 primarybutton 的颜色。</li>
</ul>
<h4 id="如果变量需要镶嵌在字符串之中，就必须需要写在-之中。"><a href="#如果变量需要镶嵌在字符串之中，就必须需要写在-之中。" class="headerlink" title="如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。"></a>如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。</h4><pre><code>&gt; $side : left;
&gt; 
&gt; 　　.rounded {
&gt; 
&gt; 　　　　border-#{$side}-radius: 5px;
&gt; 
&gt; 　　}
</code></pre><h3 id="计算功能"><a href="#计算功能" class="headerlink" title="计算功能"></a>计算功能</h3><p>SASS允许在代码中使用算式：</p>
<pre><code>&gt; body {
&gt; 
&gt; 　　　　margin: (14px/2);
&gt; 
&gt; 　　　　top: 50px + 100px;
&gt; 
&gt; 　　　　right: $var  * 10%;
&gt; 
&gt; 　　}
</code></pre><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a><strong>嵌套</strong></h3><p>SASS允许选择器嵌套。比如，下面的CSS代码：</p>
<pre><code>&gt; div h1 {
&gt; 
&gt; 　　　　color : red;
&gt; 
&gt; 　　}
</code></pre><p>可以写成：</p>
<pre><code>&gt; div {
&gt; 
&gt; 　　　　hi {
&gt; 
&gt; 　　　　　　color:red;
&gt; 
&gt; 　　　　}
&gt; 
&gt; 　　}
</code></pre><p>属性也可以嵌套，比如border-color属性，可以写成：</p>
<pre><code>&gt; p {
&gt; 
&gt; 　　　　border: {
&gt; 
&gt; 　　　　　　color: red;
&gt; 
&gt; 　　　　}
&gt; 
&gt; 　　}
</code></pre><p><strong>注意，border后面必须加上冒号。</strong></p>
<p>在嵌套的代码块内，可以使用&amp;引用父元素。比如<code>a:hover</code>伪类，可以写成：</p>
<pre><code> a {

　&amp;:hover { color: #ffb3ff; }

　}
</code></pre><p><strong>注意&amp;后面的<code>:</code>后面不能加空格</strong></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h3><p>SASS共有两种注释风格。</p>
<ul>
<li>标准的CSS注释 <code>/* comment */</code>，会保留到编译后的文件。</li>
<li>单行注释<code>// comment</code>，只保留在<code>SASS源文件</code>中，编译后被省略。</li>
</ul>
<p>在<code>/*</code>后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。</p>
<pre><code>&gt; /*! 
&gt; 
&gt; 　　　　重要注释！
&gt; 
&gt; 　　*/
</code></pre><h2 id="代码的重用"><a href="#代码的重用" class="headerlink" title="代码的重用"></a><strong>代码的重用</strong></h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><p>SASS允许一个选择器，继承另一个选择器。比如，现有<code>class1</code>：</p>
<pre><code>&gt; .class1 {
&gt; 
&gt; 　　　　border: 1px solid #ddd;
&gt; 
&gt; 　　}
</code></pre><p>class2要继承class1，就要使用<code>@extend</code>命令：</p>
<pre><code>&gt; .class2 {
&gt; 
&gt; 　　　　@extend .class1;
&gt; 
&gt; 　　　　font-size:120%;
&gt; 
&gt; 　　}
</code></pre><p><strong>注意：</strong></p>
<ul>
<li><strong>sass不支持嵌套选择器的继承，比如：</strong><br>```sass<br>.b .c {<br>  color: red;<br>}</li>
</ul>
<p>.a {<br>    @extend .b .c;<br>}</p>
<pre><code>**这样写是错误的❌,sass不会编译成功**
- **如果你只想让某个样式只用来继承给别的样式，而不想让这个样式输出到css文件中（就像接口一样），可以使用%去修饰样式，这样这个样式就只能用来继承，不能输出到css文件中**
```sass
%error {
    color: red;
}

.serious-error {
    @extend %error;
}
</code></pre><h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a><strong>Mixin</strong></h3><p>Mixin有点像C语言的宏<code>（macro）</code>，是可以重用的代码块。</p>
<p>使用<code>@mixin</code>命令，定义一个代码块。</p>
<pre><code>&gt; @mixin left {
&gt; 
&gt; 　　　　float: left;
&gt; 
&gt; 　　　　margin-left: 10px;
&gt; 
&gt; 　　}
</code></pre><p>使用<code>@include</code>命令，调用这个mixin。</p>
<pre><code>&gt; div {
&gt; 
&gt; 　　　　@include left;
&gt; 
&gt; 　　}
</code></pre><p>mixin的强大之处，在于可以指定参数和缺省值。</p>
<pre><code>&gt; @mixin left($value: 10px) {
&gt; 
&gt; 　　　　float: left;
&gt; 
&gt; 　　　　margin-right: $value;
&gt; 
&gt; 　　}
</code></pre><p>使用的时候，根据需要加入参数：</p>
<pre><code>&gt; div {
&gt; 
&gt; 　　　　@include left(20px);
&gt; 
&gt; 　　}
</code></pre><p>下面是一个mixin的实例，用来生成浏览器前缀。</p>
<pre><code>&gt; @mixin rounded($vert, $horz, $radius: 10px) {
&gt; 
&gt; 　　　　border-#{$vert}-#{$horz}-radius: $radius;
&gt; 
&gt; 　　　　-moz-border-radius-#{$vert}#{$horz}: $radius;
&gt; 
&gt; 　　　　-webkit-border-#{$vert}-#{$horz}-radius: $radius;
&gt; 
&gt; 　　}
</code></pre><p>使用的时候，可以像下面这样调用：</p>
<pre><code>&gt; #navbar li { @include rounded(top, left); }
&gt; 
&gt; 　　#footer { @include rounded(top, left, 5px); }
</code></pre><h3 id="颜色函数"><a href="#颜色函数" class="headerlink" title="颜色函数"></a><strong>颜色函数</strong></h3><p>SASS提供了一些内置的颜色函数，以便生成系列颜色。</p>
<pre><code>&gt; lighten(#cc3, 10%)  // #d6d65c
&gt; 
&gt; 　　darken(#cc3, 10%)  //  #a3a329
&gt; 
&gt; 　　grayscale(#cc3) // #808080
&gt; 
&gt; 　　complement(#cc3) // #33c
</code></pre><h3 id="插入文件"><a href="#插入文件" class="headerlink" title="插入文件"></a><strong>插入文件</strong></h3><p><code>@import</code>命令，用来插入外部文件。</p>
<pre><code>&gt; @import &quot;path/filename.scss&quot;;
</code></pre><p>如果插入的是<code>.css</code>文件，则等同于css的<code>import</code>命令。</p>
<pre><code>&gt; @import &quot;foo.css&quot;;
</code></pre><h2 id="五、高级用法"><a href="#五、高级用法" class="headerlink" title="五、高级用法"></a><strong>五、高级用法</strong></h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a><strong>条件语句</strong></h3><p><code>@if</code>可以用来判断：</p>
<pre><code>&gt; p {
&gt; 
&gt; 　　　　@if 1 + 1 == 2 { border: 1px solid; }
&gt; 
&gt; 　　　　@if 5 &amp;lt; 3 { border: 2px dotted; }
&gt; 
&gt; 　　}
</code></pre><p>配套的还有<code>@else</code>命令：</p>
<pre><code>&gt; @if lightness($color) &amp;gt; 30% {
&gt; 
&gt; 　　　　background-color: #000;
&gt; 
&gt; 　　} @else {
&gt; 
&gt; 　　　　background-color: #fff;
&gt; 
&gt; 　　}
</code></pre><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a><strong>循环语句</strong></h3><p>SASS支持<code>for循环</code>：</p>
<pre><code>&gt; @for $i from 1 to 10 {
&gt; 
&gt; 　　　　.border-#{$i} {
&gt; 
&gt; 　　　　　　border: #{$i}px solid blue;
&gt; 
&gt; 　　　　}
&gt; 
&gt; 　　}
</code></pre><p>也支持<code>while循环</code>：</p>
<pre><code>&gt; $i: 6;
&gt; 
&gt; 　　@while $i &amp;gt; 0 {
&gt; 
&gt; 　　　　.item-#{$i} { width: 2em * $i; }
&gt; 
&gt; 　　　　$i: $i - 2;
&gt; 
&gt; 　　}
</code></pre><p><code>each</code>命令，作用与<code>for</code>类似：</p>
<pre><code>&gt; @each $member in a, b, c, d {
&gt; 
&gt; 　　　　.#{$member} {
&gt; 
&gt; 　　　　　　background-image: url(&quot;/image/#{$member}.jpg&quot;);
&gt; 
&gt; 　　　　}
&gt; 
&gt; 　　}
</code></pre><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a><strong>自定义函数</strong></h3><p>SASS允许用户编写自己的函数。</p>
<pre><code>&gt; @function double($n) {
&gt; 
&gt; 　　　　@return $n * 2;
&gt; 
&gt; 　　}
&gt; 
&gt; 　　#sidebar {
&gt; 
&gt; 　　　　width: double(5px);
&gt; 
&gt; 　　}
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[系统入门sass（基础篇）]]></title>
      <url>/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8sass.html</url>
      <content type="html"><![CDATA[<h2 id="什么是-CSS-预处理器？"><a href="#什么是-CSS-预处理器？" class="headerlink" title="什么是 CSS 预处理器？"></a>什么是 CSS 预处理器？</h2><p>定义：<br>CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。<br>通俗的说，“CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题”，例如你可以在 <strong>CSS 中使用变量、简单的逻辑程序、函数</strong>（如右侧代码编辑器中就使用了变量<code>$color</code>）等等在编程语言中的一些基本特性，<strong>可以让你的 CSS 更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处</strong>。<br>其它 CSS 预处理器语言：<br>CSS 预处理器技术已经非常的成熟，而且也涌现出了很多种不同的 <strong>CSS 预处理器语言</strong>，比如说：</p>
<ul>
<li>Sass（SCSS）</li>
<li>LESS</li>
<li>Stylus</li>
<li>Turbine</li>
<li>Swithch CSS</li>
<li>CSS Cacheer</li>
<li>DT CSS<br>如此之多的 CSS 预处理器，那么<code>“我应该选择哪种 CSS 预处理器？”</code>也相应成了最近网上的一大热门话题，在 Linkedin、Twitter、CSS-Trick、知乎以及各大技术论坛上，很多人为此争论不休。相比过去我们对是否应该使用 CSS 预处理器的话题而言，这已经是很大的进步了。<br>到目前为止，在众多优秀的 CSS 预处理器语言中就属 Sass、LESS 和 Stylus 最优秀，讨论的也多，对比的也多。<h2 id="Sass-和-SCSS-有什么区别？"><a href="#Sass-和-SCSS-有什么区别？" class="headerlink" title="Sass 和 SCSS 有什么区别？"></a>Sass 和 SCSS 有什么区别？</h2>Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass，两者之间不同之处有以下两点：</li>
</ul>
<ol>
<li>文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名</li>
<li>语法书写方式不同，Sass 是以严格的<span style="color:#B22222;">缩进式</span>语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。</li>
</ol>
<p>先来看一个示例：</p>
<p><strong>Sass 语法</strong></p>
<pre><code class="sass">$font-stack: Helvetica, sans-serif  //定义变量
$primary-color: #333 //定义变量

body
  font: 100% $font-stack
  color: $primary-color&lt;/pre&gt;
</code></pre>
<p><strong>SCSS 语法</strong></p>
<pre><code class="scss">$font-stack: Helvetica, sans-serif;
$primary-color: #333;

body &lt;span style=&quot;color:#B22222;&quot;&gt;{&lt;/span&gt;
  font: 100% $font-stack;
  color: $primary-color;
</code></pre>
<p><strong>编译出来的 CSS</strong></p>
<pre><code class="css">body {
  font: 100% Helvetica, sans-serif;
  color: #333;
}
</code></pre>
<h2 id="Sass-编译"><a href="#Sass-编译" class="headerlink" title="Sass 编译"></a>Sass 编译</h2><p>常常有人会问，使用 Sass 进行开发，那么是不是直接通过<code>“&lt;link&gt;”</code>引用<code>“.scss”</code>或<code>“.sass</code>”文件呢？</p>
<p>那么这里告诉大家，在项目中还是引用“.css”文件，Sass 只不过是做为一个预处理工具，提前帮你做事情，只有你需要时候，他才有攻效。</p>
<p>这样一来，也就有了这章需要介绍的内容—— Sass 的编译。因为 Sass 开发之后，要让 Web 页面能调用 Sass 写好的东西，就得有这么一个过程，这个过程就称之为 Sass 编译过程。Sass 的编译有多种方法：</p>
<ul>
<li>命令编译</li>
<li>GUI工具编译</li>
<li>自动化编译</li>
</ul>
<h3 id="命令编译"><a href="#命令编译" class="headerlink" title="命令编译"></a>命令编译</h3><p>命令编译是指使用你电脑中的命令终端，通过输入 Sass 指令来编译 Sass。这种编译方式是最直接也是最简单的一种方式。因为只需要在你的命令终端输入：</p>
<p><strong>单文件编译：</strong></p><br><code>bash
sass &lt;要编译的Sass文件路径&gt;/style.scss:&lt;要输出CSS文件路径&gt;/style.css</code><br><p>这是对一个单文件进行编译，如果想对整个项目所有 Sass 文件编译成 CSS 文件，可以这样操作：</p>

<p><strong>多文件编译：</strong></p><br><code>bash
sass sass/:css/</code><br><p>上面的命令表示将项目中“sass”文件夹中所有“.scss”(“.sass”)文件编译成“.css”文件，并且将这些 CSS 文件都放在项目中“css”文件夹中。</p>

<p><strong>缺点及解决方法：</strong></p>

<p>在实际编译过程中，你会发现上面的命令，只能一次性编译。每次个性保存“.scss”文件之后，都得重新执行一次这样的命令。如此操作太麻烦，其实还有一种方法，就是在编译 Sass 时，<span style="color:#B22222;">开启“<strong>watch</strong>”功能，这样只要你的代码进行任保修改，都能自动监测到代码的变化，并且给你直接编译出来：</span></p><br><code>bash
sass --watch &amp;lt;要编译的Sass文件路径&amp;gt;/style.scss:&amp;lt;要输出CSS文件路径&amp;gt;/style.css</code><br><p>当然，使用 sass 命令编译时，可以带很多的参数：</p>

<p><a href="http://img.mukewang.com/54f54b7a00014d3006690586.jpg" target="_blank" rel="external"><img alt="" src="http://img.mukewang.com/54f54b7a00014d3006690586.jpg" style="width: 355px;"></a></p>

<p><strong>watch 举例：</strong></p>

<p></p><p>来看一个简单的示例，假设我本地有一个项目，我要把项目中“bootstrap.scss”编译出“bootstrap.css”文件，并且将编译出来的文件放在“css”文件夹中，我就可以在我的命令终端中执行：</p><p></p>
<pre><code class="bash">sass --watch sass/bootstrap.scss:css/bootstrap.css
</code></pre>
<p></p><p>一旦我的 bootstrap.scss 文件有任何修改，只要我重新保存了修改的文件，命令终端就能监测，并重新编译出文件：<br><img src="http://img.mukewang.com/54f54bcb00016b1005680288.jpg" alt=""></p>
<h3 id="GUI-界面工具编译"><a href="#GUI-界面工具编译" class="headerlink" title="GUI 界面工具编译"></a>GUI 界面工具编译</h3><p>或许你会说，我一直讨厌使用命令来做事情，我喜欢那种能看得到的界面操作。那么你可以考虑使用 GUI 界面工具来对 Sass 进行编译。当然不同的 GUI 工具操作方法略有不同。</p>
<p>我比较推荐使用以下两个:<br><a href="http://www.w3cplus.com/preprocessor/sass-gui-tool-koala.html" target="_blank" rel="external">Koala</a><br><a href="http://www.w3cplus.com/preprocessor/sass-gui-tool-codekit.html" target="_blank" rel="external">CodeKit</a></p>
<h3 id="自动化编译"><a href="#自动化编译" class="headerlink" title="自动化编译"></a>自动化编译</h3><p>喜欢自动化研究的同学，应该都知道 <span style="color:#B22222;"><strong>Grunt </strong></span>和 <span style="color:#B22222;"><strong>Gulp </strong></span>这两个东东。如果您正在使用其中的任何一种，那么你也可以通过他们来配置 Sass 的编译。这里仅列出两个示例代码（具体情况要根据您的项目环境来做一定的修改，不建议生搬硬套，容易发生命案，呵呵。</p>
<p><strong>1、<span style="color:#B22222;">Grunt </span>配置 Sass 编译的示例代码</strong></p>
<pre class="code">module.exports = function(grunt) {
    grunt.initConfig({
        pkg: grunt.file.readJSON('package.json'),
        sass: {
            dist: {
                files: {
                    'style/style.css' : 'sass/style.scss'
                }
            }
        },
        watch: {
            css: {
                files: '**/*.scss',
                tasks: ['sass']
            }
        }
    });
    grunt.loadNpmTasks('grunt-contrib-sass');
    grunt.loadNpmTasks('grunt-contrib-watch');
    grunt.registerTask('default',['watch']);
}</pre>

<p><strong>2、<span style="color:#B22222;">Gulp </span>配置 Sass 编译的示例代码</strong></p>
<pre class="code">var gulp = require('gulp');
var sass = require('gulp-sass');

gulp.task('sass', function () {
    gulp.src('./scss/*.scss')
        .pipe(sass())
        .pipe(gulp.dest('./css'));
});

gulp.task('watch', function() {
    gulp.watch('scss/*.scss', ['sass']);
});

gulp.task('default', ['sass','watch']);</pre>

<h2 id="常见的编译错误"><a href="#常见的编译错误" class="headerlink" title="常见的编译错误"></a>常见的编译错误</h2><p>在编译 Sass 代码时常常会碰到一些错误，让编译失败。这样的错误有系统造成的也有人为造成的，但大部分都是人为过失引起编译失败。<br>而最为常见的一个错误就是<strong>字符编译</strong>引起的。在Sass的编译的过程中，是不是支持“GBK”编码的。所以在创建 Sass 文件时，就需要将文件编码设置为“utf-8”。<br>另外一个错误就是路径中的<strong>中文字符</strong>引起的。建议在项目中文件命名或者文件目录命名不要使用中文字符。而至于人为失误造成的编译失败，在编译过程中都会有具体的说明，大家可以根据编译器提供的错误信息进行对应的修改。</p>
<h2 id="不同样式风格的输出方法"><a href="#不同样式风格的输出方法" class="headerlink" title="不同样式风格的输出方法"></a>不同样式风格的输出方法</h2><p>众所周知，每个人编写的 CSS 样式风格都不一样，有的喜欢将所有样式代码都写在同一行，而有的喜欢将样式分行书写。在 Sass 中编译出来的样式风格也可以按不同的样式风格显示。其主要包括以下几种样式风格：</p>
<ul>
<li>嵌套输出方式 nested</li>
<li>展开输出方式 expanded  </li>
<li>紧凑输出方式 compact </li>
<li>压缩输出方式 compressed<h3 id="嵌套输出方式-nested"><a href="#嵌套输出方式-nested" class="headerlink" title="嵌套输出方式 nested"></a>嵌套输出方式 nested</h3><h4 id="嵌套输出方式-nested-1"><a href="#嵌套输出方式-nested-1" class="headerlink" title="嵌套输出方式 nested"></a>嵌套输出方式 nested</h4>Sass 提供了一种嵌套显示 CSS 文件的方式。例如</li>
</ul>
<pre><code>nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}
</code></pre><p>在编译的时候带上参数“ <code>--style nested</code>”:<br><code>sass --watch test.scss:test.css --style nested</code><br>编译出来的 CSS 样式风格：</p>
<pre><code>nav ul {
  margin: 0;
  padding: 0;
  list-style: none; }
nav li {
  display: inline-block; }
nav a {
  display: block;
  padding: 6px 12px;
  text-decoration: none; }
</code></pre><p>如下图所示：<br><img src="http://img.mukewang.com/54f54dab00019a0504880296.jpg" alt=""></p>
<h3 id="展开输出方式-expanded"><a href="#展开输出方式-expanded" class="headerlink" title="展开输出方式 expanded"></a>展开输出方式 expanded</h3><h4 id="嵌套输出方式-expanded"><a href="#嵌套输出方式-expanded" class="headerlink" title="嵌套输出方式 expanded"></a>嵌套输出方式 expanded</h4><pre><code>nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}
</code></pre><p>在编译的时候带上参数<code>“ --style expanded”:
sass --watch test.scss:test.css --style expanded</code><br>这个输出的 CSS 样式风格和 nested 类似，<strong>只是大括号在另起一行</strong>，同样上面的代码，编译出来：</p>
<pre><code>nav ul {
  margin: 0;
  padding: 0;
  list-style: none;
}
nav li {
  display: inline-block;
}
nav a {
  display: block;
  padding: 6px 12px;
  text-decoration: none;
}
</code></pre><p><img src="http://img.mukewang.com/54f54e2c0001c2c004850281.jpg" alt=""></p>
<h3 id="紧凑输出方式-compact"><a href="#紧凑输出方式-compact" class="headerlink" title="紧凑输出方式 compact"></a>紧凑输出方式 compact</h3><h4 id="嵌套输出方式-compact"><a href="#嵌套输出方式-compact" class="headerlink" title="嵌套输出方式 compact"></a>嵌套输出方式 compact</h4><pre><code>nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}
</code></pre><p>在编译的时候带上参数<code>“ --style compact”:
sass --watch test.scss:test.css --style compact</code><br>该方式适合那些喜欢单行 CSS 样式格式的朋友，编译后的代码如下：</p>
<pre><code>nav ul { margin: 0; padding: 0; list-style: none; }
nav li { display: inline-block; }
nav a { display: block; padding: 6px 12px; text-decoration: none; }
</code></pre><p><img src="http://img.mukewang.com/54f7b4bb00014f9908020299.jpg" alt=""></p>
<h3 id="压缩输出方式-compressed"><a href="#压缩输出方式-compressed" class="headerlink" title="压缩输出方式 compressed"></a>压缩输出方式 compressed</h3><h4 id="压缩输出方式-compressed-1"><a href="#压缩输出方式-compressed-1" class="headerlink" title="压缩输出方式 compressed"></a>压缩输出方式 compressed</h4><pre><code>nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}
</code></pre><p>在编译的时候带上参数<code>“ --style compressed”:
sass --watch test.scss:test.css --style compressed</code><br>压缩输出方式会去掉标准的 Sass 和 CSS 注释及空格。也就是压缩好的 CSS 代码样式风格：</p>
<pre><code>nav ul{margin:0;padding:0;list-style:none}nav li{display:inline-block}nav a{display:block;padding:6px 12px;text-decoration:none}
</code></pre><p><img src="http://img.mukewang.com/54f5511d0001b5c206660401.jpg" alt=""></p>
<p>编译出来的CSS样式风格的选择完全是个人喜好问题，可以根据自己喜欢的风格选择参数。<br><strong>一段时间之后，你实际上就不再需要写 CSS 代码了，只用写 Sass 代码。在这种情况下，你只需要设定输出格式为压缩格式，知道输出的 CSS 代码可以直接使用即可。</strong></p>
<h2 id="Sass-的调试"><a href="#Sass-的调试" class="headerlink" title="Sass 的调试"></a>Sass 的调试</h2><p><img src="http://img.mukewang.com/54f7b71d0001bb0b05050268.jpg" alt=""></p>
<ul>
<li>Sass 调试一直以来都是一件头痛的事情，使用 Sass 的同学都希望能在浏览器中直接调试 Sass 文件，能找到对应的行数。值得庆幸的是，现在实现并不是一件难事，只要你的浏览器支持“<code>sourcemap</code>”功能即可。早一点的版本，需要在编译的时候添加<code>“--sourcemap”</code>  参数：<pre><code>sass --watch --scss --sourcemap style.scss:style.css
</code></pre>在 Sass3.3 版本之上（我测试使用的版本是 3.4.7），不需要添加这个参数也可以：<pre><code>sass --watch style.scss:style.css
</code></pre>在命令终端，你将看到一个信息：<pre><code>&gt;&gt;&gt; Change detected to: style.scss
write style.css
write style.css.map
</code></pre></li>
<li>在 chrome://flags/ 中启用 Developer Tools Experiments (开发者工具实验)</li>
<li>在 Developer tools 设置 Experiments 选项下开启File system folders in Sources Panel，再重启Developer tools，就会多出Workspace选项。</li>
</ul>
<p><em>这时你就可以像前面展示的 gif 图一样，调试你的 Sass 代码。</em></p>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[三分钟入门markdown]]></title>
      <url>/%E4%B8%89%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8markdown.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>经常会用markdown来编写博客，这些语法你需要知道</strong></p>
<h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><p><code>wiki释义:</code></p>
<blockquote>
<p><code>Markdown</code> 是一种轻量级<code>标记语言</code>，创始人为约翰·格鲁伯（John Gruber）和亚伦·斯沃茨（Aaron Swartz）。<br>它允许人们“使用易读易写的纯文本格式编写文档，然后<strong>转换成有效的XHTML(或者HTML)文档</strong>”。<br>这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>
</blockquote>
<p>Markdown的优点包括但不限于以下几点:</p>
<ul>
<li>纯文本，所以兼容性极强，可以用所有文本编辑器打开。</li>
<li>让你专注于文字而不是排版。</li>
<li>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。</li>
<li>Markdown 的标记语法有极好的可读性。</li>
</ul>
<h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a><a href="#Markdown_u8BED_u6CD5" title="Markdown语法"></a>Markdown语法</h2><p>Markdown语法简洁明了、容易学习，下面一一介绍。</p>
<h3 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a><a href="#u57FA_u672C_u7B26_u53F7" title="基本符号"></a>基本符号</h3><ul>
<li><code>*</code>, <code>-</code> , <code>+</code>： 这3个符号的效果都一样， 被称为Markdown符号</li>
<li><code>空白行</code> : 表示另起一个段落,对应HTML中的 <code>&lt;p&gt;</code> 元素</li>
<li><code>` </code>  表示 <code>内联代码</code>， <code>tab</code>是用来标记<code>代码段</code>，分别对应HTML的 <code>code</code> ， <code>pre</code> 元素</li>
</ul>
<h3 id="段落换行"><a href="#段落换行" class="headerlink" title="段落换行"></a><a href="#u6BB5_u843D_u6362_u884C" title="段落换行"></a>段落换行</h3><ul>
<li><code>单个回车</code>会被解释为<code>空格</code></li>
<li>一个空白行(即<code>两个回车</code>)变成单一段落<code>&amp;lt;p&amp;gt;</code></li>
<li>连续3个Markdown符号，然后回车，表示<code>&amp;lt;hr&amp;gt;</code>横线</li>
<li><strong>连续多个空格会被解释为单个空格</strong><br><a id="more"></a></li>
</ul>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a><a href="#u6807_u9898" title="标题"></a>标题</h3><ul>
<li>在文字前面加上1-6个<code>#</code>来实现, 代表HTML中的六级标题 <code>h1</code>-<code>h6</code></li>
<li>在文字左右各加1-3各符号，可本别实现斜体<code>&lt;i&gt;</code>、加粗<code>&lt;&gt;</code>和斜体加粗</li>
</ul>
<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题

*斜体*

**加粗**

***加粗斜体***


### 引用

*   在第一行加上 `&gt;` 和一个`空格`，表示引用，还可以嵌套, 对应HTML中的`&lt;blockquote&gt;`标签

### [](#u5217_u8868 &quot;列表&quot;)列表

*   使用*,+,-加上一个空格来表示,对应HTML中的`&lt;ul&gt;`标签
*   可以支持嵌套
*   有序列表用 `数字`+`.`+`空格` 来表示,对应HTML中的`&lt;ol&gt;`标签
*   如果列表内容很长，不需要手工输入换行符，css控制段落的宽度，会自动的缩放的
</code></pre><p><strong>无序列表:</strong></p>
<pre><code>- 无序列表 1
- 无序列表 2
- 无序列表 3
</code></pre><p><strong>有序列表:</strong></p>
<pre><code>1. 有序列表 1
2. 有序列表 2
3. 有序列表 3
</code></pre><p><strong>列表嵌套:</strong></p>
<pre><code>- One
    + What
    + Why
    + How
- Two
- Three
</code></pre><p><strong>或者每级列表前面加上两个空格 表示向下一级缩进</strong></p>
<pre><code>- One
    - waht
    - why
    - how        
- Two
- Three
</code></pre><p><strong>效果如下</strong></p>
<p><strong>无序列表:</strong></p>
<ul>
<li>无序列表 1</li>
<li>无序列表 2</li>
<li>无序列表 3</li>
</ul>
<p><strong>有序列表:</strong></p>
<ol>
<li>有序列表 1</li>
<li>有序列表 2</li>
<li>有序列表 3</li>
</ol>
<p><strong>列表嵌套:</strong></p>
<ul>
<li>One<ul>
<li>What</li>
<li>Why</li>
<li>How</li>
</ul>
</li>
<li>Two</li>
<li>Three<br><strong>或者每级列表前面加上两个空格 表示向下一级缩进</strong></li>
<li>One<ul>
<li>What</li>
<li>Why</li>
<li>How</li>
</ul>
</li>
<li>Two</li>
<li>Three</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="#u94FE_u63A5" title="链接"></a>链接</h3><p>在 Markdown 中，插入链接只需要使用 <code>[显示文本](连接地址)</code>这种格式，<br>插入图片只需要使用<code>![图片描述](图片链接地址)</code>这种格式即可,其中前者对应于<br>HTML中的<code>a</code>标签，后者对应<code>img</code>标签，方括号中的图片描述为img标签的的<code>alt</code>属性值</p>
<p>还有一种建立链接的方式，称为<code>参考式</code>, 参考式的链接是在链接文字的括号后面再接上另一个方括号， 而在第二个方括号里面要填入用以辨识链接的标记: <code>[显示文本][id]</code>或<code>![图片描述][id]</code>. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来：<code>[id]: http://example.com/</code></p>
<p>示例:</p>
<pre><code>个人信息:

[Wentong](http://pancakeawesome.com/)

- [GitHub][1]
- [Facebook][]
- [Twitter][Weblog]

[1]: https://github.com/pancakeawesome/
[Facebook]: https://facebook.com/pancakeawesome/
[Weblog]: https://twitter.com/pancakeawesome/
</code></pre><p><strong>效果如下:</strong></p>
<p>个人信息:</p>
<p><a href="http://www.fangwentong.com/" target="_blank" rel="external">Wentong</a></p>
<ul>
<li><a href="https://github.com/fangwentong/" target="_blank" rel="external">GitHub</a></li>
<li><a href="https://facebook.com/fangwentong/" target="_blank" rel="external">Facebook</a></li>
<li><a href="https://twitter.com/fangwentong/" target="_blank" rel="external">Twitter</a></li>
</ul>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a><a href="#u8868_u683C" title="表格"></a>表格</h3><table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:right">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td>col 3 is</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符<code>$$</code>包裹 <code>TeX</code> 或 <code>LaTeX</code> 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 <code>Mathjax</code>对数学公式进行渲染。如：</p>
<pre><code>$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $$
$$
x \href{why-equal.html}{=} y^2 + 1
$$
</code></pre><p>同时也支持 HTML 属性，如：</p>
<pre><code>$$ (x+1)^2 = \class{hidden}{(x+1)(x+1)} $$
$$
(x+1)^2 = \cssId{step1}{\style{visibility:hidden}{(x+1)(x+1)}}
$$
</code></pre><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a><a href="#u7279_u6B8A_u7B26_u53F7" title="特殊符号"></a>特殊符号</h3><ul>
<li>用<code>\</code> 来转义，表示文本中的markdown符号</li>
</ul>
<h3 id="兼容HTML语法"><a href="#兼容HTML语法" class="headerlink" title="兼容HTML语法"></a><a href="#u517C_u5BB9HTML_u8BED_u6CD5" title="兼容HTML语法"></a>兼容HTML语法</h3><p>我们知道，Markdown最终要通过Markdown解释器转换为HTML文档, 而Markdown是一种书写的格式，它的语法种类很少，只对应HTML标记中的一小部分, 不在Markdown涵盖范围内的标签， 可以直接在文档中用HTML书写.</p>
<h3 id="自定义Markdown样式"><a href="#自定义Markdown样式" class="headerlink" title="自定义Markdown样式"></a><a href="#u81EA_u5B9A_u4E49Markdown_u6837_u5F0F" title="自定义Markdown样式"></a>自定义Markdown样式</h3><p>注意到，Markdown解释器将Markdown文本转换为HTML文档，我们编写CSS，并在生成的HTML文档中引用这个样式表, 可以达到自定义Markdown显示风格的效果.</p>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo+githubio+material搭建你的个人博客（基础篇）]]></title>
      <url>/hexo+githubio+material%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(%E5%9F%BA%E7%A1%80%E7%AF%87).html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><del><em>本帖为更新贴</em></del><br>之前用的是csdn的blog，经常写一些学习笔记📒和it相关的技术，但是总觉得自己是做前端的，总用第三方的blog平台感觉不是很合适。于是狠下心来花了两三天终于通过githubio和hexo把静态博客网站给搭起来了，参照了一些网上blog的教程，但是因为环境和版本的愿意还是有很多坑，走了很多弯路，但还好最终都一步一步淌过来了，今天才把blog给完善好，但是收获很多：资源部署，域名解析，seo，资源打包📦压缩等等技术，让我受益匪浅。<br><del><strong>今天实在太累，加上还在公司实习，没时间把blog相关的技术分享给大家，之后两三天之类会发出来～</strong></del><br><img src="https://raw.githubusercontent.com/jeasonstudio/images/8b550fd8d102bf7625f47511b35489612626636d/20160526/gitlogo.jpg" alt="GitHub Logo"></p>
<p><img src="https://raw.githubusercontent.com/jeasonstudio/images/8b550fd8d102bf7625f47511b35489612626636d/20160526/Hexologo.gif" alt="Hexo Logo"></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a><a href="#环境配置" title="环境配置"></a><strong>环境配置</strong></h2><p><a href="https://hexo.io/docs" target="_blank" rel="external">Hexo官网</a>上本就有对Hexo安装及使用的详细介绍，墙裂推荐。这里来讲述自己安装的亲身步骤，或有区别。</p>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a><a href="#Node-js" title="Node.js"></a>Node.js</h3><p>用来生成静态页面。移步<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js官网</a>，下载v5.5.0 Stable 一路安装即可。</p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a><a href="#Git" title="Git"></a>Git</h3><p>用来将本地Hexo内容提交到Github上。Xcode自带Git，这里不再赘述。如果没有Xcode可以参考<a href="https://hexo.io/docs" target="_blank" rel="external">Hexo官网</a>上的安装方法。    </p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><a href="#安装Hexo" title="安装Hexo"></a><strong>安装Hexo</strong></h2><p>当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：</p>
<pre><code>$ sudo npm install -g hexo
</code></pre><p>输入管理员密码（Mac登录密码）即开始安装 (<code>sudo</code>:linux系统管理指令  <code>-g</code>:全局安装)</p>
<blockquote>
<p>注意坑一：<a href="https://hexo.io/docs" target="_blank" rel="external">Hexo官网</a>上的安装命令是<code>$ npm install -g hexo-cli</code>，安装时不要忘记前面加上<code>sudo</code>，否则会因为权限问题报错。</p>
</blockquote>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><a href="#初始化" title="初始化"></a>初始化</h3><p>终端cd到一个你选定的目录，执行<code>hexo init</code>命令：</p>
<pre><code>$ hexo init blog
</code></pre><p><code>blog</code>是你建立的文件夹名称。cd到<code>blog</code>文件夹下，执行如下命令，安装npm：</p>
<pre><code>$ npm install
</code></pre><p>执行如下命令，开启hexo服务器：</p>
<pre><code>$ hexo s
</code></pre><p>此时，浏览器中打开网址<a href="http://0.0.0.0:4000" target="_blank" rel="external">http://localhost:4000</a>，能看到如下页面：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fjo3tmedk7j30m00cn3z1.jpg" alt=""></p>
<p>本地设置好后，接下来开始关联Github。</p>
<h2 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a><a href="#关联Github" title="关联Github"></a><strong>关联Github</strong></h2><h3 id="添加ssh-key到Github"><a href="#添加ssh-key到Github" class="headerlink" title="添加ssh key到Github"></a><a href="#添加ssh-key到Github" title="添加ssh key到Github"></a>添加ssh key到Github</h3><h4 id="检查SSH-keys是否存在Github"><a href="#检查SSH-keys是否存在Github" class="headerlink" title="检查SSH keys是否存在Github"></a><a href="#检查SSH-keys是否存在Github" title="检查SSH keys是否存在Github"></a>检查SSH keys是否存在Github</h4><p>执行如下命令，检查SSH keys是否存在。如果有文件<code>id_rsa.pub</code>或<code>id_dsa.pub</code>，则直接进入步骤1.3将SSH key添加到Github中，否则进入下一步生成SSH key。</p>
<pre><code>$ ls -al ~/.ssh
</code></pre><h4 id="生成新的ssh-key"><a href="#生成新的ssh-key" class="headerlink" title="生成新的ssh key"></a><a href="#生成新的ssh-key" title="生成新的ssh key"></a>生成新的ssh key</h4><p>执行如下命令生成public/private rsa key pair，注意将<code>your_email@example.com</code>换成你自己注册Github的邮箱地址。</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;
</code></pre><p>默认会在相应路径下（<code>~/.ssh/id_rsa.pub</code>）生成<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件。</p>
<h4 id="将ssh-key添加到Github中"><a href="#将ssh-key添加到Github中" class="headerlink" title="将ssh key添加到Github中"></a><a href="#将ssh-key添加到Github中" title="将ssh key添加到Github中"></a>将ssh key添加到Github中</h4><p>Find前往文件夹<code>~/.ssh/id_rsa.pub</code>打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。</p>
<p>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:</p>
<p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方<code>Add key</code>绿色按钮即可。</p>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a><a href="#创建仓库" title="创建仓库"></a>创建仓库</h3><p>登录你的Github帐号，新建仓库，名为<code>用户名.github.io</code>固定写法，如<code>pancakeawesome.github.io</code>,如下图所示：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fjnv225vpoj30ro0gkjsn.jpg" alt="exam"></p>
<p>本地的<code>blog</code>文件夹下内容为：</p>
<table>
<thead>
<tr>
<th style="text-align:left">1</th>
<th style="text-align:left">config.yml</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">db.json</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">node_modules</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">package.json</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">scaffolds</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">source</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">themes</td>
</tr>
</tbody>
</table>
<p>终端cd到<code>blog</code>文件夹下，<code>vim</code>打开<code>_config.yml</code>，命令如下：</p>
<pre><code>$ vim _config.yml
</code></pre><p>打开后往下滑到最后，修改成下边的样子：</p>
<pre><code>deploy:
    type: git
    repository: https://github.com/pancakeawesome/pancakeawesome.github.io.git
   branch: master
</code></pre><p>   你需要将<code>repository</code>后<code>pancakeawesome</code>换成你自己的用户名，地址在上图<code>2</code>位置获取。hexo 3.1.1版本后<code>type:</code>值为<code>git</code>。</p>
<p>注意坑二：在配置所有的<code>_config.yml</code>文件时（包括theme中的），在所有的冒号<code>:</code>后边都要加一个空格，否则执行hexo命令会报错，切记 切记</p>
<p>在<code>blog</code>文件夹目录下执行生成静态页面命令：</p>
<pre><code>   $ hexo generate        或者：hexo g
</code></pre><p>此时若出现如下报错：</p>
<pre><code>ERROR Local hexo not found in ~/blog
ERROR Try runing: &#39;npm install hexo --save&#39;
</code></pre><p>则执行命令：</p>
<pre><code>npm install hexo --save
</code></pre><p>若无报错，自行忽略此步骤。</p>
<p>再执行配置命令：</p>
<pre><code>$ hexo deploy            或者：hexo d
</code></pre><blockquote>
<p>注意坑三：若执行命令<code>hexo deploy</code>仍然报错：无法连接git，则执行如下命令来安装<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="external">hexo-deployer-git</a>：</p>
<pre><code>$ npm install hexo-developer-git --save
</code></pre></blockquote>
<p>再次执行<code>hexo generate</code>和<code>hexo deploy</code>命令</p>
<p>此时，浏览器中打开网址<a href="http://pancakeawesome.github.io" target="_blank" rel="external">http://pancakeawesome.github.io</a>（将<code>pancakeawesome</code>换成你的用户名）能看到和打开<code>http://localhost:4000</code>时一样的页面。</p>
<h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a><a href="#发布文章" title="发布文章"></a>发布文章</h3><p>终端cd到<code>blog</code>文件夹下，执行如下命令新建文章：</p>
<pre><code>hexo new &quot;postName&quot;
</code></pre><p>名为<code>postName.md</code>的文件会建在目录<code>/blog/source/_posts</code>下。你当然可以用vim来编辑文章。</p>
<blockquote>
<p>在此说明一下，我一直都在用微软的 VSCode编辑器来编写MarkDown，如果你有什么更好的建议，我会非常感激的。<br>另外MarkDown格式的语法教程，前面的博文里有，但我知道你懒，<a href="http://pancakeawesome.ink/2017/09/18/%E4%B8%89%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8markdown/">传送门</a>。</p>
</blockquote>
<p>文章编辑完成后，终端cd到<code>blog</code>文件夹下，执行如下命令来发布：</p>
<pre><code>hexo generate             //生成静态页面
hexo deploy            //将文章部署到Github&amp;lt;/pre&amp;gt;
</code></pre><hr>
<p><strong>至此，Mac上搭建基于Github的Hexo博客就完成了。下面的内容是介绍安装theme，添加评论功能和绑定个人域名，如果有兴趣且还有耐心的话，请继续吧。</strong></p>
<h2 id="安装theme"><a href="#安装theme" class="headerlink" title="安装theme"></a><a href="#安装theme" title="安装theme"></a><strong>安装theme</strong></h2><p>你可以到<a href="https://hexo.io/themes/" target="_blank" rel="external">Hexo官网主题页</a>去搜寻自己喜欢的theme。这里以<a href="https://material.viosey.com/" target="_blank" rel="external">hexo-theme-material</a>为例</p>
<p>终端cd到 <code>blog</code> 目录下执行如下命令：</p>
<pre><code>$ git clone https://github.com/viosey/hexo-theme-material themes/material
</code></pre><p>将<code>blog</code>目录下<code>_config.yml</code>里<code>theme</code>的名称<code>landscape</code>修改为<code>material</code></p>
<p>终端cd到<code>blog</code>目录下执行如下命令(每次部署文章的步骤)：</p>
<pre><code>$ hexo clean           //清除缓存文件 (db.json) 和已生成的静态文件 (public)
$ hexo g             //生成缓存和静态文件
hexo d             //重新部署到服务器
</code></pre><p>至于更改theme内容，比如名称，描述，头像等去修改<code>blog/_config.yml</code>文件和<code>blog/themes/material/_config.yml</code>文件中对应的属性名称即可， 不要忘记冒号<code>:</code>后加空格。  <a href="https://material.viosey.com/" target="_blank" rel="external"> Material 使用文档</a>里有极详细的介绍。</p>
<h2 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a><a href="#绑定个人域名" title="绑定个人域名"></a><strong>绑定个人域名</strong></h2><p>现在使用的域名是Github提供的二级域名，也可以绑定为自己的个性域名。购买域名，可以到<a href="https://sg.godaddy.com/zh/" target="_blank" rel="external">GoDaddy官网</a>，网友亲切称呼为：狗爹，也可以到<a href="http://wanwang.aliyun.com/" target="_blank" rel="external">阿里万网</a>购买。</p>
<h3 id="Github端"><a href="#Github端" class="headerlink" title="Github端"></a><a href="#Github端" title="Github端"></a>Github端</h3><p>在<code>/blog/themes/landscape/source</code>目录下新建文件名为：<code>CNAME</code>文件，注意没有后缀名！直接将自己的域名如：<code>pancakeawesome.com</code>写入。</p>
<p>终端cd到<code>blog</code>目录下执行如下命令重新部署：</p>
<pre><code>$ hexo clean
$ hexo g
$ hexo d
</code></pre><blockquote>
<p>注意坑四：网上许多都是说在Github上直接新建<code>CNAME</code>文件，如果这样的话，在你下一次执行<code>hexo d</code>部署命令后<code>CNAME</code>文件就消失了，因为本地没有此文件嘛。</p>
</blockquote>
<h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a><a href="#域名解析" title="域名解析"></a>域名解析</h3><p>如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。</p>
<p>登录你注册域名的网站，比如万网，在你购买的域名后边点击：解析 –&gt; 添加解析</p>
<p>记录类型：CNAME</p>
<p>主机记录：将域名解析为example.com（不带www），填写@或者不填写</p>
<p>记录值：pancakeawesome.github.io.    (不要忘记最后的<code>.</code>，<code>pancakeawesome</code>改为你自己的用户名)，点击保存即可。</p>
<p>此时，大功告成！</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a><a href="#后记" title="后记"></a><strong>后记</strong></h2><p>参考<a href="http://pancakeawesome.ink/">pancakeawesome博客：pancakeawesome</a>，希望对大家有所帮助，欢迎吐槽～</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><a href="#参考链接" title="参考链接"></a><strong>参考链接</strong></h2><ul>
<li><a href="https://hexo.io/docs" target="_blank" rel="external">Hexo官网</a></li>
<li><a href="http://leopardpan.github.io/2015/08/12/hexo/" target="_blank" rel="external">HEXO</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动态规划迷思]]></title>
      <url>/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%BF%B7%E6%80%9D.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在刷leetcode发现很多线性表的算法题都都可以用<strong><code>dp（dynamic programming）</code></strong>去做，如果你了解dp的思想，其实很多复杂的问题都能化为简单的问题，非常棒～<br><em>let’s start~</em></p>
<h2 id="动态规划中递推式的求解方法不是动态规划的本质。"><a href="#动态规划中递推式的求解方法不是动态规划的本质。" class="headerlink" title="动态规划中递推式的求解方法不是动态规划的本质。"></a>动态规划中递推式的求解方法不是动态规划的本质。</h2><ol>
<li>动态规划的本质，是对问题<strong><em>状态的定义</em></strong>和<strong><em>状态转移方程</em>的定义</strong>。<br>引自维基百科<blockquote>
<p><strong>dynamic programming</strong> is a method for solving a complex problem by <strong>breaking it down into a collection of simpler subproblems</strong>.</p>
</blockquote>
</li>
</ol>
<p>动态规划是通过<strong>拆分问题，</strong>定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。<br>本题下的其他答案，大多都是在说递推的求解方法，但<strong>如何拆分问题</strong>，才是动态规划的核心。<br>而<strong>拆分问题</strong>，靠的就是<strong><em>状态的定义</em></strong>和<strong><em>状态转移方程</em>的定义</strong>。</p>
<h2 id="什么是状态的定义？"><a href="#什么是状态的定义？" class="headerlink" title="什么是状态的定义？"></a>什么是<strong>状态的定义？</strong></h2><p><strong><br>首先想说大家千万不要被下面的数学式吓到，这里只涉及到了函数相关的知识。</strong><br>我们先来看一个动态规划的教学必备题：</p>
<blockquote>
<p>给定一个数列，长度为N，<br>求这个数列的最长上升（递增）子数列（LIS）的长度.<br>以<br>1 7 2 8 3 4<br>为例。<br>这个数列的最长递增子数列是 1 2 3 4，长度为4；<br>次长的长度为3， 包括 1 7 8; 1 2 3 等.</p>
</blockquote>
<p>要解决这个问题，我们首先要<strong>定义这个问题</strong>和这个问题的子问题。<br>有人可能会问了，题目都已经在这了，我们还需定义这个问题吗？需要，原因就是这个问题在字面上看，找不出子问题，而没有子问题，这个题目就没办法解决。<br>所以我们来重新定义这个问题：</p>
<blockquote>
<p>给定一个数列，长度为N，<br>设<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">为：以数列中第k项结尾的最长递增子序列的长度.<br>求<img src="https://www.zhihu.com/equation?tex=F_%7B1%7D..F_%7BN%7D" alt="F_{1}..F_{N}"> 中的最大值.</p>
</blockquote>
<p>显然，这个新问题与原问题等价。<br>而对于<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">来讲，<img src="https://www.zhihu.com/equation?tex=F_%7B1%7D+..+F_%7Bk-1%7D" alt="F_{1} .. F_{k-1}">都是<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">的子问题：因为以第k项结尾的最长递增子序列（下称LIS），包含着以第<img src="https://www.zhihu.com/equation?tex=1..k-1" alt="1..k-1">中某项结尾的LIS。</p>
<p>上述的新问题<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">也可以叫做状态，定义中的“<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">为数列中第k项结尾的LIS的长度”，就叫做对状态的定义。<br>之所以把<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">做“状态”而不是“问题” ，一是因为避免跟原问题中“问题”混淆，二是因为这个新问题是数学化定义的。</p>
<p>对状态的定义只有一种吗？<em>当然不是</em>。<br>我们甚至可以二维的，以完全不同的视角定义这个问题：</p>
<blockquote>
<p>给定一个数列，长度为N，<br>设<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D" alt="F_{i, k}">为：<br>在前i项中的，长度为k的最长递增子序列中，最后一位的最小值. <img src="https://www.zhihu.com/equation?tex=1%5Cleq+k%5Cleq+N" alt="1\leq k\leq N">.<br>若在前i项中，不存在长度为k的最长递增子序列，则<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D" alt="F_{i, k}">为正无穷.<br>求最大的x，使得<img src="https://www.zhihu.com/equation?tex=F_%7BN%2Cx%7D" alt="F_{N,x}">不为正无穷。</p>
</blockquote>
<p>这个新定义与原问题的等价性也不难证明，请读者体会一下。<br>上述的<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D" alt="F_{i, k}">就是状态，定义中的“<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D" alt="F_{i, k}">为：在前i项中，长度为k的最长递增子序列中，最后一位的最小值”就是对状态的定义。</p>
<h2 id="什么是状态转移方程？"><a href="#什么是状态转移方程？" class="headerlink" title="什么是状态转移方程？"></a>什么是<strong>状态转移方程</strong>？</h2><p>上述状态定义好之后，状态和状态之间的关系式，就叫做<strong>状态转移方程。</strong><br>比如，对于LIS问题，我们的第一种定义：</p>
<blockquote>
<p>设<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">为：以数列中第k项结尾的最长递增子序列的长度.设A为题中数列，状态转移方程为：<br><img src="https://www.zhihu.com/equation?tex=F_%7B1%7D+%3D+1" alt="F_{1} = 1"> （根据状态定义导出边界情况）<br><img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D%3Dmax%28F_%7Bi%7D%2B1+%7C+A_%7Bk%7D%3EA_%7Bi%7D%2C+i%5Cin+%281..k-1%29%29+" alt="F_{k}=max(F_{i}+1 | A_{k}"><img src="https://www.zhihu.com/equation?tex=%28k%3E1%29" alt="(k"></p>
</blockquote>
<p>用文字解释一下是：<br>以第k项结尾的LIS的长度是：保证第i项比第k项小的情况下，以第i项结尾的LIS长度加一的最大值，取遍i的所有值（i小于k）。<br>第二种定义：</p>
<blockquote>
<p>设<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D" alt="F_{i, k}">为：在数列前i项中，长度为k的递增子序列中，最后一位的最小值设A为题中数列，状态转移方程为：<br>若<img src="https://www.zhihu.com/equation?tex=A_%7Bi%7D%3EF_%7Bi-1%2Ck-1%7D" alt="A_{i}">则<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2Ck%7D%3Dmin%28A_%7Bi%7D%2CF_%7Bi-1%2Ck%7D%29+" alt="F_{i,k}=min(A_{i},F_{i-1,k}) "><br>否则：<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2Ck%7D%3DF_%7Bi-1%2Ck%7D+" alt="F_{i,k}=F_{i-1,k} "></p>
</blockquote>
<p>（边界情况需要分类讨论较多，在此不列出，需要根据状态定义导出边界情况。）<br>大家套着定义读一下公式就可以了，应该不难理解，就是有点绕。</p>
<p>这里可以看出，这里的状态转移方程，就是定义了问题和子问题之间的关系。<br>可以看出，状态转移方程就是带有条件的递推式。</p>
<h2 id="动态规划迷思"><a href="#动态规划迷思" class="headerlink" title="动态规划迷思"></a>动态规划迷思</h2><h3 id="“缓存”，“重叠子问题”，“记忆化”："><a href="#“缓存”，“重叠子问题”，“记忆化”：" class="headerlink" title="“缓存”，“重叠子问题”，“记忆化”："></a>“缓存”，“重叠子问题”，“记忆化”：</h3><p>这三个名词，都是在阐述递推式求解的技巧。以Fibonacci数列为例，计算第100项的时候，需要计算<u>第99项</u>和98项；在计算第101项的时候，需要第100项和<u>第99项</u>，这时候你还需要重新计算第99项吗？不需要，你只需要在第一次计算的时候把它记下来就可以了。<br>上述的需要再次计算的“第99项”，就叫“重叠子问题”。如果没有计算过，就按照递推式计算，如果计算过，直接使用，就像“缓存”一样，这种方法，叫做“记忆化”，这是递推式求解的技巧。这种技巧，通俗的说叫“花费空间来节省时间”。<strong>都不是动态规划的本质，**</strong>不是动态规划的核心。**</p>
<h3 id="“递归”："><a href="#“递归”：" class="headerlink" title="“递归”："></a>“递归”：</h3><p>递归是递推式求解的方法，连技巧都算不上。</p>
<h3 id="“无后效性”，“最优子结构”："><a href="#“无后效性”，“最优子结构”：" class="headerlink" title="“无后效性”，“最优子结构”："></a>“无后效性”，“最优子结构”：</h3><p>上述的状态转移方程中，等式右边不会用到下标大于左边i或者k的值，这是”无后效性”的通俗上的数学定义，符合这种定义的状态定义，我们可以说它具有“最优子结构”的性质，在动态规划中我们要做的，就是找到这种“最优子结构”。<br><strong>在对状态和状态转移方程的定义过程中，满足“最优子结构”是一个隐含的条件（否则根本定义不出来）。对状态和“最优子结构”的关系的进一步解释，<a href="http://www.zhihu.com/question/23995189/answer/35429905" target="_blank" rel="external">什么是动态规划？动态规划的意义是什么？ - 王勐的回答</a> 写的很好，大家可以去读一下。</strong></p>
<p>需要注意的是，一个问题可能有多种不同的状态定义和状态转移方程定义，存在一个有后效性的定义，<em><strong>不代表该问题不适用动态规划</strong></em>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>动态规划方法要寻找符合“最优子结构“的状态和状态转移方程的定义<em>，</em>在找到之后，这个问题就可以以“记忆化地求解递推式”的方法来解决。而寻找到的定义，才是动态规划的本质。</strong></p>
]]></content>
      
        <categories>
            
            <category> 算法思想 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法思想 </tag>
            
            <tag> 知乎 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[入门Webpack，看这篇就够了]]></title>
      <url>/%E5%85%A5%E9%97%A8Webpack%EF%BC%8C%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>webpack是现在一款非常流行的模块化管理工具🔧</strong><br>webpack会将有依赖关系的文件都视为一个模块，比如scss,sass,less,css结尾的文件，这样会产生一个模块群，微博爬出坑处理过后会产生可以被浏览器识别的一些文件，比如Js,css,html等。<br><a href="https://webpack.github.io/" target="_blank" rel="external">Webpack</a>在面对大型工程项目时，非常有优势，它最大的特点是很轻，不会加载打包冗余的文件，只会打包项目中用的到的模块。这是webpack的<strong>代码分割</strong>特性～<br><strong>webpack的模块热更新特性的：当项目文件发生变化时，不需要开发人员手动刷新浏览器，webpack会自动刷新页面，极大地提高了开发效率，是不是很神奇！</strong><br><strong>注意：本文的webpack环境是<code>3.5.5</code>由于webpack的更新很快，每次更新都会更新新的语法，所以学习webpack的本质就可以</strong>，具体语法可以看webpack官网：<strong><a href="https://webpack.github.io/" target="_blank" rel="external">https://webpack.github.io/</a></strong><br>那么让我们快速开始吧～</p>
<h2 id="如何在terminal中安装webpack"><a href="#如何在terminal中安装webpack" class="headerlink" title="如何在terminal中安装webpack"></a>如何在terminal中安装webpack</h2><ul>
<li>新建project目录</li>
<li>初始化npm:<pre><code>npm init
</code></pre></li>
<li>安装webpack<pre><code>npm install webpack --save-dev
</code></pre></li>
<li>注意:dev参数是安装到项目文件夹下</li>
<li>执行打包：<pre><code>webpack [source.file] [target.file]
</code></pre>打包文件的路径设置在<em>webpack.config.js</em>文件夹下<br>具体配置如下：<pre><code>  entry: __dirname + &#39;src/app.js&#39;,
  output: {
      /**
       * __dirname: absolute file path
       * @type {[type]}
       */
      path:__dirname + &#39;/dist&#39;,
      /**
       * [name]: entry&#39;s chunck&#39;s key
       * [chunkhash]: file&#39;s md5 value(file version)
       * @type {String}
       */
      filename: &#39;js/[name].bundle.js&#39;,
  }
</code></pre><strong><code>path</code>和<code>filename</code>之前要加<code>__dirname</code>，否则会报错，这是个坑，<code>__dirname</code>是项目目录的绝对路径</strong><h2 id="webpack执行方式"><a href="#webpack执行方式" class="headerlink" title="webpack执行方式"></a>webpack执行方式</h2><h3 id="webpack命令方式"><a href="#webpack命令方式" class="headerlink" title="webpack命令方式"></a>webpack命令方式</h3><code>npm run webpack</code>命令行运行参数：<br><code>npm run webpack --config webpack.config.js --progress  --colors --display-reasons --watch</code><br><em>这些参数具体的作用后文有写</em><h3 id="npm脚本执行方式"><a href="#npm脚本执行方式" class="headerlink" title="npm脚本执行方式"></a>npm脚本执行方式</h3><code>&quot;webpack&quot;: &quot;webpack --config webpack.config.js --progress  --colors --display-reasons --watch&quot;</code><br><strong>写在项目目录下的<code>npm</code>的配置文件<code>package.json</code>中</strong><br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fjk8ffmv34j30ti07waak.jpg" alt=""><h2 id="webpack处理资源文件：webpack版本：3-5-5"><a href="#webpack处理资源文件：webpack版本：3-5-5" class="headerlink" title="webpack处理资源文件：webpack版本：3.5.5"></a>webpack处理资源文件：webpack版本：3.5.5</h2><strong>因为每个版本的文档都会变化所以坑很多，请注意自己的版本</strong><h2 id="如何在js中引用css，并使css代码在html中生效"><a href="#如何在js中引用css，并使css代码在html中生效" class="headerlink" title="如何在js中引用css，并使css代码在html中生效"></a>如何在js中引用css，并使css代码在html中生效</h2></li>
<li>在require是加入css-loader&amp;&amp;style-loader<pre><code>npm install --save-dev css-loader style-loader
</code></pre></li>
<li>在webpack.config.js中加入配置信息<pre><code>{
  test: /\.css$/,
  use: [
      {
            loader:&#39;style-loader&#39;
        },
        {
          loader:&#39;css-loader&#39;
        },
        { 
            loader: &#39;postcss-loader&#39;,
            // some plugins of postcss-loader:some options
            options: {
                plugins: function () {
                    return [
                        require(&#39;postcss-import&#39;)({
                            root:this.resourcePath
                        }),
                        require(&#39;autoprefixer&#39;)({
                            broswers: [&#39;last 5 versions&#39;]
                        })
                      ]
                }
              }
          }
      ]    
  }
</code></pre><em>注意postcss-loader预处理器的配置</em><br><strong><code>css-loader</code>保证webpack可以打包css模块</strong><br><strong><code>style-loader</code>保证<code>js</code>中的<code>css</code>代码以<code>&lt;style&gt;</code>标签的形式加入到<code>html</code>中并显示其效果</strong><h2 id="安利一下一些很有用的webpack打包的额外参数"><a href="#安利一下一些很有用的webpack打包的额外参数" class="headerlink" title="安利一下一些很有用的webpack打包的额外参数"></a>安利一下一些很有用的webpack打包的额外参数</h2></li>
<li>–watch:自动监听项目文件，如果出现改变，会自动打包不需要再次打包</li>
<li>–module-bind: 绑定loader</li>
<li>–progress: 显示打包的进程，显示进度条</li>
<li>–display-modules: 显示所有打包的模块</li>
<li>–display-reasons: 显示各个模块打包的原因<h3 id="这些参数有两种方法生效"><a href="#这些参数有两种方法生效" class="headerlink" title="这些参数有两种方法生效"></a>这些参数有两种方法生效</h3></li>
<li>可以在terminal中打包的时候添加在webpack命令之后</li>
<li>可以将这些参数同webpack命令一起加入到npm的脚本文件中，这样每次打包只要执行npm脚本就可以了，不必每次都手动输入一长串参数<pre><code>package.json:
&quot;scripts&quot;: {
  &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
  &quot;webpack&quot;: &quot;webpack --config webpack.config.js --progress  --colors&quot;
},
</code></pre><h2 id="Webpack-如何在项目自动生成html文件"><a href="#Webpack-如何在项目自动生成html文件" class="headerlink" title="Webpack 如何在项目自动生成html文件"></a>Webpack 如何在项目自动生成html文件</h2></li>
<li>如何在html中使用动态生成的打包后的文件；</li>
<li>通过html-webpack-plugin自定义html，并且通过模版和其参数，使用外联的方式传入scirpt动态文件；</li>
<li>多页面时，通过上述插件的模版生成多个html</li>
<li>如何通过上述插件inline的形式引用js的文件<h3 id="使用loader"><a href="#使用loader" class="headerlink" title="使用loader"></a>使用loader</h3></li>
</ul>
<ul>
<li>直接在require的声明中添加loader命令；</li>
<li>在webpack命令行中使用loader参数；</li>
<li>在webpack的配置文件中设置loader的配置参数（使用正则匹配）；</li>
<li>装babel转换器 将js结尾的文件用babel转换器（es6）转换<pre><code>npm install babel-loader babel-core --save-dev
</code></pre></li>
<li>安装preset插件以支持最新的es6语法<pre><code>npm install babel-preset-latest
</code></pre></li>
</ul>
<pre><code>Webpack.config.js:
// js loader
            {
                test: /\.js$/,
                loader: &#39;babel-loader&#39;,
                include: path.resolve(__dirname,&#39;src&#39;),
                // exclude: __dirname + &#39;./node_modules/&#39;,
                exclude: path.resolve(__dirname,&#39;node_modules&#39;),
                // param of loader
                options: {
                    presets: [&#39;env&#39;]
                }
            },
</code></pre><p><strong>一定要使用绝对路径去指定path或者其他相似参数的值</strong><br><strong>输入输出的参数 <code>__dirname</code>+ <code>&#39;/path&#39;</code>:绝对路径</strong><br><strong>其他路径参数<code>__dirname</code> + <code>&#39;./path&#39;</code>:相对路径</strong></p>
<h3 id="安装一些loaders去转换css文件"><a href="#安装一些loaders去转换css文件" class="headerlink" title="安装一些loaders去转换css文件"></a>安装一些loaders去转换css文件</h3><pre><code>// css loader : postcss-loader,css-loader,style-loader
            {
        test: /\.css$/,
        use: [
            {
                  loader:&#39;style-loader&#39;
              },
              {
                loader:&#39;css-loader&#39;
              },
              { 
                  loader: &#39;postcss-loader&#39;,
                  // some plugins of postcss-loader:some options
                  options: {
                      plugins: function () {
                          return [
                              require(&#39;postcss-import&#39;)({
                                  root:this.resourcePath
                              }),
                              require(&#39;autoprefixer&#39;)({
                                  broswers: [&#39;last 5 versions&#39;]
                              })
                          ]
                      }
                    }
                }
            ]    
      }
</code></pre><h3 id="使用less-loader，sass-loader去处理css易处理语言"><a href="#使用less-loader，sass-loader去处理css易处理语言" class="headerlink" title="使用less-loader，sass-loader去处理css易处理语言"></a>使用less-loader，sass-loader去处理css易处理语言</h3><p><strong>步骤是</strong>：先用less-loader去处理less文件转换成css文件，再将css文件用postcss-loader预处理css文件，加上前缀等之类的功能，再用css-loader和style-loader去处理css文件，具体loader的配置如下:</p>
<pre><code>// less loader
      {
        test: /\.less$/,
        use: [
            {
            loader: &quot;style-loader&quot; // creates style nodes from JS strings 
          }, 
          {
              loader: &quot;css-loader&quot; // translates CSS into CommonJS 
                },
                { 
                  loader: &#39;postcss-loader&#39;,
                  // some plugins of postcss-loader:some options
                  options: {
                      plugins: function () {
                          return [
                              require(&#39;postcss-import&#39;)({
                                  root:this.resourcePath
                              }),
                              require(&#39;autoprefixer&#39;)({
                                  broswers: [&#39;last 5 versions&#39;]
                              })
                          ]
                      }
                    }
                },
                {
                 loader: &quot;less-loader&quot; // compiles Less to CSS 
               }
           ]
      },
      // sass loader
      {
        test: /\.scss$/,
        use: [
            {
            loader: &quot;style-loader&quot; // creates style nodes from JS strings 
          }, 
          {
              loader: &quot;css-loader&quot; // translates CSS into CommonJS 
                },
                { 
                  loader: &#39;postcss-loader&#39;,
                  // some plugins of postcss-loader:some options
                  options: {
                      plugins: function () {
                          return [
                              require(&#39;postcss-import&#39;)({
                                  root:this.resourcePath
                              }),
                              require(&#39;autoprefixer&#39;)({
                                  broswers: [&#39;last 5 versions&#39;]
                              })
                          ]
                      }
                    }
                },
                {
                 loader: &quot;sass-loader&quot; // compiles Less to CSS 
               }
           ]
      }
</code></pre><h2 id="使用html-loader或者其他的模版引擎loader去处理html或者模版文件："><a href="#使用html-loader或者其他的模版引擎loader去处理html或者模版文件：" class="headerlink" title="使用html-loader或者其他的模版引擎loader去处理html或者模版文件："></a>使用<code>html-loader</code>或者其他的模版引擎loader去处理html或者模版文件：</h2><ul>
<li>使用<code>html-loader</code>去把htnl文件处理成字符串的形式引入到其他模块中；<br><strong>装<code>html-loader</code>之前要转<code>node-sass</code></strong></li>
<li>使用模版引擎模块将模版文件比如说<code>ejs，jsx</code>等等模版文件引入到其他模块中。<br><em>下面是<code>webpack.config.js</code>的配置代码</em><pre><code>// html loader
  rules:[
  {
      test: /\.html$/,
      loader: &#39;html-loader&#39;
  }
  ]
  //html plugin
  plugins: [
          new htmlWebpackPlugin({
              filename: &#39;index.html&#39;,
              template: &#39;index.html&#39;,
              injecet: &#39;body&#39;
          })
      ]
</code></pre><h2 id="处理图片资源文件"><a href="#处理图片资源文件" class="headerlink" title="处理图片资源文件"></a>处理图片资源文件</h2></li>
<li>重复性大的图片通过http请求会缓存，使用file-loader去处理</li>
<li>小的图片重复性不大的图片可以用base64编码，使用url-loader去处理<h3 id="三个地方会用到图片"><a href="#三个地方会用到图片" class="headerlink" title="三个地方会用到图片"></a>三个地方会用到图片</h3></li>
<li>根目录的index.html里使用；</li>
<li>less，sass,css文件中引用图片；</li>
<li>模版文件中引用；<strong> 注意 </strong>如果使用相对路径需要用require引用文件<pre><code>    &lt;img src=&quot;${ require(&#39;../../assets/logo36x36.png&#39;) }&quot;&gt;
</code></pre></li>
</ul>
<ul>
<li>使用image-webpack-loader去压缩http请求的图片大小!<pre><code>// picture loader
  {
      test: /\.(png|jpg|gif|svg)$/,
      loaders: [
          // &#39;file-loader?name=assets/[name]-[hash:5].[ext]&#39;,
          &#39;url-loader?limit=20&amp;name=assets/[name]-[hash:5].[ext]&#39;,
          &#39;image-webpack-loader&#39;
      ]
  }
</code></pre><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><h3 id="整个webpack的demo工程我都亲自在Mac环境下测试并运行成功，上传到了github，这里是地址：https-github-com-PancakeAwesome-PancakeAwesome-github-io"><a href="#整个webpack的demo工程我都亲自在Mac环境下测试并运行成功，上传到了github，这里是地址：https-github-com-PancakeAwesome-PancakeAwesome-github-io" class="headerlink" title="整个webpack的demo工程我都亲自在Mac环境下测试并运行成功，上传到了github，这里是地址：https://github.com/PancakeAwesome/PancakeAwesome.github.io"></a>整个webpack的demo工程我都亲自在Mac环境下测试并运行成功，上传到了github，这里是地址：<a href="https://github.com/PancakeAwesome/PancakeAwesome.github.io" target="_blank" rel="external">https://github.com/PancakeAwesome/PancakeAwesome.github.io</a></h3><h3 id="下面贴下我完整的webpack-config-js和pacakge-json的代码：由于webpack版本更新很快情注意自己的版本，最新语法去官网查看"><a href="#下面贴下我完整的webpack-config-js和pacakge-json的代码：由于webpack版本更新很快情注意自己的版本，最新语法去官网查看" class="headerlink" title="下面贴下我完整的webpack.config.js和pacakge.json的代码：由于webpack版本更新很快情注意自己的版本，最新语法去官网查看"></a>下面贴下我完整的<code>webpack.config.js</code>和<code>pacakge.json</code>的代码：<strong>由于webpack版本更新很快情注意自己的版本，最新语法去<a href="https://webpack.github.io/" target="_blank" rel="external">官网查看</a></strong></h3></li>
</ul>
<p><code>webpack.config.js</code></p>
<pre><code>var htmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
var path = require(&#39;path&#39;);

module.exports = {    
    // the door file of webpack packaging
    // entry: &#39;./src/script/main.js&#39;,
    // entry: [&#39;./src/script/main.js&#39;,&#39;./src/script/a.js&#39;],
    entry: __dirname + &#39;/src/app.js&#39;,
    output: {
        /**
         * __dirname: absolute file path
         * @type {[type]}
         */
        path:__dirname + &#39;/dist&#39;,
        /**
         * [name]: entry&#39;s chunck&#39;s key
         * [chunkhash]: file&#39;s md5 value(file version)
         * @type {String}
         */
        filename: &#39;js/[name].bundle.js&#39;,
    },
    /**
     * webpack loader param
     * @type {Object}
     */
    module: {
        rules: [
            // html loader
            {
                test: /\.html$/,
                loader: &#39;html-loader&#39;
            },
            // ejs loader (template loader)
            {
                test: /\.tpl$/,
                loader: &#39;ejs-loader&#39;
            },
            // js loader
            {
                test: /\.js$/,
                loader: &#39;babel-loader&#39;,
                include: path.resolve(__dirname,&#39;src&#39;),
                // exclude: __dirname + &#39;./node_modules/&#39;,
                exclude: path.resolve(__dirname,&#39;node_modules&#39;),
                // param of loader
                options: {
                    presets: [&#39;env&#39;]
                }
            },
            // css loader : postcss-loader,css-loader,style-loader
            {
        test: /\.css$/,
        use: [
            {
                  loader:&#39;style-loader&#39;
              },
              {
                loader:&#39;css-loader&#39;
              },
              { 
                  loader: &#39;postcss-loader&#39;,
                  // some plugins of postcss-loader:some options
                  options: {
                      plugins: function () {
                          return [
                              require(&#39;postcss-import&#39;)({
                                  root:this.resourcePath
                              }),
                              require(&#39;autoprefixer&#39;)({
                                  broswers: [&#39;last 5 versions&#39;]
                              })
                          ]
                      }
                    }
                }
            ]    
      },
      // less loader
      {
        test: /\.less$/,
        use: [
            {
            loader: &quot;style-loader&quot; // creates style nodes from JS strings 
          }, 
          {
              loader: &quot;css-loader&quot; // translates CSS into CommonJS 
                },
                { 
                  loader: &#39;postcss-loader&#39;,
                  // some plugins of postcss-loader:some options
                  options: {
                      plugins: function () {
                          return [
                              require(&#39;postcss-import&#39;)({
                                  root:this.resourcePath
                              }),
                              require(&#39;autoprefixer&#39;)({
                                  broswers: [&#39;last 5 versions&#39;]
                              })
                          ]
                      }
                    }
                },
                {
                 loader: &quot;less-loader&quot; // compiles Less to CSS 
               }
           ]
      },
      // sass loader
      {
        test: /\.scss$/,
        use: [
            {
            loader: &quot;style-loader&quot; // creates style nodes from JS strings 
          }, 
          {
              loader: &quot;css-loader&quot; // translates CSS into CommonJS 
                },
                { 
                  loader: &#39;postcss-loader&#39;,
                  // some plugins of postcss-loader:some options
                  options: {
                      plugins: function () {
                          return [
                              require(&#39;postcss-import&#39;)({
                                  root:this.resourcePath
                              }),
                              require(&#39;autoprefixer&#39;)({
                                  broswers: [&#39;last 5 versions&#39;]
                              })
                          ]
                      }
                    }
                },
                {
                 loader: &quot;sass-loader&quot; // compiles sess to CSS 
               }
           ]
      },
            // picture loader
            {
                test: /\.(png|jpg|gif|svg)$/,
                loaders: [
                    // &#39;file-loader?name=assets/[name]-[hash:5].[ext]&#39;,
                    &#39;url-loader?limit=200000&amp;name=assets/[name]-[hash:5].[ext]&#39;,
                    &#39;image-webpack-loader&#39;
                ]
            },
        ]
    },
    plugins: [
        new htmlWebpackPlugin({
            filename: &#39;index.html&#39;,
            template: &#39;index.html&#39;,
            injecet: &#39;body&#39;
        })
    ]
}
</code></pre><p><code>pacage.json</code></p>
<pre><code>{
  &quot;name&quot;: &quot;webpack-demo&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;webpack&quot;: &quot;webpack --config webpack.config.js --progress  --colors&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;autoprefix&quot;: &quot;^1.0.1&quot;,
    &quot;babel-core&quot;: &quot;^6.26.0&quot;,
    &quot;babel-loader&quot;: &quot;^7.1.2&quot;,
    &quot;babel-preset-env&quot;: &quot;^1.6.0&quot;,
    &quot;babel-preset-latest&quot;: &quot;^6.24.1&quot;,
    &quot;css-loader&quot;: &quot;^0.28.7&quot;,
    &quot;ejs-loader&quot;: &quot;^0.3.0&quot;,
    &quot;file-loader&quot;: &quot;^0.11.2&quot;,
    &quot;html-loader&quot;: &quot;^0.5.1&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;,
    &quot;image-webpack-loader&quot;: &quot;^3.4.2&quot;,
    &quot;less&quot;: &quot;^2.7.2&quot;,
    &quot;less-loader&quot;: &quot;^4.0.5&quot;,
    &quot;node-sass&quot;: &quot;^4.5.3&quot;,
    &quot;postcss-import&quot;: &quot;^10.0.0&quot;,
    &quot;postcss-loader&quot;: &quot;^2.0.6&quot;,
    &quot;sass&quot;: &quot;^1.0.0-beta.2&quot;,
    &quot;sass-loader&quot;: &quot;^6.0.6&quot;,
    &quot;style-loader&quot;: &quot;^0.18.2&quot;,
    &quot;url-loader&quot;: &quot;^0.5.9&quot;,
    &quot;webpack&quot;: &quot;^3.5.5&quot;
  }
}
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
