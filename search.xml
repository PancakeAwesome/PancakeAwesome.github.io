<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[网页适配 iPhoneX，就是这么简单]]></title>
      <url>/%E7%BD%91%E9%A1%B5%E9%80%82%E9%85%8D-iPhoneX%EF%BC%8C%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iPhoneX 取消了物理按键，改成底部小黑条，这一改动导致网页出现了比较尴尬的屏幕适配问题。对于网页而言，顶部（刘海部位）的适配问题浏览器已经做了处理，所以我们只需要关注底部与小黑条的适配问题即可（即常见的吸底导航、返回顶部等各种相对底部 fixed 定位的元素）。</p>
<p>笔者通过查阅了一些官方文档，以及结合实际项目中的一些处理经验，整理了一套简单的适配方案分享给大家，希望对大家有所帮助，以下是处理前后效果图：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fn297hfohoj30h80gtmzo.jpg" alt=""></p>
<h2 id="适配之前需要了解的几个新知识"><a href="#适配之前需要了解的几个新知识" class="headerlink" title="适配之前需要了解的几个新知识"></a>适配之前需要了解的几个新知识</h2><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全区域指的是一个可视窗口范围，处于安全区域的内容不受圆角（corners）、齐刘海（sensor housing）、小黑条（Home Indicator）影响，如下图蓝色区域：</p>
<p>也就是说，我们要做好适配，必须保证页面可视、可操作区域是在安全区域内。</p>
<p><a href="https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/" target="_blank" rel="external">更详细说明，参考文档：Human Interface Guidelines - iPhoneX</a></p>
<h3 id="viewport-fit"><a href="#viewport-fit" class="headerlink" title="viewport-fit"></a>viewport-fit</h3><p>iOS11 新增特性，苹果公司为了适配 iPhoneX 对现有 viewport meta 标签的一个扩展，用于设置网页在可视窗口的布局方式，可设置三个值：</p>
<ul>
<li><p>contain: 可视窗口完全包含网页内容（左图）</p>
</li>
<li><p>cover：网页内容完全覆盖可视窗口（右图）</p>
</li>
<li><p>auto：默认值，跟 contain 表现一致</p>
</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fn298t7lqwj30iq09e0t5.jpg" alt=""> </p>
<p>注意：网页默认不添加扩展的表现是 viewport-fit=contain，需要适配 iPhoneX 必须设置 viewport-fit=cover，这是适配的关键步骤。</p>
<p>更详细说明，参考文档：viewport-fit-descriptor</p>
<h2 id="constant-函数"><a href="#constant-函数" class="headerlink" title="constant 函数"></a>constant 函数</h2><p>iOS11 新增特性，Webkit 的一个 CSS 函数，用于设定安全区域与边界的距离，有四个预定义的变量：</p>
<ul>
<li><p>safe-area-inset-left：安全区域距离左边边界距离</p>
</li>
<li><p>safe-area-inset-right：安全区域距离右边边界距离</p>
</li>
<li><p>safe-area-inset-top：安全区域距离顶部边界距离</p>
</li>
<li><p>safe-area-inset-bottom：安全区域距离底部边界距离</p>
</li>
</ul>
<p>这里我们只需要关注 safe-area-inset-bottom 这个变量，因为它对应的就是小黑条的高度（横竖屏时值不一样）。</p>
<p>注意：当 viewport-fit=contain 时 constant 函数是不起作用的，必须要配合 viewport-fit=cover 使用。对于不支持 constant 的浏览器，浏览器将会忽略它。</p>
<p>官方文档中提到 env 函数即将要替换 constant 函数，笔者测试过暂时还不可用。</p>
<p>更详细说明，参考文档：Designing Websites for iPhone X</p>
<h2 id="如何适配"><a href="#如何适配" class="headerlink" title="如何适配"></a>如何适配</h2><p>了解了以上所说的几个知识点，接下来我们适配的思路就很清晰了。</p>
<h3 id="第一步：设置网页在可视窗口的布局方式"><a href="#第一步：设置网页在可视窗口的布局方式" class="headerlink" title="第一步：设置网页在可视窗口的布局方式"></a>第一步：设置网页在可视窗口的布局方式</h3><p>新增 viweport-fit 属性，使得页面内容完全覆盖整个窗口：</p>
<pre><code>&lt;metaname=&quot;viewport&quot;content=&quot;width=device-width, viewport-fit=cover&quot;&gt;
</code></pre><p>前面也有提到过，只有设置了 viewport-fit=cover，才能使用 constant 函数。</p>
<h3 id="第二步：页面主体内容限定在安全区域内"><a href="#第二步：页面主体内容限定在安全区域内" class="headerlink" title="第二步：页面主体内容限定在安全区域内"></a>第二步：页面主体内容限定在安全区域内</h3><p>这一步根据实际页面场景选择，如果不设置这个值，可能存在小黑条遮挡页面最底部内容的情况。</p>
<pre><code>body {

  padding-bottom: constant(safe-area-inset-bottom);

}
</code></pre><h3 id="第三步：fixed-元素的适配"><a href="#第三步：fixed-元素的适配" class="headerlink" title="第三步：fixed 元素的适配"></a>第三步：fixed 元素的适配</h3><p>类型一：fixed 完全吸底元素（bottom = 0），比如下图这两种情况：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt=""></p>
<p>可以通过加内边距 padding 扩展高度：</p>
<pre><code>{

  padding-bottom: constant(safe-area-inset-bottom);

}
</code></pre><p>或者通过计算函数 calc 覆盖原来高度：</p>
<pre><code>{

  height: calc(60px(假设值) + constant(safe-area-inset-bottom));

}
</code></pre><p>注意，这个方案需要吸底条必须是有背景色的，因为扩展的部分背景是跟随外容器的，否则出现镂空情况。</p>
<p>还有一种方案就是，可以通过新增一个新的元素（空的颜色块，主要用于小黑条高度的占位），然后吸底元素可以不改变高度只需要调整位置，像这样：</p>
<pre><code>{

  margin-bottom: constant(safe-area-inset-bottom);

}
</code></pre><p>空的颜色块：</p>
<pre><code>{

  position: fixed;

  bottom: 0;

  width: 100%;

  height: constant(safe-area-inset-bottom);

  background-color: #fff;

}
</code></pre><p>类型二：fixed 非完全吸底元素（bottom ≠ 0），比如 “返回顶部”、“侧边广告” 等</p>
<p>像这种只是位置需要对应向上调整，可以仅通过外边距 margin 来处理：</p>
<pre><code>{

  margin-bottom: constant(safe-area-inset-bottom);

}
</code></pre><p>或者，你也可以通过计算函数 calc 覆盖原来 bottom 值：</p>
<pre><code>{

  bottom: calc(50px(假设值) + constant(safe-area-inset-bottom));

}
</code></pre><h3 id="别忘了使用-supports"><a href="#别忘了使用-supports" class="headerlink" title="别忘了使用 @supports"></a>别忘了使用 @supports</h3><p>写到这里，我们常见的两种类型的 fixed 元素适配方案已经了解了吧，但别忘了，一般我们只希望 iPhoneX 才需要新增适配样式，我们可以配合 @supports 这样编写样式：</p>
<pre><code>@supports (bottom: constant(safe-area-inset-bottom)) {

  div {

    margin-bottom: constant(safe-area-inset-bottom);

  }

}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上几种方案仅供参考，笔者认为，现阶段适配处理起来是有点折腾，但是至少能解决，具体需要根据页面实际场景，在不影响用户体验与操作的大前提下不断尝试与探索，才能更完美的适配。</p>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《统计学习方法》学习笔记]]></title>
      <url>/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上学期花了一个多月读完了李航老师的《统计学习方法》，现在带着新入团队的新同学以读书会的形式读这本书，书里边全是干货，对于我理解基本的机器学习算法很有帮助，也笔头做了一些总结（不完全基于此书），现将其摘录于此作为在博客园的第一篇博客。因为并不是为了扫盲，所以仅仅是抓出脉络以及关键点，方便以后快速温习，而不是预习。</p>
<h2 id="《统计学习方法》学习笔记"><a href="#《统计学习方法》学习笔记" class="headerlink" title="《统计学习方法》学习笔记"></a>《统计学习方法》学习笔记</h2><h3 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h3><p>机器学习很多时候也被称作统计机器学习，这是因为大部分机器学习方法或多或少基于统计的方法，或者有基于统计方法的版本，即便是早期不涉及统计方法的算法在后来也都有了统计学的解释。</p>
<p>统计学习的三要素：<strong>模型</strong>、<strong>策略</strong>、<strong>算法</strong>，决定了一个统计学习的方法。整本书的算法均可从这三个思路去思考，并且从这三个思路思考可以培养一定的统计建模的意识。</p>
<ul>
<li><strong>模型</strong>是一个可以根据合法输入产生输出的“黑盒子”，也即一个从输入空间（或特征空间）到输出空间的映射。</li>
<li><strong>策略</strong>是衡量模型好坏的一个判断标准，以此可以确定向什么方向修改/优化模型。</li>
<li><strong>算法</strong>是确定了模型和策略，为了尽量满足策略所采用的优化模型的做法。</li>
</ul>
<p>简单的说，整个学习就是要学习出一个模型，而策略决定了我们所想要的模型，而算法是用来得到模型参数所采用的方法而已。</p>
<p>这本书讨论的是有监督学习，而对于有监督学习来说，共有的一个问题就是<strong>过拟合问题（overfitting）</strong>，简单地来讲，这是模型过分“迎合”训练数据而导致模型在训练数据上表现良好，而对未知输入的泛化能力很差的现象。</p>
<p>首先，过拟合是无法避免的。毕竟统计学习在训练时避免不了要拟合训练数据，这是因为我们的模型参数就是由训练数据训练而来的。这里的“过”指的是模型过于复杂（迎合数据），导致泛化能力急剧下降。这里举个例子：<br><img src="http://images0.cnblogs.com/blog2015/773645/201506/120014234577159.jpg" alt="how many boxes are there behind the tree?"></p>
<p>这里有多少盒子在树后？按照我们的直觉应该是只有一个盒子，然而事实上可能是：<br><img src="http://images0.cnblogs.com/blog2015/773645/201506/120016085985337.jpg" alt="possible cases"></p>
<p>显然，根据我们的直观认识，对于一个未知的参数（即这里的盒子数），越简单可能越符合我们的先验知识。也即简单的模型对未知的情况泛化能力更高（更加可能是对的）。所以“从贝叶斯估计的角度来看，正则化项对应于模型的先验概率”，模型越复杂，先验越小（经验告诉我们如此复杂的情况不太可能）。</p>
<p>因此，一个自然的想法便是要在策略中限制这种复杂的模型，虽然其在训练数据上比简单模型的表现更好。最常见的思路的就是添加<strong>正则化项</strong>，此项表示了模型的复杂度。在策略中和原始目标求和，即可得到既能得到较大的目标函数值，又不使模型较为复杂的模型参数。一个最简单的例子就是线性回归。</p>
<p>另一个常用的方法即<strong>交叉验证</strong>，意思是将训练数据分块，一部分作为训练数据，一部分作为测试数据，多次不同地分块以后取在测试数据上表现最优的模型参数。这种方法的缺点是计算开销太大，毕竟要多训练很多次模型。</p>
<h3 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h3><p>这是一个线性的模型，意在用一条线（超平面）对训练数据进行二分。</p>
<ul>
<li>输入：训练数据的特征向量</li>
<li>输出：二值类标</li>
</ul>
<p><strong>前提是数据严格线性可分，即存在一条线（超平面）能将正负例完美分开。</strong>而学习的目的即为学出这个分离线（超平面）。</p>
<p>学习的策略为经验风险最小化，即误分类点数最少，而假设是线性可分，因此误分类点数一定可以降为0。但是，误分类点数并不能指导我们如何修改模型（不能导出有效的算法），因此我们修改了一下策略的表示，改为误分类点到分离平面的距离之和。因此损失函数为：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmu67r98qoj30kk023mwy.jpg" alt=""></p>
<p>其中，(M)为误分类点集，(w)和(b)为参数，(y_i)是标准类标，乘上(y_i)乘积保证为正。为求其极小，分别对参数求导并令其导数为0即可：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fmu670d42aj30kb03w0sk.jpg" alt=""></p>
<p>学习算法为梯度下降法，有原始形式和对偶形式之分。<br><strong>原始形式核心递归式：</strong></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fmu678q0bmj30ka03l0sj.jpg" alt=""></p>
<p>其中(\eta)为梯度下降的步长。初始值(w)和(b)随机初始化。</p>
<p>如果将(w)和(b)初始化为0，那么根据原始形式的递归式，(w)和(b)分别可以写作(y<em>{i}x</em>{i})和(y_{i})的线性组合形式，即：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fmu67ksx2ej30k705bdfn.jpg" alt=""></p>
<p>系数相同的原因是因为每次更新w和b走过了相同个数的步长。这样就能将对(w)和(b)的更新改为对(\alpha)和(b)的更新，节约了乘法的计算开销。<br><strong>对偶形式的核心递归式：</strong></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmu684xplyj30ka03c742.jpg" alt=""></p>
<p>注意到感知机算法的梯度下降法是用的随机梯度下降，即每次随机选择一个误分点进行更新，而没有使用批量梯度下降，这是因为感知机是必然线性可分的，也即最后超平面必然存在，即算法必然收敛，因此可以选择计算开销更小的随机梯度下降法。</p>
<h3 id="KNN算法"><a href="#KNN算法" class="headerlink" title="KNN算法"></a>KNN算法</h3><p>根据近邻来估计实例点的属性。有两种方式，一种是Top-K最近邻，一种是根据距离确定近邻。前者算最近的k个邻居，而后者计算离实例的距离在一定范围以内的所有邻居。分别适用于分布密集和分布稀疏的情况。</p>
<p>KNN算法最大的问题在于计算pair之间的距离，这是(O(n^2))的问题，而每次增加点，都需要进行N次计算，这是不可接受的，于是对实例存在的特征空间进行切分，具体算法即kd树算法。按维度进行切分，思想类似于二分查找。</p>
<h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><p>模型为条件概率模型，即目的为学习一个条件概率分布（和一个先验分布）。</p>
<ul>
<li>输入：实例的特征向量</li>
<li>输出：多值类标</li>
</ul>
<p><strong>模型假设：对于任一实例，在已知类标时，各特征相互独立。</strong>这其实是将指数级参数个数（(2^n)）的联合分布降为了线性参数个数（(2n+1)）的条件概率与先验之积。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmu68c3plpj30kb02ca9v.jpg" alt=""></p>
<p>由于分母是平凡的，对于相同实例不同类标都是相同的。因此可以略去。分母中的条件概率因为模型假设，可以写为：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmu68jsctgj30k5028mwy.jpg" alt=""></p>
<p>策略是期望风险最小化，即分类正误的期望，可等价于后验概率最小化（证明略）。也即只用找到后验概率最大的类标赋给实例即可。这里模型未知参数为(P(x_i|c_k))和(P(c_k))，为了估计其值，使用的是极大似然估计，通俗的说就是用训练样本中对应项出现的频率来作为估计的概率（因为极大似然估计和强假设，因此被叫做朴素贝叶斯，或者傻瓜贝叶斯）。</p>
<p>所有涉及到共现矩阵，也即观测的频率，以及概率的算法，都需要考虑概率值为0的情况，或者分母为0的情况。朴素贝叶斯加入拉普拉斯平滑使避免出现0。</p>
<h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>if-then结构的树，目的即为学习出这样一棵树，非叶子节点是特征，叶子节点是类标。</p>
<ul>
<li>输入：特征向量</li>
<li>输出：多值类标</li>
</ul>
<p>策略是特征选择，越靠近根的特征应该有更好的区分能力，然而这一条件无法直接指导算法优化，因此引入信息增益定义。</p>
<p>几个定义：</p>
<ul>
<li>熵：表示随机变量X的不确定程度：</li>
</ul>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmu68qfr04j30jj02ejr6.jpg" alt=""></p>
<p>这里遍历了X可能的i个取值，限制条件为所有取值概率之和为1</p>
<ul>
<li>经验熵：将数据集D做分类的不确定程度：</li>
</ul>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmu68xck6pj30jk02g743.jpg" alt=""></p>
<p>其中D可被分成K个类，并且第k个类的实例个数为(\vert C_k\vert)，D中实例个数为(\vert D\vert)</p>
<ul>
<li>经验条件熵：给定特征下，将数据集做分类的不确定性（用分成某子类的概率对子类的经验熵进行加权）。</li>
</ul>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmu6931fitj30jx03r745.jpg" alt=""></p>
<p>然后<strong>信息增益</strong>可以定义为：<strong>给定特征A时D上的经验熵与经验条件熵之差。</strong></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fmu69a4dmaj30k701zgle.jpg" alt=""></p>
<p>定义<strong>信息增益比</strong>：<strong>信息增益与数据集关于特征A的值的熵之比。</strong></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmu69fu2tjj30k4025mwy.jpg" alt=""></p>
<p>其中(H<em>{A}(D) = -\sum\limits</em>{i=1}^n\frac{|D_i|}{|D|}\log\frac{|D_i|}{|D|})，n是A可取的值的个数，(D_i)是根据特征A进行分类以后得到的子类，可以被看作是经验熵。</p>
<p>算法中，<strong>ID3算法</strong>递归建树，对每个节点，选择当前使信息增益最大的特征。<strong>C4.5</strong>算法，用信息增益比来替代ID3中的信息增益。这是因为消息增益越大，表明该特征对全局熵减少得也就最大，也即能使全局不确定性降低最大，若一个特征可以取的值越多，每个分支下的实例数就越少，相应的不确定程度就越低，换句话说，信息增益会偏向取值更多的特征，因此ID3算法偏向生成那种宽而浅的树，这其实是不合理的。而信息增益比用经验熵做约束，惩罚了取值数多的特征，因此可以得到更好的树。</p>
<p>决策树模型为了防止过拟合，需要一定的<strong>剪枝</strong>，其做法是用节点个数作为正则化项。<br><strong>CART算法</strong>（建树、剪枝），用即你最小化建二叉树，即对于所有可能的特征的所有可能取值，取基尼最大的作为当前节点特征。<br><strong>基尼指数</strong>:</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fmu69m77k6j30kf02dwea.jpg" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>持续更新中～</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS 实用 Tips]]></title>
      <url>/CSS-%E5%AE%9E%E7%94%A8-Tips.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为前端，日常开发充满了各种挑战与乐趣，我们穷尽一切在奇葩的需求中提升用户体验。本文将列举一些前端开发中碰到的小众需求，并提供解决方案以供参考。</p>
<h2 id="CSS-实用-Tips"><a href="#CSS-实用-Tips" class="headerlink" title="CSS 实用 Tips"></a>CSS 实用 Tips</h2><h3 id="一、修改鼠标手势图标"><a href="#一、修改鼠标手势图标" class="headerlink" title="一、修改鼠标手势图标"></a>一、修改鼠标手势图标</h3><p>很多童鞋可能都用过：</p>
<pre><code>cursor: pointer | wait | hand | text | move |not-allowed;
</code></pre><p>但是，它还支持用户自定义图片，你知道吗？</p>
<pre><code>cursor: url(jartto.cur), url(http://jartto.wang/jartto.gif), auto;
</code></pre><p>下图为各浏览器支持情况：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmt0w88h1yj30hx05n74v.jpg" alt="tips1"></p>
<p>记得在定义完自定义的游标之后在末尾加上一般性的游标，以防那些url所定义的游标不能使用。</p>
<p>这里有详细说明：</p>
<p>1.<a href="https://link.funteas.com?target=https%3A%2F%2Fwww.cnblogs.com%2FMY0101%2Fp%2F6130089.html" target="_blank" rel="external">css cursor 的可选值（鼠标的各种样式）</a><br>2.<a href="https://link.funteas.com?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FCSS%2FCSS_User_Interface%2FUsing_URL_values_for_the_cursor_property" target="_blank" rel="external">Using URL values for the cursor property</a> </p>
<h3 id="二、box-shadow-三边阴影"><a href="#二、box-shadow-三边阴影" class="headerlink" title="二、box-shadow 三边阴影"></a>二、box-shadow 三边阴影</h3><p><code>box-shadow</code> 大家都不陌生，我们一般这么用：</p>
<pre><code>box-shadow: h-shadow v-shadow blur spread color inset;
</code></pre><p>可是三边阴影该如何设置呢？请不要忽视设计师的脑洞🙈：</p>
<pre><code>#shadowBox {
  background-color: #ddd;
  margin: 0px auto;
  padding: 10px;
  width: 220px;
  box-shadow: 0px 8px 10px gray,
        -10px 8px 15px gray, 10px 8px 15px gray;
}
</code></pre><p>也许你会用得到，详情请参考：<a href="https://link.funteas.com?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F8738768%2Fcss-box-shadow-on-three-sides-of-a-div" target="_blank" rel="external">CSS box-shadow on three sides of a div?</a> </p>
<h3 id="三、超好用的-currentColor"><a href="#三、超好用的-currentColor" class="headerlink" title="三、超好用的 currentColor"></a>三、超好用的 currentColor</h3><p>先来举个例子，html代码：</p>
<pre><code>&lt;a href=&quot;##&quot; class=&quot;link&quot;&gt;&lt;i class=&quot;icon&quot;&gt;&lt;/i&gt;返回&lt;/a&gt;
</code></pre><p>css 代码：</p>
<pre><code>.icon {
  display: inline-block;
  width: 16px; 
  height: 20px;
  background-image: url(http:jartto.wang/test.png);
  background-color: currentColor; /* 该颜色控制图标的颜色 */
  background-position: 0 0;
}
.link:hover {
  color: #333; /* 虽然改变的是文字颜色，但是图标颜色也一起变化了 */
}
</code></pre><p>currentColor 表示“当前的标签所继承的文字颜色”</p>
<p>了解更多，请参考：<a href="https://link.funteas.com?target=http%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2014%2F10%2Fcurrentcolor-css3-powerful-css-keyword%2F" target="_blank" rel="external">CSS3 超高校级好用 CSS 变量</a> </p>
<h3 id="四、png-图片如何改颜色"><a href="#四、png-图片如何改颜色" class="headerlink" title="四、png 图片如何改颜色"></a>四、png 图片如何改颜色</h3><p>网页中大多使用透明图片 <code>png</code> 格式，可是如果有天产品经理说，这个图标颜色能不能改成红色，恰巧设计师不能支持你，你该如何办？<br>其一：自己重新 <code>ps</code> 一下图片，换个颜色；<br>其二：只能上 <code>svg</code> 喽，搞成 <code>icon font</code>；</p>
<p>这里，我们来说第三种方式，妙不妙可以试试哦！</p>
<pre><code>.icon {
  display: inline-block;
  width: 20px; 
  height: 20px;
  overflow: hidden;
}
.icon-del {
  background: url(delete.png) no-repeat center;
}
.icon &gt; .icon {
  position: relative;
  left: -20px;
  border-right: 20px solid transparent; /*下文注意点 2 有解释*/
  -webkit-filter: drop-shadow(20px 0);
  filter: drop-shadow(20px 0);    
}
</code></pre><p>html 代码:</p>
<pre><code>&lt;p&gt;&lt;strong&gt;原始图标&lt;/strong&gt;&lt;/p&gt;
&lt;i class=&quot;icon icon-del&quot;&gt;&lt;/i&gt;
&lt;p&gt;&lt;strong&gt;可以变色的图标&lt;/strong&gt;&lt;/p&gt;
&lt;i class=&quot;icon&quot;&gt;&lt;i class=&quot;icon icon-del&quot;&gt;&lt;/i&gt;&lt;/i&gt;
</code></pre><p>需要注意几点：<br>1.对于背景透明的 <code>png</code> 小图标而言，如果我们施加一个不带模糊的投影，就等同于生成了另外一个颜色的小图标；<br>2.在 <code>chrome</code> 浏览器下，如果一个元素的主体部分，无论以何种方式，只要在页面中不可见，其 <code>drop-shadow</code> 是不可见的。实体部分哪怕有 <code>1px</code> 可见，则 <code>drop-shadow</code> 完全可见。</p>
<p>原理其实很简单，使用了 <code>css3</code> 滤镜 <code>filter</code> 中的 <code>drop-shadow</code>，<code>drop-shadow</code> 滤镜可以给元素或图片非透明区域添加投影。</p>
<p>了解更多，请参考：<br>1.<a href="https://link.funteas.com?target=http%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2016%2F06%2Fpng-icon-change-color-by-css%2F" target="_blank" rel="external">PNG 格式小图标的 CSS 任意颜色赋色技术</a><br>2.<a href="https://link.funteas.com?target=http%3A%2F%2Fwww.zhangxinxu.com%2Fstudy%2F201606%2Fpng-icon-color-fill.html" target="_blank" rel="external">demo 演示</a> </p>
<h3 id="五、vh-与-vw"><a href="#五、vh-与-vw" class="headerlink" title="五、vh 与 vw"></a>五、vh 与 vw</h3><p>相对于视口的宽度。视口被均分为 <code>100</code> 单位的 <code>vw</code>，<code>vh</code> 同理。</p>
<p>我一般会在强制某一个容器占一整屏的时候使用，如：</p>
<pre><code>.box{
  height: calc(100vh-50px);}
</code></pre><p>视口高度减去页头固定区域，剩下的高度设置给容器。当然，我们也可以用它设置大小，如下：</p>
<pre><code>h1 {
  font-size:8vw;}
</code></pre><p>如果视口的宽度是 <code>200mm</code>，那么上述代码中h1元素的字号将为 <code>16mm</code>，即 (8x200)/100</p>
<p>值得注意的是，<code>less</code> 中使用需要加 <code>～</code></p>
<pre><code>min-height:~&quot;calc(100vh - 68px)&quot;;
</code></pre><p>此外，还有一些如 <code>ch</code> ，<code>vmax</code>，<code>vmin</code> 等属性等着你去扩展，详情请移步：<a href="https://link.funteas.com?target=http%3A%2F%2Fwww.css88.com%2Fbook%2Fcss%2Fvalues%2Flength%2Fvw.htm" target="_blank" rel="external">css 参考手册之 vw</a> </p>
<h3 id="六、如何去掉-chrome-input-的背景黄色"><a href="#六、如何去掉-chrome-input-的背景黄色" class="headerlink" title="六、如何去掉 chrome input 的背景黄色"></a>六、如何去掉 chrome input 的背景黄色</h3><p>当我们在做登陆页面的时候，在 <code>chrome</code> 中 <code>input</code> 会带上自动补全的黄色背景，大大影响美观。很多网站都没有去处理，但这并不难处理。作为高逼格的前端，这里就可以体现出你的价值，解决方案如下：</p>
<pre><code>input:-webkit-autofill {
  -webkit-box-shadow: 0 0 0px 1000px rgba(255, 255, 255, 0.5) inset !important;
}
</code></pre><p>当然，你也可以使用方案二，如下：</p>
<pre><code>input:-webkit-autofill {
  -webkit-animation-name: autofill;
  -webkit-animation-fill-mode: both;
}
@-webkit-keyframes autofill {
  to {
    color: #fff;
    background: transparent;
  }
}
</code></pre><p>深入了解请移步：<br>1.<a href="https://link.funteas.com?target=http%3A%2F%2Fblog.csdn.net%2Fwangxiaohui6687%2Farticle%2Fdetails%2F10149579" target="_blank" rel="external">chrome 表单自动填充去掉 input 黄色背景解决方案</a><br>2.<a href="https://link.funteas.com?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F2781549%2Fremoving-input-background-colour-for-chrome-autocomplete" target="_blank" rel="external">Removing input background colour for Chrome autocomplete</a> </p>
<h3 id="七、chrome-中设置小于-12px-的字体"><a href="#七、chrome-中设置小于-12px-的字体" class="headerlink" title="七、chrome 中设置小于 12px 的字体"></a>七、chrome 中设置小于 12px 的字体</h3><p>这种改小字体，绝大部分肯定都是设计师的需求，因为小显得精致。</p>
<pre><code>ant-checkbox-wrapper {
 cursor: pointer;
 font-size: 10px;
 display: inline-block;
 -webkit-text-size-adjust: none; // 不支持
 transform: scale(0.9);
}
</code></pre><h3 id="八、0-5px-border-如何操作"><a href="#八、0-5px-border-如何操作" class="headerlink" title="八、0.5px border 如何操作"></a>八、0.5px border 如何操作</h3><p>现行方法大致有如下几条：<br>1.使用渐变 <code>linear-gradient</code> 来操作，但需要注意浏览器兼容前缀；</p>
<pre><code>.div::after {
  content: &quot; &quot;;
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 1px;
  background-image: linear-gradient(0deg, transparent 50%, #e0e0e0 50%);
}
</code></pre><p>2.缩放 <code>scale</code> 处理：</p>
<pre><code>div::after{
  content: &quot;&quot;;
  display: block;
  position: absolute;
  left: -50%;
  bottom: 0;
  width: 200%;
  height: 1px;
  background: #c3c3c3;
  -webkit-transform: scale(0.5);
}
</code></pre><p>3.使用 <code>background-image</code> 和 <code>css3</code> 的九宫格裁减</p>
<pre><code>.bd-t::after {
  content: &quot; &quot;;
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  border-top: 1px solid transparent;
  /* 下面用 stretch 和 round 都可以 */
  border-image: url(&#39;pic.png&#39;) 2 1 1 1 stretch; 
  -webkit-border-image: url(&#39;pic.png&#39;) 2 1 1 1 stretch;
}
</code></pre><p>深入了解可以参考：<br>1.<a href="https://link.funteas.com?target=http%3A%2F%2Fblog.csdn.net%2Ftyro_java%2Farticle%2Fdetails%2F52013531" target="_blank" rel="external">使用 css3 做 0.5px 的细线</a><br>2.<a href="https://link.funteas.com?target=http%3A%2F%2Fwww.cnblogs.com%2Fraoyunxiao%2Fp%2F4241982.html" target="_blank" rel="external">移动端页面0.5px border的实现</a> </p>
<h3 id="九、border-颜色渐变"><a href="#九、border-颜色渐变" class="headerlink" title="九、border 颜色渐变"></a>九、border 颜色渐变</h3><pre><code>border-color:red green blue pink;
</code></pre><p>“border-width” 属性如果单独使用的话是不会起作用的。请首先使用 “border-style” 属性来设置边框。</p>
<h3 id="十、css3-画小箭头"><a href="#十、css3-画小箭头" class="headerlink" title="十、css3 画小箭头"></a>十、css3 画小箭头</h3><p>这里推荐两种方式：<br>其一，通过 border 来实现</p>
<pre><code>/*箭头向上*/
.arrow-up {
  width:0;
  height:0;
  border-left:30px solid transparent;
  border-right:30px solid transparent;
  border-bottom:30px solid #fff;
}
/*箭头向下*/
.arrow-down {
  width:0;
  height:0;
  border-left:20px solid transparent;
  border-right:20px solid transparent;
  border-top:20px solid #0066cc;
}
</code></pre><p>其二，拼凑法（伪类或元素），将 <code>div</code> 隐藏两边或设置 <code>z-index</code>，然后旋转，放到合适位置。</p>
<pre><code>div {
  position: absolute;
  bottom: -2px;
  left: 7px;
  width: 10px;
  height: 10px;
  transform: rotate(-45deg);
  z-index: -1; /* 放在容器后，被遮盖住*/
}
</code></pre><p>比较简单，就不赘述了。</p>
<h3 id="十一、有趣的-drop-shadow"><a href="#十一、有趣的-drop-shadow" class="headerlink" title="十一、有趣的 drop-shadow"></a>十一、有趣的 drop-shadow</h3><p>用法如下：</p>
<pre><code>filter: drop-shadow(x偏移, y偏移, 模糊大小, 色值);
filter:drop-shadow(5px 5px 10px black)
</code></pre><p>CSS3 滤镜 filter 中的 drop-shadow，drop-shadow 滤镜可以给元素或图片非透明区域添加投影。</p>
<p>上文中已经提到了一种使用场景，这里还想说另一种，即使用拼凑法作出的小气泡，如果气泡需要阴影的话，请用 <code>drop-shadow</code> 来替代 <code>box-shadow</code>。</p>
<p>更多细节请查看：<a href="https://link.funteas.com?target=http%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2016%2F05%2Fcss3-filter-drop-shadow-vs-box-shadow%2F" target="_blank" rel="external">drop-shadow 滤镜与 box-shadow 区别应用</a> </p>
<h3 id="十二、修改浏览器默认滚动条"><a href="#十二、修改浏览器默认滚动条" class="headerlink" title="十二、修改浏览器默认滚动条"></a>十二、修改浏览器默认滚动条</h3><p>有时候一些不期而遇的滚动条会让页面很尴尬，这时候你还可以强行美化一下，参考代码如下：</p>
<pre><code>/*滚动条 start*/
::-webkit-scrollbar {
  width: 1px;
  height: 4px;
  background-color: #F5F5F5;
}
/*定义滚动条轨道 内阴影+圆角*/
::-webkit-scrollbar-track {
  box-shadow: inset 0 0 6px rgba(0,0,0,0.3);
  background: #fff ;
}
/*定义滑块 内阴影+圆角*/
::-webkit-scrollbar-thumb {
  border-radius: 3px;
  box-shadow: inset 0 0 6px rgba(0,0,0,.3);
  // background-color:rgba(7, 170, 247, 0.7);
  background-color: transparent;
}
::-webkit-scrollbar-thumb:hover {
  border-radius: 3px;
  box-shadow: inset 0 0 6px rgba(0,0,0,.3);
  background-color:rgba(7, 170, 247, 1);
}
</code></pre><p>细节请参考：<a href="https://link.funteas.com?target=http%3A%2F%2Fblog.csdn.net%2Fning0_o%2Farticle%2Fdetails%2F52188953" target="_blank" rel="external">修改浏览器默认的滚动条样式</a> </p>
<h3 id="十三、safari-placeholder-bugs"><a href="#十三、safari-placeholder-bugs" class="headerlink" title="十三、safari placeholder bugs"></a>十三、safari placeholder bugs</h3><p>在项目中遇到 <code>input</code> 的 <code>placeholder</code> 在 <code>safari</code> 下设置行高失效的问题，解决思路如下：<br>1.使用 <code>padding</code> 使提示文字居中，如果 <code>font-size:14px</code>, <code>UI</code> 高度为 <code>40px</code>,我们可以设 <code>height：14px,padding:13px 0;</code><br>2.使用 <code>line-height:1px;</code><br>3.使用 <code>vertical-align: middle;</code></p>
<p>补充一条：Safari 来写 hack 即 [;line-height:1;]</p>
<p>详情请参考：<a href="https://link.funteas.com?target=http%3A%2F%2Fwww.cnblogs.com%2Fhumaotegong%2Fp%2F6629060.html%3Futm_source%3Ditdadao%26amp%3Butm_medium%3Dreferral" target="_blank" rel="external">input 的 placeholder 在 safari 下设置行高失效</a> </p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这些都是在我日常开发中碰到的奇葩问题，回头想想其实挺有意思，遂整理总结之。如果日常开发中没有一些挑战，那开发还有什么乐趣。</p>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[20 个 CSS 高级技巧汇总]]></title>
      <url>/20-%E4%B8%AA-CSS-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用技巧会让人变的越来越懒，没错，我就是想让你变懒。下面是我收集的CSS高级技巧，希望你懒出境界。</p>
<h2 id="20-个-CSS-高级技巧汇总"><a href="#20-个-CSS-高级技巧汇总" class="headerlink" title="20 个 CSS 高级技巧汇总"></a>20 个 CSS 高级技巧汇总</h2><h3 id="1-黑白图像"><a href="#1-黑白图像" class="headerlink" title="1. 黑白图像"></a>1. 黑白图像</h3><p>这段代码会让你的彩色照片显示为黑白照片，是不是很酷？</p>
<pre><code>img.desaturate {
    filter: grayscale(100%);
    -webkit-filter: grayscale(100%);
    -moz-filter: grayscale(100%);
    -ms-filter: grayscale(100%);
    -o-filter: grayscale(100%);
}
</code></pre><h3 id="2-使用-not-在菜单上应用-取消应用边框"><a href="#2-使用-not-在菜单上应用-取消应用边框" class="headerlink" title="2. 使用 :not() 在菜单上应用/取消应用边框"></a>2. 使用 <code>:not()</code> 在菜单上应用/取消应用边框</h3><p>先给每一个菜单项添加边框</p>
<pre><code>/* add border */
.nav li {
  border-right: 1px solid #666;
}
</code></pre><p>……然后再除去最后一个元素……</p>
<pre><code>// remove border /

.nav li:last-child {
  border-right: none;
}
</code></pre><p>……可以直接使用 :not() 伪类来应用元素：</p>
<pre><code>.nav li:not(:last-child) {
  border-right: 1px solid #666;
}
</code></pre><p>这样代码就干净，易读，易于理解了。</p>
<p>当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：</p>
<pre><code>..nav li:first-child ~ li {

  border-left: 1px solid #666;
}
</code></pre><h3 id="3-页面顶部阴影"><a href="#3-页面顶部阴影" class="headerlink" title="3. 页面顶部阴影"></a>3. 页面顶部阴影</h3><p>下面这个简单的 CSS3 代码片段可以给网页加上漂亮的顶部阴影效果：</p>
<pre><code>body:before {
          content: &quot;&quot;;
          position: fixed;
          top: -10px;
          left: 0;
          width: 100%;
          height: 10px;

          -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8);
          -moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8);
          box-shadow: 0px 0px 10px rgba(0,0,0,.8);

          z-index: 100;
}
</code></pre><h3 id="4-给-body-添加行高"><a href="#4-给-body-添加行高" class="headerlink" title="4. 给 body 添加行高"></a>4. 给 body 添加行高</h3><p>你不需要分别添加 line-height 到每个p,h标记等。只要添加到 body 即可：</p>
<pre><code>body {
  line-height: 1;
}
</code></pre><p>这样文本元素就可以很容易地从 body 继承。</p>
<h3 id="5-所有一切都垂直居中"><a href="#5-所有一切都垂直居中" class="headerlink" title="5. 所有一切都垂直居中"></a>5. 所有一切都垂直居中</h3><p>要将所有元素垂直居中，太简单了：</p>
<pre><code>html, body {
  height: 100%;
  margin: 0;
}

body {
  -webkit-align-items: center;  
  -ms-flex-align: center;  
  align-items: center;
  display: -webkit-flex;
  display: flex;
}
</code></pre><p>看，是不是很简单。</p>
<p>注意：在IE11中要小心flexbox。</p>
<h3 id="6-逗号分隔的列表"><a href="#6-逗号分隔的列表" class="headerlink" title="6. 逗号分隔的列表"></a>6. 逗号分隔的列表</h3><p>让HTML列表项看上去像一个真正的，用逗号分隔的列表：</p>
<pre><code>ul &gt; li:not(:last-child)::after {
  content: &quot;,&quot;;
}
</code></pre><p>对最后一个列表项使用 :not() 伪类。</p>
<h3 id="7-使用负的-nth-child-选择项目"><a href="#7-使用负的-nth-child-选择项目" class="headerlink" title="7. 使用负的 nth-child 选择项目"></a>7. 使用负的 nth-child 选择项目</h3><p>在CSS中使用负的 nth-child 选择项目1到项目n。</p>
<pre><code>li {
  display: none;
}

/* select items 1 through 3 and display them */
li:nth-child(-n+3) {
  display: block;
}
</code></pre><h3 id="8-对图标使用-SVG"><a href="#8-对图标使用-SVG" class="headerlink" title="8. 对图标使用 SVG"></a>8. 对图标使用 SVG</h3><p>我们没有理由不对图标使用SVG：</p>
<pre><code>.logo {
  background: url(&quot;logo.svg&quot;);
}
</code></pre><p>SVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。</p>
<h3 id="9-优化显示文本"><a href="#9-优化显示文本" class="headerlink" title="9. 优化显示文本"></a>9. 优化显示文本</h3><p>有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：</p>
<pre><code>html {
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
}
</code></pre><p>注：请负责任地使用 optimizeLegibility。此外，IE /Edge没有 text-rendering 支持。</p>
<h3 id="10-对纯-CSS-滑块使用-max-height"><a href="#10-对纯-CSS-滑块使用-max-height" class="headerlink" title="10. 对纯 CSS 滑块使用 max-height"></a>10. 对纯 CSS 滑块使用 max-height</h3><p>使用 max-height 和溢出隐藏来实现只有CSS的滑块：</p>
<pre><code>.slider ul {
  max-height: 0;
  overlow: hidden;
}

.slider:hover ul {
  max-height: 1000px;
  transition: .3s ease;
}
</code></pre><h3 id="11-继承-box-sizing"><a href="#11-继承-box-sizing" class="headerlink" title="11. 继承 box-sizing"></a>11. 继承 box-sizing</h3><p>让 box-sizing 继承 html：</p>
<pre><code>html {
  box-sizing: border-box;
}

*, *:before, *:after {
  box-sizing: inherit;
}
</code></pre><p>这样在插件或杠杆其他行为的其他组件中就能更容易地改变 box-sizing 了。</p>
<h3 id="12-表格单元格等宽"><a href="#12-表格单元格等宽" class="headerlink" title="12. 表格单元格等宽"></a>12. 表格单元格等宽</h3><p>表格工作起来很麻烦，所以务必尽量使用 table-layout: fixed 来保持单元格的等宽：</p>
<pre><code>.calendar {
  table-layout: fixed;
}
</code></pre><h3 id="13-用-Flexbox-摆脱外边距的各种-hack"><a href="#13-用-Flexbox-摆脱外边距的各种-hack" class="headerlink" title="13. 用 Flexbox 摆脱外边距的各种 hack"></a>13. 用 Flexbox 摆脱外边距的各种 hack</h3><p>当需要用到列分隔符时，通过flexbox的 space-between 属性，你就可以摆脱nth-，first-，和 last-child 的hack了：</p>
<pre><code>.list {
  display: flex;
  justify-content: space-between;
}

.list .person {
  flex-basis: 23%;
}
</code></pre><p>现在，列表分隔符就会在均匀间隔的位置出现。</p>
<h3 id="14-使用属性选择器用于空链接"><a href="#14-使用属性选择器用于空链接" class="headerlink" title="14. 使用属性选择器用于空链接"></a>14. 使用属性选择器用于空链接</h3><p>当a元素没有文本值，但 href 属性有链接的时候显示链接：</p>
<pre><code>a[href^=&quot;http&quot;]:empty::before {
  content: attr(href);
}
</code></pre><p>相当方便。</p>
<h3 id="15-检测鼠标双击"><a href="#15-检测鼠标双击" class="headerlink" title="15. 检测鼠标双击"></a>15. 检测鼠标双击</h3><p>HTML：</p>
<pre><code>&lt;div class=&quot;test3&quot;&gt;
  &lt;span&gt;&lt;input type=&quot;text&quot; value=&quot; &quot; readonly=&quot;true&quot; /&gt;
  &lt;a href=&quot;http://renpingjun.com&quot;&gt;Double click me&lt;/a&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre><p>CSS：</p>
<pre><code>.test3 span {
  position: relative;
}
.test3 span a {
  position: relative;
  z-index: 2;
}
.test3 span a:hover, .test3 span a:active {
  z-index: 4;
}
.test3 span input {
  background: transparent;
  border: 0;
  cursor: pointer;
  position: absolute;
  top: -1px;
  left: 0;
  width: 101%;  /* Hacky */
  height: 301%; /* Hacky */
  z-index: 3;
}
.test3 span input:focus {
  background: transparent;
  border: 0;
  z-index: 1;
}
</code></pre><h3 id="16-CSS-写出三角形"><a href="#16-CSS-写出三角形" class="headerlink" title="16. CSS 写出三角形"></a>16. CSS 写出三角形</h3><pre><code>/* create an arrow that points up */
div.arrow-up {
  width:0px;
  height:0px;
  border-left:5px solid transparent;  /* left arrow slant */
  border-right:5px solid transparent; /* right arrow slant */
  border-bottom:5px solid #2f2f2f; /* bottom, add background color here */
  font-size:0px;
  line-height:0px;
}

/* create an arrow that points down */
div.arrow-down {
  width:0px;
  height:0px;
  border-left:5px solid transparent;
  border-right:5px solid transparent;
  border-top:5px solid #2f2f2f;
  font-size:0px;
  line-height:0px;
}

/* create an arrow that points left */
div.arrow-left {
  width:0px;
  height:0px;
  border-bottom:5px solid transparent;  /* left arrow slant */
  border-top:5px solid transparent; /* right arrow slant */
  border-right:5px solid #2f2f2f; /* bottom, add background color here */
  font-size:0px;
  line-height:0px;
}

/* create an arrow that points right */
div.arrow-right {
  width:0px;
  height:0px;
  border-bottom:5px solid transparent;  /* left arrow slant */
  border-top:5px solid transparent; /* right arrow slant */
  border-left:5px solid #2f2f2f; /* bottom, add background color here */
  font-size:0px;
  line-height:0px;
}
</code></pre><h3 id="17-CSS3-calc-的使用"><a href="#17-CSS3-calc-的使用" class="headerlink" title="17. CSS3 calc() 的使用"></a>17. CSS3 calc() 的使用</h3><p>calc() 用法类似于函数，能够给元素设置动态的值：</p>
<pre><code>/* basic calc */
.simpleBlock {
  width: calc(100% - 100px);
}

/* calc in calc */
.complexBlock {
  width: calc(100% - 50% / 3);
  padding: 5px calc(3% - 2px);
  margin-left: calc(10% + 10px);
}
</code></pre><h3 id="18-文本渐变"><a href="#18-文本渐变" class="headerlink" title="18. 文本渐变"></a>18. 文本渐变</h3><p>文本渐变效果很流行，使用 CSS3 能够很简单就实现：</p>
<pre><code>h2[data-text] {
  position: relative;
}
h2[data-text]::after {
  content: attr(data-text);
  z-index: 10;
  color: #e3e3e3;
  position: absolute;
  top: 0;
  left: 0;
  -webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,0)), color-stop(50%, rgba(0,0,0,1)), to(rgba(0,0,0,0)));}
</code></pre><h3 id="19-禁用鼠标事件"><a href="#19-禁用鼠标事件" class="headerlink" title="19. 禁用鼠标事件"></a>19. 禁用鼠标事件</h3><p>CSS3 新增的 pointer-events 让你能够禁用元素的鼠标事件，例如，一个连接如果设置了下面的样式就无法点击了。</p>
<pre><code>.disabled { pointer-events: none; }
</code></pre><h3 id="20-模糊文本"><a href="#20-模糊文本" class="headerlink" title="20. 模糊文本"></a>20. 模糊文本</h3><p>简单但很漂亮的文本模糊效果，简单又好看！</p>
<pre><code>.blur {
   color: transparent;
   text-shadow: 0 0 5px rgba(0,0,0,0.5);
}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这就是常用的css高级技巧。</p>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2018年，前端应该怎么学？]]></title>
      <url>/2018%E5%B9%B4%EF%BC%8C%E5%89%8D%E7%AB%AF%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%AD%A6%EF%BC%9F.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>面向2018年，我觉得前端有这么三个方向可以突破</p>
<ol>
<li><strong>前端逻辑层</strong>（包括三大框架，webpack，前端数据管理）</li>
<li><strong>前端交互层</strong>（包括css3，canvas，svg，vr等，以及对应性能优化）</li>
<li><strong>node服务器层</strong> （即服务器领域，以及前端开发工具的开发）</li>
</ol>
<p>当然还可以说，有electron这样开发桌面应用的，但是我觉得大部分人的规划还是在web领域范畴的。</p>
<h2 id="一、前端逻辑层"><a href="#一、前端逻辑层" class="headerlink" title="一、前端逻辑层"></a><strong>一、前端逻辑层</strong></h2><p>前端逻辑层解决的问题：前端的渲染问题。<br>其实就是，从后端拿到的各种数据（数据库的结构化数据，各种素材），如何组合成页面元素。</p>
<p>前端的渲染，其实就是   模板+数据 = 页面</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmn2gohvx2j30ea07jq2w.jpg" alt=""></p>
<p>① html 负责结构<br>② css 负责样式<br>③ js 负责逻辑<br>只有模板没有后端数据的页面我们可以理解为静态页面<br>而我们目前主流的三大框架，则提供 模板与数据之间的映射关系。<br>在逻辑层的研究，主要就是学习并熟练三大框架： Vue, React, Angular  </p>
<p>这一块是我们90%前端，日常工作的主要部分。也是很多公司面试会去重点考察的内容。<br>但是，目前的行情已经不是，你会个新框架就可以任性拿OFFER的时期了。<br>前端的井喷的情况下，仅仅会一些基础知识是不够的。你必须往下深挖。</p>
<p><strong>可以深挖的部分</strong><br>①<strong>框架部分</strong>： 举个例子，如 Vue+ Vuex+ Vue-router+axios的全家桶<br>react和angular的也类似，有这么一套全家桶。<br>要想在前端竞争中取得优势，需要在这些框架的原理上深挖。<br>研究：<br>a. 源码和实现原理 （理论）<br>b. 常见的应用场景和常见问题的实现 （经验）<br>c. 同类问题的横向对比（比如用了vuex 需要了解一下 redux是怎么实现的）</p>
<p>②<strong>构建部分</strong>：  webpack + npm/yarn +  脚手架（如vue-cli） +sass<br>构建部分，其实是一块很容易出区分度的领域。你研究透一点，你就越能驾驭住项目的变化。<br>研究：<br>a. webpack的配置和对应应用场景<br>b. npm的命令使用，以及一些高级的用法（架设私有npm或者自己写全局包等）<br>c. 脚手架快速搭建的过程，以及如何自定义更改<br>d. 如何配置eslint和单元测试等</p>
<p>③<strong>代码规范部分</strong>：   es6 + ts + css规范 等等等<br>代码规范不多说，前端的js和css都是设计得很粗糙的语言。如果你想hold住更大型的项目，那么规范是你不可忽视的地方。</p>
<p>逻辑层部分，是我们通常意义上理解的前端本职。</p>
<h2 id="二、前端交互层"><a href="#二、前端交互层" class="headerlink" title="二、前端交互层"></a>二、前端交互层</h2><p>所谓交互层，可以理解为我们常说的  特效。<br>当前的趋势下，移动端浏览器的性能逐步提升。未来一个大的趋势就是<br>前端开发的效果，正无限逼近原生效果</p>
<p>同时一些大厂也在纷纷提前布局了，之前惊艳四方的天猫造物节 H5<br><a href="http://www.jianshu.com/p/111ee1fde39f" target="_blank" rel="external">淘宝造物节-风靡朋友圈的h5怎么做的？</a> </p>
<p>如果我们要在这波浪潮上取得先机，那么就必须提前学习。<br>也许再过三年，前端的开发特效的能力，也会成为标配技能。</p>
<p>可以分三块来看<br><strong>1.呈现效果学习：</strong><br>很多同学不是不会特效，而是不知道要实现成什么样子。用前端的各种东西鼓捣了，终于出来了特效，但是效果却很难看。<br>不不不，做特效，应该先把特效样子调好了再去做。<br>建议学习Adobe Effects （AE），直观地看动效是什么样子，然后再翻译成前端的动效。</p>
<p><strong>2.相关数学/视觉原理：</strong><br>a.贝塞尔曲线原理<br>b.视差原理<br>c.阻尼公式</p>
<p><strong>3.相关技术手段实现</strong><br>前端目前实现动画特效的八种方式<br><a href="http://www.offcn.com/it/2017/0110/5881.html" target="_blank" rel="external">http://www.offcn.com/it/2017/…</a> </p>
<p><strong>①gif:</strong> 设计直接出GIF，前端直接用<br><strong>②逐帧动画</strong>： css3 step属性 或  js制作逐帧动画<br><strong>③css3</strong> ：  transition/ transform/animation<br><strong>④svg</strong> :  svg 很适合移动端<br><strong>⑤canvas</strong>:   canvas适合一些比较大面积的动效<br><strong>⑥flash</strong> 转 canvas :  这个我不了解<br><strong>⑦video</strong>:  用h5 video标签<br><strong>⑧js动画</strong>：  可以配合平台提供的api（重力感应等）开发更复杂的动效</p>
<h2 id="三、node-服务层"><a href="#三、node-服务层" class="headerlink" title="三、node 服务层"></a><strong>三、node 服务层</strong></h2><p>node在前端应该是无人不知了。在实际使用中node的使用场景应该有这几个：<br><strong>① 作为前端构建辅助工具</strong>： 如各种脚手架中，经常有node的参与<br><strong>② 作为服务端做渲染层</strong>： 实现接口合并和模板渲染<br><strong>③ 作为完整服务器</strong>：  一般是创业公司中，可以一人搭建起全部web功能。如微信公众号项目等</p>
<p>那么如果要学习的话，要从哪里入手呢？<br>学习一个新技术，我个人的方式都是<br><strong>先把原生的文档，快速过一遍，然后学框架。</strong></p>
<p>不看原生的，很容易学一套框架，就是一次学习量。<br>学习原生知识，可以让你学框架速度提升。</p>
<p>框架里面常用的：<br>①express   ②koa   ③基于以上两者衍生的框架   ④其余框架</p>
<p><strong>我建议新手学习express 框架。理由很简单，易学，使用多，教程多。</strong><br><strong>我个人想学习的node框架是天猫的egg.js 。</strong></p>
<p>推荐理由是<br>①大厂开发，面向工程<br>②经受住了双十一的考验，质量有保障<br>总结</p>
<p><strong>前端是端工程师，一切特性依赖于客户端。</strong><br>因此各位前端的同仁，除了上述的功能外，还是要多留意浏览器以及移动端环境的变迁。<br>一些类似与 HTTP2协议，PWA，openGL等技术，都随时有可能改变前端的工作方式。</p>
<p>我上面列了那么多，其实我很多都没有学过（手动狗头）。但是除了技术能力，也许以下几个综合能力，对于前端er也是要注意的<br><strong>①自我规划能力</strong>：对于技术领域的趋势的洞察，以及个人对应的学习计划<br><strong>②快速学习能力</strong>：搜索能力（利用网上的各种知识），知识迁移能力<br><strong>③沟通能力和知识输出能力</strong>：  面向产品，以及面向后端，面向社区同仁</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这就是2018年前端人才发展的规划，如有不足请指出。</p>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[H5的Notification特性 - Web的桌面通知功能]]></title>
      <url>/H5%E7%9A%84Notification%E7%89%B9%E6%80%A7-Web%E7%9A%84%E6%A1%8C%E9%9D%A2%E9%80%9A%E7%9F%A5%E5%8A%9F%E8%83%BD.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="H5的Notification特性-Web的桌面通知功能"><a href="#H5的Notification特性-Web的桌面通知功能" class="headerlink" title="H5的Notification特性 - Web的桌面通知功能"></a>H5的Notification特性 - Web的桌面通知功能</h3><blockquote>
<p>目前，<code>web</code>网页使用桌面通知功能的越来越多，包括微博，腾讯视频等大厂站，桌面通知功能是<code>H5</code>的一个<code>API</code> - <code>Notifications</code>。它允许网页或应用程序可以发出通知，通知将被显示在页面之外的系统层面上（通常使用操作系统的标准通知机制，但是在不同的平台和浏览器上的表现会有差异），这样即使应用程序空闲或在后台也可以向用户发送信息。</p>
</blockquote>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><code>Notifications</code>的诞生简化了网站或者应用与用户之间的沟通成本（时间成本和开发成本），增强用户黏性（减少了用户离开应用的可能）。传统的通知方式，大多是通过站内信（消息），邮件，短信等方式，它们通常需要刷新（跳转）页面、离开应用打开其他应用或终端来查看消息；而桌面通知功能大大的简化了这个过程，消息的传递基本不消耗时间（如果不设置<code>setTimeout</code>，用时基本不会超过<code>1s</code>），并且用户不需要离开应用，这都带来了极大的方便。可以预见，<code>Notifications</code>将会在很多网页或应用中被大量使用。当然<code>Notifications</code>也具有它的局限性：无法存档、即看即毁<br>那么，这个功能到底能用在哪些场景呢？只能说能应用的场景很多：</p>
<ul>
<li><p>社交类网站</p>
</li>
<li><p>资讯类网站</p>
</li>
<li><p>网页版邮件服务</p>
</li>
<li><p>即时通知类网站</p>
</li>
<li><p>…</p>
</li>
</ul>
<p>举个例子，当你打开微博页面，你可能会看到（使用新版浏览器）如下图的通知：<br><img src="https://img.funteas.com/f909b1aa4add36264f20d783d4b23859?imageView2/2/w/800" alt=""></p>
<p>这就是网站使用了桌面通知功能，当你选择允许，那么当网站有推送消息或者你登陆账号有新的消息将会在桌面的右下角出现一个小弹窗通知，如下：<br><img src="https://img.funteas.com/7f39205b4f6be3ef3f66565e8ebaf1c2?imageView2/2/w/800" alt=""></p>
<p>感觉有点酷酷的！！！</p>
<h2 id="用户权限-Notification-permission"><a href="#用户权限-Notification-permission" class="headerlink" title="用户权限 - Notification.permission"></a>用户权限 - Notification.permission</h2><p><code>Notification.permission</code>是一个静态方法，可以获取用户当前的通知权限状态，返回一个<code>String</code>，可以根据返回值判断用户是否授予了通知权限。返回值有三种情况：</p>
<ul>
<li><p>default</p>
</li>
<li><p>granted</p>
</li>
<li><p>表示之前已经询问过用户，并且用户已经授予了显示通知的权限。</p>
</li>
<li><p>denied</p>
</li>
</ul>
<p>当值为<code>default</code>或者<code>denied</code>时都不会显示通知消息，只有明确的被设置成<code>granted</code>才会显示通知消息</p>
<pre><code>const permission = Notification.permission;
if(permission === &#39;granted&#39;){
    console.log(&#39;已经授权通知，可以进行你的通知啦！&#39;);
}else{
    console.log(&#39;用户还未授权，请先授权！&#39;);
}
</code></pre><h2 id="请求权限-Notification-requestPermission-CALLBACK"><a href="#请求权限-Notification-requestPermission-CALLBACK" class="headerlink" title="请求权限 - Notification.requestPermission(CALLBACK)"></a>请求权限 - Notification.requestPermission(CALLBACK)</h2><p>应用发送通知之前必须要取得发送通知的权限，才能成功进行通知。<code>Notification.requestPermission(CALLBACK)</code>是请求获取权限的方法（有点类似<code>javascript</code>的<code>confirm</code>弹窗窗），允许传入一个回调，回调会返回用户选择的何种权限，返回两个值，<code>granted</code>代表允许，<code>denied</code>代表拒绝。并且<code>Notification.requestPermission()</code>支持<code>then</code>方式的链式调用，也就意味着可以异步调用它。</p>
<pre><code>Notification.requestPermission(function (permission) {
    console.log(&#39;用户是否允许通知： &#39;,permission === &#39;granted&#39; ? &#39;允许&#39; : &#39;拒绝&#39;);
});
//两种方式是等价的
Notification.requestPermission().then(function (permission) {
    console.log(&#39;用户是否允许通知： &#39;,permission === &#39;granted&#39; ? &#39;允许&#39; : &#39;拒绝&#39;);
});
</code></pre><h2 id="创建通知-new-Notification-TITLE-OPTIONS"><a href="#创建通知-new-Notification-TITLE-OPTIONS" class="headerlink" title="创建通知 - new Notification(TITLE, OPTIONS)"></a>创建通知 - new Notification(TITLE, OPTIONS)</h2><p><code>new Notification(TITLE, OPTIONS)</code>方法创建可以创建一个通知实例，允许参入参数两个参数<code>TITLE</code>和<code>OPTIONS</code>。注意默认情况下（实际可以通过<code>OPTIONS</code>中的<code>timestamp</code>参数控制）一旦通知实例被创建出来，它会立即被显示出来。</p>
<h3 id="TITLE参数"><a href="#TITLE参数" class="headerlink" title="TITLE参数"></a>TITLE参数</h3><p><code>TITLE</code>表示通知的标题。必须参数，允许数字、字符串和空</p>
<h3 id="OPTIONS参数"><a href="#OPTIONS参数" class="headerlink" title="OPTIONS参数"></a>OPTIONS参数</h3><p><code>OPTIONS</code>是非必须参数，必须为一个对象，它包含：<br>ps: 部分参数在某些浏览器可能会不生效，建议使用最新版的谷歌浏览器。以下某些内容从<a href="http://link.funteas.com/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2Fnotification" target="_blank" rel="external">Notification-MDN-EN</a> 结合谷歌翻译得来，很有可能翻译不准确，如有，请提出。</p>
<pre><code>{
    //通知显示正文。非必须，默认为空
    body: &#39;你的好友XX上线了！&#39;,
    //通知显示正文的图片地址。非必须，默认为空
    image: &#39;imgae url&#39;,
    //通知左侧图标。非必须，默认为空
    icon: &#39;imgae url&#39;,
    //通知的分类标记（ID）。非必须，默认为空
    tag: &#39;test&#39;,
    //通知相关联的数据，通常用于方法的回调，传参。非必须，默认为空
    data: &#39;可以是任意数据类型&#39;,
    //通知显示延迟的时间。非必须，默认通知实例创建完成就显示
    timestamp: &#39;&#39;,
    //通知主体内容的水平展示顺序，有点类似direction属性。非必须，默认值是auto, 可以是ltr或rtl
    dir: &#39;auto&#39;,
    //当没有足够的空间来显示通知本身时，用于表示通知的图像的URL。非必须，默认为空
    badge: &#39;xxx&#39;,
    //通知的语言。非必须默认为空
    lang: &#39;&#39;,
    //通知显示时，设备的振动模式。非必须，默认为空
    vibrate: [200, 100, 200],
    //新通知出现是否覆盖旧的通知，覆盖（true）则永远只显示一条通知，不覆盖（false）则会多条通知重叠。非必须，默认为true
    renotify: true,
    //通知是否静音。非必须，默认为false，表示无声
    silent: false,
    //通知声源文件地址。非必须，默认为空
    sound: &#39;mp3&#39;,
    //是否不在屏幕上显示通知信息。非必须，默认为false表示要显示
    noscreen: false,
    //指定通知是否应该粘滞性，即不容易被用户清理。非必须，默认false表示不具粘滞性
    sticky: false,
    //指定通知是否保持活性，知道用户点击或关闭。非必须，默认为false
    requireInteraction: false
}
</code></pre><h3 id="事件及事件钩子"><a href="#事件及事件钩子" class="headerlink" title="事件及事件钩子"></a>事件及事件钩子</h3><p>当通知被创建成功后：</p>
<ul>
<li><p>通知实例具有一个静态方法可以用来关闭通知</p>
</li>
<li><p>通知实例具有四个事件钩子，来跟踪通知当前的状态。这些事件可以通过事件处理跟踪<code>onshow</code>、<code>onclick</code>、<code>onclose</code>和<code>onerror</code>。因为<code>Notification</code>同样继承自<code>EventTarget</code>，因此可以对它调用<code>addEventListener()</code>方法。</p>
</li>
</ul>
<pre><code>const n = new Notification(&#39;XX网站消息通知&#39;, {
    body: &#39;你的朋友有新状态啦，快去围观吧！&#39;,
    tag: &#39;2ue&#39;,
    icon: &#39;https://2ue.github.io/images/common/avatar.png&#39;,
    data: {
        url: &#39;https://2ue.github.io&#39;
    },
    timestamp: 3000
});

n.onshow = function () {
    console.log(&#39;通知显示了！&#39;);
}
n.onclick = function (e) {
    //可以直接通过实例的方式获取data内自定义的数据
    //也可以通过访问回调参数e来获取data的数据
    window.open(n.data.url, &#39;_blank&#39;);
    n.close();
}
n.onclose = function () {
    console.log(&#39;你墙壁了我！！！&#39;);
}
n.onerror = function (err) {
    console.log(&#39;出错了，小伙子在检查一下吧&#39;);
    throw err;
}
</code></pre><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>写一个简单的例子，可以打开页面体验一下，建议用最新版谷歌浏览器打开~ <a href="http://link.funteas.com/?target=https%3A%2F%2Fcodepen.io%2F2ue%2Fpen%2FrYYzwB" target="_blank" rel="external">Notification.js</a> </p>
<pre><code>const NotificationInstance = Notification || window.Notification;
if (!!NotificationInstance) {
    const permissionNow = NotificationInstance.permission;
    if (permissionNow === &#39;granted&#39;) {//允许通知
        CreatNotification();
    } else if (permissionNow === &#39;denied&#39;) {
        console.log(&#39;用户拒绝了你!!!&#39;);
    } else {
        setPermission();
    }
    function setPermission() {
        //请求获取通知权限
        NotificationInstance.requestPermission(function (PERMISSION) {
            if (PERMISSION === &#39;granted&#39;) {
                CreatNotification();
            } else {
                console.log(&#39;用户无情残忍的拒绝了你!!!&#39;);
            }
        });
    }
    function CreatNotification() {
        const n = new NotificationInstance(&#39;XX网站消息通知&#39;, {
            body: &#39;你的朋友有新状态啦，快去围观吧！&#39;,
            tag: &#39;2ue&#39;,
            icon: &#39;https://2ue.github.io/images/common/avatar.png&#39;,
            data: {
                url: &#39;https://2ue.github.io&#39;
            }
        });
        n.onshow = function () {
            console.log(&#39;通知显示了！&#39;);
        }
        n.onclick = function (e) {
            //可以直接通过实例的方式获取data内自定义的数据
            //也可以通过访问回调参数e来获取data的数据
            window.open(n.data.url, &#39;_blank&#39;);
            n.close();
        }
        n.onclose = function () {
            console.log(&#39;你墙壁了我！！！&#39;);
        }
        n.onerror = function (err) {
            console.log(&#39;出错了，小伙子在检查一下吧&#39;);
            throw err;
        }
        setTimeout(() =&gt; {
            n.close();
        }, 2000);
    }
}
</code></pre><h2 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h2><p><code>Notifications</code>是<code>H5</code>的新特性，毫无疑问，它的兼容肯定是一篇哀嚎.<br><img src="https://img.funteas.com/340c2c889621a28bd304618c7a309c1a?imageView2/2/w/800" alt=""><img src="https://img.funteas.com/d8a80df35e73a7aaa99fcbf944fcbd40?imageView2/2/w/800" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> html </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> html </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jsonp的原理介绍及Promise封装]]></title>
      <url>/jsonp%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E5%8F%8APromise%E5%B0%81%E8%A3%85.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么叫jsonp"><a href="#什么叫jsonp" class="headerlink" title="什么叫jsonp?"></a>什么叫jsonp?</h3><p>jsonp是json with padding（填充式json或参数式json）的简写，是通过ajax请求跨域接口，获取数据的新实现方式</p>
<h2 id="jsonp的实现原理："><a href="#jsonp的实现原理：" class="headerlink" title="jsonp的实现原理："></a>jsonp的实现原理：</h2><p>动态创建script标签，因为script标签是没有同源策略限制，可以跨域的。 把script标签的src指向正式服务端地址，这个地址跟个参数callback=xxx, 服务端在返回数据时，在xxx里包裹一个方法（里面是返回的数据），相当于在前端执行xxx这个方法，但是浏览器并没有这个方法，所以在发送请求之前在window注册这个方法，<a href="http://link.funteas.com/?target=http%3A%2F%2Fxn--window-og8iw9wvwlnru0xhb8r207bolbe65a675cixmror.xxx" target="_blank" rel="external">这样的话相当于在前端执行window.xxx</a> ()这个方法去获取数据。 具体看接下来的实现！</p>
<p><a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fwebmodules%2Fjsonp" target="_blank" rel="external">https://github.com/webmodules…</a><br>这个是jsonp库的具体实现，建议下载来研究一下，最好自己动手写一遍。本文主要是Promise封装，所以就不具体介绍jsonp的具体实现</p>
<h2 id="步骤一："><a href="#步骤一：" class="headerlink" title="步骤一："></a>步骤一：</h2><p>首先安装这个库，因为我是在node npm环境下开发，所以</p>
<pre><code>$ npm install jsonp
</code></pre><p><strong>参数介绍</strong><br>jsonp(url, opts, fn)<br>url (String) 服务器端数据接口地址<br>opts (Object) 一般只需关注param即可</p>
<ul>
<li><p>param (String) 默认是callback,这是与后端约定的参数名称，也可以随便定义，只要前后端统一</p>
</li>
<li><p>timeout (Number) 请求超时时间，默认是6000ms</p>
</li>
<li><p>prefix (String) callback值的前缀，默认是__jp</p>
</li>
<li><p>name (String) 指定全局注册的回调方法名，一般不会用到，因为默认是prefix+自增数字</p>
</li>
</ul>
<p>fn 回调方法，用es6 Promise</p>
<h2 id="步骤二："><a href="#步骤二：" class="headerlink" title="步骤二："></a>步骤二：</h2><p><strong>下面是具体用法：</strong><br>建一个名叫jsonp.js的文件<br>先引入jsonp库文件</p>
<pre><code>import originJSONP from&#39;jsonp&#39;
</code></pre><p>对外暴露方法 url:请求服务器地址，data:参数</p>
<pre><code>export default function jsonp(url,data,option) {
    url += (url.indexOf(&#39;?&#39;)&lt;0?&#39;?&#39;:&#39;&amp;&#39;)+param(data)
    return new Promise(function(resolve,reject) {
        originJSONP(url,option, function(err,data) {
            if(!err){
                resolve(data)
            }else{
                reject(err)
            }
        })
    })
}
</code></pre><p>定义一个将Object的参数处理成为 url挂载参数的形式 的函数</p>
<pre><code>export function param(data) {
  let url = &#39;&#39;
  for (var k in data) {
    let value = data[k] !== undefined ? data[k] : &#39;&#39;
    url += &#39;&amp;&#39; + k + &#39;=&#39; + encodeURIComponent(value)
  }
  return url ? url.substring(1) : &#39;&#39;
}
</code></pre><p>到这里 这个Promise 就封装好了，接下来就具体调用来获取数据</p>
<h2 id="步骤三："><a href="#步骤三：" class="headerlink" title="步骤三："></a>步骤三：</h2><p>建一个js文件，名字自己定义<br>引入前面封装的jsonp.js</p>
<pre><code>import jsonp from&#39;../common/js/jsonp.js&#39;
</code></pre><p>定义参数</p>
<pre><code>const commonParams = {
    g_tk:1319877694,
    inCharset:&#39;utf-8&#39;,
    outCharset:&#39;utf-8&#39;,
    notice:0,
    format:&#39;jsonp&#39;
};
</code></pre><p>定义前后端统一参数</p>
<pre><code>const options = {
    param:&#39;jsonpCallback&#39;
};
</code></pre><p>定义获取数据函数 这里我是拿QQ音乐的数据<a href="http://link.funteas.com/?target=https%3A%2F%2Fm.y.qq.com%2F" target="_blank" rel="external">https://m.y.qq.com/</a> （感谢QQ音乐的接口支持）</p>
<pre><code>export function getDataFunc() { 
    const url = &#39;https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg&#39;
    const data = Object.assign({},commonParams,{
        platform:&#39;h5&#39;,
        uin:0,
        needNewCode:1,
    })
    return jsonp(url,data,options)
}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>到此，咱们就完成用jsonp库进行Promise封装，并获取数据的过程！ 感谢阅读！</p>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> es6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[undefined与null的区别]]></title>
      <url>/undefined%E4%B8%8Enull%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>undefined与null看起来用法都是一样的，但是还有一些本质的区别。</p>
<h2 id="undefined与null的区别"><a href="#undefined与null的区别" class="headerlink" title="undefined与null的区别"></a>undefined与null的区别</h2><ul>
<li><code>undefined</code>表示一个变量没有被声明，或者被声明了但没有被赋值</li>
<li><code>null</code>是一个表示“没有值”的值</li>
<li>Javascript将未赋值的变量默认值设为<code>undefined</code></li>
<li>Javascript从来不会将变量设为<code>null</code>。它是用来让程序员表明某个用<code>var</code>声明的变量时没有值的。</li>
<li><code>undefined</code>不是一个有效的JSON，而<code>null</code>是</li>
<li><code>undefined</code>的类型(typeof)是<code>undefined</code></li>
<li><code>null</code>的类型(typeof)是<code>object</code>. <a href="http://link.funteas.com/?target=http%3A%2F%2Fwww.2ality.com%2F2013%2F10%2Ftypeof-null.html" target="_blank" rel="external">为什么?</a> </li>
<li>它们都是基本类型</li>
<li>他们都是<a href="http://link.funteas.com/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2FFalsy" target="_blank" rel="external">falsy</a><br>(<code>Boolean(undefined) // false</code>, <code>Boolean(null) // false</code>)</li>
<li>你可以这样判断一个变量是否是<a href="http://link.funteas.com/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2Fundefined" target="_blank" rel="external">undefined</a> </li>
</ul>
<pre><code>typeof variable ===&quot;undefined&quot;
</code></pre><ul>
<li>你可以这样判断一个变量是否是<a href="http://link.funteas.com/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2Fnull" target="_blank" rel="external">null</a> </li>
</ul>
<pre><code>  variable ===null
</code></pre><ul>
<li><strong>双等号</strong>比较时它们相等，但<strong>三等号</strong>比较时不相等</li>
</ul>
<pre><code>null==undefined// truenull===undefined// false
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>undefined和null的区别在平常的面试和开发过程中算是比较常见的语法知识。希望大家能够记得这些知识。，</p>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[入门 node.js 你必须知道的那些事]]></title>
      <url>/%E5%85%A5%E9%97%A8-node-js-%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="最基本的一些操作和概念"><a href="#最基本的一些操作和概念" class="headerlink" title="最基本的一些操作和概念"></a>最基本的一些操作和概念</h2><h3 id="用-node-执行一段-js-代码"><a href="#用-node-执行一段-js-代码" class="headerlink" title="用 node 执行一段 js 代码"></a>用 node 执行一段 js 代码</h3><ol>
<li><p>在命令行中用 cd 切换到桌面</p>
</li>
<li><p>创建一个文件夹和并用 cd 命令切换到这个文件夹mkdir nodeTest &amp;&amp; cd nodeTest</p>
</li>
<li><p>创建一个 js 文件并写上简单的 js 代码 touch a.js</p>
</li>
</ol>
<pre><code>    var a = 10;
    console.log(a);
    console.log(a + 10);
</code></pre><ol>
<li>在命令行中输入 node a.js 命令行会输出 10 20</li>
</ol>
<h3 id="node-引用文件的方式"><a href="#node-引用文件的方式" class="headerlink" title="node 引用文件的方式"></a>node 引用文件的方式</h3><ol>
<li><p>Node.js 采用了 CommonJS 规范, 通过 require 来引入一个 js 文件</p>
</li>
<li><p>新建文件 b.js 并在文件中引入 a.js</p>
</li>
</ol>
<ul>
<li><p>touch b.js</p>
</li>
<li><p>require(‘./a.js’)</p>
</li>
</ul>
<ol>
<li>执行 b.js</li>
</ol>
<ul>
<li>node b.js 命令行会输出 10 20</li>
</ul>
<h3 id="node-中的模块概念"><a href="#node-中的模块概念" class="headerlink" title="node 中的模块概念"></a>node 中的模块概念</h3><ol>
<li><p>node 中一个模块就是一个 js 文件，多个模块组成一个特定功能的一堆文件叫包</p>
</li>
<li><p>一个 js 文件可以定义它自己暴露给外部的变量 (意思就是另一个文件通过 require 引用它后需要怎么使用它),node 中提供共了 exports 和 module.exports 两个变量来实现它</p>
</li>
</ol>
<p>a.js</p>
<pre><code>function func1() {
   console.log(&#39;aaa&#39;)
}
function func2() {
   console.log(&#39;bbb&#39;)
}
exports.a = func1
exports.b = func2
</code></pre><p>b.js</p>
<pre><code>var a = require(&#39;./a.js&#39;)
a.func1() //会打印出aaa
a.func2() //会打印出bbb
</code></pre><p>c.js</p>
<pre><code>//es6 模式匹配写法
var {fun1,fun2} = require(&#39;./a.js&#39;)//fun1和fun2必须跟a.js中的变量名相同，这里是固定的
fun1() //会打印出aaa
fun2() //会打印出bbb
</code></pre><p>a.js</p>
<pre><code>//类的写法
function Test() {
   this.func1 = function() {
       console.log(&#39;aaa&#39;)
   }
   this.func2 = function() {
       console.log(&#39;bbb&#39;)
   }
}
module.exports = Hello
</code></pre><p>b.js</p>
<pre><code>var Test = require(&#39;./a.js&#39;)
var test = new Test()
test.func1()
test.func2()
</code></pre><ol>
<li>exports 和 module.exports 的关系</li>
</ol>
<p>exports 是 module.exports 的一个引用，意思就是指向同一块内存地址，node 中真正生效的是 module.exports, 修改 exports 本质上也是修改 module.exports 的值，</p>
<p>比如 exports.a = 3，实际上 module.exports.a 也是等于 3 的</p>
<p>又比如 exports = {}，这样 exports 就和 module.exports 的指向的对象就不一样了，后面再怎么修改 exports 也不会影响到 module.exports 的值，也不会影响到文件输出的变量</p>
<p>再比如 module.exports={}，这样造成的效果和上面 exports={} 的效果是一样的</p>
<p>建议：如果你还傻傻分不清楚它们的区别，以后在不是必须用到 module.exports 的时候只用 exports, 如果导出一个类这样的必须用到 module.exports 就不要使用 exports 了, 不要混在一起用就不会出错了</p>
<ol>
<li>node 中的 npm</li>
</ol>
<p>node 中默认自带了 npm，npm 是一个包管理器，上面说到包就是一个个模块 (js 文件) 组成的一个具有特定功能的一堆 js 文件，通过 npm 我们可以引入这些包 (如果不理解，把包理解成一个个插件也没有错) 来轻松实现一些功能</p>
<p>安装一个模块你只需要 npm install xxx 就可以安装了，然后在你自己的 js 中用 var xxx = require(‘./xxx’) 就可以使用了</p>
<p>通过 npm install xxx 安装完 xxx 模块后，你会发现当前目录下多了一个 node<em>modules 文件夹，打开 node</em>modules 文件夹你会发现里面有一个 xxx 文件夹。你在执行 npm install xxx 的时候，实际上 npm 也只是帮你把 xxx 这个包下载下来了而已，仅此而已</p>
<p>当你通过 npm 安装了十来个或者更多的包的时候你可能自己早就不知道自己安装了哪些包了，因为很多包依赖了其它的包 (一个包用到另一个包提供的功能是非常正常的行为，就像我们在用别人包里的功能一样), 所以 npm 提供了 package.json 这个文件来管理包</p>
<p>package.json 是一个文件，里面可以定义很多键值对，其中有几个字段非常重要，dependencies 表示上线运行时依赖的包，devDependencies 表示开发时依赖的包，scripts 可以定义自己的脚本，main 表示所有的包你都会通过这个文件引入</p>
<p>当你在 dependencies 和 devDependencies 定义好依赖，然后在命令行中输入 npm install，npm 就会帮你自动安装好这些包；反过来你在命令行中输入 npm install xxx –save 后 npm 就会在 package.json 中的 dependencies 自动加上 xxx，如果执行的是 npm install xxx –save-dev 就会在 devDependencies 中自动加上 xxx。</p>
<p>而在 scripts 中定义的脚本就直接可以在命令行中运行了，如果还弄不懂，可以看一下我的另一篇文章，如何制作自己的 npm 包</p>
<h2 id="node-js-中自带的那些模块"><a href="#node-js-中自带的那些模块" class="headerlink" title="node.js 中自带的那些模块"></a>node.js 中自带的那些模块</h2><h3 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h3><p>使用别人的模块，其实就是使用别人写好的方法 (函数)，只需要搞清楚别人提供的方法是怎么用的就可以了，可以查 node.js 官网查 api 或者看看网上写的教程就好。</p>
<p>下面演示了一个最简单的 http 模块的使用方法，在当前目录下在命令行中输入 node test.js，http 会挂起一个监听，只需要在浏览器中输入 <a href="http://localhost:8000，test.js" target="_blank" rel="external">http://localhost:8000，test.js</a> 就会跟浏览器返回 <code>&lt;div&gt;hello world&lt;/div&gt;</code>显示在页面上：</p>
<pre><code>test.js
var http = require(&#39;http&#39;)
var callBack = function(req, res) {
    res.write(&#39;&lt;div&gt;hello world&lt;/div&gt;&#39;)
    res.end()
}
http.createServer(callBack).listen(8000)
</code></pre><h3 id="url-模块"><a href="#url-模块" class="headerlink" title="url 模块"></a>url 模块</h3><p>在 http 模块的例子中传入了一个回调函数，两个参数分别是 request 和 response，前者是浏览器传给我们的对象，后者是我们传给浏览器的对象。</p>
<p>其中 req 中包含了 url 这个属性，可以在回调函数中把它打印出来 <code>console.log(req.url)</code>, 加入你在浏览器中输入的是：<a href="http://localhost:8000/aaa/bbb?abc=3，那么打印出来的值是：/aaa/bbb?abc=3" target="_blank" rel="external">http://localhost:8000/aaa/bbb?abc=3，那么打印出来的值是：/aaa/bbb?abc=3</a></p>
<p>在这里我们需要使用到的是 / aaa/bbb 和 abc=3 分开来的结果，node 给我们提供了一个处理 url 的模块，就叫做 url 模块. 当然如果你自己想处理这个 url 也是完全可以的，用正则表达式就可以，但是已经有现成的为啥不用呢</p>
<p>下面简单演示一下用法，在浏览器输入：<a href="http://localhost:8000/aaa/bbb?abc=3" target="_blank" rel="external">http://localhost:8000/aaa/bbb?abc=3</a></p>
<pre><code>test.js
var http = require(&#39;http&#39;)
var url = require(&#39;url&#39;)
var callBack = function(req, res) {
    var urlString = url.parse(req.url)
    var path = urlString.pathname
    var query = urlString.query
    console.log(path,query)//打印出/aaa/bbb abc=3
   res.write(&#39;&lt;div&gt;hello world&lt;/div&gt;&#39;)
   res.end()
}
http.createServer(callBack).listen(8000)
</code></pre><h3 id="fs-模块"><a href="#fs-模块" class="headerlink" title="fs 模块"></a>fs 模块</h3><p>fs 是一个提供文件操作功能的模块，可以对文件进行读写存删等操作，下面演示向浏览器返回本 js 的内容：</p>
<pre><code>test.js
var http = require(&#39;http&#39;)
var fs = require(&#39;fs&#39;)
var callBack = function(req, res) {
    fs.readFile(&#39;./test.js&#39;, &#39;utf-8&#39;, function(err, data) {
        res.write(data)
        res.end()
    })
}
http.createServer(callBack).listen(8000)
</code></pre><h2 id="用-http-模块、url-模块、http-模块搭建一个静态服务器"><a href="#用-http-模块、url-模块、http-模块搭建一个静态服务器" class="headerlink" title="用 http 模块、url 模块、http 模块搭建一个静态服务器"></a>用 http 模块、url 模块、http 模块搭建一个静态服务器</h2><pre><code>var http = require(&#39;http&#39;)
var url = require(&#39;url&#39;)
var fs = require(&#39;fs&#39;)
var callBack = function(req, res) {
var pathname = url.parse(req.url).pathname
if (pathname == &#39;/&#39;) {
    pathname = &#39;/index.html&#39;
}
fs.readFile(&#39;.&#39; + pathname, &#39;utf-8&#39;, function(err, data) {
        if (err) {
            res.write(&#39;Error 404&#39;)
        } else {
            res.write(data)
        }
        res.end()
    }
)}
http.createServer(callBack).listen(8000)
</code></pre><h2 id="使用外部模块"><a href="#使用外部模块" class="headerlink" title="使用外部模块"></a>使用外部模块</h2><h3 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h3><p>外部模块都是第三方提供的模块，node.js 默认是不提供的，所以需要用 npm 安装，这里提供 package.json 文件，只需要执行 npm install 安装就行了，另外是管理 MongoDB 数据库的一个包，所以本地需要把 MongoDB 单独安装一下。</p>
<pre><code>package.json
{
  &quot;dependencies&quot;: {
    &quot;cheerio&quot;: &quot;^1.0.0-rc.2&quot;,
    &quot;eventproxy&quot;: &quot;^1.0.0&quot;,
    &quot;express&quot;: &quot;^4.16.2&quot;,
    &quot;koa&quot;: &quot;^2.4.1&quot;,&lt;!--koa是用来替代express的框架--&gt;
    &quot;superagent&quot;: &quot;^3.8.1&quot;
  }
}
</code></pre><h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><p>express 提供了基本的路由和静态文件访问的功能，当然还有其它的功能，这里主要演示它的基本使用 下面 1,2,3 都是设置 public 和 files 目录下为静态文件，可以直接通过文件路径访问，1、2 可以同时存在，即可以指定几个目录均为静态文件目录，在指定目录为静态文件后，访问静态文件需要省略这个目录，比如访问 public 目录下的 css/index.css：localhost:8000/css/index.css, 直接省略了 public， 可以通过 3 来指定替换目录名称的路径，通过 3 设置后，要访问 public 下的 css/index.css：localhost:8000/public/css/index.css</p>
<pre><code>var express = require(&#39;express&#39;)
var app = express()
1\. app.use(express.static(&#39;public&#39;))
2\. app.use(express.static(&#39;files&#39;))
3\. app.use(&#39;/static&#39;,express.static(public))
app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;Hello World&#39;);//一个回调方法对应一个路径
})
app.get(&#39;/user&#39;, function (req, res) {
  res.send(&#39;user&#39;);
})
app.listen(8000, function () {
  console.log(&#39;app is listening at port 3000&#39;);
})
</code></pre><h3 id="superagent、cheerio-模块"><a href="#superagent、cheerio-模块" class="headerlink" title="superagent、cheerio 模块"></a>superagent、cheerio 模块</h3><p>superagent 是一个可以发 http 请求的模块，回调函数中的 res 就是请求到的内容</p>
<p>cheerio 是在服务器端类式 jquery 的框架，看代码应该能看出来</p>
<p>下面演示的是抓取糯米网的餐品列表链接</p>
<pre><code>var superagent = require(&#39;superagent&#39;)
var cheerio = require(&#39;cheerio&#39;)
var spideUrl = &#39;https://t10.nuomi.com/pc/t10/index&#39;
superagent.get(spideUrl)
    .end(function(err, res) {
        if (err) {
            return console.error(err);
        }
        var foodUrls = [];
        var $ = cheerio.load(res.text)
        // 获取首页所有的链接
        $(&#39;.j-item a&#39;).each(function(idx, element) {
            var $element = $(element)
            foodUrls.push($element.attr(&#39;href&#39;))
        })
        console.log(topicUrls)
    })
</code></pre><h3 id="eventproxy"><a href="#eventproxy" class="headerlink" title="eventproxy"></a>eventproxy</h3><p>在爬取一堆类式的链接的时候，一个个链接写挺麻烦的，eventproxy 提供了监听，然后触发回调的方式来处理这类问题，下面是我拷贝的一段代码，应该挺容易看懂的</p>
<pre><code>//得到一个 eventproxy 的实例
var ep = new eventproxy() 
// 命令 ep 重复监听 urls.length 次（在这里也就是 10 次） 
ep.after(&#39;topic_html&#39;, urls.length, function (topics) {
  topics = topics.map(function(page) {
    var $ = cheerio.load(page)
    var userId = $(&#39;.runUserName a font&#39;).eq(0).text()
    return userId
  });
  console.log(topics);
})
urls.forEach(function(item) {
  superagent.get(item)
    .end(function (err, res) {
      ep.emit(&#39;topic_html&#39;, res.text)
    })
})
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>大部分学习前端其实是没必要深入学习 node.js 的，一方面没那个精力，然后也没那么必要，但是一些基本的东西还是有必要好好学学的</p>
<p>大多数前端同学之所以觉得应该学前端，其实是平时接触到的 npm、require 模块、es6 的语法等问题觉得比较棘手，以为是自己不懂 node.js，其实这些和 node.js 并无太大关系，这些已经影响到学习前端其它内容的地方还是需要好好学习的</p>
<p>学习 node.js 基本的东西还是有必要的，比如搭建个简单的服务器，做点基本的逻辑处理和数据处理，做个爬虫啥的。而这些都很简单，看两篇博客做几个练习就够了，再深入就根据实际情况学习就好了。</p>
]]></content>
      
        <categories>
            
            <category> nodejs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> nodejs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[10个React小模式]]></title>
      <url>/10%E4%B8%AAReact%E5%B0%8F%E6%A8%A1%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><del>在过去的几年，我经手过很多大大小小的React项目，在这个过程中，我不断的重复重复，逐渐的形成了一些模式，在这里分享给大家。</del></p>
<p>如果你是刚开始接触React，能看到这篇文章，只能说你很幸运 ：）。</p>
<p>如果你没有接触过React，你可以跳过（3，6，8，10）节。</p>
<h2 id="10个React小模式"><a href="#10个React小模式" class="headerlink" title="10个React小模式"></a>10个React小模式</h2><h3 id="1-数据向下和向上传递"><a href="#1-数据向下和向上传递" class="headerlink" title="1 数据向下和向上传递"></a>1 数据向下和向上传递</h3><p>对于刚接触React新手，我通常都会告诉他们数据的传递模式，也就是父组件向子组件传递数据（比如一个对象，一个字符串等等），也可以是一个方法，使得父组件可以得到子组件的数据。</p>
<p>就像把一包薯片和一个对讲机传递到被困井下的矿工手上。</p>
<p>下图是最简单的模式</p>
<p><img src="https://img.funteas.com/ba8c793625abf7e86b2c6b15afa4544b.png?imageView2/2/w/800" alt=""> （此图胜过千言万语）</p>
<p>父组件在左边，子组件在右边。连接两个组件的props允许信息在两个方向任意流动。</p>
<p>一个 props 是<code>items</code>，传递信息到子组件。 一个 props 是<code>deleteitem</code>，给子组件一个方法来告诉父组件（“ 删除这个item ”）。</p>
<h3 id="2-修复HTML的input标签"><a href="#2-修复HTML的input标签" class="headerlink" title="2 修复HTML的input标签"></a>2 修复HTML的input标签</h3><p>关于React组件化的一个重要方面就是，如果HTML中的标签不能按照你想要的方式工作，你可以按照你的方式定义它。</p>
<p>当我创建一个页面，页面有很多用户输入框，第一步先处理这些标签。</p>
<p><img src="https://img.funteas.com/04d8fda42368628d19df33668bb8f32b.png?imageView2/2/w/800" alt=""></p>
<p>还需要注意:</p>
<ul>
<li><p>输入框应该通过<code>onChange</code>方法返回输入值。</p>
</li>
<li><p>确保输入值的类型与<code>onChange</code>返回值的类型相同，如果<code>typeof props.value</code>的类型是<code>number</code>，那么就需要将<code>e.target.value</code>的类型转换成<code>number</code>。</p>
</li>
<li><p>一组单选按钮的功能和<code>&lt;Select&gt;</code>一样，只是UI不同。可以在你的应用中统一成一个组件（比如<code>&lt;PickOneFromMany /&gt;</code>），然后通过传递<code>ui=&quot;radio&quot;</code> 或者 <code>ui=&quot;dropDown&quot;</code>来区分。</p>
</li>
</ul>
<h3 id="3-为input绑定唯一的ID"><a href="#3-为input绑定唯一的ID" class="headerlink" title="3 为input绑定唯一的ID"></a>3 为input绑定唯一的ID</h3><p>我们会为input绑定唯一的ID，但是为每一个input定义一个唯一的ID很费事。</p>
<p>你可以为每一对input/label标签生成一个随机ID，但是客户端和服务器端渲染的HTML无法匹配。</p>
<p>所以，你可以写一个方法自增生成ID，如下：</p>
<pre><code>class  Input  extends  React.Component {

    constructor(props) {

        super(props);

        this.id  =  getNextId();

        this.onChange  =  this.onChange.bind(this);

    }

    onChange(e) {

        this.props.onChange(e.target.value);

    }

    render() {

        return (

            &lt;label htmlFor={this.id}&gt;

            {this.props.label}

            &lt;input

            id={this.id}

            value={this.props.value}

            onChange={this.onChange}

            /&gt;

            &lt;/label&gt;

        );

    }

}
</code></pre><p>如果每次调用<code>getNextId()</code>时，仅仅是一个数字自增，那么在服务器端渲染，这个数字将会无限大。所以在每次网络请求的时候需要重置这个数字。代码如下：</p>
<pre><code>let count = 1;

export const resetId = () =&gt; {

    count = 1;

 }

 export const getNextId = () =&gt; {

     return `element-id-${count++}`;

}
</code></pre><h3 id="4-用props控制CSS"><a href="#4-用props控制CSS" class="headerlink" title="4 用props控制CSS"></a>4 用props控制CSS</h3><p>如果你想把不同CSS应用在不同的实例中（比如：普通按钮和高亮按钮），你可以传props来控制CSS。</p>
<p>表面看起来超级简单，但我保证有很多坑等你跳的。</p>
<p>个人觉得有三种实现的方法：</p>
<h4 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h4><p>把许多CSS打包放到一起，然后使用属性<code>themes</code>来控制。比如：</p>
<p><code>&lt;Button theme=&quot;secondary&quot;&gt;Hello&lt;/Button&gt;</code></p>
<h4 id="设置boolean属性"><a href="#设置boolean属性" class="headerlink" title="设置boolean属性"></a>设置boolean属性</h4><p>比如一些特殊的按钮需要倒角，但与你定义的主题不一致。</p>
<p>要么你去找UI，让它设计时保持一致，要么你就设置一个值为boolean的属性来区分：</p>
<p><code>&lt;Button theme=&quot;secondary&quot; rounded&gt;Hello&lt;/Button&gt;</code></p>
<p>类似HTML的二进制属性，所以你不需要写成<code>rounded = [true]</code>。</p>
<h4 id="设置属性值"><a href="#设置属性值" class="headerlink" title="设置属性值"></a>设置属性值</h4><p>在某些情况下，您可能希望直接传递CSS属性的值（在组件中，将其设置为内联样式）：</p>
<p><code>&lt;Icon width=&quot;25&quot; height=&quot;25&quot; type=&quot;search&quot; /&gt;</code></p>
<h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>假设你正在创建一个链接组件，有三种主题，是否添加下划线是可选的。</p>
<p><img src="https://img.funteas.com/308756e69607e168e9595e50518b1f03.png?imageView2/2/w/800" alt=""></p>
<p>代码如下：</p>
<pre><code>const Link = (props) =&gt; {

    let className = `link link--${props.theme}-theme`;

    if (!props.underline) className += &#39; link--no-underline&#39;;

    return &lt;a  href={props.href}  className={className}&gt;{props.children}&lt;/a&gt;;

};

Link.propTypes = {

    theme: PropTypes.oneOf([

        &#39;default&#39;, // primary color, no underline

        &#39;blend&#39;, // inherit surrounding styles

        &#39;primary-button&#39;, // primary color, solid block

    ]),

    underline: PropTypes.bool,

    href: PropTypes.string.isRequired,

    children: PropTypes.oneOfType([

        PropTypes.element,

        PropTypes.array,

        PropTypes.string,

    ]).isRequired,

};

Link.defaultProps = {

    theme: &#39;default&#39;,

    underline: false,

};
</code></pre><p>CSS:</p>
<pre><code>.link--default-theme,

.link--blend-theme:hover {

    color: #D84315;

}

.link--blend-theme {

    color: inherit;

}

.link--default-theme:hover,

.link--blend-theme:hover {

    text-decoration: underline;

}

.link--primary-button-theme {

    display: inline-block;

    padding: 12px 25px;

    font-size: 18px;

    background: #D84315;

    color: white;

}

.link--no-underline {

    text-decoration: none;

}
</code></pre><h3 id="5-动态组件"><a href="#5-动态组件" class="headerlink" title="5 动态组件"></a>5 动态组件</h3><p>动态组件可以渲染任何一个组件。 它可以是一个动态的页面组件，来展示一堆页面中的某一个页面，比如:</p>
<pre><code>import  HomePage  from  &#39;./HomePage.jsx&#39;;

import  AboutPage  from  &#39;./AboutPage.jsx&#39;;

import  UserPage  from  &#39;./UserPage.jsx&#39;;

import  FourOhFourPage  from  &#39;./FourOhFourPage.jsx&#39;;

const PAGES = {

    home: HomePage,

    about: AboutPage,

    user: UserPage,

};

const Page = (props) =&gt; {

    const Handler = PAGES[props.page] || FourOhFourPage;

    return  &lt;Handler {...props} /&gt;

};

Page.propTypes  = {

    page:  PropTypes.oneOf(Object.keys(PAGES)).isRequired,

};
</code></pre><p>如果你把<code>home</code>，<code>about</code> 和 <code>user</code> 换成<code>/</code>，<code>/about</code> 和 <code>/user</code>，恭喜你，你已经把它变成了半个路由器了。</p>
<h3 id="6-优化组件"><a href="#6-优化组件" class="headerlink" title="6 优化组件"></a>6 优化组件</h3><p>当打开一个页面，input输入框自动获取光标，这会大大提升用户体验。</p>
<p>比如打开一个注册页面，光标自动获取到用户名输入栏。</p>
<p>有人在写这个组件的时候会想到，为input绑定一个id，然后通过<code>document.getElementById(&#39;user-name-input&#39;).focus()</code>来实现。</p>
<p>但我认为这并不是一个很好的方式，我有一个更好的实现方式:</p>
<pre><code>class Input extends Component {

    focus() {

        this.el.focus();

    }

    render() {

        return (

            &lt;input

                ref={el=&gt; { this.el = el; }}

            /&gt;

        );

    }

}
</code></pre><p>ok，一个拥有<code>focus()</code>方法的<code>Input</code>组件完成了。</p>
<p>在父亲组件中，我们可以调到子组件的<code>focus()</code> 方法：</p>
<pre><code>class SignInModal extends Component {

componentDidMount() {

    this.InputComponent.focus();

}

render() {

    return (

        &lt;div&gt;

            &lt;label&gt;User name: &lt;/label&gt;

            &lt;Input

                ref={comp =&gt; { this.InputComponent = comp; }}

            /&gt;

        &lt;/div&gt;

    )

}

}
</code></pre><p>注意，当您在一个组件上使用ref时，它是对组件(而不是底层元素)的引用，因此您可以访问它的方法。</p>
<h3 id="7-别过早组件化"><a href="#7-别过早组件化" class="headerlink" title="7 别过早组件化"></a>7 别过早组件化</h3><p>一个搜索组件，当你输入的时候，可以看到模糊查询到的列表，如下：</p>
<p><img src="https://img.funteas.com/21312590fab421f25931a31659129d79.png?imageView2/2/w/800" alt=""></p>
<p>(我在搜索喜欢讽刺政治的人，我和很多人一样，对别人的政治观点非常感兴趣。)</p>
<p>当设计这个组件的时候，你可能会想：是否需要新建一个搜索结果组件<code>searchResult</code>来展示搜索结果，这个组件可能只需要几行HTML和CSS代码……但我曾告诫自己，当自己犹豫是否要新建的时候，就别新建。</p>
<p>这种情况我不会新建一个独立的组件，而是添加一个<code>renderSearchResult</code>方法，返回相应的DOM。如下：</p>
<pre><code>const SearchSuggestions = (props) =&gt; {

    // renderSearchSuggestion() behaves as a pseduo SearchSuggestion component

    // keep it self contained and it should be easy to extract later if needed

    const renderSearchSuggestion = listItem =&gt; (

        &lt;li  key={listItem.id}&gt;{listItem.name} {listItem.id}&lt;/li&gt;

    );

    return (

        &lt;ul&gt;

            {props.listItems.map(renderSearchSuggestion)}

        &lt;/ul&gt;

    );

}
</code></pre><p>如果其他组件也有类似的需求，你应该复制粘贴代码到那个组件，而不是过早的组件化。</p>
<h3 id="8-用于文本格式化的组件"><a href="#8-用于文本格式化的组件" class="headerlink" title="8 用于文本格式化的组件"></a>8 用于文本格式化的组件</h3><p>这是一个<code>Price</code>组件，将数字处理成含或者不含小数点或者`&lt;div class=“markdown-html language-javascript” id=”article-text”符号的字符串。</p>
<pre><code>const Price = (props) =&gt; {

    const price = props.children.toLocaleString(&#39;en&#39;, {

        style: props.showSymbol ? &#39;currency&#39; : undefined,

        currency: props.showSymbol ? &#39;USD&#39; : undefined,

        maximumFractionDigits: props.showDecimals ? 2 : 0,

    });

    return &lt;span  className={props.className}&gt;{price}&lt;/span&gt;

};

Price.propTypes = {

    className: React.PropTypes.string,

    children: React.PropTypes.number,

    showDecimals: React.PropTypes.bool,

    showSymbol: React.PropTypes.bool,

};

Price.defaultProps = {

    children: 0,

    showDecimals: true,

    showSymbol: true,

};

const Page = () =&gt; {

    const lambPrice = 1234.567;

    const jetPrice = 999999.99;

    const bootPrice = 34.567;

    return (

        &lt;div&gt;

            &lt;p&gt;One lamb is &lt;Price  className=&quot;expensive&quot;&gt;{lambPrice}&lt;/Price&gt;&lt;/p&gt;

            &lt;p&gt;One jet is &lt;Price  showDecimals={false}&gt;{jetPrice}&lt;/Price&gt;&lt;/p&gt;

            &lt;p&gt;Those gumboots will set ya back &lt;Price  showDecimals={false}  showSymbol={false}&gt;{bootPrice}&lt;/Price&gt; bucks.&lt;/p&gt;

        &lt;/div&gt;

    );

};
</code></pre><p>正如你所看到的，我用使用了一个强大的字符串格式化库，<a href="http://link.funteas.com/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FNumber%2FtoLocaleString" target="_blank" rel="external">链接在这里</a> (target=undefined)。</p>
<p>用更少的代码实现（我不是很喜欢）:</p>
<pre><code>function numberToPrice(num, options = {}) {

    const showSymbol = options.showSymbol !== false;

    const showDecimals = options.showDecimals !== false;

    return num.toLocaleString(&#39;en&#39;, {

        style: showSymbol ? &#39;currency&#39; : undefined,

        currency: showSymbol ? &#39;USD&#39; : undefined,

        maximumFractionDigits: showDecimals ? 2 : 0,

    });

}

const Page = () =&gt; {

    const lambPrice = 1234.567;

    const jetPrice = 999999.99;

    const bootPrice = 34.567;

    return (

    &lt;div&gt;

        &lt;p&gt;One lamb is &lt;span  className=&quot;expensive&quot;&gt;{numberToPrice(lambPrice)}&lt;/span&gt;&lt;/p&gt;

        &lt;p&gt;One jet is {numberToPrice(jetPrice, { showDecimals: false })}&lt;/p&gt;

        &lt;p&gt;Those gumboots will set ya back {numberToPrice(bootPrice, { showDecimals: false, showSymbol: false })} bucks.&lt;/p&gt;

    &lt;/div&gt;

    );

};
</code></pre><p>注意：我并没有检查传入数字的的有效性，是因为…………lan。</p>
<h3 id="9-降低组件复杂度"><a href="#9-降低组件复杂度" class="headerlink" title="9 降低组件复杂度"></a>9 降低组件复杂度</h3><p>我可能写过上千次这种判断：</p>
<pre><code>if (props.user.signInStatus === SIGN_IN_STATUSES.SIGNED_IN)...
</code></pre><p>这是一个错误示范，我应该判断“用户是否登录”而不是判断“用户登录状态===登录”</p>
<p>我的组件已经够复杂了，不应该让它去考虑传入的价格是不是数字，亦或者boolean值是否是‘true’。</p>
<p>正如你所见，如果你的数据store和你的组件是相匹配的，那么你的组件将会简单得多。我以前就说过，“复杂”是bug的藏身之处。组件越简单，出bug的概率就越小。</p>
<p>但是“复杂”无法避免，如何处理呢？</p>
<p>我建议创建一个模块，来专门处理输入数据，比如重命名<code>props</code>，字符串转成数字，对象转成数组，数据字符串转成数据对象，等等。</p>
<p>全部在一个地方处理和测试。</p>
<p>如果你设置<code>react/redux</code>，你应该这样在<code>action</code>中写请求搜索结果：</p>
<pre><code>fetch(`/api/search?${queryParams}`) 

    .then(response =&gt; response.json()) 

    .then(normalizeSearchResultsApiData) // 处理所有数据 

    .then(normalData =&gt; { 

    // 得到处理后的数据

});
</code></pre><p>这样会大大降低组件的复杂度。</p>
<h3 id="10-不用相对路径来导入组件"><a href="#10-不用相对路径来导入组件" class="headerlink" title="10 不用相对路径来导入组件"></a>10 不用相对路径来导入组件</h3><p>别这样写:</p>
<pre><code>**import** Button **from** &#39;../../../../Button/Button.jsx&#39;;
**import** Icon **from** &#39;../../../../Icon/Icon.jsx&#39;;
**import** Footer **from** &#39;../../Footer/Footer.jsx&#39;;
</code></pre><p>要这样写:</p>
<pre><code>`import {Button, Icon, Footer} from &#39;Components&#39;;`
</code></pre><p>理论上你可以这样实现:</p>
<ul>
<li><p>创建一个<code>index.js</code>做索引，让你所有的组件可以被引用。</p>
</li>
<li><p>使用Webpack的 <code>resolve.alias</code> 来重定向组件的索引文件</p>
</li>
</ul>
<p>我按照以上理论实现的时候发现这样做并不好，有三个原因：</p>
<ol>
<li><p>Webpack 2删除了<code>alias</code>方法</p>
</li>
<li><p><code>eslint</code>会报错，因为组件并没有在<code>node_modules</code>中。</p>
</li>
<li><p>如果你用<code>WebStorm</code>，<code>cmd</code>/<code>ctrl</code> + 左键组件名的时候，会自动打开该组件文件。但是这个功能将会失效。</p>
</li>
</ol>
<p><img src="https://img.funteas.com/7bd63a32fee471e4389e79ddf5070659.png?imageView2/2/w/800" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>写了很多，希望对您有帮助！</p>
]]></content>
      
        <categories>
            
            <category> react </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[详解 CSS 居中布局技巧]]></title>
      <url>/%E8%AF%A6%E8%A7%A3-CSS-%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>居中布局是前端页面开发过程中一种很常见的布局方式。</p>
<h2 id="水平居中元素："><a href="#水平居中元素：" class="headerlink" title="水平居中元素："></a>水平居中元素：</h2><p>方式一：CSS3 transform</p>
<pre><code>.parent {
    position: relative;
}
.child {
    position: absolute;
    left: 50%:
    transform: translateX(-50%);
}
</code></pre><p>方式二：flex 布局</p>
<pre><code>.parent {
    display: flex;
    justify-content: center;
}
</code></pre><p>适用于子元素为浮动，绝对定位，内联元素，均可水平居中。</p>
<ul>
<li><strong>居中的元素为常规文档流中的内联元素(display: inline)</strong></li>
</ul>
<p>常见的内联元素有：span, a, img, input, label 等等</p>
<pre><code>.parent {
    text-align: center;
}
</code></pre><ul>
<li><strong>居中的元素为常规文档流中的块元素(display: block)</strong></li>
</ul>
<p>常见的块元素：div, h1~h6, table, p, ul, li 等等</p>
<p>方式一：设置 margin</p>
<pre><code>.parent {
    width: 100%;
}
.child {
    width: 600px;
    height: 50px;
    margin: 0 auto;
    background: #999;
}
</code></pre><p>方式二：修改为 inline-block 属性</p>
<pre><code>.parent {
    text-align: center;
}
.child {
    display: inline-block;
}
</code></pre><pre><code>.child {
    width: 100px;
    float: left;
    position: relative;
    left: 50%;
    margin-left: -50px;
}
</code></pre><p>方式一：</p>
<pre><code>.parent {
    position: relative;
}
.child {
    position: absolute;
    width: 100px;
    left: 50%;
    margin-left: -50px;
}
</code></pre><p>方式二：</p>
<pre><code>.parent {
    position: relative;
}
.child {
    position: absolute;
    width: 100px;
    left: 0;
    right: 0;
    margin: 0 auto;
}
</code></pre><h2 id="垂直居中元素："><a href="#垂直居中元素：" class="headerlink" title="垂直居中元素："></a>垂直居中元素：</h2><p>方式一：CSS3 transform</p>
<pre><code>.parent {
    position: relative;
}
.child {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
}
</code></pre><p>方式二：flex 布局</p>
<pre><code>.parent {
    display: flex;
    align-items: center;
}
</code></pre><p>适用于子元素为浮动，绝对定位，内联元素，均可垂直居中。</p>
<pre><code>.text {
    line-height: 200px;
    height: 200px;
}
</code></pre><p>方式一：</p>
<pre><code>.parent {
    position: relative;
}
.child{
    position: absolute;
    top: 50%;
    height: 100px;
    margin-top: -50px;
}
</code></pre><p>方式二：</p>
<pre><code>.parent {
    position: relative;
}
.child{
    position: absolute;
    top: 0;
    bottom: 0;
    height: 100px;
    margin: auto 0;
}
</code></pre><h2 id="垂直居中元素：-1"><a href="#垂直居中元素：-1" class="headerlink" title="垂直居中元素："></a>垂直居中元素：</h2><pre><code>div {
    width: 100px;
    height: 100px;
    margin: auto;
    position: fixed;
    //absolute is ok
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
}
</code></pre><p>优点：</p>
<ol>
<li><p>不仅可以实现在正中间，还可以在正左方，正右方</p>
</li>
<li><p>元素的宽高支持百分比 % 属性值和 min-/max- 属性</p>
</li>
<li><p>可以封装为一个公共类，可做弹出层</p>
</li>
<li><p>浏览器支持性好</p>
</li>
</ol>
<pre><code>.child {
    width: 100px;
    height: 100px;
    position: absolute;
    top: 50%;
    left: 50%;
    margin-left: -50px;
    margin-top: -50px;
}
</code></pre><p>特点：</p>
<ol>
<li><p>良好的跨浏览器特性,兼容 IE6 - IE7</p>
</li>
<li><p>灵活性差，不能自适应，宽高不支持百分比尺寸和 min-/max- 属性</p>
</li>
</ol>
<pre><code>.child {
    width: 100px;
    height: 100px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);  
}
</code></pre><p>特点：</p>
<ol>
<li><p>内容可自适应，可以封装为一个公共类，可做弹出层</p>
</li>
<li><p>可能干扰其他 transform 效果</p>
</li>
</ol>
<pre><code>.parent {
    display: flex;
    justify-content: center;
    align-items: center;
}
</code></pre><p>这是 CSS 布局未来的趋势。Flexbox 是 CSS3 新增属性，设计初衷是为了解决像垂直居中这样的常见布局问题。</p>
<pre><code>text {
    height: 100px;
    line-height: 100px;
    text-align: center;
}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这就是css居中布局的一些常用技巧。</p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[详解 CSS 七种三栏布局技巧]]></title>
      <url>/%E8%AF%A6%E8%A7%A3-CSS-%E4%B8%83%E7%A7%8D%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>三栏布局，顾名思义就是两边固定，中间自适应。三栏布局在开发十分常见，那么什么是三栏布局？比如我打开某东的首页：</p>
<p><img src="https://img.funteas.com/bac807a8c0f10cd4a5eef440123dab99?imageView2/2/w/800" alt=""></p>
<p>映入眼帘的就是一个常见的三栏布局：即左边商品导航和右边导航固定宽度，中间的主要内容随浏览器宽度自适应。</p>
<p>下面围绕的这样的目的，即左右模块固定宽度，中间模块随浏览器变化自适应，想要完成的最终效果如下图所示：</p>
<p><img src="https://img.funteas.com/8c0caa243fe962aaf371e9ca018366eb?imageView2/2/w/800" alt=""></p>
<p>红色和蓝色宽度固定，绿色宽度自适应，下面七种方法实现的最终效果跟这个差不多，可能会稍有不同。</p>
<p><strong>下面七种技巧各有千秋，在开发中可以根据实际需求选择适合自己的方法进行编码。</strong></p>
<h2 id="1-流体布局"><a href="#1-流体布局" class="headerlink" title="1. 流体布局"></a>1. 流体布局</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;style&gt;
    .left {
        float: left;
        height: 200px;
        width: 100px;
        background-color: red;
    }
    .right {
        width: 200px;
        height: 200px;
        background-color: blue;
        float: right;
    }
    .main {
        margin-left: 120px;
        margin-right: 220px;
        height: 200px;
        background-color: green;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>左右模块各自向左右浮动，并设置中间模块的 margin 值使中间模块宽度自适应。</p>
<p>缺点就是主要内容无法最先加载，当页面内容较多时会影响用户体验。</p>
<h2 id="2-BFC-三栏布局"><a href="#2-BFC-三栏布局" class="headerlink" title="2. BFC 三栏布局"></a>2. BFC 三栏布局</h2><p>BFC 规则有这样的描述：BFC 区域，不会与浮动元素重叠。因此我们可以利用这一点来实现 3 列布局。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;style&gt;
    .left {
        float: left;
        height: 200px;
        width: 100px;
        margin-right: 20px;
        background-color: red;
    }
    .right {
        width: 200px;
        height: 200px;
        float: right;
        margin-left: 20px;
        background-color: blue;
    }    
    .main {
        height: 200px;
        overflow: hidden;
        background-color: green;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>缺点跟方法一类似，主要内容模块无法最先加载，当页面中内容较多时会影响用户体验。因此为了解决这个问题，有了下面要介绍的布局方案双飞翼布局。</p>
<h2 id="3-双飞翼布局"><a href="#3-双飞翼布局" class="headerlink" title="3. 双飞翼布局"></a>3. 双飞翼布局</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;style&gt;
        .content {
          float: left;
          width: 100%;
        }
        .main {
          height: 200px;
          margin-left: 110px;
          margin-right: 220px;
          background-color: green;
        }
        //用于清除浮动
        .main::after {
          display: block;
          content: &#39;&#39;;
          font-size: 0;
          height: 0;
          clear: both;
          zoom: 1;
        }
    .left {
        float: left;
        height: 200px;
        width: 100px;
        margin-left: -100%;
        background-color: red;
    }
    .right {
        width: 200px;
        height: 200px;
        float: right;
        margin-left: -200px;
        background-color: blue;
    }    
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;content&quot;&gt;
        &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>利用的是浮动元素 margin 负值的应用，感兴趣的同学可以上网搜搜原理。</p>
<p>主体内容可以优先加载，HTML 代码结构稍微复杂点。</p>
<h2 id="4-圣杯布局"><a href="#4-圣杯布局" class="headerlink" title="4. 圣杯布局"></a>4. 圣杯布局</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;style&gt;
    .container {
        margin-left: 120px;
        margin-right: 220px;
    }
    .main {
        float: left;
        width: 100%;
        height: 300px;
        background-color: red;
    }
    .left {
        float: left;
        width: 100px;
        height: 300px;
        margin-left: -100%;
        position: relative;
        left: -120px;
        background-color: blue;
    }
    .right {
        float: left;
        width: 200px;
        height: 300px;
        margin-left: -200px;
        position: relative;
        right: -220px;
        background-color: green;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>跟双飞翼布局很像，有一些细节上的区别，相对于双飞翼布局来说，HTML 结构相对简单，但是样式定义就稍微复杂，也是优先加载内容主体。</p>
<h2 id="5-Flex-布局"><a href="#5-Flex-布局" class="headerlink" title="5. Flex 布局"></a>5. Flex 布局</h2><p><strong>推荐</strong></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;style&gt;
    .container {
            display: flex;
    }
    .main {
            flex-grow: 1;
        height: 300px;
        background-color: red;
    }
    .left {
        order: -1;
        flex: 0 1 200px;
        margin-right: 20px;
        height: 300px;
        background-color: blue;
    }
    .right {
        flex: 0 1 100px;
            margin-left: 20px;
        height: 300px;
        background-color: green;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>简单实用，未来的趋势，需要考虑浏览器的兼容性。</p>
<h2 id="6-Table-布局"><a href="#6-Table-布局" class="headerlink" title="6. Table 布局"></a>6. Table 布局</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;style&gt;
        .container {
        display: table;
        width: 100%;
        }
        .left, .main, .right {
        display: table-cell;
        }
        .left {
        width: 200px;
        height: 300px;
        background-color: red;
        }
        .main {
        background-color: blue;
        }
        .right {
        width: 100px;
        height: 300px;
        background-color: green;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>缺点：无法设置栏间距</p>
<h2 id="7-绝对定位布局"><a href="#7-绝对定位布局" class="headerlink" title="7. 绝对定位布局"></a>7. 绝对定位布局</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;style&gt;
    .container {
        position: relative;
    }
    .main {
        height: 400px;
        margin: 0 120px;
        background-color: green;
    }
    .left {
        position: absolute;
        width: 100px;
        height: 300px;
        left: 0;
        top: 0;
        background-color: red;
    }
    .right {
        position: absolute;
        width: 100px;
        height: 300px;
        background-color: blue;
            right: 0;
        top: 0;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>简单实用，并且主要内容可以优先加载。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上就是css常见的七种布局方式。如有不足，欢迎指出。</p>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[React特性精华]]></title>
      <url>/React%E7%89%B9%E6%80%A7%E7%B2%BE%E5%8D%8E.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以下内容是我在学习和研究 React 时，对 React 的特性、重点和注意事项的提取、精练和总结，可以做为 React 特性的字典，方便大家查阅</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><pre><code>1\. JSX语法
2\. 注释
3\. React元素
4\. 组件
5\. 标签属性
6\. 元素的子代
7\. 状态state
8\. Props和State
9\. 事件处理
10\. key
11\. 表单
12\. props的类型检查
13\. props的默认值
14\. 元素的引用
15\. 不使用ES6
16\. React的特性
17\. 性能优化
</code></pre><h3 id="1-JSX语法"><a href="#1-JSX语法" class="headerlink" title="1. JSX语法"></a>1. JSX语法</h3><ul>
<li><p>JSX 语法的解析规则是：遇到 XML 标签 &lt;…&gt;，以 XML 规则解析；遇到代码块 {…}，就用 JavaScript 规则解析；</p>
</li>
<li><p>我认为，在JSX中，XML可以理解为是创建虚拟DOM对象的字面量写法；在编译之后呢，XML标签 会被转化为 React.createElement() 函数的调用；<br>下面两种代码的作用是完全相同的：</p>
</li>
</ul>
<pre><code>const element = (
    &lt;h1 className=&quot;greeting&quot;&gt;
    Hello, world!
    &lt;/&gt;
 );
</code></pre><p>等效于：</p>
<pre><code>const element = React.createElement(
    &#39;h1&#39;,
    {className: &#39;greeting&#39;},
    &#39;Hello, world!&#39;
 );
</code></pre><p>React.createElement() 这个方法首先会进行一些避免bug的检查，之后会返回一个类似下面例子的对象：</p>
<pre><code> // 注意: 以下示例是简化过的（不代表在 React 源码中是这样）
 const element = {
     type: &#39;h1&#39;,
     props: {
         className: &#39;greeting&#39;,
         children: &#39;Hello, world&#39;
     }
 };
</code></pre><p>这样的对象被称为 “React 元素”。它代表所有你在屏幕上看到的东西。React 通过读取这些对象来构建 DOM 并保持数据内容一致。</p>
<ul>
<li><p>JSX 允许直接在模板插入 JavaScript 变量；如果这个变量是一个数组，则会展开这个数组的所有成员；</p>
</li>
<li><p>如果 JSX 中的XML带有换行，则推荐，有XML的外面加上一个小括号，这样可以防止 分号自动插入 的bug；</p>
</li>
<li><p>在JSX中的XML，通过引号定义以字符串为值的标签属性：<code>const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;;</code>，通过大括号来定义以 JavaScript 表达式为值的标签属性：<code>const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;</code>；切注意：如果使用了大括号包裹的 JavaScript 表达式时就不要再到外面套引号了。JSX 会将引号当中的内容识别为字符串而不是表达式；</p>
</li>
<li><p>JSX不允许没有闭合的标签；</p>
</li>
<li><p>因为 JSX 的特性更接近 JavaScript 而不是 HTML , 所以 XML 使用 camelCase 小驼峰命名 来定义属性的名称，而不是使用 HTML 的属性名称;例如：class 用 className 代替，而 tabindex 用 tabIndex 代替；</p>
</li>
<li><p>React DOM 在渲染之前默认会 过滤 所有传入的值。它可以确保应用不会被注入攻击。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS(跨站脚本) 攻击；</p>
</li>
</ul>
<h3 id="2-注释"><a href="#2-注释" class="headerlink" title="2. 注释"></a>2. 注释</h3><p>由于JSX的本质是JavaScript，所以在JSX中的注释还是JavaScript的注释；为了JSX的XML中使用注释，所以需要用先用花括号<code>{}</code>产生JavaScript环境，然后在<code>{}</code>内使用JavaScript注释；<br>所以，关于的注释的规则总结如下：</p>
<ol>
<li>在标签内部的注释需要花括号<code>{}</code>括住；</li>
<li>在标签外的注释不使用花括号<code>{}</code>；</li>
</ol>
<h3 id="3-React元素"><a href="#3-React元素" class="headerlink" title="3. React元素"></a>3. React元素</h3><ul>
<li>元素是构成 React 应用的最小单位；元素用来描述你在屏幕上看到的内容，如下：<code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</code>；</li>
<li>React元素与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致；</li>
<li>React 元素都是不可变的。当元素被创建之后，是无法改变其内容或属性的。一个元素就好像是动画里的一帧，它代表应用界面在某一时间点的样子。更新界面的唯一办法是创建一个新的元素，然后将它传入 ReactDOM.render() 方法；在实际生产开发中, 大多数React应用只会调用一次 ReactDOM.render()；</li>
<li>在更新视图时，React DOM 首先会比较元素内容先后的不同，而在渲染过程中只会更新改变了的部分；</li>
<li>JSX 的标签名决定了 React 元素的类型；小写开头的 JSX 标签名表示一个原生HTM元素，即内置的组件，如 <code>&lt;div&gt;</code> 或 <code>&lt;span&gt;</code>，在编译时，会将字符串 ‘div’ 或 ‘span’ 传 递给 React.createElement 方法；大写开头的 JSX 标签名表示一个 React 组件，如 <code>&lt;Foo /&gt;</code>，在编译时，会被编译为同名变量并被引用，如 <code>React.createElement(Foo)</code>，所以如果使用了 大家开头的标签，如：<code>&lt;Foo /&gt;</code>，则必须在作用域中先声明与该标签名同名的变量，如 Foo 变量；</li>
<li>由于 JSX 编译后会调用 React.createElement 方法，所以在 JSX 代码中必须首先声明或导入 React 变量；</li>
<li>JSX 的标签名可以是打点的属性调用；如： <code>&lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;</code>；但不能是表达式，如：<code>&lt;MyComponents[&quot;DatePicker&quot;] color=&quot;blue&quot; /&gt;</code> 是错误的；</li>
</ul>
<h3 id="4-组件"><a href="#4-组件" class="headerlink" title="4. 组件"></a>4. 组件</h3><ul>
<li>从概念上看组件就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素；</li>
<li>当React遇到的元素是用户自定义的组件时，它会将标签的所有标签属性作为单个对象传递给该组件构造函数,这个对象称之为“props”；</li>
<li>在组件内部，不允许修改props；</li>
<li>可以通过props.children获取组件元素的开关标签之间的内容；</li>
<li>组件可以嵌套；</li>
<li>唯一一种在 React 之外获取 React 组件实例句柄的方式就是保存 React.render 的返回值。在其它组件内，可以使用 refs 得到相同的结果；</li>
</ul>
<h4 id="定义组件的方式："><a href="#定义组件的方式：" class="headerlink" title="定义组件的方式："></a>定义组件的方式：</h4><ol>
<li>用函数定义组件：<br>定义一个组件最简单的方式是使用JavaScript函数：</li>
</ol>
<pre><code>function Welcome(props) {
    return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
 }
</code></pre><p>该函数是一个有效的React组件，它接收一个单一的“props”对象并返回了一个React元素。我们之所以称这种类型的组件为函数定义组件，是因为从字面上来看，它就是一个JavaScript函数。</p>
<ol>
<li>通过 ES6 class 来定义组件：</li>
</ol>
<pre><code>class Welcome extends React.Component {
    render() {
        return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
     }
 }
</code></pre><h4 id="组件的渲染"><a href="#组件的渲染" class="headerlink" title="组件的渲染"></a>组件的渲染</h4><ul>
<li>组件通过触发组件实例的render方法渲染自己；</li>
<li>每个组件在渲染时也会触发子组件的render方法渲染子组件；</li>
<li>根组件需要通过ReactDom.render方法把自身添加到指定的Dom元素上，并渲染自己；</li>
<li>组件类的顶层标签只能有一个；</li>
<li>如果 render 返回 null，则不会渲染该组件，但并不会影响该组件生命周期方法的回调；</li>
</ul>
<h3 id="5-标签属性"><a href="#5-标签属性" class="headerlink" title="5. 标签属性"></a>5. 标签属性</h3><p>在 JSX 中有如下几种不同的方式来指定标签属性：</p>
<ul>
<li><p>使用 JavaScript 表达式<br>可以传递任何 {} 包裹的 JavaScript 表达式作为一个标签属性值，如： <code>&lt;MyComponent foo={1 + 2 + 3 + 4} /&gt;</code>，表达式的值最终会被赋给相应的标签属性。if 语句和 for 循环在 JavaScript 中不是表达式，因此它们不能直接用在标签属性中；</p>
</li>
<li><p>字符串常量<br>可以将字符串常量作为标签属性值传递。当你传递一个字符串常量时，它不会对其进行 HTML 转义，所以下面几个 JSX 表达式是等价的：</p>
</li>
</ul>
<pre><code>&lt;MyComponent message=&quot;&lt;3&quot; /&gt;
&lt;MyComponent message=&quot;&lt;3&quot; /&gt;
&lt;MyComponent message={&#39;&lt;3&#39;} /&gt;
</code></pre><ul>
<li>默认为 True<br>如果没有给标签属性传值，则它默认为 true。因此下面两个 JSX 是等价的：</li>
</ul>
<pre><code>&lt;MyTextBox autocomplete /&gt;
&lt;MyTextBox autocomplete={true} /&gt;
</code></pre><ul>
<li>扩展属性<br>在 JSX中，你可以使用 … 作为扩展操作符来传递整个属性对象。<br>下面两个组件是等效的：</li>
</ul>
<pre><code>function App1() {
  return &lt;Greeting firstName=&quot;Ben&quot; lastName=&quot;Hector&quot; /&gt;;
}

function App2() {
  const props = {firstName: &#39;Ben&#39;, lastName: &#39;Hector&#39;};
  return &lt;Greeting {...props} /&gt;;
}
</code></pre><h3 id="6-元素的子代"><a href="#6-元素的子代" class="headerlink" title="6. 元素的子代"></a>6. 元素的子代</h3><p>在 JSX 中，开始标签和结束标签之间的子代内容会作为props.children传递；开始标签和结束标签之间可以是任何类型的东西，只要该组件在 React 渲染前能将其转换成 React 能够理解的东西即可；</p>
<p>例如，可以传递如下类型的子代：</p>
<ul>
<li><p>字符串常量：如果在开始和结束标签之间放入一个字符串，则 props.children 就是那个字符串；因为 HTML 未被转义，所以可以像写 HTML 一样写 JSX；JSX 会移除行空行和开始和结尾处的空格。标签邻近的新行也会被移除，字符串常量内部的换行会被压缩成一个空格；</p>
</li>
<li><p>JSX：可以开始和结束标签之间嵌入更多的 JSX 元素；</p>
</li>
<li><p>JavsScript 表达式：可以将任何 {} 包裹的 JavaScript 表达式作为子代传递；</p>
</li>
<li><p>函数：可以将用 {} 包裹的函数作为子代传递；</p>
</li>
<li><p>布尔值、Null 和 Undefined 被忽略：<br>false、null、undefined 和 true 都是有效的子代，但它们不会直接被渲染；而当子代是React 提供的一些 “falsy” 值 （即：除了false 外，0，“”，null，undefined 和 NaN）时，则会被渲染；<br>下面的表达式是等价的：</p>
</li>
</ul>
<pre><code>&lt;div /&gt;

&lt;div&gt;&lt;/div&gt;

&lt;div&gt;{false}&lt;/div&gt;

&lt;div&gt;{null}&lt;/div&gt;

&lt;div&gt;{undefined}&lt;/div&gt;

&lt;div&gt;{true}&lt;/div&gt;
</code></pre><h3 id="7-状态state"><a href="#7-状态state" class="headerlink" title="7. 状态state"></a>7. 状态state</h3><ul>
<li><p>构造函数是唯一能够初始化 this.state 的地方；</p>
</li>
<li><p>直接更新状态不会重新渲染组件，如：<code>this.state.comment = &#39;Hello&#39;;</code>；应当使用 setState()设置状态，如：<code>this.setState({comment: &#39;Hello&#39;});</code>；</p>
</li>
<li><p>状态更新可能是异步的；React 可以将多个setState() 调用合并成一个调用来提高性能。因为 this.props 和 this.state 可能是异步更新的，所以不应该依靠它们的值来计算下一个状态，如：</p>
</li>
</ul>
<pre><code>//错误的示范
this.setState({
    counter: this.state.counter + this.props.increment,
 });
</code></pre><p>应该给 setState() 传一个函数而不是一个对象。 该函数将接收先前的状态作为第一个参数，如：</p>
<pre><code>//正确的示范
this.setState((prevState, props) =&gt; ({
    counter: prevState.counter + props.increment
 }));
</code></pre><p>上方代码使用了箭头函数，但它也适用于常规函数；</p>
<ul>
<li>当你调用 setState(参数对象) 时，参数对象中的属性会完全替换掉this.state中相应的属性；</li>
</ul>
<h3 id="8-Props和State"><a href="#8-Props和State" class="headerlink" title="8. Props和State"></a>8. Props和State</h3><ul>
<li>Props是组件实例的标签属性的集合；它可以接收组件外传进来的值，在组件内部是不可修改Props的属性的，在组件外部可以通过标签属性给它赋值，所以可以用来从组件外部给组件内部传值；</li>
<li>State是组件实例的内部数据的集合；在组件内部是可以更改State的属性的值，且每次更改后，都会触发render方法渲染组件；<br>组件的标签属性在使用前不用先定义；而组件的内部数据State的属性在使用前需要先通过getInitialState方法定义；</li>
</ul>
<h3 id="9-事件处理"><a href="#9-事件处理" class="headerlink" title="9. 事件处理"></a>9. 事件处理</h3><ul>
<li>React事件绑定属性的命名采用驼峰式写法，而不是小写。</li>
<li>如果采用 JSX 的语法，则需要传入一个函数作为事件处理函数，而不是一个字符串(DOM元素的写法)；处理函数接收一个事件对象，这个事件对象是 React 根据 W3C spec 来合成的事件对象，所以不需要担心跨浏览器的兼容性问题；</li>
<li>不能使用返回 false 的方式阻止默认行为，必须明确的使用 preventDefault 来阻止默认行为；</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code>function ActionLink() {

  function handleClick(e) {
    e.preventDefault();
    console.log(&#39;已被点击！&#39;);
  }

  return (
    &lt;a href=&quot;#&quot; onClick={handleClick}&gt;
      点击我
    &lt;/a&gt;
  );
}
</code></pre><h3 id="10-key"><a href="#10-key" class="headerlink" title="10. key"></a>10. key</h3><ul>
<li>key必须在其兄弟节点中是唯一的，而非全局唯一；</li>
<li>key会作为给React的提示，但不会传递给你的组件，即不会成为props中的属性；</li>
</ul>
<h3 id="11-表单"><a href="#11-表单" class="headerlink" title="11. 表单"></a>11. 表单</h3><ul>
<li>对于 textarea 元素，在HTML当中，是通过子节点（开关标签之间的内容）来定义它的文本内容的，而在React中，是通过 标签属性value来设置它的文本内容的；</li>
<li>对于 select 标签，在HTML中，是通过在设置它的选项option元素的标签属性selected来设置被选中的选项的；而在React中，是通过设置 select 元素的标签属性 value 来设置被选中的值的；</li>
<li>通过给表单元素设置标签属性 defaultValue 可以为其指定初始值；</li>
</ul>
<h3 id="12-props的类型检查"><a href="#12-props的类型检查" class="headerlink" title="12. props的类型检查"></a>12. props的类型检查</h3><p>要给组件的props限制类型，则需要设置组件类的propTypes属性；<br><strong>示例代码：</strong></p>
<pre><code>import PropTypes from &#39;prop-types&#39;;

class Greeting extends React.Component {
  render() {
    return (
      &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;
    );
  }
}

Greeting.propTypes = {
  name: PropTypes.string,
  children: PropTypes.element.isRequired
};
</code></pre><p>可以通过设置propTypes的children属性 <code>propTypes.children</code> 来限传入的子代内容；</p>
<h3 id="13-props的默认值"><a href="#13-props的默认值" class="headerlink" title="13. props的默认值"></a>13. props的默认值</h3><p>要给组件的props设置默认值，则需要设置组件类的defaultProps属性；<br>defaultProps 用来确保 <a href="http://link.funteas.com/?target=http%3A%2F%2Fthis.props.name" target="_blank" rel="external">this.props.name</a> (target=undefined) 在父组件没有特别指定的情况下，有一个初始值。类型检查发生在 defaultProps 赋值之后，所以类型检查也会应用在 defaultProps 上面；<br><strong>示例代码：</strong></p>
<pre><code>class Greeting extends React.Component {
  render() {
    return (
      &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;
    );
  }
}

// 为属性指定默认值:
Greeting.defaultProps = {
  name: &#39;Stranger&#39;
};

// 渲染 &quot;Hello, Stranger&quot;:
ReactDOM.render(
  &lt;Greeting /&gt;,
  document.getElementById(&#39;example&#39;)
);
</code></pre><h3 id="14-元素的引用"><a href="#14-元素的引用" class="headerlink" title="14. 元素的引用"></a>14. 元素的引用</h3><p>元素的标签属性 ref 接受一个回调函数，它在元素被加载或卸载时执行；该回调函数接收一个参数element，<br>在元素被加载时：<br>如果该元素是原生的HTML元素，则参数element是该元素的DOM节点实例；<br>如果该元素是React组件，则参数element是该元素的Reac实例；<br>在元素被卸载时：参数element是null；</p>
<p><strong>注意：</strong></p>
<ul>
<li>对函数式组件（用函数定义的组件）设置ref无效；</li>
<li>如果 ref 回调以内联函数的方式定义，在更新期间它会被调用两次，第一次参数是 null ，之后参数是元素的实例。这是因为在每次渲染中都会创建一个新的函数实例。因此，React 需要清理旧的 ref 并且设置新的；</li>
</ul>
<h3 id="15-不使用ES6"><a href="#15-不使用ES6" class="headerlink" title="15. 不使用ES6"></a>15. 不使用ES6</h3><p>以上是用ES6的语法创建的React组件的，当然也可以仅用ES5及以下的语法特性来创建，如下：</p>
<p>用 <code>create-react-class</code> 模块创建组件类，代替ES6的用class创建组件类：</p>
<pre><code>var createReactClass = require(&#39;create-react-class&#39;);
var Greeting = createReactClass({
  render: function() {
    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
  }
});
</code></pre><p>ES6 中 class 相关的接口与 createReactClass 方法十分相似，但有以下几个区别：</p>
<ol>
<li>声明默认属性：</li>
</ol>
<ul>
<li>如果使用 class 关键字创建组件，可以直接把自定义属性对象写到类的 defaultProps 属性中；</li>
<li>如果使用 createReactClass 方法创建组件，那就需要在配置对象中定义 getDefaultProps 方法，并且在这个方法中返回包含自定义属性的对象；</li>
</ul>
<ol>
<li>设置初始状态：</li>
</ol>
<ul>
<li>如果使用 class 关键字创建组件，你可以通过在 constructor 中给 this.state 赋值的方式来定义组件的初始状态；</li>
<li>如果使用 createReactClass 方法创建组件，你就需要多写一个 getInitialState 方法，并让这个方法返回你要定义的初始属性；</li>
</ul>
<ol>
<li>自动绑定：</li>
</ol>
<ul>
<li>对于使用 class 关键字创建的 React 组件，组件中的方法是不会自动绑定 this 的。类似地，通过 ES6 class 生成的实例，实例上的方法也不会绑定 this。因此，你需要在 constructor 中为方法手动添加 .bind(this)；</li>
<li>如果使用 createReactClass 方法创建组件，组件中的方法会自动绑定至实例，不需要加 .bind(this)；</li>
</ul>
<h3 id="16-React的特性"><a href="#16-React的特性" class="headerlink" title="16. React的特性"></a>16. React的特性</h3><ol>
<li>JSX使用大、小写的约定来区分标签是定义的组件类还是原生的HTML标签；</li>
<li>由于JSX就是JavaScript，所以一些标识符（如：class和for）不能作为XML标签的属性名。在JSX中，使用className替代XML标签的class属性，htmlFor替代XML的for属性；</li>
<li>在JSX中的XML中的花括号<code>{}</code>表达式中不能使用<code>if else</code>语句，可以使用条件表达式(三元运算<code>条件?值1: 值2</code>)代替；</li>
<li>组件类的顶层标签只能有一个；</li>
<li>每次调用this.setState方法修改状态值，都会触发this.render方法渲染组件；</li>
</ol>
<h3 id="17-性能优化"><a href="#17-性能优化" class="headerlink" title="17. 性能优化"></a>17. 性能优化</h3><ul>
<li>虽然 props 由React本身设置以及 state 用于存储状态，但如果需要存储不用于视觉输出的东西，则建议通过手动向类或实例中添加相应属性来存储，而不应用 state 和 props 来存储；</li>
<li>如果在组件的钩子方法shouldComponentUpdate中返回false，则React不会对该组件及其子组件进行变化检查和渲染，所以，应在组件不需要更新的情况下，让钩子方法shouldComponentUpdate内返回false；</li>
<li>因为 <code>React.PureComponent</code> 类型的组件在做变化检查时是用浅比较来判断是否有变化的，所以性能较快，所以：对于没有必须进行深比较的组件，优先使用 <code>React.PureComponent</code> 而不是 <code>React.Componen</code>；</li>
<li>合理的使用key；</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上就是react的特性精华。如有不足，欢迎指出。</p>
]]></content>
      
        <categories>
            
            <category> react </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 前端技术 </tag>
            
            <tag> react </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[变量类型、原型、闭包、作用域面试题及知识点简单总结]]></title>
      <url>/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于变量类型、原型、闭包、作用域面试题及知识点简单总结的一篇文章，可以当作参考书来查资料。</p>
<h2 id="变量类型和计算知识点："><a href="#变量类型和计算知识点：" class="headerlink" title="变量类型和计算知识点："></a>变量类型和计算知识点：</h2><h3 id="值类型、引用类型"><a href="#值类型、引用类型" class="headerlink" title="值类型、引用类型"></a>值类型、引用类型</h3><pre><code>//值类型
var a=100
var b=a
a=200
console.log(b) //100
//引用类型
var a={age:20}
var b=a
b.age=21
console.log(a.age) //21
</code></pre><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><pre><code>// Numbers
typeof 37 === &#39;number&#39;;
typeof 3.14 === &#39;number&#39;;
typeof Math.LN2 === &#39;number&#39;;
typeof Infinity === &#39;number&#39;;
typeof NaN === &#39;number&#39;; // 尽管NaN是&quot;Not-A-Number&quot;的缩写
typeof Number(1) === &#39;number&#39;; // 但不要使用这种形式!
// Strings
typeof &quot;&quot; === &#39;string&#39;;
typeof &quot;bla&quot; === &#39;string&#39;;
typeof (typeof 1) === &#39;string&#39;; // typeof总是返回一个字符串
typeof String(&quot;abc&quot;) === &#39;string&#39;; // 但不要使用这种形式!
// Booleans
typeof true === &#39;boolean&#39;;
typeof false === &#39;boolean&#39;;
typeof Boolean(true) === &#39;boolean&#39;; // 但不要使用这种形式!
// Symbols
typeof Symbol() === &#39;symbol&#39;;
typeof Symbol(&#39;foo&#39;) === &#39;symbol&#39;;
typeof Symbol.iterator === &#39;symbol&#39;;
// Undefined
typeof undefined === &#39;undefined&#39;;
typeof declaredButUndefinedVariable === &#39;undefined&#39;;
typeof undeclaredVariable === &#39;undefined&#39;; 
// Objects
typeof {a:1} === &#39;object&#39;;
// 使用Array.isArray 或者 Object.prototype.toString.call
// 区分数组,普通对象
typeof [1, 2, 4] === &#39;object&#39;;
typeof new Date() === &#39;object&#39;;
// 下面的容易令人迷惑，不要使用！
typeof new Boolean(true) === &#39;object&#39;;
typeof new Number(1) ==== &#39;object&#39;;
typeof new String(&quot;abc&quot;) === &#39;object&#39;;
// 函数
typeof function(){} === &#39;function&#39;;
typeof Math.sin === &#39;function&#39;;
//NaN
typeof 1/0 === &#39;NaN&#39;;
//null
typeof null === &#39;object&#39;;
</code></pre><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><pre><code>//逻辑运算符
console.log(10 &amp; 0) //0  转换为true&amp;&amp;0
console.log(&#39;&#39;||&#39;abc&#39;) //abc  转换为false||&#39;abc&#39;
console.log(!window.abc) //true  !undefined为true
//if语句 false情况
null &#39;&#39; false 0 NaN undefined
//判断一个变量是否当作true或者false
var a = 100
console.log(!!a)
</code></pre><h3 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h3><p>1.JS中使用typeof能得到哪些类型<br>undefined null string number object function boolean symbol<br>2.何时使用’===’，何时使用’==‘<br>参考jQuery源码 只有这种情况下使用’==’:</p>
<pre><code>if(obj.a == null) {
}
//这句相当于obj.a === null || obj.a === undefined
</code></pre><p>3.JS有哪些内置函数<br>Object Array String Number Function Boolean Date RegExp Error<br>4.JS变量按照存储方式分为哪些类型，并描述其特点<br>值类型、引用类型。<br>值类型是将变量的值存在内存中。<br>引用类型的变量是真实变量的指针（对象、数组、函数）。可以无限扩张属性。<br>5.如何理解JSON<br>是JavaScript的对象，内置两个方法 JSON.stringify JSON.parse</p>
<h2 id="原型知识点："><a href="#原型知识点：" class="headerlink" title="原型知识点："></a>原型知识点：</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code>function Foo(name, age) {
  this.name = name
  this.age = age 
  this.class = &#39;class-1&#39;
  //return this  默认有这行
}

var f = new Foo(&#39;zs&#39;, 20)

//执行过程：1.new函数执行时this会变成空对象 2.this. 的时候赋值 3.return this 4.给f赋值

//var a = {}         ===&gt; var a = new Object()
//var a =[]          ===&gt; var a = new Array()
//function Foo(){}   ===&gt; var Foo = new Function()
//instanceof 用于判断一个函数是否是一个变量的构造函数
</code></pre><h3 id="原型规则"><a href="#原型规则" class="headerlink" title="原型规则"></a>原型规则</h3><pre><code>//所有的引用类型（数组、对象、函数）都具有对象特性，除了null之外，都可以自由扩展属性
//所有的引用类型 都有__proto__ 隐式原型
//所有的函数都有 prototype 显式原型   属性值也是一个普通对象
//所有的引用类型（数组、对象、函数），__proto__属性值指向它的构造函数的prototype属性值
var obj = {}; obj.a = 100
var arr = []; arr.a = 100
function fn () {}
fn.a = 100

console.log(obj.__proto__)
console.log(arr.__proto__)
console.log(fn.__proto__)

console.log(fn.prototype)

console.log(obj.__proto__ === Object.prototype)

//试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__(构造函数的prototype)中寻找
function Foo(name, age) {
  this.name = name
}

Foo.prototype.alertName = function () {
  alert(this.name)
}

var f = new Foo(&#39;zs&#39;)
f.printName = function () {
  console.log(this.name)
}

f.printName()
f.alertName()
</code></pre><h3 id="原型链-instanceof"><a href="#原型链-instanceof" class="headerlink" title="原型链 instanceof"></a>原型链 instanceof</h3><pre><code>//instanceof 是用于判断引用类型属于哪个构造函数的方法
//构造函数
function Foo(name, age) {
  this.name = name
}

Foo.prototype.alertName = function () {
  alert(this.name)
}

//创建实例
var f = new Foo(&#39;zs&#39;)
f.printName = function () {
  console.log(this.name)
}

f.printName()
f.alertName()
f.toString()

// f instanceof Foo 判断过程：
// f 的 __proto__一层层往上找到是否对应Foo.prototype
// 再判断f instanceof Object
</code></pre><p>直角矩形是构造函数 圆角矩形是对象<br><img src="https://img.funteas.com/2b915fcafa6ffbc2c00a38c792aeb082?imageView2/2/w/800" alt=""></p>
<h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h3><pre><code>var obj={
x:100,
y:200,
z:300
}
var key
for(key in obj){
//hasOwnProperty会返回一个布尔值，判断是否是原生的属性，以此来排除原型链上的属性
if(obj.hasOwnProperty(key)){
  console.log(key,obj[key]);
}
}
//x 100
//y 200
//z 300
</code></pre><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>6.如何准确判断一个变量是数组函数</p>
<pre><code>var arr =[]
arr instanceofArraytypeof arr //object, typeof 是无法判断是否是数组的
</code></pre><p>7.写一个原型链继承的例子</p>
<pre><code>function Elem(id) {
  this.elem = document.getElementById(id)
}

Elem.prototype.html = function (val) {
  var elem = this.elem
  if (val) {
    elem.innerHTML = val
    return this
  } else {
    return elem.innerHTML
  }
}

Elem.prototype.on = function (type, fn) {
  var elem = this.elem
  elem.addEventListener(type, fn)
  return this
}

var div1 = new Elem(&#39;wrapper&#39;)
div1.html(&#39;&lt;p&gt;hello&lt;/p&gt;&#39;).on(&#39;click&#39;, function () {
  alert(&#39;clicked&#39;)
}).html(&#39;&lt;p&gt;javascript&lt;/p&gt;&#39;)
</code></pre><p>8.描述new一个对象的过程</p>
<pre><code>//创建一个对象
//this指向这个对象
//执行代码  即对this赋值
//返回this
function Foo(name, age) {
  this.name = name 
  this.age = age
  this.class = &#39;class-1&#39;
  //return this   构造函数最好不要写return
}

var f = new Foo(&#39;zs&#39;, 20)
</code></pre><h2 id="作用域和闭包知识点："><a href="#作用域和闭包知识点：" class="headerlink" title="作用域和闭包知识点："></a>作用域和闭包知识点：</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><pre><code>//执行上下文：当前被执行代码的环境/作用域
console.log(a)
var a = 100

fn(&#39;zs&#39;)
//函数声明
function fn(name) {

  console.log(this)
  console.log(arguments)

  age = 20
  console.log(name, age)
  var age

  bar(100)

  function bar(num) {
    console.log(num)
  }
}
//函数表达式： var fn = function () {}

//在全局代码执行前，会将变量定义和函数声明先提出来
//在函数代码执行前，会将变量定义，函数声明，this，arguments(所有参数的集合)先提出来
</code></pre><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><pre><code>//this的值执行时才能确定
var a = {
  name: &#39;A&#39;,
  fn: function () {
    console.log(this.name)  //这个阶段的this无法确定值
  }
}

a.fn()                  //this === a
a.fn.call({name: &#39;B&#39;})  //this === {name: &#39;B&#39;}
var fn1 = a.fn
fn1()                   //this === window

//作为构造函数执行
function Foo(name) {
  // this = {}
  this.name = name
  // return this
}
var f = new Foo(&#39;zs&#39;)
//作为对象属性执行
var obj = {
  name: &#39;A&#39;,
  printName: function () {
    console.log(this.name)    //这里this就是obj
  }
}
obj.printName
//作为普通函数执行
function fn() {
  console.log(this)       //这里的this就是window
}
fn
//call apply bind
function fn1(name, age) {
  console.log(name)
  console.log(this)       //这里的this是{x:100}
}
fn1.call({x:100}, &#39;zs&#39;, 20)

var fn2h = function fn2(name, age) {
  console.log(name)
  console.log(this)       //这里的this是{y:200}
}.bind({y:200})
fn2(&#39;zs&#39;, 20)
</code></pre><h3 id="作用域-作用域链"><a href="#作用域-作用域链" class="headerlink" title="作用域 作用域链"></a>作用域 作用域链</h3><pre><code>//不断向父级作用域寻找变量的过程形成了作用域链
//没有块级作用域概念
if (true) {
  var name = &#39;zs&#39;
}
console.log(name)

//函数、全局作用域
var a = 10
function fn() {
  var a = 200
  console.log(&#39;fn&#39;, a)
}
console.log(&#39;global&#39;, a)
fn()

var b = 100
function fn() {
  var c = 200

  console.log(b)  //当前作用域没有定义的变量叫做自由变量
  console.log(c)  
}
fn()

var a = 100
function f1() {
  var b = 200
  function f2() {
    var c = 300

    console.log(a)
    console.log(b)
    console.log(c)
  }
  f2()
}
f1()
//哪个作用域定义了f1这个函数,f1的父级作用域就是谁
</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><pre><code>//闭包应用：1.函数作为返回值
function F1() {
  var a = 100

  //返回一个函数  
  return function () {
    console.log(a)     //100
  }
}

//f1得到一个函数
var f1 = F1()
var a = 200
f1()

//2.函数作为参数传递
function F1() {
  var a = 100
  return function() {
    console.log(a)  //100
  }
}

var f1 = F1()

function F2(fn) {
  var a = 200
  fn()
}
F2(f1)
</code></pre><h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><p>9.说一下对变量提升的理解<br>变量定义、函数声明会提前。<br>10.说明this几种不同的使用场景<br>作为构造函数、对象属性、普通函数执行，call apply bind<br>11.创建10个<code>&lt;a&gt;</code>标签，点击时弹出对应序号</p>
<pre><code>var i
  for (i = 0; i &lt; 10; i++) {
    (function (i) {
      var a = document.createElement(&#39;a&#39;)
      a.innerHTML = i + &#39;&lt;br&gt;&#39;
      a.addEventListener(&#39;click&#39;, function (e) {
        e.preventDefault()
        alert(i)
      })
      document.body.appendChild(a)
    })(i)
  }
</code></pre><p>12.如何理解作用域<br>自由变量、作用域链，即自由变量的寻找、闭包的两个场景。<br>13.实际开发中闭包的应用<br>封装变量，收敛权限 案例：</p>
<pre><code>function isFirstLoad() {
  var _list = []
  return function (id) {
    if (_list.indexOf(id) &gt;=0) {
      return false
    } else {
      _list.push(id)
      return true
    }
  }
}

var firstLoad = isFirstLoad()
console.log(firstLoad(10))
console.log(firstLoad(10))
console.log(firstLoad(20))
console.log(firstLoad(20))
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上就是JavaScript中一些常见的变量类型、原型、闭包、作用域面试题及知识点简单总结，会不定期更新，欢迎大家补充。</p>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 前端技术 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器的渲染：过程与原理]]></title>
      <url>/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%EF%BC%9A%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文不是关于浏览器渲染的底层原理或前端优化具体细节的讲解，而是关于浏览器对页面的渲染——这一过程的描述及其背后原理的解释。这是因为前端优化是一个非常庞大且零散的知识集合，一篇文章如果要写优化的具体方法恐怕只能做一些有限的列举。</p>
<p>然而，如果了解清楚浏览器的渲染过程、渲染原理，其实就掌握了指导原则。根据优化原则，可以实现出无数种具体的优化方案，各种预编译、预加载、资源合并、按需加载方案都是针对浏览器渲染习惯的优化。</p>
<h2 id="关键渲染路径"><a href="#关键渲染路径" class="headerlink" title="关键渲染路径"></a><strong>关键渲染路径</strong></h2><p>提到页面渲染，有几个相关度非常高的概念，最重要的是关键渲染路径，其他几个概念都可以从它展开，下面稍作说明。</p>
<p><strong>关键渲染路径（Critical Rendering Path）</strong>是指与当前用户操作有关的内容。例如用户刚刚打开一个页面，首屏的显示就是当前用户操作相关的内容，具体就是浏览器收到 HTML、CSS 和 JavaScript 等资源并对其进行处理从而渲染出 Web 页面。</p>
<p>了解浏览器渲染的过程与原理，很大程度上是为了<strong>优化关键渲染路径</strong>，但优化应该是针对具体问题的解决方案，所以优化没有一定之规。例如为了保障<strong>首屏内容</strong>的最快速显示，通常会提到<strong>渐进式页面渲染</strong>，但是为了渐进式页面渲染，就需要做资源的拆分，那么以什么粒度拆分、要不要拆分，不同页面、不同场景策略不同。具体方案的确定既要考虑体验问题，也要考虑工程问题。</p>
<h2 id="浏览器渲染页面的过程"><a href="#浏览器渲染页面的过程" class="headerlink" title="浏览器渲染页面的过程"></a><strong>浏览器渲染页面的过程</strong></h2><p>从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面<a href="http://link.funteas.com/?target=https%3A%2F%2Flink.juejin.im%3Ftarget%3Dhttp%253A%252F%252Flink.zhihu.com%252F%253Ftarget%253Dhttps%25253A%252F%252Fdevelopers.google.com%252Fspeed%252Fdocs%252Finsights%252Fmobile" target="_blank" rel="external">五件事情</a> 上：</p>
<ol>
<li>DNS 查询</li>
<li>TCP 连接</li>
<li>HTTP 请求即响应</li>
<li>服务器响应</li>
<li>客户端渲染</li>
</ol>
<p>本文讨论第五个部分，即浏览器对内容的渲染，这一部分（渲染树构建、布局及绘制），又可以分为下面<a href="http://link.funteas.com/?target=https%3A%2F%2Flink.juejin.im%3Ftarget%3Dhttp%253A%252F%252Flink.zhihu.com%252F%253Ftarget%253Dhttps%25253A%252F%252Fdevelopers.google.com%252Fweb%252Ffundamentals%252Fperformance%252Fcritical-rendering-path%252Frender-tree-construction" target="_blank" rel="external">五个步骤</a> ：</p>
<ol>
<li>处理 HTML 标记并构建 DOM 树。</li>
<li>处理 CSS 标记并构建 CSSOM 树。</li>
<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>
<li>根据渲染树来布局，以计算每个节点的几何信息。</li>
<li>将各个节点绘制到屏幕上。</li>
</ol>
<p>需要明白，这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM，下面就来看看它们的影响方式。</p>
<h2 id="阻塞渲染：CSS-与-JavaScript"><a href="#阻塞渲染：CSS-与-JavaScript" class="headerlink" title="阻塞渲染：CSS 与 JavaScript"></a><strong>阻塞渲染：CSS 与 JavaScript</strong></h2><p>谈论资源的阻塞时，我们要清楚，现代浏览器总是并行加载资源。例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。</p>
<p>同时，由于下面两点：</p>
<ol>
<li>默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。</li>
<li>JavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性。</li>
</ol>
<p>存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外：</p>
<ol>
<li>当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。</li>
<li>JavaScript 可以查询和修改 DOM 与 CSSOM。</li>
<li>CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。</li>
</ol>
<p>所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：</p>
<ol>
<li>CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。</li>
<li>JavaScript 应尽量少影响 DOM 的构建。</li>
</ol>
<p>浏览器的发展日益加快（目前的 Chrome 官方稳定版是 61），具体的渲染策略会不断进化，但了解这些原理后，就能想通它进化的逻辑。下面来看看 CSS 与 JavaScript 具体会怎样阻塞资源。</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a><strong>CSS</strong></h2><pre><code>&lt;style&gt; p { color: red;}&lt;/style&gt;&lt;linkrel=&quot;stylesheet&quot;href=&quot;index.css&quot;&gt;
</code></pre><p>这样的 link 标签（无论是否 inline）会被视为阻塞渲染的资源，浏览器会优先处理这些 CSS 资源，直至 CSSOM 构建完毕。</p>
<p>渲染树（Render-Tree）的关键渲染路径中，要求同时具有 DOM 和 CSSOM，之后才会构建渲染树。即，HTML 和 CSS 都是阻塞渲染的资源。HTML 显然是必需的，因为包括我们希望显示的文本在内的内容，都在 DOM 中存放，那么可以从 CSS 上想办法。</p>
<p>最容易想到的当然是<strong>精简 CSS 并尽快提供它</strong>。除此之外，还可以用媒体类型（media type）和媒体查询（media query）来解除对渲染的阻塞。</p>
<pre><code>&lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;
&lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 30em) and (orientation: landscape)&quot;&gt;
</code></pre><p>第一个资源会加载并阻塞。<br>第二个资源设置了媒体类型，会加载但不会阻塞，print 声明只在打印网页时使用。<br>第三个资源提供了媒体查询，会在符合条件时阻塞渲染。</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><strong>JavaScript</strong></h2><p>JavaScript 的情况比 CSS 要更复杂一些。观察下面的代码：</p>
<pre><code>&lt;p&gt;Do not go gentle into that good night,&lt;/p&gt;
&lt;script&gt;console.log(&quot;inline&quot;)&lt;/script&gt;
&lt;p&gt;Old age should burn and rave at close of day;&lt;/p&gt;
&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;
&lt;p&gt;Rage, rage against the dying of the light.&lt;/p&gt;

&lt;p&gt;Do not go gentle into that good night,&lt;/p&gt;
&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;
&lt;p&gt;Old age should burn and rave at close of day;&lt;/p&gt;
&lt;script&gt;console.log(&quot;inline&quot;)&lt;/script&gt;
&lt;p&gt;Rage, rage against the dying of the light.&lt;/p&gt;
</code></pre><p>这样的 script 标签会阻塞 HTML 解析，无论是不是 inline-script。上面的 P 标签会从上到下解析，这个过程会被两段 JavaScript 分别打算一次（加载、执行）。</p>
<p>所以实际工程中，我们常常将资源放到文档底部。</p>
<h2 id="改变阻塞模式：defer-与-async"><a href="#改变阻塞模式：defer-与-async" class="headerlink" title="改变阻塞模式：defer 与 async"></a><strong>改变阻塞模式：defer 与 async</strong></h2><p>为什么要将 script 加载的 defer 与 async 方式放到后面呢？因为这两种方式是的出现，全是由于前面讲的那些阻塞条件的存在。换句话说，defer 与 async 方式可以改变之前的那些阻塞情形。</p>
<p>首先，注意 async 与 defer 属性对于 inline-script 都是无效的，所以下面这个示例中三个 script 标签的代码会从上到下依次执行。</p>
<pre><code>&lt;!-- 按照从上到下的顺序输出 1 2 3 --&gt;
&lt;script async&gt;
  console.log(&quot;1&quot;);
&lt;/script&gt;
&lt;script defer&gt;
  console.log(&quot;2&quot;);
&lt;/script&gt;
&lt;script&gt;
  console.log(&quot;3&quot;);
&lt;/script&gt;
</code></pre><p>故，下面两节讨论的内容都是针对设置了 src 属性的 script 标签。</p>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a><strong>defer</strong></h2><pre><code>&lt;script src=&quot;app1.js&quot; defer&gt;&lt;/script&gt;
&lt;script src=&quot;app2.js&quot; defer&gt;&lt;/script&gt;
&lt;script src=&quot;app3.js&quot; defer&gt;&lt;/script&gt;
</code></pre><p>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</p>
<p>defer 不会改变 script 中代码的执行顺序，示例代码会按照 1、2、3 的顺序执行。所以，defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。</p>
<h2 id="async"><a href="#async" class="headerlink" title="async"></a><strong>async</strong></h2><pre><code>&lt;script src=&quot;app.js&quot; async&gt;&lt;/script&gt;
&lt;script src=&quot;ad.js&quot; async&gt;&lt;/script&gt;
&lt;script src=&quot;statistics.js&quot; async&gt;&lt;/script&gt;
</code></pre><p>async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</p>
<p>从上一段也能推出，多个 async-script 的执行顺序是不确定的。值得注意的是，向 document 动态添加 script 标签时，async 属性默认是 true，下一节会继续这个话题。</p>
<h2 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement"></a><strong>document.createElement</strong></h2><p>使用 document.createElement 创建的 script 默认是异步的，示例如下。</p>
<pre><code>console.log(document.createElement(&quot;script&quot;).async);// true
</code></pre><p>所以，通过动态添加 script 标签引入 JavaScript 文件默认是不会阻塞页面的。如果想同步执行，需要将 async 属性人为设置为 false。</p>
<p>如果使用 document.createElement 创建 link 标签会怎样呢？</p>
<pre><code>const style = document.createElement(&quot;link&quot;);
style.rel = &quot;stylesheet&quot;;
style.href = &quot;index.css&quot;;
document.head.appendChild(style); // 阻塞？
</code></pre><p>其实这只能通过试验确定，已知的是，Chrome 中已经<a href="http://link.funteas.com/?target=https%3A%2F%2Flink.juejin.im%3Ftarget%3Dhttp%253A%252F%252Flink.zhihu.com%252F%253Ftarget%253Dhttps%25253A%252F%252Fbugs.chromium.org%252Fp%252Fchromium%252Fissues%252Fdetail%25253Fid%25253D571725" target="_blank" rel="external">不会阻塞渲染</a> ，Firefox、IE 在以前是阻塞的，现在会怎样我没有试验。</p>
<h2 id="document-write-与-innerHTML"><a href="#document-write-与-innerHTML" class="headerlink" title="document.write 与 innerHTML"></a><strong>document.write 与 innerHTML</strong></h2><p>通过 document.write 添加的 link 或 script 标签都相当于添加在 document 中的标签，因为它操作的是 document stream（所以对于 loaded 状态的页面使用 document.write 会自动调用 document.open，这会覆盖原有文档内容）。即正常情况下， link 会阻塞渲染，script 会同步执行。不过这是不推荐的方式，Chrome 已经会显示警告，提示未来有可能禁止这样引入。如果给这种方式引入的 script 添加 async 属性，Chrome 会检查是否同源，对于非同源的 async-script 是不允许这么引入的。</p>
<p>如果使用 innerHTML 引入 script 标签，其中的 JavaScript 不会执行。当然，可以通过 eval() 来手工处理，不过不推荐。如果引入 link 标签，我试验过在 Chrome 中是可以起作用的。另外，outerHTML、insertAdjacentHTML() 应该也是相同的行为，我并没有试验。这三者应该用于文本的操作，即只使用它们添加 text 或普通 HTML Element。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p><a href="http://link.funteas.com/?target=https%3A%2F%2Flink.juejin.im%3Ftarget%3Dhttp%253A%252F%252Flink.zhihu.com%252F%253Ftarget%253Dhttps%25253A%252F%252Fdevelopers.google.com%252Fspeed%252Fdocs%252Finsights%252Fmobile" target="_blank" rel="external">Mobile Analysis in PageSpeed Insights</a> </p>
<p><a href="http://link.funteas.com/?target=https%3A%2F%2Flink.juejin.im%3Ftarget%3Dhttp%253A%252F%252Flink.zhihu.com%252F%253Ftarget%253Dhttps%25253A%252F%252Fdevelopers.google.com%252Fweb%252Ffundamentals%252F" target="_blank" rel="external">Web Fundamentals</a> </p>
<p><a href="http://link.funteas.com/?target=https%3A%2F%2Flink.juejin.im%3Ftarget%3Dhttp%253A%252F%252Flink.zhihu.com%252F%253Ftarget%253Dhttps%25253A%252F%252Fdeveloper.mozilla.org%252Fen-US%252Fdocs%252FWeb%252FHTML%252FElement%252Fscript" target="_blank" rel="external">MDN - HTML element reference</a> </p>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack构建react项目]]></title>
      <url>/webpack%E6%9E%84%E5%BB%BAreact%E9%A1%B9%E7%9B%AE.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在书写文章之前，我假设大家已经有了 <code>JavaScript</code>，<code>Node 包管理工具</code>，<code>Linux 终端操作</code> 这些基本技能，接下来，我将一步一步指引大家从头搭建一个 <code>React</code> 项目</p>
<h2 id="重新回顾-Webpack-Babel-和-React"><a href="#重新回顾-Webpack-Babel-和-React" class="headerlink" title="重新回顾 Webpack, Babel 和 React"></a>重新回顾 Webpack, Babel 和 React</h2><h2 id="最终实现的效果"><a href="#最终实现的效果" class="headerlink" title="最终实现的效果"></a>最终实现的效果</h2><p>我们将使用 <code>Webpack</code> 和 <code>Babel</code> 搭建一个 <code>React</code> 应用，我们的目的很清晰，就是 <code>更好的理解和掌握这些工具的使用</code></p>
<p>我们创建的应用程序既要做到 <code>最小</code>，也要遵循 <code>最佳实践</code>，为不是特别熟练的同学巩固一下基础</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>创建你的项目，并添加的你的配置文件 <code>package.json</code></p>
<pre><code>mkdir webpack-babel-react-revisited
cd webpack-babel-react-revisited

yarn init
</code></pre><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>我们首先安装 <code>Webpack</code>，它是目前非常流行的 <code>模块打包器</code>，它将应用程序包含的每个模块打包成少量的 <code>块</code>，以便这些代码从服务器加载到浏览器中</p>
<pre><code>yarn add webpack --dev
</code></pre><p>接下来，我们开始书写一些模块。我们将源文件 <code>app.js</code> 保存到 <code>src</code> 目录中</p>
<pre><code>/** app.js */

console.log(&#39;Hello from 枫上雾棋!&#39;);
</code></pre><p>然后，我们跑一下 <code>Webpack</code></p>
<pre><code>./node_modules/webpack/bin/webpack.js ./src/app.js --output-filename ./dist/app.bundle.js
</code></pre><p>如果你打开生成的 <code>app.bundle.js</code>，你会发现上面是 <code>webpack</code> 的模块处理代码，下面是我们书写的 <code>console.log</code></p>
<p>这条指令是将我们的 <code>app.js</code> 作为 <code>Webpack</code> 的 <code>入口文件</code>，将结果输出到 <code>dist</code> 文件夹中，指令有些冗长，在实际开发中，我们使用 <code>webpack</code> 配置文件来代替，为了文档结构看起来更加清晰，参考 <code>目录</code> 如下</p>
<pre><code>├── config
│├── paths.js
│├── webpack.config.prod.js
├── src
│├── app.js
├──package.json
</code></pre><p>下面是参考 <code>配置</code></p>
<p><code>paths.js</code></p>
<pre><code>const path = require(&#39;path&#39;);
const fs = require(&#39;fs&#39;);

const appDirectory = fs.realpathSync(process.cwd());
const resolveApp = relativePath =&gt; path.resolve(appDirectory, relativePath);

module.exports = {
  appDist: resolveApp(&#39;dist&#39;),
  appSrc: resolveApp(&#39;src&#39;),
};
</code></pre><p>这个文件不是必须的，但在项目增大后，它的意义就瞬间出来了</p>
<p><code>webpack.config.prod.js</code></p>
<pre><code>const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

const paths = require(&#39;./paths&#39;);

const plugins = [
  new HtmlWebpackPlugin({
    title: &#39;webpack babel react revisited&#39;,
    filename: path.join(paths.appDist, &#39;index.html&#39;),
  }),
];

const config = {
  entry: {
    app: path.join(paths.appSrc, &#39;app&#39;),
  },
  output: {
    path: paths.appDist,
    filename: &#39;assets/js/[name].js&#39;,
  },
  resolve: {
    extensions: [&#39;.js&#39;, &#39;.jsx&#39;],
  },
  plugins,
};

module.exports = config;
</code></pre><p>这里我们还添加了一个 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fjantimon%2Fhtml-webpack-plugin" target="_blank" rel="external">html-webpack-plugin</a> ，它简化了我们 <code>HTML</code> 文件的创建，安装我们就不再这里赘述了，如果还不知道的同学可以点击链接查看</p>
<p>其中，我们还使用了一个 <code>语法糖</code>，这样在我们导入 <code>.js</code>，<code>.jsx</code> 时就不需要指定扩展名了</p>
<p>接下来，我们指定配置文件再跑一下 <code>Webpack</code></p>
<pre><code>./node_modules/webpack/bin/webpack.js --config config/webpack.config.prod.js
</code></pre><p>发现除了实现上面的效果外，还自动帮我们生成了一个 <code>index.html</code>，我们可以点击这个 <code>html</code>，在控制台中查看效果，相比上面，是不是方便了很多</p>
<p>当然，最后我们肯定也不是使用这种方式来 <code>build</code>，打开 <code>package.json</code>，添加如下 <code>脚本命令</code>，然后执行 <code>yarn build</code>，是不是瞬间感觉 <code>nice</code> 了很多</p>
<pre><code>&quot;scripts&quot;: {
  &quot;clean&quot;: &quot;rimraf dist *.log .DS_Store&quot;,
  &quot;build&quot;: &quot;yarn run clean &amp;&amp; webpack --config config/webpack.config.prod.js --progress&quot;
}
</code></pre><pre><code>const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const OpenBrowserPlugin = require(&#39;open-browser-webpack-plugin&#39;);

const paths = require(&#39;./paths&#39;);

const hostname = process.env.HOST || &#39;localhost&#39;;
const port = process.env.PORT || 3000;

const plugins = [
  new HtmlWebpackPlugin({
    title: &#39;webpack babel react revisited&#39;,
    filename: path.join(paths.appDist, &#39;index.html&#39;),
  }),
  new OpenBrowserPlugin({ url: `http://${hostname}:${port}` }),
];

const config = {
  entry: {
    app: path.join(paths.appSrc, &#39;app&#39;),
  },
  output: {
    path: paths.appDist,
    filename: &#39;assets/js/[name].js&#39;,
  },
    resolve: {
    extensions: [&#39;.js&#39;, &#39;.jsx&#39;],
  },
  plugins,
  devServer: {
    contentBase: paths.appDist,
    compress: true,
    port,
  },
};

module.exports = config;
</code></pre><p>在 <code>webpack.config.prod.js</code> 的基础上，我们增加了 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fbaldore%2Fopen-browser-webpack-plugin" target="_blank" rel="external">open-browser-webpack-plugin</a>  插件和 <code>devServer</code> 配置，<code>open-browser-webpack-plugin</code> 插件顾名思义，会帮我们自动打开 <code>dev server</code> 最后返回给我们的地址</p>
<p>更新 <code>package.json</code></p>
<pre><code>&quot;scripts&quot;: {
  &quot;clean&quot;: &quot;rimraf dist *.log .DS_Store&quot;,
  &quot;webpack:dev&quot;:
    &quot;NODE_ENV=development webpack-dev-server --config config/webpack.config.dev.js --progress&quot;,
  &quot;webpack:prod&quot;:
    &quot;NODE_ENV=production webpack --config config/webpack.config.prod.js --progress&quot;,
  &quot;start&quot;: &quot;yarn run clean &amp;&amp; yarn run webpack:dev&quot;,
  &quot;build&quot;: &quot;yarn run clean &amp;&amp; yarn run webpack:prod&quot;
}
</code></pre><p>现在，我们就可以通过如下方式来启动</p>
<pre><code>yarn start
</code></pre><p>启动后，有没有瞬间感觉很棒</p>
<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>为了能够使用 <code>ES6</code> 以及更高版本，我们需要一个 <code>转换编译器</code>，我们选择 <code>Babel</code>，它能将 <code>ES6</code> 转换成可以在浏览器中运行的代码，除此之外，他还内置了 <code>React JSX</code> 扩展，可以说它的出现推动了 <code>JavaScipt</code> 的发展</p>
<p>所有，我们安装下面这些依赖包</p>
<pre><code>yarn add --dev babel-loader babel-core babel-preset-env babel-preset-react
</code></pre><p>创建 <code>Babel</code> 默认配置文件 <code>.babelrc</code></p>
<pre><code>{&quot;presets&quot;:[&quot;env&quot;,&quot;react&quot;]}
</code></pre><p>这个是告诉 <code>Babel</code> 用我们刚刚安装的两个 <code>presets</code></p>
<p>接下来，更新 <code>webpack</code> 配置文件</p>
<pre><code>config.module = {
  rules: [
    {
      test: /\.(js|jsx)$/,
      exclude: /node_modules/,
      use: [&#39;babel-loader&#39;],
    },
  ],
}
</code></pre><p>更新以后，虽然看不到什么变化，但事实上我们可以使用 <code>ES6</code> 了</p>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>最后，我们来添加 <code>React</code>，这也可能是你阅读这篇文章的原因</p>
<p>首先，我们还是先安装它</p>
<pre><code>yarn add react react-dom
</code></pre><p>用下面代码替换 <code>console.log</code></p>
<pre><code>import React, { Component } from &#39;react&#39;;
import { render } from &#39;react-dom&#39;;

export default class Hello extends Component {
  render() {
    return &lt;h1&gt;Hello from 枫上雾棋!&lt;/h1&gt;;
  }
}

render(&lt;Hello /&gt;, document.getElementById(&#39;app&#39;));
</code></pre><p>因为要添加 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，所以我们要修改一下 <code>html-webpack-plugin</code> 的配置</p>
<pre><code>new HtmlWebpackPlugin({
  template: path.join(paths.appSrc, &#39;index.html&#39;),
}),
</code></pre><p>参考 <code>template</code> 如下</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;
    &lt;title&gt;webpack babel react revisited&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;noscript&gt;
      You need to enable JavaScript to run this app.
    &lt;/noscript&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>接下来，就是见证奇迹的时刻</p>
<p>重新启动服务，你有没有发现搭建一个 <code>React</code> 应用程序就这么简单</p>
<p>接下里，大家就可以 <code>自行探索</code>，添加更多的东西来适应自身应用程序的需要</p>
<p>下面再补充一下如何添加 <code>CSS</code> 和 <code>图片</code></p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>每个 web 应用程序都离不开 <code>CSS</code>，我们在 <code>src</code> 目录中创建 <code>style.css</code></p>
<pre><code>body,
html,
#app {
  margin: 0;
  width: 100%;
  height: 100%;
}

#app {
  padding: 30px;
  font-family: &#39;微软雅黑&#39;;
}
</code></pre><p>将其添加到应用程序中我们需要使用 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fcss-loader" target="_blank" rel="external">css-loader</a> </p>
<p>如果想将 <code>css</code> 注入 <code>style</code> 标签中，我们还需要 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fstyle-loader" target="_blank" rel="external">style-loader</a> ，通常，是将这两个结合使用</p>
<p>我们使用 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fextract-text-webpack-plugin" target="_blank" rel="external">extract-text-webpack-plugin</a>  将其解压到外部</p>
<p>为此，我们首先安装</p>
<pre><code>yarn add --dev css-loader style-loader extract-text-webpack-plugin
</code></pre><p>然后在 <code>app.js</code> 中导入 <code>style.css</code></p>
<pre><code>import&#39;./style.css&#39;;
</code></pre><p>最后更新 <code>webpack</code> 配置文件</p>
<pre><code>config.module = {
  rules: [
    {
      test: /\.css$/,
      use: ExtractTextPlugin.extract({
        fallback: &#39;style-loader&#39;,
        use: &#39;css-loader&#39;,
      }),
    },
  ],
}

config.plugins.push([
  new ExtractTextPlugin(&quot;styles.css&quot;),
])
</code></pre><p>看起来稍显复杂，但是大功告成，为了更好地使用它，我们都得经历这个过程</p>
<p>重新启动服务，你会发现你的 <code>dist</code> 目录中多了一个 <code>styles.css</code></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>最后我们增加 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Ffile-loader" target="_blank" rel="external">file-loader</a>  来处理我们引入的图片等文件</p>
<p>首先，安装 <code>file-loader</code></p>
<pre><code>yarn add --dev file-loader
</code></pre><p>我们在 <code>src/images</code> 中放入一张图片，在 <code>app.js</code> 中导入</p>
<pre><code>import avatar from &#39;./images/avatar.jpg&#39;;

export default class Hello extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;img src={avatar} alt=&quot;avatar&quot; style={{ width: 400, height: 250 }} /&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre><p>更新 <code>webpack</code> 配置文件</p>
<pre><code>config.module = {
  rules: [
    {
      test: /\.(png|jpg|gif)$/,
      use: [
        {
          loader: &#39;file-loader&#39;,
          options: {
            name: &#39;[name].[ext]&#39;,
            outputPath: &#39;assets/images/&#39;,
          },
        },
      ],
    },
  ],
}
</code></pre><p>重启服务，哈哈</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如果有什么问题，可以查看 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2FFengShangWuQi%2Fwebpack-babel-react-revisited" target="_blank" rel="external">webpack-babel-react-revisited</a>  仓库</p>
<p>现在，大家对搭建 <code>React</code> 应用程序是不是感觉轻松了很多，但 <code>React</code> 整个技术栈并不止包括这些，还有 <code>Redux</code>，<code>React Router</code>，<code>单元测试</code>，<code>代码校验</code> 等内容，关于 <code>React</code> 其他内容，欢迎查看日志其他文章</p>
]]></content>
      
        <categories>
            
            <category> react </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS实现常用算法]]></title>
      <url>/JS%E5%AE%9E%E7%8E%B0%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目标：总结本书主要内容，相应算法使用js来模仿实现</p>
<blockquote>
<p>在计算机科学领域，我们用算法这个词来描述一种有限、确定、有效的并适合用计算机程序来实现的解决问题的方法。</p>
<p>我们关注的大多数算法都需要<code>适当地组织数据</code>，而为了组织数据就产生了<code>数据结构</code></p>
</blockquote>
<p><strong>原书所有代码是基于JAVA语法的，这里，我们使用js来实现所有算法逻辑</strong></p>
<h2 id="队列、栈的实现"><a href="#队列、栈的实现" class="headerlink" title="队列、栈的实现"></a>队列、栈的实现</h2><blockquote>
<p>队列是一种先进先出的集合类型，栈是一种先进后出的集合类型</p>
</blockquote>
<p>首先定义要实现的队列、栈的API<br><strong>Queue</strong>说明Queue()创建空队列enqueue(item)添加一个元素dequeue()删除最近添加的元素isEmpty()队列是否为空size（）队列中元素的数量iterator()返回一个可迭代对象</p>
<p><strong>Stack</strong>说明Stack()创建空栈push(item)添加一个元素pop()删除最近添加的元素isEmpty()栈是否为空size（）栈中元素的数量iterator()返回一个可迭代对象</p>
<p>Iterator说明hasNext()是否还有下一个元素next()返回下一个元素<br>由于JS语言的特殊性，采用数组的方式来实现队列、栈是非常容易的,js中数组本来就提供了从头部插入、删除元素，从尾部插入、删除元素的功能。这里只需要简单的封装一下(js的弱类型特点，不需要像JAVA那样采用泛型来声明可以储存任意类型的数据，同时，js中数组是不定长的，可以动态扩展)</p>
<p><strong>实现</strong></p>
<p>队列的数组方式实现，并模拟可迭代功能</p>
<pre><code>    function Queue() {
    this.container = []
}
Queue.prototype.enqueue = function (ele) {
    this.container.push(ele)
}
Queue.prototype.dequeue = function () {
    return this.container.shift()
}
Queue.prototype.isEmpty = function () {
    return !this.container.length
}
Queue.prototype.size = function () {
    return this.container.length
}

Queue.prototype.iterator = function () {
    var container = this.container
    var current = 0
    return {
        hasNext: function () {
            return current !== container.length
        },
        next: function () {
            return container[current++]
        }
    }
}

用例:
var Qu = new Queue()
Qu.enqueue(&#39;to&#39;)
Qu.enqueue(&#39;be&#39;)
Qu.enqueue(&#39;or&#39;)
Qu.enqueue(&#39;not&#39;)
Qu.dequeue()
var iterator = Qu.iterator()
while (iterator.hasNext()) {
    console.log(iterator.next())
}
输出:
be
or
not
</code></pre><p>栈的数组方式实现，并模拟可迭代功能</p>
<pre><code>class Stack {

    constructor() {
        this.container = []
    }

    push(ele) {
        this.container.unshift(ele)
    }

    pop() {
        return this.container.shift()
    }

    isEmpty() {
        return !this.container.length
    }
    size() {
        return this.container.length
    }

    iterator() {
        const container = this.container
        let current = 0
        return {
            hasNext: function () {
                return current !== container.length
            },
            next: function () {
                return container[current++]
            }
        }
    }

}
用例:
var St = new Stack()
Stack.push(&#39;to&#39;)
Stack.push(&#39;be&#39;)
Stack.push(&#39;or&#39;)
Stack.push(&#39;not&#39;)
Stack.pop()
var iterator = Stack.iterator()
while (iterator.hasNext()) {
    console.log(iterator.next())
}
输出:
or
be
to
</code></pre><blockquote>
<p>链表是一种递归的数据结构，它或者为空(null)，或者是指向一个结点(node)的引用，该结点含有一个泛型的元素和一个指向另一个链表的引用。</p>
</blockquote>
<p>在这个定义中，结点是一个可能含有任意类型数据的抽象实体，它所包含的指向结点的应用显示了它在构造链表之中的作用。</p>
<p>结点表示:</p>
<pre><code> function Node(){
        this.item=null
        this.next=null
    }
</code></pre><p>构造链表：</p>
<p><img src="https://img.funteas.com/ee445ad64319177f007f2a53102cbb29?imageView2/2/w/800" alt=""></p>
<p>在表头插入结点</p>
<pre><code>var oldFirst=first
    first=new Node()
    first.next=oldFirst
</code></pre><p>从表头删除结点</p>
<pre><code>first=first.next
</code></pre><p>从表尾插入结点</p>
<pre><code> var oldlast=last
    lst=new Node()
    oldlast.next=last
</code></pre><blockquote>
<p>实现任意插入和删除操作的标准解决方案是双向链表，其中每个结点都含有两个链接，分别指向不同的方向</p>
</blockquote>
<pre><code>function Node(item) {
    this.item = item
    this.next = null
}

function Stack() {
    this.count = 0 //元素数量
    this.first = null //指向栈顶
}

Stack.prototype.isEmpty = function () {
    return this.first == null
}
Stack.prototype.size = function () {
    return this.count
}
Stack.prototype.push = function (ele) {
    var oldfirst = this.first
    var newnode = new Node(ele)
    newnode.next = oldfirst
    this.first = newnode
    this.count++
}
Stack.prototype.pop = function () {
    var ele = this.first.item
    this.first = this.first.next
    this.count--
    return ele
}
Stack.prototype.iterator = function () {
    var firstnode = this.first
    var count = this.count
    return {
        hasNext: function () {
            return  count
        },
        next: function () {
            var ele=firstnode.item
            firstnode=firstnode.next
            count--
            return ele
        }
    }
}
用例：
var stack=new Stack()
stack.push(&#39;to&#39;)
stack.push(&#39;be&#39;)
stack.push(&#39;or&#39;)
stack.push(&#39;not&#39;)
stack.push(&#39;to&#39;)
stack.push(&#39;be&#39;)
console.log(stack.size())
var iterator=stack.iterator()
while(iterator.hasNext()){
    console.log(iterator.next())
}
输出：
6
be
to
not
or
be
to
</code></pre><blockquote>
<p>将链表表示为一条从最早插入的元素到最近插入的元素的链表，实例变量first指向队列的开头，last指向队列的结尾。这样，要讲一个元素入列，就将它添加到表尾，要将一个元素出列，就删除表头的结点.</p>
</blockquote>
<pre><code>function Node(item) {
    this.item = item
    this.next = null
}

class Queue {

    constructor() {
        this.first = null
        this.last = null
        this.count = 0
    }

    isEmpty() {
        return this.first == null
    }
    size() {
        return this.count
    }
    enqueue(item) {
        const oldlast = this.last
        const last = new Node(item)
        this.last = last
        if (this.isEmpty()) {
            this.first = last
        } else {
            oldlast.next = last
        }
        this.count++
    }
    dequeue() {
        const ele = this.first.item
        this.first = this.first.next
        if (this.isEmpty()) {
            this.last = null
        }
        this.count--
        return ele
    }
    iterator() {
        let firstnode = this.first
        let count = this.count
        return {
            hasNext: function () {
                return count
            },
            next: function () {
                var ele = firstnode.item
                firstnode = firstnode.next
                count--
                return ele
            }
        }
    }
}
用例:
const queue=new Queue()
queue.enqueue(&#39;to&#39;)
queue.enqueue(&#39;be&#39;)
queue.enqueue(&#39;or&#39;)
queue.enqueue(&#39;not&#39;)
queue.enqueue(&#39;to&#39;)
queue.enqueue(&#39;be&#39;)
queue.dequeue()
console.log(queue.size())
const iterator=queue.iterator()
while(iterator.hasNext()){
    console.log(iterator.next())
}

输出:
5
be
or
not 
to
be
</code></pre><blockquote>
<p>在结构化存储数据集时，链表是数组的一种重要的替代方式，两者都非常基础，常常被称为顺序存储和链式存储。</p>
</blockquote>
<p><img src="https://img.funteas.com/70ac99ef5b679cc727dad3b2b4aa9f86?imageView2/2/w/800" alt=""></p>
<h2 id="常见的时间复杂度的级别"><a href="#常见的时间复杂度的级别" class="headerlink" title="常见的时间复杂度的级别"></a>常见的时间复杂度的级别</h2><p><img src="https://img.funteas.com/baa593fe9ffa490960a5c8acec7f70fa?imageView2/2/w/800" alt=""></p>
<p>问题描述：</p>
<blockquote>
<p>假设所有整数都不相同，统计一个数组中所有和为0的三整数元组的数量</p>
</blockquote>
<pre><code>function threesum(arr){
    var N=arr.length
    var count=0
    for(var i=0;i&lt;N;i++){
        for(var j=i+1;j&lt;N;j++){
            for(var k=j+1;k&lt;N;k++){
                if(arr[i]+arr[j]+arr[k]==0){
                    count++
                }
            }
        }
    }
    return count
}
</code></pre><p>分析：</p>
<p>执行最频繁的指令决定了程序执行的总时间，对上面的threesum算法，最频繁的部分就是if语句判断，它套在三个for循环内，对于给定的N，if语句执行次数为<code>N*(N-1)*(N-2)/6=N^3/6-N^2/2+N/3</code>,当N很大时，首项后的其他项都相对较小可以忽略，所以if语句的执行次数约等于<code>N^3/6</code>,表示为(~N^3/6)</p>
<p>所以暴力算法的threesum执行用时的增长数量级为<code>N^3</code></p>
<blockquote>
<p>学习程序的增长数量级的一个重要动力是为了帮助我们为同一个问题设计更快的算法</p>
</blockquote>
<p>改进后的算法的思路是：当且仅当-( a[i]+a[j] )在数组中( 不是a[i]也不是a[j] )时,整数对( a[i]和a[j] )为某个和为0的三元组的一部分。要解决这个问题，首先对数组进行排序(为二分查找做准备),然后对数组中的每个a[i]+a[j],使用二分查找算法对-(a[i]+a[j])进行二分查找，如果结果为k，且k&gt;j,则count加一。</p>
<p>下面中的代码会将数组排序并进行N*(N-1)/2次二分查找，每次查找所需的时间都和logN成正比，因此总的运行时间和N^2logN成正比。</p>
<pre><code>//二分查找
function binarySearch(key, arr) {
    var start = 0
    var end = arr.length - 1
    while (start &lt;= end) {
        var mid = start + Math.floor((end - start) / 2)
        if (key &lt; arr[mid]) {
            end = mid - 1
        } else if (key &gt; arr[mid]) {
            start = mid + 1
        } else {
            return mid
        }
    }
    return -1
}

function threesum(arr) {
    var N = arr.length
    var count = 0
    arr = arr.sort(function (a, b) {
        return a &gt; b ? 1 : -1
    })
    for (var i = 0; i &lt; N; i++) {
        for (var j = i + 1; j &lt; N; j++) {
            if (binarySearch(-arr[i] - arr[j], arr) &gt; j) {
                count++
            }
        }
    }
    return count
}
</code></pre><p><img src="https://img.funteas.com/86e3c247a4e4a51fa7d20afcbac520b3?imageView2/2/w/800" alt=""></p>
<h2 id="案例研究-union-find算法"><a href="#案例研究-union-find算法" class="headerlink" title="案例研究:union-find算法"></a>案例研究:union-find算法</h2><h3 id="动态连通性问题"><a href="#动态连通性问题" class="headerlink" title="动态连通性问题"></a>动态连通性问题</h3><p>首先我们详细说明一下问题</p>
<blockquote>
<p>问题的输入是一列整数对，对于一对整数p,q,如果p,q不相连，则将p,q连接</p>
</blockquote>
<p>所谓的相连:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 自反性: p与p是相连的</li>
<li style="list-style: none"><input type="checkbox" checked> 对称性: 若p与q是相连的,则q与p是相连的</li>
<li style="list-style: none"><input type="checkbox" checked> 传递性: 若p与q是相连的,且q和r相连，则p与r是相连的</li>
</ul>
<p>我们假设相连的整数构成了一个“集合”,对于新的连接，就是在将新的元素加入“集合”来构成更大的“集合”,若判断p,q是否相连，只要判断p,q是否在同一个“集合”中即可。</p>
<p><img src="https://img.funteas.com/32b475d705dc8beb69db82db1c877b3c?imageView2/2/w/800" alt=""></p>
<blockquote>
<p>这里我们应用动态连通性来处理计算机网络中的主机之间的连通关系</p>
<p>输入中的整数表示的可能是一个大型计算机网络中的计算机，而整数对则表示网络中的连接，这个程序能够判定我们是否需要在p和q之间架设一条新的连接来通信，或是我们可以通过已有的连接在两者之间建立通信线路。</p>
</blockquote>
<p>这里我们使用网络方面的术语，将<code>输入的整数</code>称为<code>触点</code>，将形成的<code>集合</code>称为<code>连通分量</code></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>为了说明问题，我们设计一份API来封装所需的基本操作:初始化、连接两个触点、判断包含某个触点的分量、判断两个触点是否存在于同一个分量之中以及返回所有分量的数量<br>UF说明UF(N)以整数标识（0到N-1）初始化N个触点union(p,q)连接触点p、qfind§返回p所在分量的标识符connected(p,q)判断p,q是否存在于同一个连通分量中count()连通分量的数量<br><strong>我们看到，为解决动态连通性问题设计算法的任务转化成了实现这份API，所有的实现都应该</strong></p>
<p>[x] 定义一种数据结构表示已知的连接</p>
<p>[x] 基于此数据结构实现高效的union()、find()、connected()、count()</p>
<p><strong>我们用一个以触点为索引的数组id[]作为基本数据结构来表示所有分量，我们将使用分量中的某个触点的名称作为分量的标识符</strong></p>
<p>一开始，我们有N个分量，每个触点都构成了一个只含有自己的分量，因此我们将id[i]的值设为i。</p>
<pre><code>class UF {

    /**
     * 
     * @param {number} N 
     */
    constructor(N) {
        this.id = new Array(N).fill(0).map((x, index) =&gt; index)
        this.count = 0
    }

    count(){
        return this.count
    }

    /**
     * 
     * @param {number} p 
     * @param {number} q 
     */
    connected(p,q){
        return this.find(p)===this.find(q)
    }

    /** 
     * @param {number} p 
     */
    find(p){

    }
    /**
     * 
     * @param {number} p 
     * @param {number} q 
     */
    union(p,q){

    }

}
</code></pre><pre><code>**find()和union()是实现的重点,我们将讨论三种不同的实现，它们均根据以触点为索引的id[]数组来确定两个触点是否存在于相同的连通分量中**
</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>思想是:保证当且仅当<code>id[p]==id[q]</code>时，p和q是连通的。换句话说，在同一个连通分量中的所有触点在id[]数组中的值都一样。</p>
<pre><code> /** 
     * @param {number} p 
     */
    find(p){
        return this.id[p]
    }

    /**
     * 
     * @param {number} p 
     * @param {number} q 
     */
    union(p,q){
        var pId=this.find(p)
        var qId=this.find(q)
        if(pId==qId) return
        this.id.forEach(x=&gt;{
            if(id[x]==pId){
                id[x]==qId
            }
        })
        this.count--
    }
</code></pre><p>复杂度分析:</p>
<p>find()操作很快，它只访问id[]数组一次,但union()会整个扫描id[]数组</p>
<p>在union()中,find p、q会访问2次数组，for循环及赋值操作会访问数组 N+1 ~ N+（N-1）次。</p>
<p>所以union()方法访问数组的次数在(2+N+1) ~(2+N+(N-1)) 即 N+3 ~ 2N+1 次之间</p>
<p>假设我们使用quick-union算法来解决动态连通性问题并最后只得到一个连通分量，则至少需要调用(N-1)次 union(),<br>即（N+3）<em>（N-1） ~（2N+1）</em>（N-1）次数组访问</p>
<p>所以此算法的时间复杂度是<code>平方级别的</code></p>
<p>此算法的重点是提高union()方法的速度，它也是基于相同的数据结构–以触点作为索引的id[]数组，但我们赋予这些值的意义不同，我们需要用他们来定义更加复杂的数据结构:</p>
<blockquote>
<p>每个触点所对应的id[]元素都是同一个分量中的另一个触点的名称（也可以说是它自己，即根触点）–我们将这种联系称为链接。</p>
</blockquote>
<pre><code> /** 
     * 找到根触点，即分量的标识符
     * @param {number} p 
     */
    find(p) {
        while (p !== this.id[p]) p = this.id[p]
        return p
    }

    /**
     * 
     * @param {number} p 
     * @param {number} q 
     */
    union(p, q) {
        let pRoot = this.find(p)
        let qRoot = this.find(q)
        if (pRoot == qRoot) return
        id[pRoot] = qRoot
        this.count--
    }
</code></pre><p><img src="https://img.funteas.com/1ac6aaeb8ea65151f887c2e9e8c7e55b?imageView2/2/w/800" alt=""></p>
<p>如图所示：id[]数组用父链接的形式表示了一片森林</p>
<p>复杂度分析：</p>
<blockquote>
<p>一棵树的大小是它的节点的数量，树中一个节点的深度是它到根节点路径上的链接数</p>
</blockquote>
<p>quick-union算法的分析依赖于输入的特点，find()访问数组的次数为1加上给定的触点所对应的节点的深度的2倍。</p>
<p>在最好的情况下，find()只需要访问数组1次就能够得到当前触点所在分量的标识符</p>
<p>在最坏的情况下，find()需要1 + 2*(N-1) 即 2N-1 次数组访问</p>
<p>如下图所示</p>
<p><img src="https://img.funteas.com/46d986d30409f03990188874ac65fef2?imageView2/2/w/800" alt=""></p>
<p>对最坏的情况，处理N对整数所需的所有find()操作访问数组的总次数为:</p>
<p>等差数列 (1+ 2N-1) *N /2 = N^2,即<code>在最差的情况下，quick-union算的复杂度为平方级的</code></p>
<p>union()访问数组的次数是两次find()操作，(如果union中给定的两个触点在不同的分量还要加1)</p>
<p>由此，我们构造了一个最佳情况的输入使得算法的运行时间是线性的，最差情况的输入使得算法的运行时间是平方级的。</p>
<ul>
<li>加权 quick-union算法 (控制树的深度)</li>
</ul>
<blockquote>
<p>与其在union()中随意将一颗树连接到另一棵树，我们现在会记录每一颗树的大小并总是将较小的树连接到较大的树上。</p>
</blockquote>
<p><img src="https://img.funteas.com/a8309189a668bb00186e3ff92c355c5e?imageView2/2/w/800" alt=""></p>
<pre><code>class UF {

    /**
     * 
     * @param {number} N 
     */
    constructor(N) {
        this.id = new Array(N).fill(0).map((x, index) =&gt; index)
        //各个根节点所对应的分量的大小
        this.sz = new Array(N).fill(1)
        this.count = 0
    }

    count() {
        return this.count
    }

    /**
     * 
     * @param {number} p 
     * @param {number} q 
     */
    connected(p, q) {
        return this.find(p) === this.find(q)
    }

    /** 
     * 找到根触点，即分量的标识符
     * @param {number} p 
     */
    find(p) {
        while (p !== this.id[p]) p = this.id[p]
        return p
    }
    /**
     * 
     * @param {number} p 
     * @param {number} q 
     */
    union(p, q) {
        let pRoot = this.find(p)
        let qRoot = this.find(q)
        if (pRoot == qRoot) return
        //将小树连接到大树上
        if (sz[pRoot] &lt; sz[qRoot]) {
            id[p] = qRoot
            sz[qRoot] += sz[pRoot]
        } else {
            id[q] = pRoot
            sz[pRoot] += sz[qRoot]
        }
        this.count--
    }

}
</code></pre><p>复杂度分析：</p>
<p><img src="https://img.funteas.com/5d818b417482f6348f82ce4ad6f9850c?imageView2/2/w/800" alt=""></p>
<p>如图所示，在最坏的情况下，其中将要被归并的树的大小总是相等的，它们均含有2^n个节点（树的高度为n）,当我们归并两个2^n个节点的树时，得到的树的高度增加到n+1。</p>
<p>对于加权quick-union算法和N个触点，在最坏的情况下，find() union()的运行时间的增长数量级为logN</p>
<blockquote>
<p>加权quick-union算法处理N个触点和M条连接时最多访问数组cMlgN次，这与quick-find需要MN形成了鲜明对比</p>
</blockquote>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>通过《算法》第一章我学习了</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 基本的数据类型栈、队列</li>
<li style="list-style: none"><input type="checkbox" checked> 通过数组、链表来构造队列和栈</li>
<li style="list-style: none"><input type="checkbox" checked> 数组和链表是两种基本的数据结构</li>
<li style="list-style: none"><input type="checkbox" checked> 时间复杂度的分析和常见的复杂度增长数量级</li>
<li style="list-style: none"><input type="checkbox" checked> 二分查找算法</li>
<li style="list-style: none"><input type="checkbox" checked> 对一个问题寻求解决方案时，要确定好基本的数据结构，好的数据结构是构造高效算法的前提</li>
<li style="list-style: none"><input type="checkbox" checked> 动态连通性问题</li>
<li style="list-style: none"><input type="checkbox" checked> 动态连通性问题的解决方案，并不断优化算法</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法思想 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法思想 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[移动端 Web 开发踩坑之旅]]></title>
      <url>/%E7%A7%BB%E5%8A%A8%E7%AB%AF-Web-%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>移动端的整体布局一般来说可以分为上中下三个部分，分别为 header、main、footer，其中 header、footer 是固定高度，分别固定在页面顶部和页面底部，而 main 是占据页面其余位置，并且可以滚动</p>
<p>最近在一个移动端的 Web 项目中踩了很多的坑，感觉有必要把它们记录下来，分享给即将踏入移动端 Web 开发大门的新人们。</p>
<h2 id="一、从布局说起"><a href="#一、从布局说起" class="headerlink" title="一、从布局说起"></a>一、从布局说起</h2><p>移动端的整体布局一般来说可以分为上中下三个部分，分别为 header、main、footer，其中header、footer 是固定高度，分别固定在页面顶部和页面底部，而 main 是占据页面其余位置，并且可以滚动。</p>
<p><img src="https://img.funteas.com/1c3510b27e5f15614bb2c21c82c4e064?imageView2/2/w/800" alt=""></p>
<p>（上图是使用纯 CSS 实现，然后截图，上传到专栏有点失真，看官老爷们将就着看吧。）</p>
<p>页面布局如下：</p>
<pre><code>&lt;body&gt;

  &lt;div class=&quot;header&quot;&gt;&lt;/div&gt;

  &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;

  &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;

&lt;/body&gt;
</code></pre><p>根据页面滚动的位置分为两种布局，一种是滚动 body，另一种是固定 body 的高度为100%，在 main 中滚动。</p>
<p>第一种布局有个优点，就是页面的地址栏会随着 body 的滚动隐藏起来，并且 Android 设备中，滚动 body 会更加的流畅，如果项目中有类似需求可以考虑。</p>
<p>实现布局的方式如下:</p>
<pre><code>body {
  overflow: auto;
}

.header,
.footer {
  position: fixed;
  left: 0;
  right: 0;
  height: 44px;
}

.header {
  top: 0;
}

.footer {
  bottom: 0;
}

.main {
  height: 100%;
  padding: 44px 0;
}
</code></pre><p>第一种情况比较适合长列表页面，整个页面除了 header 和 footer 之外都需要滚动，但很多时候，我们只希望页面的某个元素滚动，这个时候，就采取第二种布局方式。</p>
<p>这种页面布局有三种相对简单的实现方式：</p>
<ol>
<li><p>fixed 定位</p>
</li>
<li><p>absolute 定位</p>
</li>
<li><p>flex 定位</p>
</li>
</ol>
<p>最容易想到的实现方式是 fixed 定位，实现方式如下：</p>
<pre><code>html, body {
  height: 100%;
  overflow: hidden;
}
.header,
.footer {
  position: fixed;
  left: 0;
  right: 0;
  height: 44px;
}

.header {
  top: 0;
}

.footer {
  bottom: 0;
}

.main {
  height: 100%;
  padding: 44px 0;
  box-sizing: border-box;
}
</code></pre><p>fixed 定位实现起来简单，在大多数浏览器中也能正常显示，但是 fixed 定位在移动端会有兼容性问题，后面会提到，所以不建议这种实现方式。</p>
<p>absolute 定位和 fixed 定位类似，只要把 header 的 footer 的 position 改为 absolute 就可以了。</p>
<p>细心的小伙伴可能发现了，这里的 main 没有设置 overflow ，因为这里有一个坑，不管是absolute 定位还是 fixed 定位都一样，为了方便描述，以下只说 fixed 定位(在 absolute 定位也一样成立)。在PC端没有问题，但是在移动端，如果 main 设置了 overflow 为 true，header 会被 main 遮住，对，没有错，虽然是 fixed 定位，但是在移动端，<strong>如果 fixed 定位节点后面紧接跟着的兄弟节点是可滚动的(也就是设置了 overflow 为 true )，那么 fixed 节点会被其后的兄弟节点遮住。</strong></p>
<p>这个问题解决方式有很多，既然是 fixed 定位后面紧接着可滚动的兄弟节点才会有这个坑，只要让他的条件有一个不成立就好了，有以下解决方案：</p>
<ol>
<li><p>让 fixed 定位节点后面不紧接着可滚动的节点</p>
</li>
<li><p>不让 scroll 节点遮住 fixed 节点</p>
</li>
</ol>
<p>第一种方方案有以下可选方法:</p>
<ol>
<li>把所有 fixed 节点放在 scroll 元素后面，即把 header 节点放在 main 节点后面</li>
</ol>
<pre><code>&lt;body&gt;
  &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;header&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre><p>但这样显然不太符合一般人的思维习惯，代码可读性降低。</p>
<ol>
<li>使 main 不可滚动，给 main 嵌套一层可滚动的子节点</li>
</ol>
<pre><code>&lt;body&gt;
  &lt;div class=&quot;header&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;main&quot;&gt;
    &lt;div class=&quot;scroll-container&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;
&lt;/body&gt;

&lt;style&gt;
  .main {
    overflow: hidden;
  }
  .scroll-container {
    height: 100%;
    overflow: auto;
  }
&lt;/style&gt;
</code></pre><p>第二种方案有以下可选方法:</p>
<ol>
<li>让 scroll 节点不与 fixed 节点有重合</li>
</ol>
<pre><code>body {
  padding: 44px 0;
}

.main {
  padding: 0;
}
</code></pre><ol>
<li>给 fixed 节点设置 z-index</li>
</ol>
<pre><code>.header,
.footer {
    z-index: 8888;
}
</code></pre><p>看到这里可能会有小伙伴觉得，一个简单的布局，还要绕过这么多坑，难道没有简单的方式吗，答案当然是肯定的，那就是第三种实现方式，flex 布局。flex 定位在移动端兼容到了 iOS 7.1+，Android 4.4+,如果使用 autoprefixer 等工具还可以降级为旧版本的 flexbox ，可以兼容到 iOS 3.2 和 Android 2.1。而且用 flex 实现起来相对简单，在各个浏览器里表现也相对一致。实现如下:</p>
<pre><code>body {
  display: flex;
  flex-direction: column;
}
.main {
  flex: 1;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}
.header {
  height: 44px;
}
.footer {
  height: 44px;
}
</code></pre><h2 id="二、fixed-与-input"><a href="#二、fixed-与-input" class="headerlink" title="二、fixed 与 input"></a>二、fixed 与 input</h2><p>刚接触移动端 Web 开发的小伙伴应该都会听前辈们说过，不要在有 input 标签的页面使用 fixed 定位，因为这两者在一起的时候，总是会有奇奇怪怪的问题。</p>
<p>在 iOS 上，当点击 input 标签获取焦点唤起软键盘的时候，fixed 定位会暂时失效，或者可以理解为变成了 absolute 定位，在含有滚动的页面，fixed 定位的节点和其他节点一起滚动。</p>
<p>其实这个问题也很好解决，只要保证 fixed 定位的节点的父节点不可滚动，那么即使 fixed 定位失效，也不会和其他滚动节点一起滚动，影响界面。</p>
<p>但是除此之外，还有很多坑比较难以解决，例如 Android 软键盘唤起后遮挡住 input 标签，用户没法看到自己输入的字符串，iOS 则需要在输入至少一个字符之后，才能将对应的 input 标签滚动到合适的位置，所以为了避开这些难以解决的坑，在有表单输入的页面，尽量用absolute 或者 flex 替换 fixed。</p>
<h2 id="三、input-的-compositionstart-和-compositionend-事件"><a href="#三、input-的-compositionstart-和-compositionend-事件" class="headerlink" title="三、input 的 compositionstart 和 compositionend 事件"></a>三、input 的 compositionstart 和 compositionend 事件</h2><p>在 Web 开发中，经常要对表单元素的输入进行限制，比如说不允许输入特殊字符，标点。通常我们会监听 input 事件:</p>
<pre><code>inputElement.addEventListener(&#39;input&#39;, function(event) {
  let regex = /[^1-9a-zA-Z]/g;
  event.target.value = event.target.value.replace(regex, &#39;&#39;);
  event.returnValue = false
});
</code></pre><p>这段代码在 Android 上是没有问题的，但是在 iOS 中，input 事件会截断非直接输入，什么是非直接输入呢，在我们输入汉字的时候，比如说「喜茶」，中间过程中会输入拼音，每次输入一个字母都会触发 input 事件，然而在没有点选候选字或者点击「选定」按钮前，都属于非直接输入。</p>
<p><img src="https://img.funteas.com/ea3aa45e414168e2ddfc0539480ee7b9?imageView2/2/w/800" alt="">所以输入「喜茶」两个字，会触发6次 input 事件，如果把每次 input 的 value 打印出来，结果如下：</p>
<p><img src="https://img.funteas.com/f89919765cfc34c7355699fce12b3a64?imageView2/2/w/800" alt="">这显然不是我们想要的结果，我们希望在直接输入之后才触发 input 事件，这就需要引出我要说的两个事件—— compositionstart 和 compositionend。</p>
<p>compositionstart 事件在用户开始进行非直接输入的时候触发，而在非直接输入结束，也即用户点选候选词或者点击「选定」按钮之后，会触发 compositionend 事件。</p>
<pre><code>var inputLock = false;
function do(inputElement) {
    var regex = /[^1-9a-zA-Z]/g;
    inputElement.value = inputElement.value.replace(regex, &#39;&#39;);
}

inputElement.addEventListener(&#39;compositionstart&#39;, function() {
  inputLock = true;
});

inputElement.addEventListener(&#39;compositionend&#39;, function(event) {
  inputLock = false;
  do(event.target);
})

inputElement.addEventListener(&#39;input&#39;, function(event) {
  if (!inputLock) {
    do(event.target);
    event.returnValue = false;
  }
});
</code></pre><p>添加一个 inputLock 变量，当用户未完成直接输入前，inputLock 为 true，不触发 input 事件中的逻辑，当用户完成有效输入之后，inputLock 设置为 false，触发 input 事件的逻辑。这里需要注意的一点是，compositionend 事件是在 input 事件后触发的，所以在 compositionend事件触发时，也要调用 input 事件处理逻辑。</p>
<h2 id="四、iOS-1px-border-实现"><a href="#四、iOS-1px-border-实现" class="headerlink" title="四、iOS 1px border 实现"></a>四、iOS 1px border 实现</h2><p>iOS设备上，由于retina屏的原因，1px 的 border 会显示成两个物理像素，所以看起来会感觉很粗，这是一个移动端开发常见的问题。解决方案有很多，但都有自己的优缺点。</p>
<p><strong>0.5px border</strong></p>
<p>从iOS 8开始，iOS 浏览器支持 0.5px 的 border，但是在 Android 上是不支持的，0.5px 会被认为是 0px，所以这种方法，兼容性是很差的。</p>
<p><strong>背景渐变</strong></p>
<p>CSS3 有了渐变背景，可以通过渐变背景实现 1px 的 border，实现原理是设置 1px 的渐变背景，50% 有颜色，50% 是透明的。</p>
<pre><code>@mixin commonStyle() {
  background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%;
  background-repeat: no-repeat;
  background-position: top, right top,  bottom, left top;
}

@mixin border($border-color) {
  @include commonStyle();
  background-image:linear-gradient(180deg, $border-color, $border-color 50%, transparent 50%),
  linear-gradient(270deg, $border-color, $border-color 50%, transparent 50%),
  linear-gradient(0deg, $border-color, $border-color 50%, transparent 50%),
  linear-gradient(90deg, $border-color, $border-color 50%, transparent 50%);
}
</code></pre><p>这种方法虽然可行，但是没有办法实现圆角。</p>
<p><strong>伪类 + transform</strong></p>
<p>这类方法的实现原理是用伪元素的 box-shadow 或 border 实现 border，然后用 transform缩小到原来的一半。即使有圆角的需求也能很好的实现。</p>
<pre><code>@mixin hairline-common($border-radius) {
  position: relative;
  z-index: 0;
  &amp;:before {
    position: absolute;
    content: &#39;&#39;;
    border-radius: $border-radius;
    box-sizing: border-box;
    transform-origin: 0 0;
  }
}
@mixin hairline($direct: &#39;all&#39;, $border-color: #ccc, $border-radius: 0) {
  @include hairline-common($border-radius);
  &amp;:before {
    transform: scale(.5);
    @if $direct == &#39;all&#39; {
      top: 0;
      left: 0;
      width: 200%;
      height: 200%;
      box-shadow: 0 0 0 1px $border-color;
      z-index: -1;
    } @else if $direct == &#39;left&#39; or $direct == &#39;right&#39; {
      #{$direct}: 0;
      top: 0;
      width: 0;
      height: 200%;
      border-#{$direct}: 1px solid $border-color;
    } @else {
      #{$direct}: 0;
      left: 0;
      width: 200%;
      height: 0;
      border-#{$direct}: 1px solid $border-color;
    }
  }
}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上的坑都是在项目里频繁遇到的，每一个都给出了对应的解决方式，但由于笔者也是初入坑移动 Web 开发的新人一枚，所以给出的方案未必是最合适的，做了点微小的工作，希望能为大家提供一点帮助，不足的地方也请大家多多指正。</p>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 移动端web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[列举一些前端优化点---移动端优化]]></title>
      <url>/%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%82%B9---%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BC%98%E5%8C%96.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://pancakeawesome.ink/%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%82%B9---PC%E7%AB%AF%E4%BC%98%E5%8C%96.html">前一篇博客</a>我介绍了前端开发中比较常用的pc端优化点，包括网络加载和页面渲染类的优化。</p>
<p>这篇博客我们讨论下移动端web开发的常用优化点，包括缓存类，图片类，脚本类，渲染类，架构协议类的相关常用优化点。</p>
<h2 id="移动端浏览器前端优化策略"><a href="#移动端浏览器前端优化策略" class="headerlink" title="移动端浏览器前端优化策略"></a>移动端浏览器前端优化策略</h2><p>相对于桌面端浏览器，移动端 Web 浏览器上有一些较为明显的特点：设备屏幕较小、新特性兼容性较好、支持一些较新的 HTML5 和 CSS3 特性、需要与 Native 应用交互等。但移动端浏览器可用的 CPU 计算资源和网络资源极为有限，因此要做好移动端 Web 上的优化往往需要做更多的事情。首先，在移动端 Web 的前端页面渲染中，桌面浏览器端上的优化规则同样适用，此外针对移动端也要做一些极致的优化来达到更好的效果。需要注意的是，并不是移动端的优化原则在桌面浏览器端就不适用，而是由于兼容性和差异性的原因，一些优化原则在移动端更具代表性。</p>
<h3 id="网络加载类"><a href="#网络加载类" class="headerlink" title="网络加载类"></a>网络加载类</h3><h4 id="1．首屏数据请求提前，避免-JavaScript-文件加载后才请求数据"><a href="#1．首屏数据请求提前，避免-JavaScript-文件加载后才请求数据" class="headerlink" title="1．首屏数据请求提前，避免 JavaScript 文件加载后才请求数据"></a>1．首屏数据请求提前，避免 JavaScript 文件加载后才请求数据</h4><p>为了进一步提升页面加载速度，可以考虑将页面的数据请求尽可能提前，避免在 JavaScript 加载完成后才去请求数据。通常数据请求是页面内容渲染中关键路径最长的部分，而且不能并行，所以如果能将数据请求提前，可以极大程度上缩短页面内容的渲染完成时间。</p>
<h4 id="2．首屏加载和按需加载，非首屏内容滚屏加载，保证首屏内容最小化"><a href="#2．首屏加载和按需加载，非首屏内容滚屏加载，保证首屏内容最小化" class="headerlink" title="2．首屏加载和按需加载，非首屏内容滚屏加载，保证首屏内容最小化"></a>2．首屏加载和按需加载，非首屏内容滚屏加载，保证首屏内容最小化</h4><p>由于移动端网络速度相对较慢，网络资源有限，因此为了尽快完成页面内容的加载，需要保证首屏加载资源最小化，非首屏内容使用滚动的方式异步加载。一般推荐移动端页面首屏数据展示延时最长不超过 3 秒。目前中国联通 3G 的网络速度为 338KB/s（2.71Mb/s），所以推荐首屏所有资源大小不超过 1014KB，即大约不超过 1MB。</p>
<h4 id="3．模块化资源并行下载"><a href="#3．模块化资源并行下载" class="headerlink" title="3．模块化资源并行下载"></a>3．模块化资源并行下载</h4><p>在移动端资源加载中，尽量保证 JavaScript 资源并行加载，主要指的是模块化 JavaScript 资源的异步加载，例如 AMD 的异步模块，使用并行的加载方式能够缩短多个文件资源的加载时间。</p>
<h4 id="4．inline-首屏必备的-CSS-和-JavaScript"><a href="#4．inline-首屏必备的-CSS-和-JavaScript" class="headerlink" title="4．inline 首屏必备的 CSS 和 JavaScript"></a>4．inline 首屏必备的 CSS 和 JavaScript</h4><p>通常为了在 HTML 加载完成时能使浏览器中有基本的样式，需要将页面渲染时必备的 CSS 和 JavaScript 通过 <code>&lt;script&gt;</code> 或 <code>&lt;style&gt;</code> 内联到页面中，避免页面 HTML 载入完成到页面内容展示这段过程中页面出现空白。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;htmllang=&quot;en&quot;&gt;
    &lt;head&gt;
    &lt;metacharset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;样例&lt;/title&gt;
    &lt;meta&gt;
    &lt;style&gt;
    /*必备的首屏CSS*/
    html,body{
        margin:0;
        padding:0;
        background-color:#ccc;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="5．meta-dns-prefetch-设置-DNS-预解析"><a href="#5．meta-dns-prefetch-设置-DNS-预解析" class="headerlink" title="5．meta dns prefetch 设置 DNS 预解析"></a>5．meta dns prefetch 设置 DNS 预解析</h4><p>设置文件资源的 DNS 预解析，让浏览器提前解析获取静态资源的主机 IP，避免等到请求时才发起 DNS 解析请求。通常在移动端 HTML 中可以采用如下方式完成。</p>
<pre><code>&lt;!--cdn域名预解析--&gt;
&lt;metahttp-equiv=&quot;x-dns-prefetch-control&quot;content=&quot;on&quot;&gt;
&lt;linkrel=&quot;dns-prefetch&quot;href=&quot;//cdn.domain.com&quot;&gt;
</code></pre><h4 id="6．资源预加载"><a href="#6．资源预加载" class="headerlink" title="6．资源预加载"></a>6．资源预加载</h4><p>对于移动端首屏加载后可能会被使用的资源，需要在首屏完成加载后尽快进行加载，保证在用户需要浏览时已经加载完成，这时候如果再去异步请求就显得很慢。</p>
<h4 id="7．合理利用-MTU-策略"><a href="#7．合理利用-MTU-策略" class="headerlink" title="7．合理利用 MTU 策略"></a>7．合理利用 MTU 策略</h4><p>通常情况下，我们认为 TCP 网络传输的最大传输单元（Maximum Transmission Unit，MTU）为 1500B，即一个 RTT（Round-Trip Time，网络请求往返时间）内可以传输的数据量最大为 1500 字节。因此，在前后端分离的开发模式中，尽量保证页面的 HTML 内容在 1KB 以内，这样整个 HTML 的内容请求就可以在一个 RTT 内请求完成，最大限度地提高 HTML 载入速度。</p>
<h3 id="缓存类"><a href="#缓存类" class="headerlink" title="缓存类"></a>缓存类</h3><h4 id="1．合理利用浏览器缓存"><a href="#1．合理利用浏览器缓存" class="headerlink" title="1．合理利用浏览器缓存"></a>1．合理利用浏览器缓存</h4><p>除了上面说到的使用 Cache-Control、Expires、Etag 和 Last-Modified 来设置 HTTP 缓存外，在移动端还可以使用 localStorage 等来保存 AJAX 返回的数据，或者使用 localStorage 保存 CSS 或 JavaScript 静态资源内容，实现移动端的离线应用，尽可能减少网络请求，保证静态资源内容的快速加载。</p>
<h4 id="2．静态资源离线方案"><a href="#2．静态资源离线方案" class="headerlink" title="2．静态资源离线方案"></a>2．静态资源离线方案</h4><p>对于移动端或 Hybrid 应用，可以设置离线文件或离线包机制让静态资源请求从本地读取，加快资源载入速度，并实现离线更新。关于这块内容，我们会在后面的章节中重点讲解。</p>
<h4 id="3．尝试使用-AMP-HTML"><a href="#3．尝试使用-AMP-HTML" class="headerlink" title="3．尝试使用 AMP HTML"></a>3．尝试使用 AMP HTML</h4><p>AMP HTML 可以作为优化前端页面性能的一个解决方案，使用 AMP Component 中的元素来代替原始的页面元素进行直接渲染。</p>
<pre><code>

&lt;!--不推荐--&gt;
&lt;videowidth=&quot;400&quot;height=&quot;300&quot;src=&quot;http://www.domain.com/videos/myvideo.mp4&quot;
poster=&quot;path/poster.jpg&quot;&gt;
    &lt;divfallback&gt;
        &lt;p&gt;Your browser doesn’t support HTML5 video&lt;/p&gt;
    &lt;/div&gt;
    &lt;sourcetype=&quot;video/mp4&quot;src=&quot;foo.mp4&quot;&gt;
    &lt;sourcetype=&quot;video/webm&quot;src=&quot;foo.webm&quot;&gt;
&lt;/video&gt;
&lt;!--推荐--&gt;
&lt;amp-videowidth=&quot;400&quot;height=&quot;300&quot;src=&quot;http://www.domain.com/videos/myvideo.mp4&quot;
poster=&quot;path/poster.jpg&quot;&gt;
    &lt;divfallback&gt;
        &lt;p&gt;Your browser doesn’t support HTML5 video&lt;/p&gt;
    &lt;/div&gt;
    &lt;sourcetype=&quot;video/mp4&quot;src=&quot;foo.mp4&quot;&gt;
    &lt;sourcetype=&quot;video/webm&quot;src=&quot;foo.webm&quot;&gt;
&lt;/amp-video&gt;
</code></pre><h4 id="4．尝试使用-PWA-模式"><a href="#4．尝试使用-PWA-模式" class="headerlink" title="4．尝试使用 PWA 模式"></a>4．尝试使用 PWA 模式</h4><p>PWA（Progressive Web Apps）是 Google 提出的用前沿的 Web 技术为网页提供 App 般使用体验的一系列方案。</p>
<h3 id="图片类"><a href="#图片类" class="headerlink" title="图片类"></a>图片类</h3><h4 id="1．图片压缩处理"><a href="#1．图片压缩处理" class="headerlink" title="1．图片压缩处理"></a>1．图片压缩处理</h4><p>在移动端，通常要保证页面中一切用到的图片都是经过压缩优化处理的，而不是以原图的形式直接使用的，因为那样很消耗流量，而且加载时间更长。</p>
<h4 id="2．使用较小的图片，合理使用-base64-内嵌图片"><a href="#2．使用较小的图片，合理使用-base64-内嵌图片" class="headerlink" title="2．使用较小的图片，合理使用 base64 内嵌图片"></a>2．使用较小的图片，合理使用 base64 内嵌图片</h4><p>在页面使用的背景图片不多且较小的情况下，可以将图片转化成 base64 编码嵌入到 HTML 页面或 CSS 文件中，这样可以减少页面的 HTTP 请求数。需要注意的是，要保证图片较小，一般图片大小超过 2KB 就不推荐使用 base64 嵌入显示了。</p>
<pre><code>.class-name{
    background-image : url(&#39;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAALCAMAAABxsOwqAAAAYFBMVEWnxwusyQukxQudwQyZvgyhxAyfwgyxzAsUHQGOuA0aJAERGAFIXwSTugyEqgtqhghQZgUwQQIpOQKbuguVtQuKrAuCowp2kQlheghTbQZHWQU7SwVAVgQ6TgQlLwMeKwFOemyQAAAAVElEQVQI1y3JVRaAIAAF0UconXbvf5ei8HfPDIQQhBAAFE10iKig3SLRNN4SP/p+N08VC0YnfIlNWtqIkhg/TPYbCvhqdHAWRXPZSp3g3CWZvVLXC6OJA3ukv0AaAAAAAElFTkSuQmCC&#39;);
}
</code></pre><h4 id="3．使用更高压缩比格式的图片"><a href="#3．使用更高压缩比格式的图片" class="headerlink" title="3．使用更高压缩比格式的图片"></a>3．使用更高压缩比格式的图片</h4><p>使用具有较高压缩比格式的图片，如 webp（需要设计降级兼容方案）等。在同等图片画质的情况下，高压缩比格式的图片体积更小，能够更快完成文件传输，节省网络流量。</p>
<pre><code>&lt;imgsrc=&quot;//cdn.domain.com/path/photo.webp&quot;alt=&quot;webp格式图片&quot;&gt;
</code></pre><h4 id="4．图片懒加载"><a href="#4．图片懒加载" class="headerlink" title="4．图片懒加载"></a>4．图片懒加载</h4><p>为了保证页面内容的最小化，加速页面的渲染，尽可能节省移动端网络流量，页面中的图片资源推荐使用懒加载实现，在页面滚动时动态载入图片。</p>
<pre><code>&lt;imgdata-src=&quot;//cdn.domain.com/path/photo.jpg&quot;alt=&quot;懒加载图片&quot;&gt;
</code></pre><h4 id="5．使用-MediaQuery-或-srcset-根据不同屏幕加载不同大小图片"><a href="#5．使用-MediaQuery-或-srcset-根据不同屏幕加载不同大小图片" class="headerlink" title="5．使用 MediaQuery 或 srcset 根据不同屏幕加载不同大小图片"></a>5．使用 MediaQuery 或 srcset 根据不同屏幕加载不同大小图片</h4><p>在介绍响应式的章节中我们了解到，针对不同的移动端屏幕尺寸和分辨率，输出不同大小的图片或背景图能保证在用户体验不降低的前提下节省网络流量，加快部分机型的图片加载速度，这在移动端非常值得推荐。</p>
<h4 id="6．使用-iconfont-代替图片图标"><a href="#6．使用-iconfont-代替图片图标" class="headerlink" title="6．使用 iconfont 代替图片图标"></a>6．使用 iconfont 代替图片图标</h4><p>在页面中尽可能使用 iconfont 来代替图片图标，这样做的好处有以下几个：</p>
<ul>
<li><p>使用 iconfont 体积较小，而且是矢量图，因此缩放时不会失真；</p>
</li>
<li><p>可以方便地修改图片大小尺寸和呈现颜色。</p>
</li>
</ul>
<p>但是需要注意的是，iconfont 引用不同 webfont 格式时的兼容性写法，根据经验推荐尽量按照以下顺序书写，否则不容易兼容到所有的浏览器上。</p>
<pre><code>@font-face{
    font-family:iconfont;
    src:url(&quot;./iconfont.eot&quot;);
    src:url(&quot;./iconfont.eot?#iefix&quot;)  format(&quot;eot&quot;),
        url(&quot;./iconfont.woff&quot;)  format(&quot;woff&quot;),
        url(&quot;./iconfont.ttf&quot;)  format(&quot;truetype&quot;);
}
</code></pre><h4 id="7．定义图片大小限制"><a href="#7．定义图片大小限制" class="headerlink" title="7．定义图片大小限制"></a>7．定义图片大小限制</h4><p>加载的单张图片一般建议不超过 30KB，避免大图片加载时间长而阻塞页面其他资源的下载，因此推荐在 10KB 以内。如果用户上传的图片过大，建议设置告警系统，帮助我们观察了解整个网站的图片流量情况，做出进一步的改善。</p>
<h4 id="8．强缓存策略"><a href="#8．强缓存策略" class="headerlink" title="8．强缓存策略"></a>8．强缓存策略</h4><p>对于一些「永远」不会变的图片可以使用强缓存的方式缓存在用户的浏览器上。</p>
<h3 id="脚本类"><a href="#脚本类" class="headerlink" title="脚本类"></a>脚本类</h3><h4 id="1．尽量使用-id"><a href="#1．尽量使用-id" class="headerlink" title="1．尽量使用 id"></a>1．尽量使用 id</h4><p>选择器选择页面 DOM 元素时尽量使用 id 选择器，因为 id 选择器速度最快。</p>
<h4 id="2．合理缓存-DOM-对象"><a href="#2．合理缓存-DOM-对象" class="headerlink" title="2．合理缓存 DOM 对象"></a>2．合理缓存 DOM 对象</h4><p>对于需要重复使用的 DOM 对象，要优先设置缓存变量，避免每次使用时都要从整个 DOM 树中重新查找。</p>
<pre><code>//不推荐
$(&#39;#mod.active&#39;).remove(&#39;active&#39;);
$(&#39;#mod.not-active&#39;).addClass(&#39;active&#39;);
//推荐
let $mod=$(&#39;#mod&#39;);
$mod.find(&#39;.active&#39;).remove(&#39;active&#39;);
$mod.find(&#39;.not-active&#39;).addClass(&#39;active&#39;);
</code></pre><h4 id="3．页面元素尽量使用事件代理，避免直接事件绑定"><a href="#3．页面元素尽量使用事件代理，避免直接事件绑定" class="headerlink" title="3．页面元素尽量使用事件代理，避免直接事件绑定"></a>3．页面元素尽量使用事件代理，避免直接事件绑定</h4><p>使用事件代理可以避免对每个元素都进行绑定，并且可以避免出现内存泄露及需要动态添加元素的事件绑定问题，所以尽量不要直接使用事件绑定。</p>
<pre><code>//不推荐
$(&#39;.btn&#39;).on(&#39;click&#39;,function(e){
    console.log(this);
});
//推荐
$(&#39;body&#39;).on(&#39;click&#39;,&#39;.btn&#39;,function(e){
    console.log(this);
});
</code></pre><h4 id="4．使用-touchstart-代替-click"><a href="#4．使用-touchstart-代替-click" class="headerlink" title="4．使用 touchstart 代替 click"></a>4．使用 touchstart 代替 click</h4><p>由于移动端屏幕的设计， touchstart 事件和 click 事件触发时间之间存在 300 毫秒的延时，所以在页面中没有实现 touchmove 滚动处理的情况下，可以使用 touchstart 事件来代替元素的 click 事件，加快页面点击的响应速度，提高用户体验。但同时我们也要注意页面重叠元素 touch 动作的点击穿透问题。</p>
<pre><code>//不推荐
$(&#39;body&#39;).on(&#39;click&#39;,&#39;.btn&#39;,function(e){
    console.log(this);
});
//推荐
$(&#39;body&#39;).on(&#39;touchstart&#39;,&#39;.btn&#39;,function(e){
    console.log(this);
});
</code></pre><h4 id="5．避免-touchmove、scroll-连续事件处理"><a href="#5．避免-touchmove、scroll-连续事件处理" class="headerlink" title="5．避免 touchmove、scroll 连续事件处理"></a>5．避免 touchmove、scroll 连续事件处理</h4><p>需要对 touchmove、scroll 这类可能连续触发回调的事件设置事件节流，例如设置每隔 16ms（60 帧的帧间隔为 16.7ms，因此可以合理地设置为 16ms ）才进行一次事件处理，避免频繁的事件调用导致移动端页面卡顿。</p>
<pre><code>//不推荐
$(&#39;.scroller&#39;).on(&#39;touchmove&#39;,&#39;.btn&#39;,function(e){
    console.log(this);
});
//推荐
$(&#39;.scroller&#39;).on(&#39;touchmove&#39;,&#39;.btn&#39;,function(e){
    letself=this;
    setTimeout(function(){
        console.log(self);
    },16);
});
</code></pre><h4 id="6．避免使用-eval、with，使用-join-代替连接符＋，推荐使用-ECMAScript6-的字符串模板"><a href="#6．避免使用-eval、with，使用-join-代替连接符＋，推荐使用-ECMAScript6-的字符串模板" class="headerlink" title="6．避免使用 eval、with，使用 join 代替连接符＋，推荐使用 ECMAScript6 的字符串模板"></a>6．避免使用 eval、with，使用 join 代替连接符＋，推荐使用 ECMAScript6 的字符串模板</h4><p>这些都是一些基础的安全脚本编写问题，尽可能使用较高效率的特性来完成这些操作，避免不规范或不安全的写法。</p>
<h4 id="7．尽量使用-ECMAScript6＋的特性来编程"><a href="#7．尽量使用-ECMAScript6＋的特性来编程" class="headerlink" title="7．尽量使用 ECMAScript6＋的特性来编程"></a>7．尽量使用 ECMAScript6＋的特性来编程</h4><p>ECMAScript6＋ 一定程度上更加安全高效，而且部分特性执行速度更快，也是未来规范的需要，所以推荐使用 ECMAScript6＋ 的新特性来完成后面的开发。</p>
<h3 id="渲染类"><a href="#渲染类" class="headerlink" title="渲染类"></a>渲染类</h3><h4 id="1．使用-Viewport-固定屏幕渲染，可以加速页面渲染内容"><a href="#1．使用-Viewport-固定屏幕渲染，可以加速页面渲染内容" class="headerlink" title="1．使用 Viewport 固定屏幕渲染，可以加速页面渲染内容"></a>1．使用 Viewport 固定屏幕渲染，可以加速页面渲染内容</h4><p>一般认为，在移动端设置 Viewport 可以加速页面的渲染，同时可以避免缩放导致页面重排重绘。在移动端固定 Viewport 设置的方法如下。</p>
<pre><code>&lt;!--设置viewport不缩放--&gt;
&lt;meta&gt;
</code></pre><h4 id="2．避免各种形式重排重绘"><a href="#2．避免各种形式重排重绘" class="headerlink" title="2．避免各种形式重排重绘"></a>2．避免各种形式重排重绘</h4><p>页面的重排重绘很耗性能，所以一定要尽可能减少页面的重排重绘，例如页面图片大小变化、元素位置变化等这些情况都会导致重排重绘。</p>
<h4 id="3．使用-CSS3-动画，开启-GPU-加速"><a href="#3．使用-CSS3-动画，开启-GPU-加速" class="headerlink" title="3．使用 CSS3 动画，开启 GPU 加速"></a>3．使用 CSS3 动画，开启 GPU 加速</h4><p>使用 CSS3 动画时可以设置 transform:translateZ(0) 来开启移动设备浏览器的 GPU 图形处理加速，让动画过程更加流畅，但需要注意的是，在 Native WebView 下 GPU 加速有几率产生 App Crash。</p>
<pre><code>-webkit-transform:translateZ(0);
    -ms-transform:translateZ(0);
     -o-transform:translateZ(0);
        transform:translateZ(0);
</code></pre><h4 id="4．合理使用-Canvas-和-requestAnimationFrame"><a href="#4．合理使用-Canvas-和-requestAnimationFrame" class="headerlink" title="4．合理使用 Canvas 和 requestAnimationFrame"></a>4．合理使用 Canvas 和 requestAnimationFrame</h4><p>选择 Canvas 或 requestAnimationFrame 等更高效的动画实现方式，尽量避免使用 setTimeout、setInterval 等方式来直接处理连续动画。</p>
<h4 id="5．SVG-代替图片"><a href="#5．SVG-代替图片" class="headerlink" title="5．SVG 代替图片"></a>5．SVG 代替图片</h4><p>部分情况下可以考虑使用 SVG 代替图片实现动画，因为使用 SVG 格式内容更小，而且 SVG DOM 结构方便调整。</p>
<h4 id="6．不滥用-float"><a href="#6．不滥用-float" class="headerlink" title="6．不滥用 float"></a>6．不滥用 float</h4><p>在 DOM 渲染树生成后的布局渲染阶段，使用 float 的元素布局计算比较耗性能，所以尽量减少 float 的使用，推荐使用固定布局或 flex-box 弹性布局的方式来实现页面元素布局。</p>
<h4 id="7．不滥用-web-字体或过多-font-size-声明"><a href="#7．不滥用-web-字体或过多-font-size-声明" class="headerlink" title="7．不滥用 web 字体或过多 font-size 声明"></a>7．不滥用 web 字体或过多 font-size 声明</h4><p>过多的 font-size 声明会增加字体的大小计算，而且也没有必要的。</p>
<h4 id="8．做好脚本容错"><a href="#8．做好脚本容错" class="headerlink" title="8．做好脚本容错"></a>8．做好脚本容错</h4><p>脚本容错可以避免「非正常环境」的执行错误影响页面的加载和不相关功能的使用</p>
<h3 id="架构协议类"><a href="#架构协议类" class="headerlink" title="架构协议类"></a>架构协议类</h3><h4 id="1．尝试使用-SPDY-和-HTTP2"><a href="#1．尝试使用-SPDY-和-HTTP2" class="headerlink" title="1．尝试使用 SPDY 和 HTTP2"></a>1．尝试使用 SPDY 和 HTTP2</h4><p>在条件允许的情况下可以考虑使用 SPDY 协议来进行文件资源传输，利用连接复用加快传输过程，缩短资源加载时间。HTTP2 在未来也是可以考虑尝试的。</p>
<h4 id="2．使用后端数据渲染"><a href="#2．使用后端数据渲染" class="headerlink" title="2．使用后端数据渲染"></a>2．使用后端数据渲染</h4><p>使用后端数据渲染的方式可以加快页面内容的渲染展示，避免空白页面的出现，同时可以解决移动端页面 SEO 的问题。如果条件允许，后端数据渲染是一个很不错的实践思路。后面的章节会详细介绍后端数据渲染的相关内容。</p>
<h4 id="3．使用-NativeView-代替-DOM-的性能劣势"><a href="#3．使用-NativeView-代替-DOM-的性能劣势" class="headerlink" title="3．使用 NativeView 代替 DOM 的性能劣势"></a>3．使用 NativeView 代替 DOM 的性能劣势</h4><p>可以尝试使用 NativeView 的 MNV＊ 开发模式来避免 HTML DOM 性能慢的问题，目前使用 MNV＊ 的开发模式已经可以将页面内容渲染体验做到接近客户端 Native 应用的体验了。但需要避免 js Framework 和 native Framework 的频繁交互。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>关于页面优化的常用技术手段和思路主要包括以上这些，尽管列举出很多，但仍可能有少数遗漏，可见前端性能优化不是一件简简单单的事情，其涉及的内容很多。大家可以根据实际情况将这些方法应用到自己的项目当中，要想全部做到几乎是不可能的，但做到用户可接受的原则还是很容易实现的。</p>
<p>另外，如果你有比较好的优化点想要扩充，欢迎下方评论。</p>
]]></content>
      
        <categories>
            
            <category> 前端优化 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 前端优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[列举一些前端优化点---PC端优化]]></title>
      <url>/%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%82%B9---PC%E7%AB%AF%E4%BC%98%E5%8C%96.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>围绕前端的性能多如牛毛，涉及到方方面面，以我我们将围绕 PC 浏览器和移动端浏览器的优化策略进行罗列 注意，是罗列不是展开，遇到不会不懂的点还请站外扩展</p>
</blockquote>
<p>开车速度有点快，坐稳了。</p>
<blockquote>
<p>tips : 这么多前端优化点你都记得住吗？反正我是收藏起来备查的。<br>由于优化点很多，所以分了两篇博客来讲，本篇讲pc端的优化，包括网络加载类, 页面渲染类的优化点。<a href="http://pancakeawesome.ink/%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%82%B9---PC%E7%AB%AF%E4%BC%98%E5%8C%96.html">下篇博客</a> 会讲一下移动端的优化点，<a href="http://pancakeawesome.ink/%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%82%B9---PC%E7%AB%AF%E4%BC%98%E5%8C%96.html">传送门。</a></p>
</blockquote>
<h2 id="PC-浏览器前端优化策略"><a href="#PC-浏览器前端优化策略" class="headerlink" title="PC 浏览器前端优化策略"></a>PC 浏览器前端优化策略</h2><p>PC 端优化的策略很多，如 YSlow（YSlow 是 Yahoo 发布的一款 Firefox 插件，现 Chrome 也可安装，可以对网站的页面性能进行分析，提出对该页面性能优化的建议）原则，或者 Chrome 自带的 Audits 等，总结起来主要包括网络加载类、页面渲染类、CSS 优化类、JavaScript 执行类、缓存类、图片类、架构协议类等几类，下面逐一介绍。</p>
<h3 id="网络加载类"><a href="#网络加载类" class="headerlink" title="网络加载类"></a>网络加载类</h3><h4 id="1．减少-HTTP-资源请求次数"><a href="#1．减少-HTTP-资源请求次数" class="headerlink" title="1．减少 HTTP 资源请求次数"></a>1．减少 HTTP 资源请求次数</h4><p>在前端页面中，通常建议尽可能合并静态资源图片、JavaScript 或 CSS 代码，减少页面请求数和资源请求消耗，这样可以缩短页面首次访问的用户等待时间。通过构建工具合并雪碧图、CSS、JavaScript 文件等都是为了减少 HTTP 资源请求次数。另外也要尽量避免重复的资源，防止增加多余请求。</p>
<h4 id="2．减小-HTTP-请求大小"><a href="#2．减小-HTTP-请求大小" class="headerlink" title="2．减小 HTTP 请求大小"></a>2．减小 HTTP 请求大小</h4><p>除了减少 HTTP 资源请求次数，也要尽量减小每个 HTTP 请求的大小。如减少没必要的图片、JavaScript、CSS 及 HTML 代码，对文件进行压缩优化，或者使用 gzip 压缩传输内容等都可以用来减小文件大小，缩短网络传输等待时延。前面我们使用构建工具来压缩静态图片资源以及移除代码中的注释并压缩，目的都是为了减小 HTTP 请求的大小。</p>
<h4 id="3．将-CSS-或-JavaScript-放到外部文件中，避免使用-style或-script标签直接引入"><a href="#3．将-CSS-或-JavaScript-放到外部文件中，避免使用-style或-script标签直接引入" class="headerlink" title="3．将 CSS 或 JavaScript 放到外部文件中，避免使用 style或 script标签直接引入"></a>3．将 CSS 或 JavaScript 放到外部文件中，避免使用 <code>style</code>或 <code>script</code>标签直接引入</h4><p>在 HTML 文件中引用外部资源可以有效利用浏览器的静态资源缓存，但有时候在移动端页面 CSS 或 JavaScript 比较简单的情况下为了减少请求，也会将 CSS 或 JavaScript 直接写到 HTML 里面，具体要根据 CSS 或 JavaScript 文件的大小和业务的场景来分析。如果 CSS 或 JavaScript 文件内容较多，业务逻辑较复杂，建议放到外部文件引入。</p>
<pre><code>&lt;linkrel=&quot;stylesheet&quot;href=&quot;//cdn.domain.com/path/main.css&quot;&gt;
...
&lt;scriptsrc=&quot;//cdn.domain.com/path/main.js&quot;&gt;&lt;/script&gt;
</code></pre><h4 id="4．避免页面中空的-href-和-src"><a href="#4．避免页面中空的-href-和-src" class="headerlink" title="4．避免页面中空的 href 和 src"></a>4．避免页面中空的 href 和 src</h4><p>当 <code>&lt;link&gt;</code>标签的 href 属性为空，或 <code>&lt;script&gt;</code>、 <code>&lt;img&gt;</code>、 <code>&lt;iframe&gt;</code>标签的 src 属性为空时，浏览器在渲染的过程中仍会将 href 属性或 src 属性中的空内容进行加载，直至加载失败，这样就阻塞了页面中其他资源的下载进程，而且最终加载到的内容是无效的，因此要尽量避免。</p>
<pre><code>&lt;!--不推荐--&gt;
&lt;imgsrc=&quot;&quot;alt=&quot;photo&quot;&gt;
&lt;ahref=&quot;&quot;&gt;点击链接&lt;/a&gt;
</code></pre><h4 id="5．为-HTML-指定-Cache-Control-或-Expires"><a href="#5．为-HTML-指定-Cache-Control-或-Expires" class="headerlink" title="5．为 HTML 指定 Cache-Control 或 Expires"></a>5．为 HTML 指定 Cache-Control 或 Expires</h4><p>为 HTML 内容设置 Cache-Control 或 Expires 可以将 HTML 内容缓存起来，避免频繁向服务器端发送请求。前面讲到，在页面 Cache-Control 或 Expires 头部有效时，浏览器将直接从缓存中读取内容，不向服务器端发送请求。</p>
<pre><code>&lt;metahttp-equiv=&quot;Cache-Control&quot;content=&quot;max-age=7200&quot;&gt;
&lt;metahttp-equiv=&quot;Expires&quot;content=&quot;Mon,20Jul201623:00:00GMT&quot;&gt;
</code></pre><h4 id="6．合理设置-Etag-和-Last-Modified"><a href="#6．合理设置-Etag-和-Last-Modified" class="headerlink" title="6．合理设置 Etag 和 Last-Modified"></a>6．合理设置 Etag 和 Last-Modified</h4><p>合理设置 Etag 和 Last-Modified 使用浏览器缓存，对于未修改的文件，静态资源服务器会向浏览器端返回 304，让浏览器从缓存中读取文件，减少 Web 资源下载的带宽消耗并降低服务器负载。</p>
<pre><code>&lt;metahttp-equiv=&quot;last-modified&quot;content=&quot;Sun,05 Nov 2017 13:45:57 GMT&quot;&gt;
</code></pre><h4 id="7．减少页面重定向"><a href="#7．减少页面重定向" class="headerlink" title="7．减少页面重定向"></a>7．减少页面重定向</h4><p>页面每次重定向都会延长页面内容返回的等待延时，一次重定向大约需要 200 毫秒不等的时间开销（无缓存），为了保证用户尽快看到页面内容，要尽量避免页面重定向。</p>
<h4 id="8．使用静态资源分域存放来增加下载并行数"><a href="#8．使用静态资源分域存放来增加下载并行数" class="headerlink" title="8．使用静态资源分域存放来增加下载并行数"></a>8．使用静态资源分域存放来增加下载并行数</h4><p>浏览器在同一时刻向同一个域名请求文件的并行下载数是有限的，因此可以利用多个域名的主机来存放不同的静态资源，增大页面加载时资源的并行下载数，缩短页面资源加载的时间。通常根据多个域名来分别存储 JavaScript、CSS 和图片文件。</p>
<pre><code>&lt;linkrel=&quot;stylesheet&quot;href=&quot;//cdn1.domain.com/path/main.css&quot;&gt;
...
&lt;scriptsrc=&quot;//cdn2.domain.com/path/main.js&quot;&gt;&lt;/script&gt;
</code></pre><h4 id="9．使用静态资源-CDN-来存储文件"><a href="#9．使用静态资源-CDN-来存储文件" class="headerlink" title="9．使用静态资源 CDN 来存储文件"></a>9．使用静态资源 CDN 来存储文件</h4><p>如果条件允许，可以利用 CDN 网络加快同一个地理区域内重复静态资源文件的响应下载速度，缩短资源请求时间。</p>
<h4 id="10．使用-CDN-Combo-下载传输内容"><a href="#10．使用-CDN-Combo-下载传输内容" class="headerlink" title="10．使用 CDN Combo 下载传输内容"></a>10．使用 CDN Combo 下载传输内容</h4><p>CDN Combo 是在 CDN 服务器端将多个文件请求打包成一个文件的形式来返回的技术，这样可以实现 HTTP 连接传输的一次性复用，减少浏览器的 HTTP 请求数，加快资源下载速度。例如同一个域名 CDN 服务器上的 a.js，b.js，c.js 就可以按如下方式在一个请求中下载。</p>
<pre><code>&lt;scriptsrc=&quot;//cdn.domain.com/path/a.js,b.js,c.js&quot;&gt;&lt;/script&gt;
</code></pre><h4 id="11．使用可缓存的-AJAX"><a href="#11．使用可缓存的-AJAX" class="headerlink" title="11．使用可缓存的 AJAX"></a>11．使用可缓存的 AJAX</h4><p>对于返回内容相同的请求，没必要每次都直接从服务端拉取，合理使用 AJAX 缓存能加快 AJAX 响应速度并减轻服务器压力。</p>
<pre><code>$.ajax({
    url: url,
    type: &#39;get&#39;,
    cache: true,
    //推荐使用缓存
    data: {},
    success() {
        //
        ...
    },
    error() {
        //
        ...
    }
});
</code></pre><h4 id="12．使用-GET-来完成-AJAX-请求"><a href="#12．使用-GET-来完成-AJAX-请求" class="headerlink" title="12．使用 GET 来完成 AJAX 请求"></a>12．使用 GET 来完成 AJAX 请求</h4><p>使用 XMLHttpRequest 时，浏览器中的 POST 方法会发起两次 TCP 数据包传输，首先发送文件头，然后发送 HTTP 正文数据。而使用 GET 时只发送头部，所以在拉取服务端数据时使用 GET 请求效率更高。</p>
<pre><code>$.ajax({
    url: url,
    type: &#39;get&#39;,
    //推荐使用get完成请求
    data: {},
    success() {
        //
        ...
    },
    error() {
        //
        ...
    }
});
</code></pre><h4 id="13．减少-Cookie-的大小并进行-Cookie-隔离"><a href="#13．减少-Cookie-的大小并进行-Cookie-隔离" class="headerlink" title="13．减少 Cookie 的大小并进行 Cookie 隔离"></a>13．减少 Cookie 的大小并进行 Cookie 隔离</h4><p>HTTP 请求通常默认带上浏览器端的 Cookie 一起发送给服务器，所以在非必要的情况下，要尽量减少 Cookie 来减小 HTTP 请求的大小。对于静态资源，尽量使用不同的域名来存放，因为 Cookie 默认是不能跨域的，这样就做到了不同域名下静态资源请求的 Cookie 隔离。</p>
<h4 id="14．缩小-favicon-ico-并缓存"><a href="#14．缩小-favicon-ico-并缓存" class="headerlink" title="14．缩小 favicon.ico 并缓存"></a>14．缩小 favicon.ico 并缓存</h4><p>有利于 favicon.ico 的重复加载，因为一般一个 Web 应用的 favicon.ico 是很少改变的。</p>
<h4 id="15．推荐使用异步-JavaScript-资源"><a href="#15．推荐使用异步-JavaScript-资源" class="headerlink" title="15．推荐使用异步 JavaScript 资源"></a>15．推荐使用异步 JavaScript 资源</h4><p>异步的 JavaScript 资源不会阻塞文档解析，所以允许在浏览器中优先渲染页面，延后加载脚本执行。例如 JavaScript 的引用可以如下设置，也可以使用模块化加载机制来实现。</p>
<pre><code>&lt;scriptsrc=&quot;main.js&quot;defer&gt;&lt;/script&gt;
&lt;scriptsrc=&quot;main.js&quot;async&gt;&lt;/script&gt;
</code></pre><p>使用 async 时，加载和渲染后续文档元素的过程和 main.js 的加载与执行是并行的。使用 defer 时，加载后续文档元素的过程和 main.js 的加载是并行的，但是 main.js 的执行要在页面所有元素解析完成之后才开始执行。</p>
<h4 id="16．消除阻塞渲染的-CSS-及-JavaScript"><a href="#16．消除阻塞渲染的-CSS-及-JavaScript" class="headerlink" title="16．消除阻塞渲染的 CSS 及 JavaScript"></a>16．消除阻塞渲染的 CSS 及 JavaScript</h4><p>对于页面中加载时间过长的 CSS 或 JavaScript 文件，需要进行合理拆分或延后加载，保证关键路径的资源能快速加载完成。</p>
<h4 id="17．避免使用-CSS-import-引用加载-CSS"><a href="#17．避免使用-CSS-import-引用加载-CSS" class="headerlink" title="17．避免使用 CSS import 引用加载 CSS"></a>17．避免使用 CSS import 引用加载 CSS</h4><p>CSS 中的 <code>＠import</code> 可以从另一个样式文件中引入样式，但应该避免这种用法，因为这样会增加 CSS 资源加载的关键路径长度，带有 <code>＠import</code> 的 CSS 样式需要在 CSS 文件串行解析到 <code>@import</code> 时才会加载另外的 CSS 文件，大大延后 CSS 渲染完成的时间。</p>
<pre><code>&lt;!--不推荐--&gt;
&lt;style&gt;
    @import&quot;path/main.css&quot;;
&lt;/style&gt;
&lt;!--推荐--&gt;
&lt;linkrel=&quot;stylesheet&quot;href=&quot;//cdn1.domain.com/path/main.css&quot;&gt;
</code></pre><h3 id="页面渲染类"><a href="#页面渲染类" class="headerlink" title="页面渲染类"></a>页面渲染类</h3><h4 id="1．把-CSS-资源引用放到-HTML-文件顶部"><a href="#1．把-CSS-资源引用放到-HTML-文件顶部" class="headerlink" title="1．把 CSS 资源引用放到 HTML 文件顶部"></a>1．把 CSS 资源引用放到 HTML 文件顶部</h4><p>一般推荐将所有 CSS 资源尽早指定在 HTML 文档 <code>&lt;head&gt;</code> 中，这样浏览器可以优先下载 CSS 并尽早完成页面渲染。</p>
<h4 id="2．JavaScript-资源引用放到-HTML-文件底部"><a href="#2．JavaScript-资源引用放到-HTML-文件底部" class="headerlink" title="2．JavaScript 资源引用放到 HTML 文件底部"></a>2．JavaScript 资源引用放到 HTML 文件底部</h4><p>JavaScript 资源放到 HTML 文档底部可以防止 JavaScript 的加载和解析执行对页面渲染造成阻塞。由于 JavaScript 资源默认是解析阻塞的，除非被标记为异步或者通过其他的异步方式加载，否则会阻塞 HTML DOM 解析和 CSS 渲染的过程。</p>
<h4 id="3．尽量预先设定图片等大小"><a href="#3．尽量预先设定图片等大小" class="headerlink" title="3．尽量预先设定图片等大小"></a>3．尽量预先设定图片等大小</h4><p>在加载大量的图片元素时，尽量预先限定图片的尺寸大小，否则在图片加载过程中会更新图片的排版信息，产生大量的重排</p>
<h4 id="4．不要在-HTML-中直接缩放图片"><a href="#4．不要在-HTML-中直接缩放图片" class="headerlink" title="4．不要在 HTML 中直接缩放图片"></a>4．不要在 HTML 中直接缩放图片</h4><p>在 HTML 中直接缩放图片会导致页面内容的重排重绘，此时可能会使页面中的其他操作产生卡顿，因此要尽量减少在页面中直接进行图片缩放。</p>
<h4 id="5．减少-DOM-元素数量和深度"><a href="#5．减少-DOM-元素数量和深度" class="headerlink" title="5．减少 DOM 元素数量和深度"></a>5．减少 DOM 元素数量和深度</h4><p>HTML 中标签元素越多，标签的层级越深，浏览器解析 DOM 并绘制到浏览器中所花的时间就越长，所以应尽可能保持 DOM 元素简洁和层级较少。</p>
<pre><code>&lt;!--不推荐--&gt;
&lt;div&gt;
    &lt;span&gt;
        &lt;ahref=&quot;javascript:void(0);&quot;&gt;
            &lt;imgsrc=&quot;./path/photo.jpg&quot;alt=&quot;图片&quot;&gt;
        &lt;/a&gt;
    &lt;/span&gt;
&lt;/div&gt;
&lt;!--推荐--&gt;
&lt;imgsrc=&quot;./path/photo.jpg&quot;alt=&quot;图片&quot;&gt;
</code></pre><h4 id="6．尽量避免在选择器末尾添加通配符"><a href="#6．尽量避免在选择器末尾添加通配符" class="headerlink" title="6．尽量避免在选择器末尾添加通配符"></a>6．尽量避免在选择器末尾添加通配符</h4><p>CSS 解析匹配到 渲染树的过程是从右到左的逆向匹配，在选择器末尾添加通配符至少会增加一倍多计算量。</p>
<h4 id="7．减少使用关系型样式表的写法"><a href="#7．减少使用关系型样式表的写法" class="headerlink" title="7．减少使用关系型样式表的写法"></a>7．减少使用关系型样式表的写法</h4><p>直接使用唯一的类名即可最大限度的提升渲染引擎绘制渲染树等效率</p>
<h4 id="8．尽量减少使用-JS-动画"><a href="#8．尽量减少使用-JS-动画" class="headerlink" title="8．尽量减少使用 JS 动画"></a>8．尽量减少使用 JS 动画</h4><p>JS 直接操作 DOM 极容易引起页面的重排</p>
<h4 id="9．CSS-动画使用-translate、scale-代替-top、height"><a href="#9．CSS-动画使用-translate、scale-代替-top、height" class="headerlink" title="9．CSS 动画使用 translate、scale 代替 top、height"></a>9．CSS 动画使用 translate、scale 代替 top、height</h4><p>尽量使用 CSS3 的 translate、scale 属性代替 top、left 和 height、width，避免大量的重排计算</p>
<h4 id="10．尽量避免使用-table、-iframe"><a href="#10．尽量避免使用-table、-iframe" class="headerlink" title="10．尽量避免使用 table、 iframe"></a>10．尽量避免使用 <code>table</code>、 <code>iframe</code></h4><p><code>&lt;table&gt;</code> 内容的渲染是将 table 的 DOM 渲染树全部生成完并一次性绘制到页面上的，所以在长表格渲染时很耗性能，应该尽量避免使用它，可以考虑使用列表元素 <code>&lt;ul&gt;</code> 代替。尽量使用异步的方式动态添加 iframe，因为 iframe 内资源的下载进程会阻塞父页面静态资源的下载与 CSS 及 HTML DOM 的解析。</p>
<h4 id="11．避免运行耗时的-JavaScript"><a href="#11．避免运行耗时的-JavaScript" class="headerlink" title="11．避免运行耗时的 JavaScript"></a>11．避免运行耗时的 JavaScript</h4><p>长时间运行的 JavaScript 会阻塞浏览器构建 DOM 树、DOM 渲染树、渲染页面。所以，任何与页面初次渲染无关的逻辑功能都应该延迟加载执行，这和 JavaScript 资源的异步加载思路是一致的。</p>
<h4 id="12．避免使用-CSS-表达式或-CSS-滤镜"><a href="#12．避免使用-CSS-表达式或-CSS-滤镜" class="headerlink" title="12．避免使用 CSS 表达式或 CSS 滤镜"></a>12．避免使用 CSS 表达式或 CSS 滤镜</h4><p>CSS 表达式或 CSS 滤镜的解析渲染速度是比较慢的，在有其他解决方案的情况下应该尽量避免使用。</p>
<pre><code>//不推荐
.opacity{
    filter : progid :DXImageTransform.Microsoft.Alpha( opacity =50);
}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这样我们就对web前端开发过程中pc端的常用优化点做了粗略的分析，下篇博客讨论一下移动端的常用优化点。<a href="http://pancakeawesome.ink/%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%82%B9---PC%E7%AB%AF%E4%BC%98%E5%8C%96.html">传送门。</a></p>
<p>关于页面优化的常用技术手段和思路主要包括以上这些，尽管列举出很多，但仍可能有少数遗漏，可见前端性能优化不是一件简简单单的事情，其涉及的内容很多。大家可以根据实际情况将这些方法应用到自己的项目当中，要想全部做到几乎是不可能的，但做到用户可接受的原则还是很容易实现的。</p>
<p>另外，如果你有比较好的优化点想要扩充，欢迎下方评论。</p>
]]></content>
      
        <categories>
            
            <category> 前端优化 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 前端优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器「内核」都做了些什么？]]></title>
      <url>/%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%8C%E5%86%85%E6%A0%B8%E3%80%8D%E9%83%BD%E5%81%9A%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>四不四经常有人在你面前念(zhūang)叨(bī)，「这是浏览器内核的问题！Safari[səˈfɑri]的内核不支持！」？</p>
</blockquote>
<p>今天咱们就来聊聊所谓的「内核」！</p>
<p>要讲内核首先要讲浏览器基础，浏览器基础是前端知识网中的一个小分支，也是前端开发人员必须掌握的基础知识点。他贯穿着前端的整个网络体系，项目优化也是围绕着浏览器进行的。</p>
<h2 id="浏览器「内核」都做了些什么？"><a href="#浏览器「内核」都做了些什么？" class="headerlink" title="浏览器「内核」都做了些什么？"></a>浏览器「内核」都做了些什么？</h2><h3 id="一个网址引发的操作"><a href="#一个网址引发的操作" class="headerlink" title="一个网址引发的操作"></a>一个网址引发的操作</h3><p>开发人员在面试的时候或许会被问到：</p>
<p>从你在浏览器输入一个网址到网页内容完全被展示的这段时间内，都发生了什么事情？ 确实是个老生常谈的问题，但问题的答案并不是唯一的，或许在三五年前，这个问题还会有一个「相对」标准的答案。</p>
<ol>
<li><p>浏览器在接收到这个指令时，会开启一个单独的线程来处理这个指令，首先要判断用户输入的是否为合法或合理的 URL 地址，是否为 HTTP 协议请求，如果是那就进入下一步</p>
</li>
<li><p>浏览器的浏览器引擎将对此 URL 进行分析，如果存在缓存「cache-control」且未过期，则会从本地缓存提取文件（From Memory Cache，200返回码），如果缓存「cache-control」不存在或过期，浏览器将发起远程请求</p>
</li>
<li><p>通过 DNS 解析域名获取该网站地址对应的 IP 地址，连同浏览器的 Cookie、 userAgent 等信息向此 IP 发出 GET 请求。</p>
</li>
<li><p>接下来就是经典的「三次握手」，HTTP 协议会话，浏览器客户端向 Web 服务器发送报文，进行通讯和数据传输。</p>
</li>
<li><p>进入网站的后端服务，如 Tomcat、Apache 等，还有近几年流行的 Node.js 服务器，这些服务器上部署着应用代码，语言有很多，如 Java、 PHP、 C++、 C# 和 Javascript 等。</p>
</li>
<li><p>服务器根据 URL 执行相应的后端应用逻辑，期间会使用到「服务器缓存」或「数据库」。</p>
</li>
<li><p>服务器处理请求并返回响应报文，如果浏览器访问过该页面，缓存上有对应资源，与服务器最后修改记录对比，一致则返回 304，否则返回 200 和对应的内容。</p>
</li>
<li><p>浏览器接收到返回信息并开始下载该 HTML文件（无缓存、200返回码）或从本地缓存提取文件（有缓存、304返回码）</p>
</li>
<li><p>浏览器的渲染引擎在拿到 HTML 文件后，便开始解析构建 DOM 树，并根据 HTML 中的标记请求下载指定的 MIME 类型文件（如 CSS、 JavaScript 脚本等），同时使用&amp;设置缓存等内容。</p>
</li>
<li><p>渲染引擎根据 CSS 样式规则将 DOM 树扩充为渲染树，然后进行重排、重绘。</p>
</li>
<li><p>如果含有 JS 文件将会执行，进行 Dom 操作、缓存读存、事件绑定等操作。最终页面将被展示在浏览器上。</p>
</li>
</ol>
<p>此答案精简的概括了「后端为主的 MVC 模式」及早期 Web 应用的浏览器响应的全过程。前端技术发展到现在，「前后端分离」「中间件直出」和「MNV*模式」也已问世，再谈及此问题，答案会有所不同。</p>
<p>就以「前后端分离」为例，在上方答案的第4步后，紧接着就不会直接进入后端服务器了。而会被 HTTP 和反向代理服务器，如 Ngnix，拦截。</p>
<ul>
<li><p>前置步骤1、2、3、4</p>
</li>
<li><p>Ngnix 在监听到 HTTP（80端口）或 HTTPS（443端口）请求，根据 URL 做服务分发，分发（rewrite）到后端服务器或静态资源服务器，首页请求基本是分发到静态服务器，返回一个 HTML 文件</p>
</li>
<li><p>步骤7、8、9、10</p>
</li>
<li><p>执行 JS 脚本，异步 ajax、 fetch 发起 POST、 GET 请求，重新进入 Ngnix 分发，此次分发到后端服务器，步骤5、6、7，然后返回一个 xml 或 json 格式的信息，一般含有 code（返回码）和 result（依赖信息）</p>
</li>
<li><p>js 回调根据返回码执行不同的逻辑，增删改页面元素，此时可能会发生重排或重绘。首页加载结束。</p>
</li>
</ul>
<p>从以上步骤可以发现，浏览器可能会触发两次重绘，极易产生「白屏」或「页面抖动」现象，为了解决这个问题「中间件直出」的模式应运而生。另外为了扩充大前端的阵营，吸纳 IOS 和 Android，Google 设计了「MNV*模式」，典型代表就是 ReactNative，但此模式已经脱离了浏览器的范畴，此处就不再做扩展。</p>
<p>以上讨论的渲染过程中使用到了较多的浏览器功能，如用户地址栏输入框、网络请求、浏览器文档解析、渲染引擎渲染网页、 JavaScript 引擎执行 js 脚本、客户端存储等。 接下来我们介绍下浏览器的基本结构组成。</p>
<h3 id="浏览器的结构组成"><a href="#浏览器的结构组成" class="headerlink" title="浏览器的结构组成"></a>浏览器的结构组成</h3><p>浏览器一般由七个模块组成，User Interface（用户界面）、Browser engine（浏览器引擎）、Rendering engine（渲染引擎）、Networking（网络）、JavaScript Interpreter（js解释器）、UI Backend（UI 后端）、Date Persistence（数据持久化存储） 如下图：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fllfkpe04bj30eo09z74c.jpg" alt=""></p>
<ul>
<li><p><strong>用户界面</strong> －包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了页面显示窗口之外的其他部分</p>
</li>
<li><p><strong>浏览器引擎</strong> －可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据等，是浏览器中各个部分之间相互通信的核心</p>
</li>
<li><p><strong>渲染引擎</strong> －解析DOM文档和CSS规则并将内容排版到浏览器中显示有样式的界面，也有人称之为排版引擎，我们常说的浏览器内核主要指的就是渲染引擎</p>
</li>
<li><p><strong>网络</strong> －用来完成网络调用或资源下载的模块</p>
</li>
<li><p><strong>UI 后端</strong> －用来绘制基本的浏览器窗口内控件，如输入框、按钮、单选按钮等，根据浏览器不同绘制的视觉效果也不同，但功能都是一样的。</p>
</li>
<li><p><strong>JS解释器</strong> －用来解释执行JS脚本的模块，如 V8 引擎、JavaScriptCore</p>
</li>
<li><p><strong>数据存储</strong> －浏览器在硬盘中保存 cookie、localStorage等各种数据，可通过浏览器引擎提供的API进行调用</p>
</li>
</ul>
<p>作为前端开发人员，我们需要重点理解渲染引擎的工作原理，灵活应用数据存储技术，在实际项目开发中会经常涉及到这两个部分，尤其是在做项目性能优化时，理解浏览器渲染引擎的工作原理尤为重要。而其他部分则是由浏览器自行管理的，开发者能控制的地方较少。今天我们就围绕这两个重点其中的一个部分「浏览器渲染引擎」也就是进行展开，「浏览器内核」。</p>
<h3 id="浏览器渲染引擎"><a href="#浏览器渲染引擎" class="headerlink" title="浏览器渲染引擎"></a>浏览器渲染引擎</h3><p>浏览器渲染引擎是由各大浏览器厂商依照 W3C 标准自行研发的，也被称之为「浏览器内核」。</p>
<p>目前，市面上使用的主流浏览器内核有5类：Trident、Gecko、Presto、Webkit、Blink。</p>
<p><strong>Trident</strong>：俗称 IE 内核，也被叫做 MSHTML 引擎，目前在使用的浏览器有 IE11 -，以及各种国产多核浏览器中的IE兼容模块。另外微软的 Edge 浏览器不再使用 MSHTML 引擎，而是使用类全新的引擎 EdgeHTML。</p>
<p><strong>Gecko</strong>：俗称 Firefox 内核，Netscape6 开始采用的内核，后来的 Mozilla FireFox（火狐浏览器）也采用了该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko 内核的浏览器也很多，这也是 Gecko 内核虽然年轻但市场占有率能够迅速提高的重要原因。</p>
<p><strong>Presto</strong>：Opera 前内核，为啥说是前内核呢？因为 Opera12.17 以后便拥抱了 Google Chrome 的 Blink 内核，此内核就没了寄托</p>
<p><strong>Webkit</strong>：Safari 内核，也是 Chrome 内核原型，主要是 Safari 浏览器在使用的内核，也是特性上表现较好的浏览器内核。也被大量使用在移动端浏览器上。</p>
<p><strong>Blink</strong>： 由 Google 和 Opera Software 开发，在Chrome（28及往后版本）、Opera（15及往后版本）和Yandex浏览器中使用。Blink 其实是 Webkit 的一个分支，添加了一些优化的新特性，例如跨进程的 iframe，将 DOM 移入 JavaScript 中来提高 JavaScript 对 DOM 的访问速度等，目前较多的移动端应用内嵌的浏览器内核也渐渐开始采用 Blink。</p>
<h3 id="渲染引擎的工作流程"><a href="#渲染引擎的工作流程" class="headerlink" title="渲染引擎的工作流程"></a>渲染引擎的工作流程</h3><p>浏览器渲染引擎最重要的工作就是将 HTML 和 CSS 文档解析组合最终渲染到浏览器窗口上。如下图所示，渲染引擎在接受到 HTML 文件后主要进行了以下操作：解析 HTML 构建 DOM 树 -&gt; 构建渲染树 -&gt; 渲染树布局 -&gt; 渲染树绘制。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fllfkzy0elj30hr02gmx3.jpg" alt=""></p>
<p>解析 HTML 构建 DOM 树时渲染引擎会将 HTML 文件的便签元素解析成多个 DOM 元素对象节点，并且将这些节点根据父子关系组成一个树结构。同时 CSS 文件被解析成 CSS 规则表，然后将每条 CSS 规则按照「从右向左」的方式在 DOM 树上进行逆向匹配，生成一个具有样式规则描述的 DOM 渲染树。接下来就是将渲染树进行布局、绘制的过程。首先根据 DOM 渲染树上的样式规则，对 DOM 元素进行大小和位置的定位，关键属性如 <code>position;width;margin;padding;top;border;...</code>，接下来再根据元素样式规则中的 <code>color;background;shadow;...</code>规则进行绘制。</p>
<p>另外，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<p>再者，需要注意的是，在浏览器渲染完首屏页面后，如果对 DOM 进行操作会引起浏览器引擎对 DOM 渲染树的重新布局和重新绘制，我们叫做「重排」和「重绘」，由于重排和重绘是前后依赖的关系，重绘发生时未必会触发渲染引擎的重排，但是如果发生了重排就必然会触发重绘操作，这样带来的性能损害就是巨大的。因此我们在做性能优化的时候应该遵循「避免重排；减少重绘」的原则。</p>
<h3 id="不同浏览器内核间的差异"><a href="#不同浏览器内核间的差异" class="headerlink" title="不同浏览器内核间的差异"></a>不同浏览器内核间的差异</h3><p>在不同的浏览器内核下， 浏览器页面渲染的流程略有不同</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fllflc4s2xj30hj08e74d.jpg" alt=""></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fllfm1l1b1j30hq08f0tj.jpg" alt=""> </p>
<p>上面两幅图分别是 Webkit 和 Geoko 内核渲染 DOM 的工作流程，对比可以看出，两者的区别主要在于 CSS 样式表的解析时机，Webkit 内核下，HTML 和 CSS 文件的解析是同步的，而 Geoko 内核下，CSS 文件需要等到 HTML 文件解析成内容 Sink 后才进行解析。</p>
<p>另外描述术语也有不同，除此之外两者的流程就基本相同了，其中最重要的三个部分就是 「HTML 的解析」「CSS 的解析」「渲染树的生成」。这三个部分的原理比较深，会涉及到「词法分析」「语法分析」「转换」「解释」等数据结构的知识，比较枯燥，一般我们了解到这里就够了，想深入了解的同学可以阅读此篇译文，浏览器的工作原理，里面详细的解释了以上三个部分的流程和原理。此处就不再多做赘述了。</p>
<h3 id="关于-CSS-规则的匹配"><a href="#关于-CSS-规则的匹配" class="headerlink" title="关于 CSS 规则的匹配"></a>关于 CSS 规则的匹配</h3><p>上面我们提到过， CSS 规则是按照「从右向左」的方式在 DOM 树上进行逆向匹配的，最终生成一个具有样式规则描述的 DOM 渲染树。</p>
<p>但是你知道为什么要「从右向左」做逆向匹配吗？</p>
<p>我们重新回看【webkit 内核工作流程图】</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fllfmecm8zj30hs08d74d.jpg" alt=""></p>
<p>CSS 规则匹配是发生在webkit引擎的「Attachment」过程中，浏览器要为每个 DOM Tree 中的元素扩充 CSS 样式规则（匹配 Style Rules）。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。</p>
<p>我们来举一个最简单的栗子：</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;divclass=&quot;t&quot;&gt;
            &lt;span&gt;test&lt;/span&gt;
            &lt;p&gt;test&lt;/p&gt;
            &lt;div&gt;
            &lt;/div&gt;
&lt;/template&gt;
&lt;style&gt;
div {
    color: #000;
}

div .t span {
    color: red;
}

div .t p {
    color: blue;
}
&lt;/style&gt;
</code></pre><p>此处我们有一个 html 元素 和一个 style 元素，两者需要做遍历匹配</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fllfmlb3g2j30hg08xglk.jpg" alt=""></p>
<p>此处会有 4*3 个匹配项，如果做正向匹配，在遇到 <code>&lt;span&gt;</code> 标签匹配 <code>div .t p{color: red; }</code> 到匹配项时，计算机首先要找到 <code>&lt;span&gt;</code> 标签的父标签和祖父标签，判断他们是否满足 <code>div .t</code>的规则，然后再匹配 <code>&lt;span&gt;</code>是否为 <code>p</code>标签，此处匹配不成功，产生了三次浪费。</p>
<p>如果时逆向匹配，那么第一次对比是否为p标签便可排除此规则，效率更高。</p>
<p>如果将 HTML 结构变复杂，CSS 规则表变庞大，那么，「逆向匹配」的优势就远大于「正向匹配」了，因为匹配的情况远远低于不匹配的情况。另外，如果在选择器结尾加上通配符「*」，那么「逆向匹配」的优势就大打折扣了，这也就是很多优化原则提到的「尽量避免在选择器末尾添加通配符」的原因。</p>
<p>极限了想，如果我们的样式表不存在嵌套关系，如下：</p>
<pre><code>&lt;template&gt;
    &lt;divclass=&quot;t&quot;&gt;
        &lt;spanclass=&quot;div_t_span&quot;&gt;test&lt;/span&gt;
            &lt;pclass=&quot;div_t_p&quot;&gt;test&lt;/p&gt;
                &lt;div&gt;
&lt;/template&gt;
&lt;style&gt;
div {
    color: #000;
}

.div_t_span {
    color: red;
}

.div_t_p {
    color: blue;
}
&lt;/style&gt;
</code></pre><p>那么引擎的「Attachment」过程将得到极大的精简，效率也是可想而知的，这就是为什么「微信小程序」样式表不建议使用关系行写法的原因。</p>
<h3 id="相关的性能优化"><a href="#相关的性能优化" class="headerlink" title="相关的性能优化"></a>相关的性能优化</h3><p>我们大致可以在以上案例中看到同浏览器渲染引擎相关的可行优化点。</p>
<p>大致为以下几种</p>
<h4 id="减少-JS-加载对-Dom-渲染的影响"><a href="#减少-JS-加载对-Dom-渲染的影响" class="headerlink" title="减少 JS 加载对 Dom 渲染的影响"></a>减少 JS 加载对 Dom 渲染的影响</h4><p>将 JS 文件放在 HTML 文档后加载，或者使用异步的方式加载 JS 代码</p>
<h4 id="避免重排，减少重绘"><a href="#避免重排，减少重绘" class="headerlink" title="避免重排，减少重绘"></a>避免重排，减少重绘</h4><p>在做 css 动画的时候减少使用 width、 margin、 padding 等影响 CSS 布局对规则，可以使用 CSS3 的 transform 代替。另外值得注意的是，在加载大量的图片元素时，尽量预先限定图片的尺寸大小，否则在图片加载过程中会更新图片的排版信息，产生大量的重排。</p>
<h4 id="减少使用关系型样式表的写法"><a href="#减少使用关系型样式表的写法" class="headerlink" title="减少使用关系型样式表的写法"></a>减少使用关系型样式表的写法</h4><p>直接使用唯一的类名即可最大限度的提升渲染效率，另外尽量避免在选择器末尾添加通配符</p>
<h4 id="减少-DOM-的层级"><a href="#减少-DOM-的层级" class="headerlink" title="减少 DOM 的层级"></a>减少 DOM 的层级</h4><p>减少无意义的 dom 层级可以减少 渲染引擎 Attachment 过程中的匹配计算量</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我所认识的JavaScript正则表达式]]></title>
      <url>/%E6%88%91%E6%89%80%E8%AE%A4%E8%AF%86%E7%9A%84JavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果说这是一篇关于正则表达式的小结，我更愿意把它当做一个手册。</p>
<h2 id="我所认识的JavaScript正则表达式"><a href="#我所认识的JavaScript正则表达式" class="headerlink" title="我所认识的JavaScript正则表达式"></a>我所认识的JavaScript正则表达式</h2><h3 id="RegExp-三大方法"><a href="#RegExp-三大方法" class="headerlink" title="RegExp 三大方法"></a>RegExp 三大方法</h3><p>本文的RegExp采用直接量语法表示：/pattern/attributes。attributes有三个选择，i、m和g，m（多行匹配）不常用直接省略，所以一个pattern（匹配模式）可以表示如下：</p>
<pre><code>var pattern =/hello/ig;
</code></pre><p>i（ignore）表示不区分大小写（地搜索匹配），比较简单，以下例子中不加述说；g（global）表示全局（搜索匹配），即找到一个后继续找下去，相对复杂，以下各种方法中会特别介绍。</p>
<p>既然是RegExp的三大方法，所以都是pattern.test/exec/complie的格式。</p>
<p>主要功能：检测指定字符串是否含有某个子串（或者匹配模式），返回true或者false。</p>
<p>示例如下：</p>
<pre><code>var s = &#39;you love me and I love you&#39;;
var pattern = /you/;
var ans = pattern.test(s);
console.log(ans);
// true
</code></pre><p>如果attributes用了g，则可以继续找下去，其中还会涉及lastIndex属性（参照exec中搭配g的介绍）。</p>
<p>主要功能：提取指定字符串中的符合要求的子串（或者匹配模式），返回一个数组存放匹配结果；如果没有，则返回null。（也可自己写方法循环提取所有或者指定index的数据）</p>
<p>exec可以说是test的升级版本，因为它不仅可以检测，而且检测到了可以直接提取结果。</p>
<p>示例如下：</p>
<pre><code>var s = &#39;you love me and I love you&#39;;
var pattern = /you/;
var ans = pattern.exec(s);
console.log(ans);
// [&quot;you&quot;, index: 0, input: &quot;you love me and I love you&quot;]
console.log(ans.index);
// 0
console.log(ans.input);
// you love me and I love you
</code></pre><p>输出的东西很有意思。此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。</p>
<p>啥叫“与子表达式相匹配的文本”？看下面的例子：</p>
<pre><code>var s = &#39;you love me and I love you&#39;;
var pattern = /y(o?)u/;
var ans = pattern.exec(s);
console.log(ans);
// [&quot;you&quot;, &quot;o&quot;, index: 0, input: &quot;you love me and I love you&quot;]
console.log(ans.length)
// 2
</code></pre><p>所谓的子表达式就是pattern里（）内的东西（具体可以参考下文对子表达式的介绍）。再看上面例子的数组长度，是2！！index和input只是数组属性（chrome中以上的输出可能会让人误会）。</p>
<p>除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。我们可以看得出，<strong>在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的</strong>。</p>
<p>如果使用 “g” 参数，exec() 的工作原理如下（还是以上的例子 ps：如果test使用g参数类似）：</p>
<ol>
<li>找到第一个 “you”，并存储其位置</li>
<li>如果再次运行 exec()，则从存储的位置（lastIndex）开始检索，并找到下一个 “you”，并存储其位置</li>
</ol>
<p>当 RegExpObject 是一个全局正则表达式时，exec() 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，我们可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。这里引入lastIndex属性，这货只有跟g和test（或者g和exec）三者搭配时才有作用。它是pattern的一个属性，一个整数，标示开始下一次匹配的字符位置。</p>
<p>实例如下：</p>
<pre><code>var s = &#39;you love me and I love you&#39;;
var pattern = /you/g;
var ans;
do {
    ans = pattern.exec(s);
    console.log(ans);
    console.log(pattern.lastIndex);
} while (ans !== null)
</code></pre><p>结果如下：</p>
<p><img src="https://img.funteas.com/a301222db5d77dd9038aa49a6fa50a74.png?imageView2/2/w/800" alt=""></p>
<p>应该还容易理解，当第三次循环时，找不到“you”了，于是返回null，lastIndex值也变成0了。</p>
<p>如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串（仍然使用旧的pattern），就必须手动地把 lastIndex 属性重置为 0。</p>
<p>主要功能：改变当前匹配模式（pattern）</p>
<p>这货是改变匹配模式时用的，用处不大，略过。详见JavaScript compile() 方法</p>
<h3 id="String-四大护法"><a href="#String-四大护法" class="headerlink" title="String 四大护法"></a>String 四大护法</h3><p>和RegExp三大方法分庭抗礼的是String的四大护法，四大护法有些和RegExp三大方法类似，有的更胜一筹。</p>
<p>既然是String家族下的四大护法，所以肯定是string在前，即str.search/match/replace/split形式。</p>
<p>既然是String的方法，当然参数可以只用字符串而不用pattern。</p>
<p>主要功能：搜索指定字符串中是否含有某子串（或者匹配模式），如有，返回子串在原串中的初始位置，如没有，返回-1。</p>
<p>是不是和test类似呢？test只能判断有木有，search还能返回位置！当然test()如果有需要能继续找下去，而search则会自动忽略g（如果有的话）。实例如下：</p>
<pre><code>var s = &#39;you love me and I love you&#39;;
var pattern = /you/;
var ans = s.search(pattern);
console.log(ans);
// 0
</code></pre><p>话说和String的indexOf方法有点相似，不同的是indexOf方法可以从指定位置开始查找，但是不支持正则。</p>
<p>主要功能：和exec类似，从指定字符串中查找子串或者匹配模式，找到返回数组，没找到返回null</p>
<p>match是exec的轻量版，当不使用全局模式匹配时，match和exec返回结果一致；当使用全局模式匹配时，match直接返回一个字符串数组，获得的信息远没有exec多，但是使用方式简单。</p>
<p>实例如下：</p>
<pre><code>var s =&#39;you love me and I love you&#39;;
console.log(s.match(/you/));
// [&quot;you&quot;, index: 0, input: &quot;you love me and I love you&quot;]
console.log(s.match(/you/g));
// [&quot;you&quot;, &quot;you&quot;]
</code></pre><p>主要功能：用另一个子串替换指定字符串中的某子串（或者匹配模式），返回替换后的新的字符串  str.replace(‘搜索模式’,’替换的内容’)  如果用的是pattern并且带g，则全部替换；否则替换第一处。</p>
<p>实例如下：</p>
<pre><code>var s =&#39;you love me and I love you&#39;;
console.log(s.replace(&#39;you&#39;,&#39;zichi&#39;));
// zichi love me and I love you
console.log(s.replace(/you/,&#39;zichi&#39;));
// zichi love me and I love you
console.log(s.replace(/you/g,&#39;zichi&#39;));
// zichi love me and I love zichi
</code></pre><p>如果需要替代的内容不是指定的字符串，而是跟匹配模式或者原字符串有关，那么就要用到$了（记住这些和$符号有关的东东只和replace有关哦）。</p>
<p><img src="https://img.funteas.com/af7727482590a48709ff28d8de0d1dd2.png?imageView2/2/w/800" alt=""></p>
<p>怎么用？看个例子就明白了。</p>
<pre><code>var s = &#39;I love you&#39;;
var pattern = /love/;
var ans = s.replace(pattern, &#39;&lt;div class=&quot;article-entry&quot; id=&quot;article-entry&quot;&#39; + &#39;&gt;&lt;&#39; + &quot;/div&gt;&quot;);
console.log(ans);
// I I love you you
</code></pre><p>没错，’<div class="“article-entry”" id="“article-entry”’" +="" ‘="">&lt;’ + “$’”其实就相当于原串了！</div></p>
<p>replace的第二个参数还能是函数，看具体例子前先看一段介绍：</p>
<blockquote>
<p>注意：第一个参数是匹配到的子串，接下去是子表达式匹配的值，如果要用子表达式参数，则必须要有第一个参数（表示匹配到的串），也就是说，如果要用第n个参数代表的值，则左边参数都必须写出来。最后两个参数跟exec后返回的数组的两个属性差不多。</p>
</blockquote>
<pre><code>var s = &#39;I love you&#39;;
var pattern = /love/;
var ans = s.replace(pattern, function(a) {　　 
// 只有一个参数，默认为匹配到的串（如还有参数，则按序表示子表达式和其他两个参数）
    return a.toUpperCase();
});
console.log(ans);
// I LOVE you
</code></pre><p>主要功能：分割字符串</p>
<p>字符串分割成字符串数组的方法（另有数组变成字符串的join方法）。直接看以下例子：</p>
<pre><code>var s = &#39;you love me and I love you&#39;;
var pattern = &#39;and&#39;;
var ans = s.split(pattern);
console.log(ans);
// [&quot;you love me &quot;, &quot; I love you&quot;]
</code></pre><p>如果你嫌得到的数组会过于庞大，也可以自己定义数组大小，加个参数即可：</p>
<pre><code>var s = &#39;you love me and I love you&#39;;
var pattern = /and/;
var ans = s.split(pattern, 1);
console.log(ans);
// [&quot;you love me &quot;]
</code></pre><h3 id="RegExp-字符"><a href="#RegExp-字符" class="headerlink" title="RegExp 字符"></a>RegExp 字符</h3><p><img src="https://img.funteas.com/0f972256c0d7f457495addfb48b46aec.png?imageView2/2/w/800" alt=""><img src="https://img.funteas.com/452f237aaa6135b99502df770729c0f2.png?imageView2/2/w/800" alt=""><img src="https://img.funteas.com/7002103ee3659d4c5453949a4d1b528b.png?imageView2/2/w/800" alt=""></p>
<ul>
<li>\s 任意空白字符 \S相反 空白字符可以是： 空格符 (space character) 制表符 (tab character) 回车符 (carriage return character) 换行符 (new line character) 垂直换行符 (vertical tab character) 换页符 (form feed character)</li>
<li>\b是正则表达式规定的一个特殊代码，代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。（和^ $ 以及零宽断言类似）</li>
<li>\w 匹配字母或数字或下划线   [a-z0-9A-Z_]完全等同于\w</li>
</ul>
<h3 id="贪婪匹配和懒惰匹配"><a href="#贪婪匹配和懒惰匹配" class="headerlink" title="贪婪匹配和懒惰匹配"></a>贪婪匹配和懒惰匹配</h3><p>什么是贪婪匹配？贪婪匹配就是在正则表达式的匹配过程中，默认会使得匹配长度越大越好。</p>
<pre><code>var s = &#39;hello world welcome to my world&#39;;
var pattern = /hello.*world/;
var ans = pattern.exec(s);
console.log(ans)
// [&quot;hello world welcome to my world&quot;, index: 0, input: &quot;hello world welcome to my world&quot;]
</code></pre><p>以上例子不会匹配最前面的<a href="http://link.funteas.com/?target=http%3A%2F%2Fwww.codeceo.com%2Farticle%2Fhello-world-30-years.html" target="_blank" rel="external">Hello World</a> (title=undefined target=undefined)，而是一直贪心的往后匹配。</p>
<p>那么我需要最短的匹配怎么办？很简单，加个‘？’即可，这就是传说中的懒惰匹配，即匹配到了，就不往后找了。</p>
<pre><code>var s = &#39;hello world welcome to my world&#39;;
var pattern = /hello.*?world/;
var ans = pattern.exec(s);
console.log(ans)
// [&quot;hello world&quot;, index: 0, input: &quot;hello world welcome to my world&quot;]
</code></pre><p><strong>懒惰限定符（？）添加的场景如下：</strong></p>
<p><img src="https://img.funteas.com/bfed54f78ebb16f531dbb785782e7a7f.png?imageView2/2/w/800" alt=""></p>
<h3 id="子表达式"><a href="#子表达式" class="headerlink" title="子表达式"></a>子表达式</h3><p>用一个小括号指定：</p>
<pre><code>var s = &#39;hello world&#39;;
var pattern = /(hello)/;
var ans = pattern.exec(s);
console.log(ans);
</code></pre><p>在exec中数组输出子表达式所匹配的值：</p>
<pre><code>var s = &#39;hello world&#39;;
var pattern = /(h(e)llo)/;
var ans = pattern.exec(s);
console.log(ans);
// [&quot;hello&quot;, &quot;hello&quot;, &quot;e&quot;, index: 0, input: &quot;hello world&quot;]
</code></pre><p>在replace中作为替换值引用：</p>
<pre><code>var s = &#39;hello world&#39;;
var pattern = /(h\w*o)\s*(w\w*d)/;
var ans = s.replace(pattern, &#39;$2 $1&#39;)
console.log(ans);
// world hello
</code></pre><p>后向引用 &amp; 零宽断言</p>
<p>简单地说：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p>
<p>复杂地说：分组0对应整个正则表达式实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号。可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．</p>
<h3 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h3><p>如果我们要找连续两个一样的字符，比如要找两个连续的c，可以这样/c{2}/，如果要找两个连续的单词hello，可以这样/(hello){2}/，但是要在一个字符串中找连续两个相同的任意单词呢，比如一个字符串hellohellochinaworldworld，我要找的是hello和world，怎么找？</p>
<p>这时候就要用后向引用。看具体例子：</p>
<pre><code>var s = &#39;hellohellochinaworldworld&#39;;
var pattern = /(\w+)\1/g;
var a = s.match(pattern);
console.log(a);
// [&quot;hellohello&quot;, &quot;worldworld&quot;]
</code></pre><p>这里的\1就表示和匹配模式中的第一个子表达式（分组）一样的内容，\2表示和第二个子表达式（如果有的话）一样的内容，\3 \4 以此类推。（也可以自己命名，详见参考文献）</p>
<p>或许你觉得数组里两个hello两个world太多了，我只要一个就够了，就又要用到子表达式了。因为match方法里是不能引用子表达式的值的，我们回顾下哪些方法是可以的？没错，exec和replace是可以的！</p>
<p><strong>exec方式：</strong></p>
<pre><code>var s = &#39;hellohellochinaworldworld&#39;;
var pattern = /(\w+)\1/g;
var ans;
do {
    ans = pattern.exec(s);
    console.log(ans);
} while (ans !== null);
// result
// [&quot;hellohello&quot;, &quot;hello&quot;, index: 0, input: &quot;hellohellochinaworldworld&quot;] index.html:69
// [&quot;worldworld&quot;, &quot;world&quot;, index: 15, input: &quot;hellohellochinaworldworld&quot;] index.html:69// null
</code></pre><p>如果输出只要hello和world，console.log(ans[1])即可。</p>
<p><strong>replace方式：</strong></p>
<pre><code>var s = &#39;hellohellochinaworldworld&#39;;
var pattern = /(\w+)\1/g;
var ans = [];
s.replace(pattern, function(a, b) {
    ans.push(b);
});
console.log(ans);
// [&quot;hello&quot;, &quot;world&quot;]
</code></pre><p>如果要找连续n个相同的串，比如说要找出一个字符串中出现最多的字符：</p>
<pre><code>String.prototype.getMost = function() {
    var a = this.split(&#39;&#39;);
    a.sort();
    var s = a.join(&#39;&#39;);
    var pattern = /(\w)\1*/g;
    var a = s.match(pattern);
    a.sort(function(a, b) { return a.length &lt; b.length; });
    var letter = a[0][0];
    var num = a[0].length;
    return letter + &#39;: &#39; + num;
}
var s = &#39;aaabbbcccaaabbbcccccc&#39;;
console.log(s.getMost());
// c: 9
</code></pre><p>如果需要引用某个子表达式（分组），请认准后向引用！</p>
<h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><p>别被名词吓坏了，其实解释很简单。</p>
<p>它们用于查找在某些内容(但并不包括这些内容)之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)</p>
<p>零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。</p>
<pre><code>// 获取字符串中以ing结尾的单词的前半部分
var s = &#39;I love dancing but he likes singing&#39;;
var pattern = /\b\w+(?=ing\b)/g;
var ans = s.match(pattern);
console.log(ans);
// [&quot;danc&quot;, &quot;sing&quot;]
</code></pre><p>零宽度负预测先行断言，断言此位置的后面不能匹配表达式exp</p>
<pre><code>// 获取第五位不是i的单词的前四位
var s = &#39;I love dancing but he likes singing&#39;;
var pattern = /\b\w{4}(?!i)/g;
var ans = s.match(pattern);
console.log(ans);
// [&quot;love&quot;, &quot;like&quot;]
</code></pre><p>javascript正则只支持前瞻，不支持后瞻（(?&lt;=exp)和(?</p>
<p>关于零宽断言的具体应用可以参考综合应用一节给字符串加千分符。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>因为某些字符已经被正则表达式用掉了，比如. * ( ) / \  []，所以需要使用它们（作为字符）时，需要用\转义</p>
<pre><code>var s = &#39;http://www.cnblogs.com/zichi/&#39;;
var pattern = /http:\/\/www\.cnblogs\.com\/zichi\//;
var ans = pattern.exec(s);
console.log(ans);
// [&quot;http://www.cnblogs.com/zichi/&quot;, index: 0, input: &quot;http://www.cnblogs.com/zichi/&quot;]
</code></pre><p>如果需要匹配abc里的任意字母，可以用[abc]，但是如果不是单个字母那么简单，就要用到分支条件。</p>
<p>分支条件很简单，就是用|表示符合其中任意一种规则。</p>
<pre><code>var s = &quot;I don&#39;t like you but I love you&quot;;
var pattern = /I.*(like|love).*you/g;
var ans = s.match(pattern);
console.log(ans);
// [&quot;I don&#39;t like you but I love you&quot;]
</code></pre><p>答案执行了贪婪匹配，如果需要懒惰匹配，则：</p>
<pre><code>var s = &quot;I don&#39;t like you but I love you&quot;;
var pattern = /I.*?(like|love).*?you/g;
var ans = s.match(pattern);
console.log(ans);
// [&quot;I don&#39;t like you&quot;, &quot;I love you&quot;]
</code></pre><h3 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h3><pre><code>String.prototype.trim = function() {
returnthis.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
};
var s = &#39;    hello  world     &#39;;
var ans = s.trim();
console.log(ans.length);
// 12
</code></pre><pre><code>String.prototype.getAns = function() { var pattern = /(?=((?!\b)\d{3})+$)/g;
    returnthis.replace(pattern, &#39;,&#39;); }
var s = &#39;123456789&#39;;
console.log(s.getAns());
// 123,456,789
</code></pre><pre><code>String.prototype.getMost = function() {
    var a = this.split(&#39;&#39;);
    a.sort();
    var s = a.join(&#39;&#39;);
    var pattern = /(\w)\1*/g;
    var a = s.match(pattern);
    a.sort(function(a, b) { return a.length &lt; b.length; });
    var letter = a[0][0];
    var num = a[0].length;
    return letter + &#39;: &#39; + num;
}
var s = &#39;aaabbbcccaaabbbcccccc&#39;;
console.log(s.getMost());
// c: 9
</code></pre><h3 id="常用匹配模式（持续更新）"><a href="#常用匹配模式（持续更新）" class="headerlink" title="常用匹配模式（持续更新）"></a>常用匹配模式（持续更新）</h3><ol>
<li>只能输入汉字：/^[\u4e00-\u9fa5]{0,}$/</li>
</ol>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ol>
<li><strong>test</strong>：检查指定字符串中有没有某子串（或某匹配模式），返回true或者false；如有必要可以进行全局模式搜索。</li>
<li><strong>exec</strong>：检查指定字符串中有没有某子串（或者匹配模式），如有返回数组（数组信息丰富，可参考上文介绍），如没有返回null；如有必要可以进行全局搜索找出所有子串（或者匹配模式）的信息，<strong>信息中含有匹配模式中子表达式所对应的字符串</strong>。</li>
<li><strong>compile</strong>：修改正则表达式中的pattern</li>
<li><strong>search</strong>：检查指定字符串中有没有某子串（或者匹配模式），如有返回子串（或者匹配模式）在原串中的开始位置，如没有返回-1。不能进行全局搜索。</li>
<li><strong>match</strong>：检查指定字符串中有没有某子串（或者匹配模式），非全局模式下返回信息和exec一致；如进行全局搜索，直接返回字符串数组。（如不需要关于每个匹配的更多信息，推荐用match而不是exec）</li>
<li><strong>replace</strong>：检查指定字符串中有没有某子串（或者匹配模式），并用另一个子串代替（该子串可以跟原字符串或者搜索到的子串有关）；如启动g，则全局替换，否则只替换第一个。<strong>replace方法可以引用子表达式所对应的值</strong>。</li>
<li><strong>split</strong>：用特定模式分割字符串，返回一个字符串数组；与Array的join方法正好相反。</li>
<li><strong>子表达式</strong>：用括号括起来的正则匹配表达式，用后向引用可以对其进行引用；也可以和exec或者replace搭配获取其真实匹配值。</li>
<li><strong>后向引用</strong> ：对子表达式所在分组进行引用。</li>
<li><strong>零宽断言</strong>：和\b ^ 以及$类似的某个位置概念。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[10大使用Node.js的理由]]></title>
      <url>/10%E5%A4%A7%E4%BD%BF%E7%94%A8Node-js%E7%9A%84%E7%90%86%E7%94%B1.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无论你的经验是否丰富，都有许多理由使用Node.js。我们来看看使用Node的几个主要的理由，以及为什么你会爱上他。</p>
<p>啊！我懂了。你不是一个跟随潮流的开发者。因为大家都不用，所以你也不使用一些很酷的与时俱进的平台。这就是为什么你还没有认真看待 <a href="http://link.funteas.com/?target=http%3A%2F%2Fnodejs.org%2F" target="_blank" rel="external">Node.js</a> （或者你的boss还没有让你捣鼓这些）。好嘞，是时候重新审视Node.js了。使用Nodejs，有许多理由，这里是其中的10条。</p>
<p><img src="https://img.funteas.com/ad24552f92178045c20fc8bf10f6c036.png?imageView2/2/w/800" alt=""></p>
<h2 id="10大使用Node-js的理由"><a href="#10大使用Node-js的理由" class="headerlink" title="10大使用Node.js的理由"></a>10大使用Node.js的理由</h2><h3 id="1-你已经熟悉了JavaScript"><a href="#1-你已经熟悉了JavaScript" class="headerlink" title="1. 你已经熟悉了JavaScript"></a>1. 你已经熟悉了JavaScript</h3><p>让我猜猜。你正在使用一个功能强大的客户端框架(<a href="http://link.funteas.com/?target=https%3A%2F%2Fangularjs.org%2F" target="_blank" rel="external">Angular</a> ，<a href="http://link.funteas.com/?target=http%3A%2F%2Femberjs.com%2F" target="_blank" rel="external">Ember</a> , <a href="http://link.funteas.com/?target=http%3A%2F%2Fbackbonejs.org%2F" target="_blank" rel="external">Backbone</a> )以及REST-ful服务器端的API，使用JSON这种数据格式来传输和接受数据。即使你没有使用其中的任一种框架，你也用jQuery写过自己的框架。因此如果你不在服务器端使用Node.js，那么你就不断地做转译吧。你在转译两件事：1）来自你脑中JavaScript的逻辑转换为服务器端框架的逻辑。以及2）来自JSON的HTTP数据转换为你的服务器端的对象。</p>
<p>JavaScript贯穿着你的应用，你不但智力上涨，你也获得了实践经验。通过模型和模板的复用，你可以减少应用的大小，同时减少了复杂度和出现bug的可能性。</p>
<p>JavaScript作为一种语言正在占领全世界！过不了多久，全球的每台电脑上都会有一个JavaScript运行环境，并且这看上去会持续一段时间。</p>
<h3 id="2-它很快"><a href="#2-它很快" class="headerlink" title="2. 它很快"></a>2. 它很快</h3><p>Node.js是JavaScript运行环境，使用了Google用在Chrome中的V8引擎。V8以闪电般的速度编译和执行JavaScript是因为V8将JavaScript编译成本地机器代码。</p>
<p><img src="https://img.funteas.com/5dccdfd3d100fc36c58553a2afd90c0a.jpg?imageView2/2/w/800" alt=""></p>
<p>除了让JavaScript运行有闪电般的速度，Node.js真正的魔法是event loop。event loop 在所有的I/O异步操作中都是单线程实现的。传统上，I/O操作可以同步运行（阻塞），也可以是异步的，通过并行线程来执行工作。这种传统的方法消耗许多内存并且是臭名昭著地难编程。相比较之下，当一个Node应用需要执行一个I/O操作，他传递一个异步任务到event loop，加上一个回调函数，然后继续执行剩下的程序。当异步操作完成，event loop 返回任务去执行他的回调函数。</p>
<p>换句话说，网络连接的读写，文件系统的读写，以及数据库的读写——所有的在网页应用中的日常任务——在Node中执行地非常非常快。Node能让你创建快速，大规模的网络应用，能够处理高吞吐量的大量的实时连接。</p>
<h3 id="3-工具"><a href="#3-工具" class="headerlink" title="3. 工具"></a>3. 工具</h3><p><img src="https://img.funteas.com/b4272c749019b1891df708f29722b0cd.png?imageView2/2/w/800" alt=""></p>
<p><a href="http://link.funteas.com/?target=https%3A%2F%2Fwww.npmjs.org%2F" target="_blank" rel="external">npm</a> 是Node.js的包管理器并且它棒呆了。这确实很棒，当然，这类似于其他生态系统的包管理器，但是npm很快很稳很一致。他在寻找和安装项目依赖做的非常好。他让包和其他的项目隔离开来，防止版本混淆。但是，他也处理全局shell命令安装和平台依赖的二进制。一时间，我不记得我在npm中安装的包，在这里我要问自己，“为什么会混淆这些模块？模块安装在哪里？为什么选这个版本而不是另一个？”</p>
<p><a href="http://link.funteas.com/?target=http%3A%2F%2Fgruntjs.com%2F" target="_blank" rel="external">grunt</a>  是较早的任务管理器，但是也有新生代的工具，如<a href="http://link.funteas.com/?target=http%3A%2F%2Fgulpjs.com%2F" target="_blank" rel="external">gulp</a> , <a href="http://link.funteas.com/?target=http%3A%2F%2Fbrunch.io%2F" target="_blank" rel="external">brunch</a> , 和 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fbroccolijs%2Fbroccoli" target="_blank" rel="external">broccoli</a> ，他们专注于创建编译你的文件，利用了JavaScript强大的文件流能力。</p>
<h3 id="4-你又一次刷新了对JavaScript的认识"><a href="#4-你又一次刷新了对JavaScript的认识" class="headerlink" title="4. 你又一次刷新了对JavaScript的认识"></a>4. 你又一次刷新了对JavaScript的认识</h3><p><img src="https://img.funteas.com/df836ec47f9c5433d83e4b60579aa141.png?imageView2/2/w/800" alt=""></p>
<p>那么你决定在你的服务器上用JavaScript了，并且你为你的决定感到庆幸，避免了所有的从客户端数据到服务器端数据的编译。但是数据到数据库需要甚至更多的编译！</p>
<p>There’s good news. If you’re using an object database like <a href="http://link.funteas.com/?target=http%3A%2F%2Fwww.mongodb.org%2F" target="_blank" rel="external">Mongo</a> , then you can extend JavaScript to the persistence layer as well. 这是一个好消息。如果你在用对象数据库，如 <a href="http://link.funteas.com/?target=http%3A%2F%2Fwww.mongodb.org%2F" target="_blank" rel="external">Mongo</a> ，然后你可以扩展JavaScript让持久层更好。</p>
<p>使用node.js允许你在客户端，在服务器端和在数据库中用相同的语言。从浏览器到磁盘，你可以用他的原生JSON格式保存你的数据。</p>
<h3 id="5-实时变得简单"><a href="#5-实时变得简单" class="headerlink" title="5. 实时变得简单"></a>5. 实时变得简单</h3><p>如果Node.js很擅长多并发连接，那么他也擅长多用户的，实时的网页程序，例如聊天室和游戏。Node的 event loop 能够满足多用户需求。实时能力使用websocket协议。Websocket是在客户端和服务器端的简单的双向沟通渠道。因此服务器能够推送数据到客户端就像客户端推送一样。websocket运行在TCP，避免了HTTP的消耗。</p>
<p><a href="http://link.funteas.com/?target=http%3A%2F%2Fsocket.io%2F" target="_blank" rel="external">Socket.io</a> 是在websoket库中的一个非常受欢迎的库，这让杀掉协同的web应用变得简单。这里是一个简单的使用 socket.io的服务器：</p>
<pre><code>var app = require(&#39;http&#39;).createServer(handler) var io = require(&#39;socket.io&#39;)(app);

app.listen(8080);

io.on(&#39;connection&#39;, function(socket) {
    // Send a message to the client
    socket.emit(&#39;event to client&#39;, { hello: &#39;world&#39; });
    // Handle a message from the client
    socket.on(&#39;event from client&#39;, function (data) {
        console.log(data);
    });
});
</code></pre><h3 id="6-流数据"><a href="#6-流数据" class="headerlink" title="6. 流数据"></a>6. 流数据</h3><p>传统意义上来说，web框架将HTTP请求和响应当做一个整体的数据对象。实际上，他们是I/O流，你可以想象，如果你把文件从文件系统中以流的形式取出。既然Node.js非常擅长处理I/O，我们能够利用这个特点创建一些很酷的东西。比如，它能够当视频或音频文件上传的时候，就<a href="http://link.funteas.com/?target=http%3A%2F%2Ftransloadit.com%2Fblog%2F2010%2F12%2Frealtime-encoding-over-150x-faster%2F" target="_blank" rel="external">转码音频或视频文件</a> ，减少了整体处理的时间。</p>
<p>Node能够读写流到websocket，就像他可以读写流到HTTP。比如，我们能够从服务器中运行的进程中通过websocket标准输出到浏览器，并且实时在网页上显示输出结果。</p>
<h3 id="7-一个代码库和免费的实时"><a href="#7-一个代码库和免费的实时" class="headerlink" title="7. 一个代码库和免费的实时"></a>7. 一个代码库和免费的实时</h3><p>如果你已经了解了这么多，你可能会问自己，“如果Node.js允许你在服务器和客户端使用JavaScript，并且让客户端和服务器端数据传输变得简单，我能不能写一个web应用，让一个代码库在客户端和服务器端运行，并且在两者之间自动异步处理数据。”</p>
<p>这个问题的答案是yes，并且对于此app的框架可以是<a href="http://link.funteas.com/?target=https%3A%2F%2Fwww.meteor.com%2F" target="_blank" rel="external">Meteor</a> 。Meteor是下一代基于Node的web框架。他可以在客户端和服务器端运行相同的代码库。然后，数据自动保存在服务器。其他的方式也奏效！任何服务器上的数据都自动传到客户端。未来会更好！任何展示数据的网页都会自动回应和自动更新。</p>
<pre><code>// Save the value of &#39;name&#39; upon clicking &#39;submit&#39; directly in the browser!
&#39;.click .submit&#39;: function(e, tpl) { Users.update({ _id: this._id }, { $set: { name: $(&#39;.name&#39;).val() } }); }
</code></pre><h3 id="8-企业管理者"><a href="#8-企业管理者" class="headerlink" title="8. 企业管理者"></a>8. 企业管理者</h3><p>任何开源项目的潜在风险就是被项目维护者所放弃。这不是Node.js的现况。Node现在由 <a href="http://link.funteas.com/?target=https%3A%2F%2Fwww.joyent.com%2F" target="_blank" rel="external">Joyent</a> 所赞助，这雇佣了项目带头人和其他的核心贡献者，因此有一家真实的公司在支持这项目的未来。更不要说有一大批大公司在每一个层级支持了此项目，其中包括 Walmart, Microsoft, Yahoo, Paypal, Voxer, 等等。</p>
<h3 id="9-托管"><a href="#9-托管" class="headerlink" title="9. 托管"></a>9. 托管</h3><p><img src="https://img.funteas.com/b857a57188ba9bdb1a01612e03b918e7.png?imageView2/2/w/800" alt=""></p>
<p>随着Node.js的快速普及，世界级规模的Node.js托管也在增长着。特别是，平台即服务（PaaS）供应者，比如<a href="http://link.funteas.com/?target=https%3A%2F%2Fmodulus.io%2F" target="_blank" rel="external">Modulus</a>  和其他减少为一个指令的部署。PaaS的鼻祖，Heroku，现在正式地支持Node部署。</p>
<h3 id="10-每个开发者都知道（一些）JavaScript"><a href="#10-每个开发者都知道（一些）JavaScript" class="headerlink" title="10. 每个开发者都知道（一些）JavaScript"></a>10. 每个开发者都知道（一些）JavaScript</h3><p>这是给你boss的理由。</p>
<p>随着web的兴起，已经存在的JavaScript的点击和鼠标滑过事件。每个web开发者都编写过一点JavaScript，即使是使用jQuery插件开发的JavaScript。寻找web开发擦能的人现在非常困难，因此当选择一个web平台，为什么不选择在这个世界上每个web开发者都熟悉的语言？</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如果想看<code>node.js</code>的教程，可以看我的这篇博客。<a href="http://pancakeawesome.ink/nodejs%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B.html">传送门</a></p>
]]></content>
      
        <categories>
            
            <category> node.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node.js </tag>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript => TypeScript 入门]]></title>
      <url>/JavaScript-TypeScript-%E5%85%A5%E9%97%A8.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ES6 是 ES5 转向主流语规格的一个重要升级，顺着这个角度看，TypeScript 让这门语言披上一层类型的外衣，直接演变成一种强类型的语言；从相反角度看，TypeScript 将编程语言们一些主流的特性引入到了 JS 的世界。</p>
<h2 id="JavaScript-gt-TypeScript-入门"><a href="#JavaScript-gt-TypeScript-入门" class="headerlink" title="JavaScript =&gt; TypeScript 入门"></a>JavaScript =&gt; TypeScript 入门</h2><p>几个月前把 ES6 的特性都过了一遍，收获颇丰。现在继续来看看 TypesScript（下文简称为 “TS”）。限于经验，本文一些总结如有不当，欢迎指正。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>官网有这样一段描述：</p>
<blockquote>
<p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.</p>
</blockquote>
<p>说的是 TS 是 JS 的超集，并且可以编译成普通的 JS。</p>
<p>其中， <strong>超集</strong> 的定义是：</p>
<blockquote>
<p>如果一个集合 S2 中的每一个元素都在集合 S1 中，且集合 S1 中可能包含 S2 中没有的元素，则集合 S1 就是 S2 的一个超集，反过来，S2 是 S1 的子集。</p>
</blockquote>
<p>而实际上，“超出” 的部分主要就是 “类型系统”。因此可以这样归纳：</p>
<blockquote>
<p>TS ≈ ES6 + 类型系统</p>
</blockquote>
<p>ES6 是 ES5 转向主流语规格的一个重要升级，顺着这个角度看，TS 让这门语言披上一层类型的外衣，直接演变成一种强类型的语言；从相反角度看，TS 将编程语言们一些主流的特性引入到了 JS 的世界。</p>
<h3 id="平稳过渡"><a href="#平稳过渡" class="headerlink" title="平稳过渡"></a>平稳过渡</h3><p>TypeScript 设计巧妙，兼具微软工业化的水准。首先，它仅靠一行命令，就融入到了广大前端人的世界：</p>
<pre><code>npm install -g typescript
</code></pre><p>然后由你随便挑一个曾编写的 <code>.js</code> 脚本文件（不妨叫做<code>hello.js</code>），不用对内容做任何修改，直接将文件后缀改成 <code>.ts</code>。这样，你就已经完成了一份 TypeScript 脚本的编写！</p>
<p>然后编译它：</p>
<pre><code>tsc hello.ts
</code></pre><p>OK，你已经平滑过渡到了 TS 的世界。就是这么简单！</p>
<p>当然这只是“一小步”，似乎后边还有无数的坑要填。不用担心，TS 已经填平了大部分的坑！</p>
<p>比如，时下最流行的 gulp，webpake 工具，只需做一些简单的配置，就能接引入TypeScript 进行编译；同时为了能与 React 完美融合，TS 引入了与 JSX 类似的 TSX 语法。当然，TS 在 Angular、Vue.js 以及 Node.js 中也是畅通的…</p>
<p>坑都填平了，大家过渡起来自然顺心顺手。</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>与 ES6 一脉相承的，同时也接轨大部分强类型语言，TS 的类型大概有这些：<br>1），<code>Number</code>、<code>Boolean</code>、<code>String</code>、<code>Null</code> 、<code>undefined</code>、<code>Symbol</code><br>2）， <code>Array</code>、<code>Function</code>、<code>Object</code><br>3），<code>Tuple</code>、<code>enum</code>、<code>Void</code>、 <code>Never</code>、<code>Any</code><br>TS 作为 JS 的一个超集，在 JS 的基础上扩展了一些非常有用的类型。第 3）中的类型就是从一些强类型语言引入的类型。</p>
<p>为了由简入繁，不妨将这些类型划分为：<strong>基本类型</strong>、<strong>复合类型</strong>。<strong>复合类型</strong> 一般由 <strong>基本类型</strong> 构成。以下将渐进式的对 TS 的这些类型进行了解。</p>
<h3 id="如何做类型声明？"><a href="#如何做类型声明？" class="headerlink" title="如何做类型声明？"></a>如何做类型声明？</h3><p>强类型语言都有一套类型声明的语法规则，TS 也不例外。TS 采用类型注释的写法，像这样<strong>将一个带冒号的注释，置于声明变量名之后，就构成了 TS 类型声明的语法</strong>。</p>
<pre><code>let str :string=&#39;hello typescript&#39;;
</code></pre><p>JAVA 的写法是相反的，但无实质差别：</p>
<pre><code>String str =&#39;hello java&#39;;
</code></pre><p>这样的注释如同一种补充说明，后文将简称它为 “冒号注释”，熟悉书写规则，有利于快速进入到 TS 的代码世界。</p>
<p>实际上，ES6 有一种属性描述对象，是通过<code>Object.getOwnPropertyDescriptor(obj, key)</code> 获取的。</p>
<pre><code>let obj = {
    set name(val) {}
}
Object.getOwnPropertyDescriptor(obj, &#39;name&#39;);
// {
//      configurable: true
//   enumerable: true
//   get: undefined
//   set: ƒ a(val)
// }
</code></pre><p>如果将 <code>setter</code> 类型的 <code>name</code> 方法适当改写，我们甚至可以实现 <code>obj.name</code> 赋值的类型检查功能，也非常有意思。</p>
<p>同样的，冒号注释 <code>: string</code> 也可以理解为对一个 <code>str</code> 变量的描述。凭借这个注释的描述，TS 的类型编译器就能进行类型检查了。</p>
<p>建立了类型的认知后，继续跑马圈地，巩固认知。其中，<code>Function</code>、 <code>Never</code>、<code>Any</code> 规则稍显复杂，但也没有什么特别的，留后细说。</p>
<h4 id="简单的基本类型"><a href="#简单的基本类型" class="headerlink" title="简单的基本类型"></a>简单的基本类型</h4><pre><code>// boolean 类型
let isBool: boolean = 1 &lt; 5; 
// string 类型
let str: string = &#39;hello world&#39;; 
// number 类型
let num: number = 123; 
// void 类型
let unusable: void = undefined; 
// undefined 类型
let u: undefined = undefined; 
// null 类型
let n: null = null; 
//Symbol 类型
// 类型 symbol 小写也能编译通过
let sym: Symbol = Symbol(&#39;hello&#39;);
</code></pre><h4 id="简单的复合类型。"><a href="#简单的复合类型。" class="headerlink" title="简单的复合类型。"></a>简单的复合类型。</h4><pre><code>// object 类型
let obj: object = {};
let arrObj: object = [];
let funcObj: object = () =&gt; {};
// array 类型
let arrNum: number[] = [1, 2, 3]
let arrStr: string[] = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
let arrObj: object[] = [{}];
// 元组 类型
let tup: [number, string] = [1, &#39;hello&#39;];
// 枚举类型
enumDays { Sun, Mon, Tue, Wed, Thu, Fri, Sat };
</code></pre><p>可谓一览无余，类型的语法就是冒号注释，仅凭这一条，60~70% 的情况你都无需担心自己的类型书写有误。</p>
<h4 id="一个灵活的子类型"><a href="#一个灵活的子类型" class="headerlink" title="一个灵活的子类型"></a>一个灵活的子类型</h4><p>但 JS 的动态类型太灵活了，<code>null</code> 和 <code>undefined</code> 的相似性, <code>Array</code>、<code>Function</code> 和 <code>Object</code>的纠缠不清的关系，仅凭一招恐怕还很难驾驭的住 JS 的 “多动症” 般的类型。比如：</p>
<pre><code>// boolean 类型接收这样的赋值
let isBool_n: boolean = null;
let isBool_u: boolean = undefined;
// void 类型接收这样的赋值
let unusable: void = undefined;
unusable = null;
// Symbol 类型接收这样的赋值
let sym: Symbol = Symbol(&#39;hello&#39;);
sym = null;
sym = undefined;
// object 类型接收这样的赋值
let obj: object = {};
obj = null;
obj = undefined;
</code></pre><p>它们都能编译通过。但是 <code>null</code> 不属于 <code>boolean</code> 类型，<code>undefined</code>也并不属于<code>object</code> 类型，为什么能通过类型检查？</p>
<p>事实上，<code>undefined</code> 和 <code>null</code> 是所有类型的子类型。也就是说，它们俩可以作为值赋给任何类型的变量。甚至，它们俩可以互相赋值给对方。</p>
<pre><code>// undefined 类型
let u:undefined=null;
// null 类型
let n:null=undefined;
</code></pre><p>有了这一条规则，就能解释一些 “复合类型” 中遇到的问题：</p>
<pre><code>let arrNum: number[]=[];
let arrStr:string[]=[];
// undefined 也属于 number 类型
let arrNum: number[]=[undefined];
// undefined 也属于 object 类型
let obj :object=undefined;
</code></pre><p>有了这条规则，我们可以大胆的写 TS 的类型声明了。</p>
<p>但太过放开的规则——本文姑且称之为 “混杂模式”，又似乎一下子让 TS 退回到了 JS 的动态类型的原始状态了，让习惯了强类型的同学容易懵掉，也让从 JS 转 TS 的同学体会不到强类型的好处。</p>
<h4 id="画条界限"><a href="#画条界限" class="headerlink" title="画条界限"></a>画条界限</h4><p>好在，TS 设计了一套巧妙的类型系统，犹如给 JS 披上 了一层强大的盔甲。</p>
<p>TS 在 “混杂模式” 下，可能存在这样的风险，就是：编译正确，运行出错。比如：</p>
<pre><code>// 无意获得一个 undefined 作为初始值
let init_name =undefined;
let nameList:string[]=[init_name];
console.log(nameList[0].split(&#39;_&#39;));
// 运行报错
</code></pre><p>在非 “严格模式” 下，上述 TS 代码编译无误，但是真正拿到页面去运行编译结果时，出现错误。</p>
<p>那怎么办呢？要相信 TS 强大的类型系统，只需一项配置，就能将编译切换成 “严格模式”：</p>
<pre><code>// 在配置文件 tsconfig.json 中增加一项
&quot;compilerOptions&quot;: {
    // ...
    &quot;strictNullChecks&quot;: true
},
</code></pre><p>再次执行编译，就会出现错误提示信息：</p>
<pre><code>error TS2322: Type &#39;undefined[]&#39;
isnot assignable to type &#39;string[]&#39;.
</code></pre><p>TypeScript 官方教程鼓励尽可能地使用 <code>--strictNullChecks</code>，因此这里也强烈建议配置该属性再进行编译，这样能很好的发挥 TS 类型检查的作用。</p>
<h4 id="网开一面和漏网之鱼"><a href="#网开一面和漏网之鱼" class="headerlink" title="网开一面和漏网之鱼"></a>网开一面和漏网之鱼</h4><p>TS 编译通过指的是类型检查符合类型系统的规则，运行 OK 则是编译后的 JS 本身执行无误。编译通过，不等于运行OK，即使在 “严格模式” 下也是这样的，所以千万别以为编译通过了就完事了。</p>
<p>以 <code>Any</code> 类型为例，在 <code>--strictNullChecks</code> 模式下：</p>
<pre><code>// TS 代码
let anyThing: any = &#39;hello&#39;;
console.log(anyThing.myName);
// 编译后的 ES6
let anyThing = &#39;hello&#39;;
console.log(anyThing.setName(&#39;world&#39;));
</code></pre><p>很显然，编译后的 <code>anyThing.setName(&#39;world&#39;)</code> 会运行报错。</p>
<p>当然， <code>Any</code> 类型略有点特殊，因为它可以当做是 TS 平滑退化到 JS 的一个类型，官网教程也有这样解说：</p>
<p><em>在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。</em></p>
<p>那问题又回来了，是否除了 <code>Any</code> 类型，其他编译OK，代码就运行无错呢？鉴于笔者正在入门，经验有限，不敢给这个结论。但无论如何，类型检查是可以排除大部分错误的。</p>
<p>最后，编译的时候，尽量选择编译成 ES6 （前提是项目是用 ES6 写的）。配置是：</p>
<pre><code>&quot;compilerOptions&quot;:{&quot;target&quot;:&quot;es6&quot;// &quot;es5&quot;}
</code></pre><h4 id="只有一条规则"><a href="#只有一条规则" class="headerlink" title="只有一条规则"></a>只有一条规则</h4><p>TS “冒号注释” ——就这一条规则，贯穿始终。在函数的类型声明中，继续来巩固这条规则的写法。</p>
<p>类型声明只对变量负责，对于函数，需考察输入——函数参数（也是变量）、输出——函数返回值两个要素。</p>
<p>因为函数的特殊结构，所有 “冒号注释” 规则的写法要特别了解下：</p>
<pre><code>// 声明函数
function add(x: number, y: number): number { return x + y; }
// 函数直接量
let myAdd = function(x: number, y: number): number { return x + y; };
</code></pre><p>可以看到，参数的 “冒号注释” 和一般变量没有任何差别。倒是函数输出类型注释有点特别——试想，<code>: number</code> 紧随函数名之后或者 <code>function</code> 关键字之后，是不是容易被误解为函数名的一部分？是不是对编译引擎不太友好？从这个角度看，注释置于<code>)</code> 之后最为合理。</p>
<p>对了，一个疑问一直从头保留到现在：要是一个变量是 <code>function</code> 类型，那类型注释怎么写，又不能拿 <code>function</code> 关键字去做类型注释？</p>
<pre><code>let myAdd: (x: number, y: number) =&gt; number = function(x: number, y: number): number { return x + y; };
</code></pre><p>其中等号前边的 <code>: (x: number, y: number) =&gt; number</code> 就代表了函数类型。它仍然在结构上符合 “冒号注释” 的规则，只不过冒号后边是一串表达式。这样的结构有点像 Python 中的推导式的概念。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>好了，补上这一块重要的缺漏，本文就完成了所有基本类型的类型声明的解释。凭借一条规则，希望在 TS 学习上畅通无阻的敲代码~</p>
]]></content>
      
        <categories>
            
            <category> typescript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 内存管理及 V8 优化]]></title>
      <url>/JavaScript-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8F%8A-V8-%E4%BC%98%E5%8C%96.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 具有垃圾自动回收机制（Garbage Collection）简称 GC。垃圾回收机制会中断整个代码执行，释放不可能再被使用的变量，释放内存，这个工作机制是周期性的，我们会在下文详细探讨。</p>
<h2 id="JavaScript-内存管理及-V8-优化"><a href="#JavaScript-内存管理及-V8-优化" class="headerlink" title="JavaScript 内存管理及 V8 优化"></a>JavaScript 内存管理及 V8 优化</h2><h3 id="可释放对象"><a href="#可释放对象" class="headerlink" title="可释放对象"></a>可释放对象</h3><pre><code>function fn1() { var obj1 = { name: &#39;xiaomuchen&#39;, age: &#39;20&#39; } }

function fn2() {
    var obj2 = { name: &#39;xiaomuchen&#39;, age: &#39;20&#39; }
    return obj2
}
var a = fn1() var b = fn2()
console.log(a, b)
// undefined, {name: &quot;xiaomuchen&quot;, age: &quot;20&quot;}
</code></pre><p>我们对比上面两个函数，fn1 在函数内声明变量 obj1 并且赋值，在函数执行后这个变量<code>便不可再访问了</code>，fn2 在最后把函数内的变量 obj2 返回到全局变量 b，所以 <code>{ name: &#39;xiaomuchen&#39;, age: &#39;20&#39; }</code> 这个对象（或者说 obj2）<code>依然可被访问</code>。</p>
<p>JavaScript 回收机制通过判断变量是否可被访问，来决定回收哪些变量。</p>
<h3 id="标记清除和引用计数"><a href="#标记清除和引用计数" class="headerlink" title="标记清除和引用计数"></a>标记清除和引用计数</h3><p>那么 JavaScript 是如何判断变量是否可被访问？这就要提到标记清除和引用计数。</p>
<p>标记清除：标记清除是目前大部分 JavaScript 引擎使用的判断方式，通过标记变量的状态来确定是否可被回收。当变量在环境中被声明时标记<code>进入环境</code>，理论上永远不要释放进入环境的变量，因为它可以在环境中的任何位置、任何时刻被访问。当环境被销毁（如函数执行完），则变量被标记<code>离开环境</code>等待回收。</p>
<pre><code>function fn() {
    var a = { count: 10 }
    // 被标记，进入环境 
    var b = { count: 20 }
    // 被标记，进入环境
}
fn();
// 执行完毕之后 b 被标记，离开环境
</code></pre><p>引用计数：JavaScript 引擎维护一张<code>引用表</code>，保存内存中所有的资源的引用次数。资源被引用一次则引用 +1，资源被去掉引用或者退出变量的函数作用域时，则引用 -1，当资源的引用次数为<code>0</code>时，说明无法访问这个值，则等待回收。<br>（注：引用计数从 1 到 0 这个过程可能不执行，而是直接标记<code>可被回收</code>，不再进行加减运算节约开销）</p>
<pre><code>function fn() {
    var a = { count: 10 }
    // 资源 { count: 10 } 被引用次数为 1
    a = { count: 20 }
    // 资源 { count: 20 } 被引用次数为 1，资源 { count: 10 } 被引用次数为 0，等待回收
    do someThing
}
fn();
// 资源 { count: 20 } 被释放
</code></pre><p>但是引用计数存在一种<code>循环引用</code>的情况，如下例子，两个对象之间相互引用，在离开环境后对象不可访问，但由于对象的引用次数为 1，则导致不会被回收。这个例子来自《JavaScript 高级程序设计》，但我思考良久，如果引用计数把 a.param 也作为一个变量来计数，那么就没有这个问题了，引用计数实现的方式不同，产生的结果也不一样。</p>
<pre><code>function fn() {
    var a = { count: 10 }
    var b = { count: 20 }
    a.param = b
    // b 的引用次数为 2
    b.param = a
    // a 的引用次数为 2
}
fn();
// a、b 的引用次数为 1
</code></pre><h4 id="GC-的缺陷、分代回收和增量-GC"><a href="#GC-的缺陷、分代回收和增量-GC" class="headerlink" title="GC 的缺陷、分代回收和增量 GC"></a>GC 的缺陷、分代回收和增量 GC</h4><p>和其他语言一样 GC 会中断代码执行，停止其他操作。因为要遍历所有对象，回收所有不可访问对象，这个操作的耗时可能有 100ms 以上。在 V8 引擎新版本中引入了两种优化方法：1. 分代回收（Generation GC），2. 增量 GC（increment GC）</p>
<p>分代回收：目的是通过对象的使用频率、存在时长区分新生代与老生代对象。多回收新生代区（young generation），少回收老生代区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时</p>
<p>增量 GC：把需要长耗时的遍历、回收操作<code>拆分运行</code>，减少中断时间，但是会增大上下文切换开销</p>
<h4 id="Node-js-中的-GC-表现"><a href="#Node-js-中的-GC-表现" class="headerlink" title="Node.js 中的 GC 表现"></a>Node.js 中的 GC 表现</h4><p>当我们用 Node.js 搭建一个稳定的服务时，就需要考虑服务器内存的开销，下面一个 Node.js 内存回收执行的例子：</p>
<p>执行代码<code>node --trace_gc --trace_gc_verbose test.js</code>跟踪一个网络服务的 GC。</p>
<pre><code>[41204: 0x102001c00] Memory reducer: call rate 0.056, low alloc, foreground[41204: 0x102001c00] Memory reducer: started GC #1
[41204:0x102001c00]Heap growing factor 1.1 based on mu= 0.970, speed_ratio = 42956(gc = 675253, mutator = 16)
[41204: 0x102001c00] Grow: old size: 21382 KB, new limit: 33604 KB(1.1)
[41204: 0x102001c00] Memory reducer: finished GC #1 (will do more)
[41204:0x102001c00]156410 ms:Mark-sweep 27.7(50.0)-&gt;21.0(30.0) MB,12.4/0.0 ms (+20.4 ms in7 steps since start of marking, biggest step 4.8 ms)[Incremental marking task: finalize incremental marking][GC in old space requested].
[41204:0x102001c00]Memory allocator,   used:30756 KB, available:1435612 KB
[41204:0x102001c00]New space,          used:169 KB, available:838 KB, committed:1024 KB
[41204:0x102001c00]Old space,          used:16662 KB, available:2417 KB, committed:19412 KB
[41204:0x102001c00]Code space,         used:4078 KB, available:178 KB, committed:5120 KB
[41204:0x102001c00]Map space,          used:642 KB, available:0 KB, committed:2128 KB
[41204:0x102001c00]Largeobject space, used:0 KB, available:1434571 KB, committed:0 KB
[41204:0x102001c00]All spaces,         used:21552 KB, available:1438005 KB, committed:27684 KB
[41204:0x102001c00]External memory reported:1026 KB
[41204:0x102001c00]Total time spent in GC  :158.6 ms
[41204:0x102001c00]Memory reducer: call rate 0.003, low alloc, foreground
</code></pre><p>首先我们可以看到 Node.js 区分 <code>New space</code>、<code>Old space</code> 等来划分检索空间。而提示<code>(+ 20.4 ms in 7 steps since start of marking, biggest step 4.8 ms)</code> 告诉我们这个标记的步骤分 7 步进行，耗时最长的一次时 4.8ms。这使 JavaScript 可以很好的支持开发高实时应。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>因为篇幅有限，留下一些小问题供大家思考：</p>
<ol>
<li>闭包一定会导致内存不可被回收？</li>
<li>如何监控一个 Node.js 服务的内存开销，如何处理不可预知的内存泄漏？</li>
</ol>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅析网站工作原理]]></title>
      <url>/%E6%B5%85%E6%9E%90%E7%BD%91%E7%AB%99%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果您刚接触Web开发，您认为自己知道网络的工作原理 - 至少在基本层面上。</p>
<p>…但是，当您尝试解释一个网站为什么出现空白。 什么是IP地址？ “客户 - 服务”模型是如何工作的？</p>
<p>最近开发框架功能很强大。强大到让我们这些新码农忽视了网站工作的基本原理。</p>
<p>我确实是这样， 没什么不好意思承认的：网络很复杂，只有当您开式编程时，您才意识到这些基础知识有多重要。 （如果您想让你的web app正常工作）</p>
<p>所以我写了一个关于这些基础知识的四部分的指南，这些基础每个人都需要掌握，无论你是编程菜鸟还是只是对编程感兴趣。</p>
<p><strong>Part 1:</strong> 网站工作原理</p>
<p><strong>第2部分：</strong> Web应用程序的结构</p>
<p><strong>第3部分：</strong> HTTP和REST</p>
<p><strong>第4部分：</strong>客户端 - 服务器交互的代码示例</p>
<h2 id="网站的工作原理：网络开发新手（或任何人-入门"><a href="#网站的工作原理：网络开发新手（或任何人-入门" class="headerlink" title="网站的工作原理：网络开发新手（或任何人)入门"></a>网站的工作原理：网络开发新手（或任何人)入门</h2><h3 id="一个基本的网页搜索"><a href="#一个基本的网页搜索" class="headerlink" title="一个基本的网页搜索"></a>一个基本的网页搜索</h3><p>让我们像之前那样开始，在浏览器的地址栏中输入“www.github.com” ，我们会看到页面开始加载。</p>
<p>看起来似乎很简单，幕后却隐藏着一大堆魔法。 让我们来深入学习吧。</p>
<h3 id="定义网络的部分"><a href="#定义网络的部分" class="headerlink" title="定义网络的部分"></a>定义网络的部分</h3><p>了解网络是非常麻烦的，因为有很多术语。不幸的是，有些术语对于理解这篇文章的其余部分至关重要。</p>
<p>如果您想了解万维网的秘密，以下是最重要的术语：</p>
<p><strong>客户端：</strong>在计算机上运行并连接到互联网的应用程序，如Chrome或Firefox。其主要作用是进行用户交互，并将其转换为对另一台称为Web服务器的计算机的请求。虽然我们通常使用浏览器访问网络，但您可以将整个计算机视为客户端 - 服务器模型的“客户端”。每个客户端计算机都有一个唯一的地址，称为IP地址，其他计算机可以用来识别它。</p>
<p><strong>服务器：</strong>连接到互联网且具有IP地址的机器。服务器等待来自其他机器（例如客户机）的请求并对其进行响应。不同于您的计算机（即客户端），服务器也具有IP地址并安装运行特殊的服务器软件，确定如何响应来自浏览器的请求。 Web服务器的主要功能是将网页存储，处理和传送给客户端。有许多类型的服务器，包括Web服务器，数据库服务器，文件服务器，应用程序服务器等。 （在这篇文章中，我们在谈论Web服务器。）</p>
<p><strong> IP地址：</strong>互联网协议地址。 TCP / IP网络上的设备（计算机，服务器，打印机，路由器等）的数字标识符。互联网上的每台计算机都有一个IP地址，用于识别和与其他计算机通信。 IP地址有四组数字，以小数点分隔（例如244.155.65.2）。这被称为“逻辑地址”。为了在网络中定位设备，通过TCP / IP协议软件将逻辑IP地址转换为物理地址。这个物理地址（即MAC地址）内置在您的硬件中。<br><strong> ISP：</strong>互联网服务提供商。 ISP是客户端和服务器之间的中间人。典型的ISP通常是“有线电视公司”。当您的浏览器收请求<a href="http://www.github.com," target="_blank" rel="external">www.github.com,</a>  时，它不会知道在哪里寻找<a href="http://www.github.com," target="_blank" rel="external">www.github.com,</a>  因此，ISP的工作是进行DNS（域名系统）查找，以询问查找的网站的IP地址。</p>
<p><strong> DNS：</strong>域名系统。跟踪计算机的域名及其在互联网上相应IP地址的分布式数据库。不要担心“分布式数据库”如何工作：只需要知道输入<a href="http://www.github.com," target="_blank" rel="external">www.github.com,</a> 而不是IP地址就行了。</p>
<p><strong>域名：</strong>用于标识一个或多个IP地址。用户使用域名（例如<a href="http://www.github.com," target="_blank" rel="external">www.github.com,</a> ）访问互联网上的网站。当您在浏览器中键入域名时，DNS使用它来查找该给定网站的IP地址。</p>
<p><strong> TCP / IP：</strong>传输控制协议/互联网协议。最广泛使用的通信协议。 “协议”是一些标准的规则。TCP / IP被用作通过网络传输数据的标准。</p>
<p><strong>端口号：</strong>一个16位整数，用于标识服务器上的特定端口，并始终与IP地址相关联。它可以用来识别服务器上可以转发网络请求的特定进程。</p>
<p><strong>主机：</strong>连接到网络的计算机 - 它可以是客户端，服务器或任何其他类型的设备。每个主机都有唯一的IP地址。对于<a href="http://www.google.com," target="_blank" rel="external">www.google.com,</a> 等网站，主机可以是为该网站的网页提供服务的网络服务器。主机和服务器概念经常混合，但是它们是两个不同的东西。服务器是一种主机 - 它们是一个特定的机器。另一方面，提供托管服务来维护多个Web服务器的机器可以称作主机。在这个意义上，您可以从主机运行服务器。</p>
<p><strong> HTTP：</strong>超文本传输协议。 Web浏览器和Web服务器用于通过互联网进行通信的协议。</p>
<p><strong> URL：</strong>统一资源定位符。 URL识别特定的Web资源。一个简单的例子是<a href="https://github.com/someone." target="_blank" rel="external">https://github.com/someone.</a> URL指定协议（“https”），主机名（github.com）和文件名（某人的个人资料页面）。用户可以从域名为github.com的网络主机通过HTTP获取该URL所标识的Web资源。（很绕口吗？）</p>
<h3 id="从代码到网页的旅程"><a href="#从代码到网页的旅程" class="headerlink" title="从代码到网页的旅程"></a>从代码到网页的旅程</h3><p>好的，现在我们有了必要的定义，让我们尝试Github的搜索，看看从地址栏输入一个网址到获取到网页经历了什么：</p>
<p>1）您在浏览器中输入URL<br><img src="http://p0.qhimg.com/t0176b1ef05e841e079.png" alt=""></p>
<p>2）浏览器解析URL中包含的信息。包括协议（“https”），域名（“github.com”）和资源（“/”）。 在这种情况下，“.com”之后没有指示特定的资源，所以浏览器知道检索主（索引）页面<br><img src="http://p0.qhimg.com/t01c869ebeabdd534c1.png" alt=""></p>
<p>3)浏览器与ISP进行通信，对主机的Web服务器的IP地址进行DNS查找<a href="http://www.github.com." target="_blank" rel="external">www.github.com.</a> DNS服务首先联系根服务器, 查询 <a href="https://www.github.com" target="_blank" rel="external">https://www.github.com</a>  顶级域服务器的IP地址。<br>该地址被发送回您的DNS服务。 DNS服务与“.com”名称服务器进行另外的沟通，并请求 <a href="https://www.github.com." target="_blank" rel="external">https://www.github.com.</a> 的地址。</p>
<p><img src="http://p0.qhimg.com/t0131e28807f376490e.gif" alt=""></p>
<p><em>source:</em><a href="https://technet.microsoft.com/en-us/library/bb962069.aspx" target="_blank" rel="external"><em>https://technet.microsoft.com/en-us/library/bb962069.aspx</em></a></p>
<p>4)一旦ISP收到目标服务器的IP地址，它会将其发送到您的Web浏览器<br><a href="http://preethikasireddy.me/wp-content/uploads/2015/12/Screen-Shot-2015-12-06-at-6.32.27-PM1.png" target="_blank" rel="external">http://preethikasireddy.me/wp-content/uploads/2015/12/Screen-Shot-2015-12-06-at-6.32.27-PM1.png</a></p>
<p><img src="http://p0.qhimg.com/t01f981a5ba2985f958.png" alt=""></p>
<p>5)您的浏览器从URL中获取IP地址和给定的端口号（HTTP协议默认为端口80，HTTPS默认为端口443），并打开TCP套接字连接。 此时，您的Web浏览器和Web服务器终于连接了。<br>6) 您的网络浏览器向网页服务器发送HTTP请求，请求 <a href="http://www.github.com." target="_blank" rel="external">www.github.com.</a> 的主页面</p>
<p><img src="http://p0.qhimg.com/t011fb50edbb274e338.png" alt=""><br>来自客户端的GET请求</p>
<p>7）Web服务器接收请求并查找该HTML页面。 如果页面存在，则Web服务器准备响应并将其发送回您的浏览器。 如果服务器找不到请求的页面，它将发送一个HTTP 404错误消息，代表“找不到页面”。</p>
<p><img src="http://p0.qhimg.com/t0101a1197df9353e5d.png" alt=""></p>
<p>服务端响应</p>
<p>8）您的Web浏览器将接收到HTML页面，然后通过它从上到按下解析寻找列出的其他资源，如图像，CSS文件，JavaScript文件等。</p>
<p><img src="http://p0.qhimg.com/t019c7165f57be8a468.png" alt=""></p>
<p>index.html 页面</p>
<p>9）对于列出的每个资源，浏览器重复上述整个过程，向服务器发送HTTP请求。</p>
<p>10）浏览器完成加载HTML页面中列出的所有其他资源后，页面将最终加载到浏览器窗口中，并且连接将被关闭<br><img src="http://p0.qhimg.com/t01557152f4e5fdf4c2.png" alt=""></p>
<p>Github</p>
<h3 id="穿越互联网深渊"><a href="#穿越互联网深渊" class="headerlink" title="穿越互联网深渊"></a>穿越互联网深渊</h3><p>值得注意的一件事是当您提出信息请求时，如何传输信息。当您发出请求时，该信息被分解成许多称为数据包的小块。每个数据包都标有一个包括源和目标端口号的TCP报头，以及包含源IP地址和目标IP地址作为身份标识的IP报头。然后，数据包通过以太网，WiFi或蜂窝网络传输，并允许在任何路由上经过多次跳转，直到到达目的地。</p>
<p>（我们实际上并不关心数据包到达那里 - 重要的是它们到达目的地安全无恙！）一旦数据包到达目的地，它们将被重新组合。</p>
<p>那么所有的数据包怎么知道如何到达目的地而不会迷路？</p>
<p>答案是TCP / IP。</p>
<p>TCP / IP是一个两部分系统，作为互联网的基本“控制系统”。IP代表互联网协议;其作用是使用每个数据包上的IP头（即IP地址）将数据包发送到其他计算机。传输控制协议（TCP）负责将消息或文件分解成较小的数据包，使用TCP头将数据包路由到目的地计算机上的正确应用程序，如果丢包，则重新发送数据包;一旦到达另一端，重新组装数据包。</p>
<h3 id="绘制最后的图片"><a href="#绘制最后的图片" class="headerlink" title="绘制最后的图片"></a>绘制最后的图片</h3><p>等等 - 工作还没有完成！ 现在，您的浏览器具有构成网站（HTML，CSS，JavaScript，图像等）的资源，必须通过几个步骤将资源呈现为可读的网页。</p>
<p>您的浏览器有一个渲染引擎，负责显示内容。 渲染引擎以小块形式接收资源的内容。 然后有一个HTML解析算法告诉浏览器如何解析资源。</p>
<p><img src="http://p0.qhimg.com/t01580da28230348db3.jpg" alt=""><br>一个DOM树</p>
<p>构建DOM树后，将分析样式表以了解如何对每个节点进行样式化。 使用此信息，浏览器遍历DOM节点并计算每个节点的CSS样式，位置，坐标等。</p>
<p>一旦浏览器具有DOM节点及其样式，那么<em>最终</em>就可以将页面绘制到屏幕上了。 结果是：你在互联网上看过的一切。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="网络很复杂，但你刚刚完成了很多的工作"><a href="#网络很复杂，但你刚刚完成了很多的工作" class="headerlink" title="网络很复杂，但你刚刚完成了很多的工作"></a>网络很复杂，但你刚刚完成了很多的工作</h3><p>所以这就是网络。迷惑吗？ 我们都是，但是如果你已经读到这里，你已经完成了最艰难的部分。 我跳过了一些细节，以便在这里向大家展示这个大图; 但是如果你能记起上面列出事件的基本顺序，填写细节将是小菜一碟。</p>
<p>查看<a href="https://medium.com/@preethikasireddy/how-the-web-works-part-ii-client-server-model-the-structure-of-a-web-application-735b4b6d76e3#.e6tmj8112" target="_blank" rel="external">Part 2</a>, 在那里我们将讲解一个基本的Web应用程序的结构)</p>
]]></content>
      
        <categories>
            
            <category> 网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> http协议 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[重温ES6核心概念和基本用法]]></title>
      <url>/%E9%87%8D%E6%B8%A9ES6%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 中其实并不存在真正的类，ES6 的类其实是基于原型链模拟面向对象的一种语法糖。其本质上可以看做是构造函数的另一种写法。</p>
<h2 id="重温ES6核心概念和基本用法"><a href="#重温ES6核心概念和基本用法" class="headerlink" title="重温ES6核心概念和基本用法"></a>重温ES6核心概念和基本用法</h2><h3 id="ES6新特性列表"><a href="#ES6新特性列表" class="headerlink" title="ES6新特性列表"></a>ES6新特性列表</h3><p>相比ES5，ES6提供了太多的更新，简单说来，主要为以下方面（大家可以依据自己不算清晰的点选择性查看本文）：</p>
<ul>
<li><p>Arrows,箭头函数，</p>
</li>
<li><p>Classes，类</p>
</li>
<li><p>Enhanced object literals，增强的对象字面值</p>
</li>
<li><p>Template strings：模板字符串</p>
</li>
<li><p>Destructuring：解构</p>
</li>
<li><p>Default + rest + spread：参数默认值，rest参数,扩展运算符</p>
</li>
<li><p>Let + const:命名声明的新方式</p>
</li>
<li><p>Iterators + for…of：遍历器</p>
</li>
<li><p>Generators：生成器</p>
</li>
<li><p>Unicode：更广泛的编码支持</p>
</li>
<li><p>Modules：语言层面上支持的模块机制</p>
</li>
<li><p>Module loaders：模块加载器</p>
</li>
<li><p>Map + set + weakmap + weakset：新的数据结构</p>
</li>
<li><p>Proxies：代理器</p>
</li>
<li><p>Symbols：新的基本类型，独一无二的值</p>
</li>
<li><p>Subclassable built-ins：类的继承</p>
</li>
<li><p>Promises：</p>
</li>
<li><p>Math + number + string + array + object apis：拓展了一些内置对象的方法</p>
</li>
<li><p>Binary and octal literals：二进制八进制字面量</p>
</li>
<li><p>Reflect api：操作对象的新api</p>
</li>
<li><p>Tail calls:尾调用</p>
</li>
</ul>
<h3 id="Arrows箭头函数"><a href="#Arrows箭头函数" class="headerlink" title="Arrows箭头函数"></a>Arrows箭头函数</h3><p>箭头函数使用类似于<code>=&gt;</code>这样的语法定义函数，支持表达式模式和语句模式，不过其最大特点在于和父作用域具有一样的<code>this</code>。我们知道普通函数的<code>this</code> 既不指向函数自身也不指向函数的词法作用域，this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。使用箭头函数时再也不用担心<code>this</code>跳来跳去了。<br>此外如果箭头函数如果定义在另一个函数里面，箭头函数会共享它父函数的arguments变量。</p>
<pre><code>// 表达式模式箭头函数
var odds = evens.map(v =&gt; v + 1);
var nums = evens.map((v, i) =&gt; v + i);
var pairs = evens.map(v =&gt; ({ even: v, odd: v + 1 })); // 语句模式箭头函数
nums.forEach(v =&gt; {
    if (v % 5 === 0)
        fives.push(v);
}); // 和父作用域具有相同的thisvar bob ={
_name: &quot;Bob&quot;,
    _friends: [],
    printFriends() {
        this._friends.forEach(f =&gt;
            console.log(this._name + &quot; knows &quot; + f));
    }
}

function square() {
    let example = () =&gt; {
        let numbers = [];
        for (let number of arguments) {
            numbers.push(number * number);
        }
        return numbers;
    };
    return example();
}

square(2, 4, 7.5, 8, 11.5, 21);
// returns: [4, 16, 56.25, 64, 132.25, 441]
</code></pre><h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>JavaScript中其实并不存在真正的类，ES6的类其实是基于原型链模拟面向对象的一种语法糖。其本质上可以看做是构造函数的另一种写法。<br>与真的类一样，它支持<code>super</code>继承，实例，静态方法和<code>constructor</code>方法。<br>如果你也使用React，工作中定义模块时一定没少写过<code>class A extends React.Component{}</code>吧。</p>
<pre><code>// 定义类
classPoint {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    toString() { return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;; }
}
// 通过extends关键字实现继承
class SkinnedMeshextends THREE.Mesh {
    //constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。
    //一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。
    constructor(geometry, materials) {
        // super表示父类的构造函数，用来新建父类的this对象,
        // 子类必须在constructor方法中调用super方法，否则新建实例时会报错。如果不调用super方法，子类就得不到this对象。
        super(geometry, materials);
        //在构造方法中绑定this,可以防止实例找不到this
        this.idMatrix = SkinnedMesh.defaultMatrix();
        this.bones = [];
        this.boneMatrices = [];
        //...
    }
    // 非定义在this上的方法都会被直接定义在原型链上
    update(camera) {
        //...// super在此处作为对象，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
        super.update();
    }
    // 可以使用get和set关键字，对某个属性设置存值函数和取值函数
    get boneCount() { // 类的方法内部如果含有this，它默认指向类的实例
        return this.bones.length;
    }
    set matrixType(matrixType) { this.idMatrix = SkinnedMesh[matrixType](); } // 加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用
    static defaultMatrix() { returnnew THREE.Matrix4(); }
}
// 类的所有实例共享一个原型对象
let skin = newSkinnedMesh(); // 静态方法需要直接通过类调用
SkinnedMesh.defaultMatrix()
</code></pre><h3 id="对象的拓展"><a href="#对象的拓展" class="headerlink" title="对象的拓展"></a>对象的拓展</h3><p>ES6中对象的使用方法得以拓展，主要包括以下几点：</p>
<ul>
<li><p>属性和方法可以简洁表示；</p>
</li>
<li><p>允许以表达式的模式定义属性名；</p>
</li>
<li><p>可以通过<code>__proto__</code>读取或设置当前对象的prototype对象;</p>
</li>
<li><p>使用<code>Object.is({},{})</code>判断两个对象是否完全相对，类似于<code>===</code>;</p>
</li>
<li><p><code>Object.assign(target, source1, source2)</code>合并对象；（浅拷贝）</p>
</li>
</ul>
<pre><code>var obj = {
    // __proto__用以设置当前对象的prototype对象，不推荐使用，推荐使用
    Object.setPrototypeOf()
    __proto__: theProtoObj,
    //‘handler:handler’可简写为handler（只需要写变量名就可以实现变量名为变量名，变量值为属性值）
    handler,
    // 简写在定义方法的时候同样有效
    toString() { // Super call
        sreturn &quot;d &quot; + super.toString();
    },
    // 方括号内的表达式用以计算属性名
    [&#39;prop_&#39; + (() =&gt; 42)()]: 42
};
</code></pre><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串是一种组合字符串的语法糖，其使用类似于<code>Perl</code>,<code>Python</code>等语言的字符串修改方法类似，它的出现让我们拼合字符串时方便多了。目前相互中几乎所有字符串的拼接都用这个了，异常方便。</p>
<ul>
<li><p>模板字符串定义在两个反撇号中；</p>
</li>
<li><p>在模板字符串中可以直接换行，格式会得以保留；</p>
</li>
<li><p>通过<code>${}</code>可以很方便的在模板字符串中添加变量；</p>
</li>
</ul>
<pre><code>// 把字符串放在``(注意不是引号)中就可以使用
`In JavaScript &#39;\n&#39; is a line-feed.`
// 模板字符串保留了换行
`In JavaScript this is
 not legal.`
// 在字符串中添加变量的方法，变量直接放在${}中即可
var name = &quot;Bob&quot;,
    time = &quot;today&quot;;
`Hello ${name}, how are you ${time}?`
// 拼合请求时异常方便了
POST `http://foo.org/bar?a=${a}&amp;b=${b}
     Content-Type: application/json
     X-Credentials: ${credentials}
     { &quot;foo&quot;: ${foo},
       &quot;bar&quot;: ${bar}}` (myOnReadyStateChangeHandler);
</code></pre><h3 id="Destructuring-解构"><a href="#Destructuring-解构" class="headerlink" title="Destructuring 解构"></a>Destructuring 解构</h3><p>解构使用模式匹配的方法绑定变量和值，数组和对象都可使用。解构在绑定失败的时会实现软绑定，即没有匹配值时，返回<code>undefined</code>。使用方法可见示例：</p>
<pre><code>// 数组解构
var [a, , b] = [1, 2, 3];
// a = 1,b = 3
// React中常见以下用法
var { a, b, c } = this.props;
// 对象解构也能用在函数的参数中
function g({ name: x }) {
    console.log(x);
}
g({ name: 5 })
// 绑定失败时返回undefined
var [a] = [];
a === undefined;
// 解构时也可以绑定默认值
var [a = 1] = [];
a === 1;
// 配合默认参数使用结构
function r({ x, y, w = 10, h = 10 }) { return x + y + w + h; }
r({ x: 1, y: 2 }) === 23
</code></pre><h3 id="默认值，剩余值和拓展值"><a href="#默认值，剩余值和拓展值" class="headerlink" title="默认值，剩余值和拓展值"></a>默认值，剩余值和拓展值</h3><ul>
<li><p>ES6允许我们在给变量添加默认值</p>
</li>
<li><p>使用拓展值使得函数调用时可传入数组作为连续的参数</p>
</li>
<li><p>利用剩余值特性我们可以把函数尾部的参数转换为一个数组，现在使用<code>rest</code>就可以替换以前的<code>arguments</code>对象了。</p>
</li>
</ul>
<pre><code>// 给函数的参数添加默认值
function f(x, y = 12) {
    // y is 12 if not passed (or passed as undefined)
    return x + y;
}
// 可以只传参数x的值了
f(3) == 15
// 使用rest
function f(x, ...y) {
    // y is an Array
    return x * y.length;
}
f(3, &quot;hello&quot;, true) == 6
// 传入数组作为参数
function f(x, y, z) { return x + y + z; }
// 直接传入数组当作上面函数的参数
f(...[1, 2, 3]) == 6
</code></pre><h3 id="Let-和-Const"><a href="#Let-和-Const" class="headerlink" title="Let 和 Const"></a>Let 和 Const</h3><p>ES6新增了块作用域，新增了两种定义变量的方法，定义变量时推荐使用<code>let</code>替代<code>var</code>，<code>let</code>定义的变量在块作用域内有效，<code>const</code>用以指定固定值，这两类新定义的变量不允许在定义前使用，也不允许重复定义。</p>
<pre><code>function f() {
    {
        let x; {
            const x = &quot;sneaky&quot;;
            // 改变const
            x = &quot;foo&quot;;
        }
        // 重复定义会出错
        let x = &quot;inner&quot;;
    }
}
// 在这里想到一个使用var时新手特别容易犯的问题
for (var i = 0; i &lt; 10; ++i) {
    setTimeout(function() {
        console.log(i);
    }, i * 1000);
}
// 使用var 所有的结果都是10
// 使用let 结果就是预想要的结果
for (let i = 0; i &lt; 10; ++i) {
    setTimeout(function() {
        console.log(i);
    }, i * 1000);
}
</code></pre><h3 id="Iterators-For…Of"><a href="#Iterators-For…Of" class="headerlink" title="Iterators + For…Of"></a>Iterators + For…Of</h3><p>ES6为部署了Iterator接口的各种不同的数据结构提供了统一的访问机制。其本质是一个指针对象。每次调用<code>next</code>方法，可以把指针指向数据结构的下一个成员。具体说来，每一次调用next方法，都会返回数据结构的当前成员的信息（一个包含value和done两个属性的对象，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束）。</p>
<p>凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p>
<pre><code>let fibonacci = {
    // 一个数据结构只要具有Symbol.iterator属性，就可被认为是可遍历的，`Symbol.iterator`是一个表达式，返回Symbol对象的iterator属性，所以需要放在[]中，本质上它是当前数据结构的遍历器生成函数。
    [Symbol.iterator]() {
        let pre = 0,
            cur = 1;
        return { next() {
                [pre, cur] = [cur, pre + cur]; return { done: false, value: cur } } }
    }
}
// fibonacci部署了Symbol.iterator属性，只要done不为true就会一直遍历
for (var n of fibonacci) {
    // 调用1000以内的值做遍历
    if (n &gt; 1000) break;
    console.log(n);
}
</code></pre><blockquote>
<p>原生具备<code>Iterator</code>接口的数据结构有以下几种:数组、某些类似数组的对象（字符串、DOM NodeList 对象、arguments对象）、Set和Map结构。</p>
</blockquote>
<p>对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p>
<blockquote>
<p>实际使用时需引入<a href="http://link.funteas.com/?target=http%3A%2F%2Fbabeljs.io%2Fdocs%2Fusage%2Fpolyfill%2F" target="_blank" rel="external">polyfill</a> </p>
</blockquote>
<h3 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h3><p>可以从两个角度理解<code>Generators</code>，它既是状态机也是一个遍历器对象生成函数。执行该函数可以理解为启动了遍历器，之后每次执行<code>next()</code>函数则每次执行到<code>yield</code>处。</p>
<p>值得注意的是执行<code>next()</code>时可添加参数，这实现了在函数运行的不同阶段，可以从外部向内部注入不同的值，</p>
<p>生成器使用<code>function*</code>和<code>yield</code>简化了迭代过程，使用<code>function*</code>定义的函数返回了一个生成器实例。<br>生成器是迭代器的子类，但是包含<code>next</code>和<code>throw</code>。这使得值可以回流到生成器，<code>yield</code>是一个可以返回值的表达式。</p>
<p><code>for...of</code>循环可以自动遍历 <code>Generator</code> 函数时生成的<code>Iterator</code>对象，此时不再需要调用<code>next</code>方法。</p>
<p><code>Generator</code>的<code>return</code>方法会返回固定的值，终结遍历Generator函数。返回值的value属性就是return方法的参数，返回值的done属性为true。</p>
<p>结合<code>co</code>模块可以实现比Promise更加优雅的异步调用方式</p>
<pre><code>// 使用generator函数实现上述遍历器对象
var fibonacci = {
    [Symbol.iterator]: function*() {
        var pre = 0,
            cur = 1;
        for (;;) {
            var temp = pre;
            pre = cur;
            cur += temp;
            yield cur;
        }
    }
}
for (var n of fibonacci) {
    // truncate the sequence at 1000
    if (n &gt; 1000) break;
    console.log(n);
}
// 使用co模块（基于 Promise 对象的自动执行器），可以实现异步函数的自动执行
var gen = function*() { var f1 = yield somethingAsync(); var f2 = yield anotherThingAsync(); };
var co = require(&#39;co&#39;);
co(gen);
</code></pre><blockquote>
<p>实际使用时需引入<a href="http://link.funteas.com/?target=http%3A%2F%2Fbabeljs.io%2Fdocs%2Fusage%2Fpolyfill%2F" target="_blank" rel="external">polyfill</a> </p>
</blockquote>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>ES6完整支持所有的Unicode,包括新的<code>Unicode</code>字面量和<code>u</code>模式正则，提供了新的API来处理<code>21bit</code>级别的字符串。这些新加特性使得我们的JavaScript应用有能力支持各种语言。</p>
<pre><code>// same as ES5.1
&quot;𠮷&quot;.length == 2
// 新的正则匹配模式
&quot;𠮷&quot;.match(/./u)[0].length == 2
// 新形式
&quot;\u{20BB7}&quot; == &quot;𠮷&quot; == &quot;\uD842\uDFB7&quot;
// codePointAt()能够正确处理4个字节储存的字符，返回一个字符的码点
&quot;𠮷&quot;.codePointAt(0) == 0x20BB7
// for-of 遍历字符，以整体输出
for (var c of &quot;𠮷&quot;) {
    console.log(c);
}
// 𠮷
</code></pre><p>我们也可以在JS中写出Emoji了，很有趣，对不对：</p>
<p><img src="https://img.funteas.com/f63286ff9702745ddb6f58c8ab5ce837?imageView2/2/w/800" alt=""></p>
<h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>现代JS应用的开发离不开模块了，ES6对模块的定义提供了语言层面的支持。规范化了各种JavaScript模块加载器，支持运行时动态加载模块，支持异步加载模块。</p>
<p>ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，效率要比 CommonJS 模块的加载方式高。</p>
<pre><code>// lib/math.js 模块的定义
exportfunction sum(x, y) { return x + y; } exportvar pi = 3.141593;
// app.js 模块的全部引用
import * as math from &quot;lib/math&quot;;
alert(&quot;2π = &quot; + math.sum(math.pi, math.pi));
// otherApp.js 模块的部分引用
import { sum, pi } from &quot;lib/math&quot;;
alert(&quot;2π = &quot; + sum(pi, pi));
// 模块导出方法
// lib/mathplusplus.js
export * from &quot;lib/math&quot;;
exportvar e = 2.71828182846;
exportdefaultfunction(x) { returnMath.log(x); }
// 混合引入方法
import ln, { pi, e } from &quot;lib/mathplusplus&quot;;
alert(&quot;2π = &quot; + ln(e) * pi * 2);
</code></pre><h3 id="Module-Loaders（其实并非ES6标准的一部分，只是草案）"><a href="#Module-Loaders（其实并非ES6标准的一部分，只是草案）" class="headerlink" title="Module Loaders（其实并非ES6标准的一部分，只是草案）"></a>Module Loaders（其实并非ES6标准的一部分，只是草案）</h3><p>模块加载器支持以下功能：</p>
<ul>
<li><p>动态加载</p>
</li>
<li><p>状态隔离</p>
</li>
<li><p>全局命名空间隔离</p>
</li>
<li><p>编写钩子</p>
</li>
<li><p>嵌套</p>
</li>
</ul>
<p>默认的模块加载器可以被配置，新的加载器可以被配置来评估加载独立上下文中的内容。</p>
<pre><code>// 动态加载 – ‘System’ 是默认的加载器
System.import(&#39;lib/math&#39;).then(function(m) {
    alert(&quot;2π = &quot; + m.sum(m.pi, m.pi));
});
// 新的加载器创建了执行沙盒
var loader = newLoader({
    global: fixup(window) // replace ‘console.log’
});
loader.eval(&quot;console.log(&#39;hello world!&#39;);&quot;);
// 可以直接修改模块的缓存
System.get(&#39;jquery&#39;);
System.set(&#39;jquery&#39;, Module({ $: $ }));
// WARNING: not yet finalized
</code></pre><h3 id="Map-Set-WeakMap-WeakSet"><a href="#Map-Set-WeakMap-WeakSet" class="headerlink" title="Map Set WeakMap WeakSet"></a>Map Set WeakMap WeakSet</h3><p>ES6为算法提供了新的高效的数据结构，<code>WeakMaps</code>提供了防泄漏的键值对表。</p>
<pre><code>// Set类似于数组，但是成员的值都是唯一的，没有重复的值。
var s = newSet();
s.add(&quot;hello&quot;).add(&quot;goodbye&quot;).add(&quot;hello&quot;);
s.size === 2;
s.has(&quot;hello&quot;) === true;
// Map 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
var m = newMap();
m.set(&quot;hello&quot;, 42);
m.set(s, 34);
m.get(s) == 34;
// WeakMap结构与Map结构类似，也是用于生成键值对的集合，但是WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名，此外WeakMap的键名所指向的对象，不计入垃圾回收机制。
var wm = newWeakMap();
wm.set(s, { extra: 42 });
wm.size === undefined
// WeakSet 结构与 Set 类似，也是不重复的值的集合,但是WeakSet 的成员只能是对象，而不能是其他类型的值，此外WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用
var ws = newWeakSet();
ws.add({ data: 42 });
// Because the added object has no other references, it will not be held in the set
</code></pre><blockquote>
<p>实际使用时需引入<a href="http://link.funteas.com/?target=http%3A%2F%2Fbabeljs.io%2Fdocs%2Fusage%2Fpolyfill%2F" target="_blank" rel="external">polyfill</a> </p>
</blockquote>
<h3 id="Proxies"><a href="#Proxies" class="headerlink" title="Proxies"></a>Proxies</h3><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<blockquote>
<p>需要注意的是目前未被Babel支持，使用时需谨慎</p>
</blockquote>
<pre><code>// target参数表示所要拦截的目标对象;
var target = {};
// handler参数也是一个对象，用来定制拦截行为;
var handler = { get: function(receiver, name) { return `Hello, ${name}!`; } };
// 生成一个Proxy实例
var p = newProxy(target, handler);
p.world === &#39;Hello, world!&#39;;
// 对函数同样可以使用代理
var target = function() { return &#39;I am the target&#39;; };
var handler = {
    apply: function(receiver, ...args) { return &#39;I am the proxy&#39;; }
};
var p = newProxy(target, handler);
p() === &#39;I am the proxy&#39;;
</code></pre><p>// Proxy支持的拦截操作如下</p>
<pre><code>var handler = {
    get: ...,
    set: ...,
    has: ...,
    deleteProperty: ...,
    apply: ...,
    construct: ...,
    getOwnPropertyDescriptor: ...,
    defineProperty: ...,
    getPrototypeOf: ...,
    setPrototypeOf: ...,
    enumerate: ...,
    ownKeys: ...,
    preventExtensions: ...,
    isExtensible: ...
}
</code></pre><blockquote>
<p>Babel 不支持，使用时应注意</p>
</blockquote>
<h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p><code>Symbol</code>保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名的冲突；<br>它是一种类似于字符串的数据类型,Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述；<br>Symbols是唯一的，单并非私有的，通过<code>Object.getOwnPropertySymbols</code>可以获取对应的值；<br>Symbol 值作为对象属性名时，不能用点运算符。</p>
<pre><code>varMyClass = (function() {
    // module scoped symbol
    var key = Symbol(&quot;key&quot;);
    functionMyClass(privateData) { this[key] = privateData; } MyClass.prototype = {
        doStuff: function() { ...this[key]... }
    };
    returnMyClass;
})();
var c = newMyClass(&quot;hello&quot;)
c[&quot;key&quot;] === undefined
</code></pre><blockquote>
<p>由于语言限制，Babel只提供部分支持，使用时需要注意</p>
</blockquote>
<h3 id="内置类的继承"><a href="#内置类的继承" class="headerlink" title="内置类的继承"></a>内置类的继承</h3><p>在ES6中，内置的<code>Array</code>,<code>Date</code>,<code>DOM Element</code>可以被继承以拓展了。</p>
<pre><code>// User code of Array subclass
classMyArrayextendsArray {
    constructor(...args) { super(...args); }
}
var arr = newMyArray();
arr[1] = 12;
arr.length == 2
</code></pre><blockquote>
<p>babel 部分支持，由于ES5引擎的限制<code>Date</code>,<code>Array</code>,<code>Error</code>不被支持，但是<code>HTMLElement</code>是被支持的</p>
</blockquote>
<h3 id="Math-Number-String-Array-Object-APIs"><a href="#Math-Number-String-Array-Object-APIs" class="headerlink" title="Math + Number + String + Array + Object APIs"></a>Math + Number + String + Array + Object APIs</h3><p>ES6 为很多旧有对象添加了新的API，这些对象包括<code>Math</code>,<code>Array器</code>，<code>String</code>,<code>Object</code>，如下：</p>
<pre><code>Number.EPSILON
Number.isInteger(Infinity)
// false
Number.isNaN(&quot;NaN&quot;)
// false
Math.acosh(3)
// 1.762747174039086
Math.hypot(3, 4)
// 5
Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2)
// 2
&quot;abcde&quot;.includes(&quot;cd&quot;)
// true
&quot;abc&quot;.repeat(3)
// &quot;abcabcabc&quot;
Array.from(document.querySelectorAll(&#39;*&#39;))
// Returns a real Array
Array.of(1, 2, 3)
// Similar to new Array(...), but without special one-arg behavior
[0, 0, 0].fill(7, 1)
// [0,7,7]
[1, 2, 3].find(x =&gt; x == 3)
// 3
[1, 2, 3].findIndex(x =&gt; x == 2)
// 1
[1, 2, 3, 4, 5].copyWithin(3, 0)
// [1, 2, 3, 1, 2]
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries()
// iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;]
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys()
// iterator 0, 1, 2
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values()
// iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;
Object.assign(Point, { origin: newPoint(0, 0) })
</code></pre><blockquote>
<p>babel 通过 polyfill 提供部分支持</p>
</blockquote>
<h3 id="二进制和八进制字面量"><a href="#二进制和八进制字面量" class="headerlink" title="二进制和八进制字面量"></a>二进制和八进制字面量</h3><p>ES6添加了二进制和八进制数值的字面量定义方法：</p>
<pre><code>0b111110111===503
// true
0o767===503
// true
</code></pre><blockquote>
<p>babel 只支持字面量形式，不支持 Number(“0o767”)形式</p>
</blockquote>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise为异步编程提供了一种新的方式，Promise把未来将用到的值当做一等对象，Promise在很多前端库中已经有所支持了。这个平时用得最多了，还没使用的推荐试试。</p>
<pre><code>function timeout(duration = 0) {
    returnnewPromise((resolve, reject) =&gt; {
        setTimeout(resolve, duration);
    })
}
var p = timeout(1000).then(() =&gt; { return timeout(2000); }).then(() =&gt; { thrownewError(&quot;hmm&quot;); }).catch(err =&gt; { returnPromise.all([timeout(100), timeout(200)]); })
</code></pre><blockquote>
<p>实际使用时需引入<a href="http://link.funteas.com/?target=http%3A%2F%2Fbabeljs.io%2Fdocs%2Fusage%2Fpolyfill%2F" target="_blank" rel="external">polyfill</a> </p>
</blockquote>
<h3 id="Reflect-API"><a href="#Reflect-API" class="headerlink" title="Reflect API"></a>Reflect API</h3><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API，作用如下：</p>
<ul>
<li><p>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上；</p>
</li>
<li><p>修改某些Object方法的返回结果，让其变得更合理；</p>
</li>
<li><p>让Object操作都变成函数行为，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</p>
</li>
<li><p>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法；</p>
</li>
</ul>
<pre><code>var O = { a: 1 };
Object.defineProperty(O, &#39;b&#39;, { value: 2 });
O[Symbol(&#39;c&#39;)] = 3;
Reflect.ownKeys(O);
// [&#39;a&#39;, &#39;b&#39;, Symbol(c)]
function C(a, b) { this.c = a + b; }
var instance = Reflect.construct(C, [20, 22]);
instance.c;
// 42
</code></pre><blockquote>
<p>实际使用时需引入<a href="http://link.funteas.com/?target=http%3A%2F%2Fbabeljs.io%2Fdocs%2Fusage%2Fpolyfill%2F" target="_blank" rel="external">polyfill</a> </p>
</blockquote>
<h3 id="Tail-Calls"><a href="#Tail-Calls" class="headerlink" title="Tail Calls"></a>Tail Calls</h3><p>尾部调用被保证不能无限拓展栈，这让有无限制输入时的递归算法更加安全。</p>
<pre><code>function factorial(n, acc = 1) { &#39;use strict&#39;; if (n &lt;= 1) return acc; return factorial(n - 1, n * acc); }
// 堆栈越来越常用，在ES6中其使用更加安全了
factorial(100000)
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>上文对ES6的新特性都做了简单的描述，但是关于<code>Reflect API</code>和<code>Proxies</code>,由于本人对他们的理解还不够透彻，说得可能有些不清不楚。希望阅读本文让你有收获，有任何疑问，大家也可以一起讨论。</p>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> es6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ajax 的全面总结]]></title>
      <url>/Ajax-%E7%9A%84%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Ajax在前端开发中有着举足轻重的地位，关于Ajax的使用和注意事项一直是一个重要的话题，借此机会，本文希望对Ajax做一个全面的总结，彻底揭开Ajax的神秘面纱。</p>
<h2 id="Ajax-的全面总结"><a href="#Ajax-的全面总结" class="headerlink" title="Ajax 的全面总结"></a>Ajax 的全面总结</h2><h2 id="一-什么是Ajax"><a href="#一-什么是Ajax" class="headerlink" title="一.什么是Ajax"></a>一.什么是Ajax</h2><p>Ajax(Asynchronous JavaScript and XML),可以理解为JavaScript执行异步网络请求。通俗的理解的话就是，如果没有Ajax技术，改变网页的一小部分（哪怕是一行文字、一张图片）都需要重新加载一次整个页面，<strong>而有了Ajax之后，就可以实现在网页不跳转不刷新的情况下，在网页后台提交数据，部分更新页面内容。</strong></p>
<h2 id="二-Ajax的原生写法"><a href="#二-Ajax的原生写法" class="headerlink" title="二.Ajax的原生写法"></a>二.Ajax的原生写法</h2><h3 id="1-XMLHttpRequest对象"><a href="#1-XMLHttpRequest对象" class="headerlink" title="1.XMLHttpRequest对象"></a>1.XMLHttpRequest对象</h3><p>XMLHttpRequest 对象用于在后台与服务器交换数据，能够在不重新加载页面的情况下更新网页，在页面已加载后从服务器请求数据，在页面已加载后从服务器接收数据，在后台向服务器发送数据。所以<strong>XMLHttpRequest对象是Ajax技术的核心所在。</strong></p>
<h3 id="2-实现流程"><a href="#2-实现流程" class="headerlink" title="2.实现流程"></a>2.实现流程</h3><p>创建 XMLHttpRequest对象——&gt;打开请求地址，初始化数据——&gt;发送请求数据——&gt;监听回调函数状态——&gt;收到服务器返回的应答结果。</p>
<p>下面用具体的代码进行解释：</p>
<pre><code>var xmlhttp;

function loadXMLDoc(url) {

    xmlhttp = null;


    if (window.XMLHttpRequest)


    { // code for all new browsers


        xmlhttp = newXMLHttpRequest(); //在这里创建 XMLHttpRequest对象


    }


    elseif(window.ActiveXObject)


    { // code for IE5 and IE6


        xmlhttp = newActiveXObject(&quot;Microsoft.XMLHTTP&quot;);


    }


    if (xmlhttp != null)


    {


        xmlhttp.open(&quot;GET&quot;, url, true); //请求的方式和请求地址


        xmlhttp.send(null); //发送请求


        xmlhttp.onreadystatechange = state_Change; //监听回调函数


    } else


    {


        alert(&quot;Your browser does not support XMLHTTP.&quot;);


    }


}


function state_Change() //这里是回调函数


{


    if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200)


    //当满足这两个条件时表示请求成功,完成响应 4 = &quot;loaded&quot;, 200 = OK  


    {


        var data = xmlhttp.responseText; //拿到服务器返回的数据


        // ...our code here...在这里进行数据返回后的操作


    } else


    {


        alert(&quot;Problem retrieving XML data&quot;);


    }


}
</code></pre><h3 id="3-原生写法中的注意点"><a href="#3-原生写法中的注意点" class="headerlink" title="3.原生写法中的注意点"></a>3.原生写法中的注意点</h3><p>(1).open() 的第三个参数中使用了 “true”,该参数规定请求是否异步处理，默认是异步。True 表示脚本会在 send() 方法之后继续执行，而不等待来自服务器的响应。</p>
<p>(2).关于readyState<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fllfps9jy7j30mc05mmxi.jpg" alt=""></p>
<p>(3).关于status 由服务器返回的 HTTP 状态代码，200 表示成功，而 404 表示 “Not Found” 错误。当 readyState 小于 3 的时候读取这一属性会导致一个异常。(后面会有http状态码的详细解读)</p>
<h2 id="三-JQuery中的Ajax"><a href="#三-JQuery中的Ajax" class="headerlink" title="三.JQuery中的Ajax"></a>三.JQuery中的Ajax</h2><p>JQuery对原生Ajax做了很好的封装，使用起来非常简单方便,具体的很多方法如 $.ajax，$.post， $.get， $.getJSON等能根据不同需要进行调用，写法更加简洁，但是为了兼顾各个方法在这里我以一个通用的方法 $.ajax为例做一个简单的解析,按照下面的模式写好各个参数,就能成功进行Ajax的请求了,可能在实际中使用 $.post， $.get 这两个方法使用比较多，但是<strong>理**</strong>解$.ajax 这个通用的方法能对封装原理有很好的认识。**</p>
<pre><code> $.ajax({


     type: //数据的提交方式：get和post


         url: //请求地址


         async: //是否支持异步刷新，默认是true


         data: //需要提交的数据


         dataType: //服务器返回数据的类型，例如xml,String,Json等


         success: function(data) {


         } //请求成功后的回调函数,参数data就是服务器返回的数据


     error: function(data) {


     } //请求失败后的回调函数，根据需要可以不写，一般只写上面的success回调函数


 })
</code></pre><h2 id="四-GET-or-POST？"><a href="#四-GET-or-POST？" class="headerlink" title="四.GET or POST？"></a>四.GET or POST？</h2><p>作为Ajax最常用的两种数据提交方式，GET和POST有着自己的特点和适用场景，<strong>正确区分GET和POST的不同并根据实际需要进行选用在开发中十分重要，简单但是关键</strong>！</p>
<p>先上一张GET 和 POST的比较图，从这张图中可以看出两者之间的差别：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fllfq8vt89j30m40d3gmt.jpg" alt=""></p>
<p><strong>从表格中拎出关键点：</strong> 1.传递数据的方式不同：get是直接把请求数据放在url的后面，是可见的，post的请求数据不会显示在url中，是不可见的。 2.数据长度和数据类型的差异：get有数据长度的的限制，且数据类型只允许ASCII字符，post在这两方面都没有限制。 3.安全性的差异：get不安全，post更安全。</p>
<p><strong>由此得出的两者的使用场景</strong>：get使用较方便，适用于页面之间非敏感数据的简单传值，post使用较为安全，适用于向服务器发送密码、token等敏感数据。</p>
<h2 id="五-success和complete的区别"><a href="#五-success和complete的区别" class="headerlink" title="五.success和complete的区别"></a>五.success和complete的区别</h2><p>JQuery封装的Ajax回调函数中，success、error、complete是最常用的三个，其中，success和error很好区别，一个是请求成功调用的，另一个是请求失败调用的，从字面上就可以理解。但是success和complete容易混淆，在这里特别做一个说明：</p>
<p>success:请求成功后回调函数。</p>
<p>complete:请求完成后回调函数 (请求成功或失败时均调用)。</p>
<p>注意到括号里面了吗，没错，<strong>区别就在于complete只要请求完成，不论是成功还是失败均会调用</strong>。也就是说如果调用了success，一定会调用complete；反过来调用了complete，不一定会调用success。(状态码404、403、301、302…都会进入complete，只要不出错就会调用)</p>
<h2 id="六-XML-gt-JSON"><a href="#六-XML-gt-JSON" class="headerlink" title="六.XML -&gt; JSON"></a>六.XML -&gt; JSON</h2><p>Ajax中的是 “x” 指的就是XML。</p>
<p>xml:可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。</p>
<p>xml作为一种数据交互格式，广泛用在计算机领域，然而，随着json的发展，json以其明显的优势已经渐渐取代了xml成为现在数据交互格式的标准，所以在这里，想强调的是，<strong>json现在是主流的数据交互格式</strong>，前后端的交互标准，无论是前端提交给后台的数据，还是后台返回给前端的数据，都最好统一为json格式，各自接收到数据后再解析数据即可供后续使用。所以 “Ajax” 实际上已经发展为 “Ajaj”</p>
<h2 id="七-JSON和JSONP"><a href="#七-JSON和JSONP" class="headerlink" title="七.JSON和JSONP"></a>七.JSON和JSONP</h2><p>json 和 jsonp 看起来只相差了一个 “p” ，然而实际上根本不是一个东西，千万别以为是差不多的两个概念。</p>
<p>json：(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。</p>
<p>jsonp：一种借助 <code>&lt;script&gt;</code> 元素解决主流浏览器的跨域数据访问问题的方式。</p>
<h2 id="八-Ajax跨域访问"><a href="#八-Ajax跨域访问" class="headerlink" title="八.Ajax跨域访问"></a>八.Ajax跨域访问</h2><p>ajax很好，但不是万能的，<strong>ajax的请求与访问同样会受到浏览器同源策略的限制</strong>，不能访问不同主域中的地址。所以，为了解决这一问题，实现跨域访问，有很多种方式，上述提到的jsonp就是一种流行的方式，还有其他一些方式，我在这里就不展开说了，只是想说明ajax的使用也是有条件的，任何技术的实现都不会是没有限制的。跨域访问时一个很重要的知识点，之前专门写过一篇关于跨域访问的总结，还挺详细的，可以移步查看： javascript中实现跨域的方式总结</p>
<h2 id="九-再议HTTP状态码"><a href="#九-再议HTTP状态码" class="headerlink" title="九.再议HTTP状态码"></a>九.再议HTTP状态码</h2><p>前面提到的”200”、”404”只是http状态码中常见的两个，当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p>
<p>需要掌握的常见http状态码大致有以下一些：</p>
<pre><code>
1. 101：切换协议，服务器根据客户端的请求切换协议

2. **200：请求成功。一般用于GET与POST请求**

3. **301：永久重定向**

4. **302：临时重定向**

5. 303：与301类似。使用GET和POST请求查看

6. **304：请求资源未修改，使用缓存**

7. 307：与302类似。使用GET请求重定向

8. **404：客户端请求失败**

9. 408：请求超时

10. **500：内部服务器错误，无法完成请求**

11. 505:服务器不支持请求的HTTP协议的版本，无法完成处理
</code></pre><h2 id="十-不可忽视的HTTP头文件"><a href="#十-不可忽视的HTTP头文件" class="headerlink" title="十.不可忽视的HTTP头文件"></a>十.不可忽视的HTTP头文件</h2><p>http请求中的一个重要关注点就是请求头和响应头的内容，从这两个头文件中可以看出很多东西，当我们用发送一个ajax请求的时候，如果没有达到预期的效果，那么就需要打开浏览器的调试工具，从NetWork中找到相应的ajax请求，再通过查看请求头和响应头的信息，大体会知道这次请求的结果是怎么样的，结合响应的主体内容，可以很快找到问题。所以学会看http的头文件信息是前端开发中必须掌握的一个技能，下面就来看看具体的头文件信息。</p>
<p>首先随便上一张sf中的完成一个搜索结果的http请求，可以从图中的右侧清楚看到请求头和响应头的内容，包括了很多个字段信息，这些字段信息就是我们需要掌握的知识点，下面挑出其中的重点字段进行分析。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fllfu0gundj30md0cu75k.jpg" alt=""> </p>
<h3 id="1-请求头信息："><a href="#1-请求头信息：" class="headerlink" title="1.请求头信息："></a>1.请求头信息：</h3><pre><code>
1. Accept：客户端支持的数据类型

2. Accept-Charset：客户端采用的编码

3. Accept-Encoding：客户端支持的数据压缩格式

4. Accept-Language：客户端的语言环境

5. Cookie：客服端的cookie

6. Host：请求的服务器地址

7. Connection：客户端与服务连接类型

8. If-Modified-Since:上一次请求资源的缓存时间，与Last-Modified对应

9. If-None-Match：客户段缓存数据的唯一标识，与Etag对应

10. Referer:发起请求的源地址。
</code></pre><h3 id="2-响应头信息："><a href="#2-响应头信息：" class="headerlink" title="2.响应头信息："></a>2.响应头信息：</h3><pre><code>
1. content-encoding：响应数据的压缩格式。

2. content-length：响应数据的长度。

3. content-language：语言环境。

4. content-type：响应数据的类型。

5. Date:消息发送的时间

6. Age:经过的时间

7. Etag:被请求变量的实体值,用于判断请求的资源是否发生变化

8. Expires：缓存的过期时间

9. Last-Modified：在服务器端最后被修改的时间

10. server：服务器的型号
</code></pre><h3 id="3-两者都可能出现的消息"><a href="#3-两者都可能出现的消息" class="headerlink" title="3.两者都可能出现的消息"></a>3.两者都可能出现的消息</h3><p>Pragma：是否缓存(http1.0提出) Cache-Control:是否缓存(http1.1提出)</p>
<h3 id="4-跟缓存相关的字段"><a href="#4-跟缓存相关的字段" class="headerlink" title="4.跟缓存相关的字段"></a>4.跟缓存相关的字段</h3><p>(1) 强制缓存 expire 和 cache-control</p>
<p>(2) 对比缓存 Last-Modified 和 If-Modified-Since Etag 和 If-None-Match</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h2 id="十一-Ajax的优缺点"><a href="#十一-Ajax的优缺点" class="headerlink" title="十一.Ajax的优缺点"></a>十一.Ajax的优缺点</h2><h3 id="1-优点："><a href="#1-优点：" class="headerlink" title="1.优点："></a>1.优点：</h3><ol>
<li><p>页面无刷新，在页面内与服务器通信，减少用户等待时间，增强了用户体验。</p>
</li>
<li><p>使用异步方式与服务器通信，响应速度更快。</p>
</li>
<li><p>可以把一些原本服务器的工作转接到客户端，利用客户端闲置的能力来处理，减轻了服务器和带宽的负担，节约空间和宽带租用成本。</p>
</li>
<li><p>基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。</p>
</li>
</ol>
<h3 id="2-缺点："><a href="#2-缺点：" class="headerlink" title="2.缺点："></a>2.缺点：</h3><ol>
<li><p>无法进行操作的后退，即不支持浏览器的页面后退。</p>
</li>
<li><p>对搜索引擎的支持比较弱。</p>
</li>
<li><p>可能会影响程序中的异常处理机制。</p>
</li>
<li><p>安全问题，对一些网站攻击，如csrf、xxs、sql注入等不能很好地防御。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识Pandas]]></title>
      <url>/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Python</code>有着很多强大的计算库，用来做科学计算非常方便。其中pandas库是一个很有名的库，用来做数据分析非常方便。</p>
<h2 id="pandas简介"><a href="#pandas简介" class="headerlink" title="pandas简介"></a>pandas简介</h2><p>pandas是一个专门用于数据分析的开源Python库。</p>
<h3 id="使用Anaconda安装pandas"><a href="#使用Anaconda安装pandas" class="headerlink" title="使用Anaconda安装pandas"></a>使用Anaconda安装pandas</h3><p>安装pandas库最简单和最常用的方法是先安装一个发行版。我们选用先安装Anaconda，再用Anaconda安装pandas。</p>
<blockquote>
<p>Anaconda 是一个可用于科学计算的 Python 发行版，支持 Linux、Mac、Windows系统，内置了常用的科学计算包。它解决了官方 Python 的两大痛点。</p>
<ul>
<li>第一：提供了包管理功能，Windows 平台安装第三方包经常失败的场景得以解决，</li>
<li>第二：提供环境管理的功能，功能类似 Virtualenv，解决了多版本Python并存、切换的问题。</li>
</ul>
</blockquote>
<h4 id="安装conda"><a href="#安装conda" class="headerlink" title="安装conda"></a>安装conda</h4><p>conda是Anaconda的包管理器，用来管理各种依赖关系的包。可以通过它下载自己想要的包。</p>
<p>首先安装Anaconda，在<a href="https://www.anaconda.com/download/#macos" target="_blank" rel="external">官网下载</a>软件包（以mac系统为例），大约需要1.8G的磁盘空间。打开安装包，一路默认配置。这样，conda就会默认加到你的环境变量中。</p>
<h3 id="使用pypi安装pandas"><a href="#使用pypi安装pandas" class="headerlink" title="使用pypi安装pandas"></a>使用pypi安装pandas</h3><p>pypi是python安装之后自带的包管理器，我们也可以是用pip安装pandas。</p>
<pre><code>pip install pandas
</code></pre><h3 id="安装nose"><a href="#安装nose" class="headerlink" title="安装nose"></a>安装nose</h3><blockquote>
<p>坚持是否成功安装pandas</p>
</blockquote>
<pre><code>nosetests pandas
</code></pre><p>nose是python的测试模块，可以在开发阶段测试python代码。没有安装python发行版的或者没有nose模块的，可以安装nose模块。</p>
<blockquote>
<p>检查是否安装过nose模块。</p>
</blockquote>
<pre><code>pip list
</code></pre><blockquote>
<p>使用pip安装nose</p>
</blockquote>
<pre><code>pip install nose
</code></pre><h3 id="开始pandas之旅"><a href="#开始pandas之旅" class="headerlink" title="开始pandas之旅"></a>开始pandas之旅</h3><p>那么现在我们就可以开始学习我们的pandas了。</p>
<blockquote>
<p>命令行模式调试python代码。</p>
</blockquote>
<pre><code>python
</code></pre><p>这样就会进入python的命令行模式。</p>
<p>引入pandas模块。</p>
<pre><code>import pandas as pd
</code></pre><p><em>我们就可以使用pd这个pandas的实例，来调用pandas库一些常用的方法来处理数据。</em><br><em>exit()或者quit()命令：退出python命令行模式。</em></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> 数据分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> Python </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript异步编程（二）]]></title>
      <url>/%E4%BD%BF%E7%94%A8-await-%E5%87%8F%E5%B0%91%E5%9B%9E%E8%B0%83%E5%B5%8C%E5%A5%97.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发的时候，有时候需要发很多请求，然后经常会面临嵌套回调的问题，即在一个回调里面又嵌了一个回调，导致代码层层缩进得很厉害</p>
<h2 id="使用-await-减少回调嵌套"><a href="#使用-await-减少回调嵌套" class="headerlink" title="使用 await 减少回调嵌套"></a>使用 await 减少回调嵌套</h2><p>在开发的时候，有时候需要发很多请求，然后经常会面临嵌套回调的问题，即在一个回调里面又嵌了一个回调，导致代码层层缩进得很厉害，如下代码所示：</p>
<pre><code>ajax({
    url: &quot;/list&quot;,
    type: &quot;GET&quot;,
    success: function(data) {
        appendToDOM(data);
        ajax({
                url: &quot;/update&quot;,
                type: &quot;POST&quot;,
                success: function(data) {
                    util.toast(&quot;Success!&quot;);
                })
        });
}
});
</code></pre><p>这样的代码看起来有点吃力，这种异步回调通常可以用Promise优化一下，可以把上面代码改成：</p>
<pre><code>newPromise(resolve =&gt; {
ajax({
    url: &quot;/list&quot;,
    type: &quot;GET&quot;,
    success: data =&gt; resolve(data);
})
}).then(data =&gt; {
    appendToDOM(data);
    ajax({
            url: &quot;/update&quot;,
            type: &quot;POST&quot;,
            success: function(data) {
                util.toast(&quot;Successfully!&quot;);
            })
    });
});
</code></pre><p>Promise提供了一个resolve，方便通知什么时候异步结束了，不过本质还是一样的，还是使用回调，只是这个回调放在了then里面。</p>
<p>当需要获取多次异步数据的时候，可以使用Promise.all解决：</p>
<pre><code>let orderPromise = newPromise(resolve =&gt; {
    ajax(&quot;/order&quot;, &quot;GET&quot;, data =&gt; resolve(data));
});
let userPromise = newPromise(resolve =&gt; {
    ajax(&quot;/user&quot;, &quot;GET&quot;, data =&gt; resolve(data));
});
Promise.all([orderPromise, userPromise]).then(values =&gt; {
    let order = values[0],
        user = values[1];
});
</code></pre><p>但是这里也是使用了回调，有没有比较优雅的解决方式呢？</p>
<p>ES7的await/async可以让异步回调的写法跟写同步代码一样。第一个嵌套回调的例子可以用await改成下面的代码：</p>
<pre><code>let leadList = await newPromise(resolve =&gt; {
    ajax({
        url: &quot;/list&quot;,
        type: &quot;GET&quot;,
        success: data =&gt; resolve(data);
    });
});

appendToDom(leadList);
ajax({
    url: &quot;/update&quot;,
    type: &quot;POST&quot;,
    success: () =&gt; util.toast(&quot;Successfully&quot;);
});
</code></pre><p>Await让代码可以像瀑布流一样很自然地写下来。</p>
<p>第二个例子：获取多次异步数据，可以改成这样：</p>
<pre><code>let order = await newPromise(
        resolve =&gt; ajax(&quot;/order&quot;, data =&gt; resovle(data))),

    user = await newPromise(
        resolve =&gt; ajax(&quot;/user&quot;, data =&gt; resolve(data)));
</code></pre><p>这种写法就好像从本地获取数据一样，就不用套回调函数了。</p>
<p>Await除了用在发请求之外，还适用于其它异步场景，例如我在创建订单前先弹一个小框询问用户是要创建哪种类型的订单，然后再弹具体的设置订单的框，所以按正常思路这里需要传递一个按钮回调的点击函数，如下图所示：</p>
<p><img src="https://img.funteas.com/7ed628dbfa69b90eb33b6a77ef5efc56?imageView2/2/w/800" alt=""></p>
<p>但其实可以使用await解决，如下代码所示：</p>
<pre><code>let quoteHandler =require(&quot;./quote&quot;);

let createType = await quoteHandler.confirmCreate();
</code></pre><p>quote里面返回一个Promise，监听点击事件，并传递createType：</p>
<pre><code>let quoteHandler = {
    confirmCreate: function() {
        dialog.showDialog({
            contentTpl: tpl,
            className: &quot;confirm-create-quote&quot;
        });
        let $quoteDialog = $(&quot;.confirm-create-quote form&quot;)[0];
        returnnewPromise(resolve =&gt; {
            $(form.submit).on(&quot;click&quot;, function(event) {
                resolve(form.createType.value);
            });
        });
    }
}
</code></pre><p>这样外部调用者就可以使用await，而不用传递一个点击事件的回调函数了。</p>
<p>但是需要注意的是await的一次性执行特点。相对于回调函数来说，await的执行是一次性的，例如监听点击事件，然后使用await，那么点击事件只会执行一次，因为代码从上往下执行完了，所以当希望点击之后出错了还能继续修改和提交就不能使用await，另外使用await获取异步数据，如果出错了，那么成功的resolve就不会执行，后续的代码也不会执行，所以请求出错的时候基本逻辑不会有问题。</p>
<p>要在babel里面使用await，需要：</p>
<p>（1）安装一个Node包</p>
<p>npm install –save-dev babel-plugin-transform-async-to-generator</p>
<p>（2）在工程的根目录添加一个.babelrc文件，内容为：</p>
<pre><code>{&quot;plugins&quot;:[&quot;transform-async-to-generator&quot;]}
</code></pre><p>（3）使用的时候先引入一个模块</p>
<pre><code>require(&quot;babel-polyfill&quot;);
</code></pre><p>然后就可以愉快地使用ES7的await了。</p>
<p>使用await的函数前面需要加上async关键字，如下代码：</p>
<pre><code>async showOrderDialog() {

    let createType = await quoteHandler.confirmCreate();

    let orderInfo = await orderHandler.getOrderData();
}
</code></pre><p>我们再举一个例子：使用await实现JS版的sleep函数，因为原生是没有提供线程休眠函数的，如下代码所示：</p>
<pre><code>function sleep(time) {
    returnnewPromise(resolve =&gt; setTimeout(() =&gt; resolve(), time));
}

async function start() {
    await sleep(1000);
}

start();
</code></pre><p>babel的await实现是转成了ES6的generator，如下关键代码：</p>
<pre><code>while (1) {
    switch (_context.prev = _context.next) {
        case0: _context.next = 2;
        return sleep(1000);case2:
            case &quot;end&quot;:
            return _context.stop();
    }
}
</code></pre><p>而babel的generator也是要用ES5实现的，什么是generator呢？如下图所示：</p>
<p><img src="https://img.funteas.com/acefdf462f920886e55556cce745e124?imageView2/2/w/800" alt=""></p>
<p>生成器用function*定义，每次执行生成器的next函数的时候会返回当前生成器里用yield返回的值，然后生成器的迭代器往后走一步，直到所有yield完了。</p>
<p>有兴趣的可以继续研究babel是如何把ES7转成ES5的，据说原生的实现还是直接基于Promise.</p>
<p>使用await还有一个好处，可以直接try-catch捕获异步过程抛出的异常，因为我们是不能直接捕获异步回调里面的异常的，如下代码：</p>
<pre><code>let quoteHandler = {
    confirmCreate: function() {
        $(form.submit).on(&quot;click&quot;, function(event) {

            callback(form.notFoundInput.value);
        });
    }
}
try {

    quoteHandler.confirmCreate();
} catch (e) {}
</code></pre><p>上面的try-catch是没有办法捕获到异常的，因为try里的代码已经执行完了，在它执行的过程中并没有异常，因此无法在这里捕获，如果使用Promise的话一般是使用Promise链的catch：</p>
<pre><code>let quoteHandler = {
    confirmCreate: function() {
        returnnewPromise(resolve =&gt; {
            $(form.submit).on(&quot;click&quot;, function(event) {

                resolve(form.notFoundInput.value);
            });
        });
    }
}

quoteHandler.confirmCreate().then(createType =&gt; {
}).catch(e =&gt; {
});
</code></pre><p>而使用await，我们可以直接用同步的catch，就好像它真的变成同步执行了：</p>
<pre><code>try {
    createType = await quoteHandler.confirmCreate(&quot;order&quot;);
} catch (e) {
    console.log(e);
    return;
}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>总之使用await让代码少写了很多嵌套，很方便的逻辑处理，纵享丝滑。</p>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> es6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript异步编程（一）]]></title>
      <url>/%E6%88%91%E4%BA%86%E8%A7%A3%E5%88%B0%E7%9A%84JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="我了解到的JavaScript异步编程"><a href="#我了解到的JavaScript异步编程" class="headerlink" title="我了解到的JavaScript异步编程"></a>我了解到的JavaScript异步编程</h2><p>浏览器的内核是多线程的，他们在内核的控制下互相配合以保持同步，一个浏览器至少实现三个常驻的线程：javascript 引擎线程，GUI 渲染线程，浏览器事件触发线程</p>
<h2 id="一、-一道面试题"><a href="#一、-一道面试题" class="headerlink" title="一、 一道面试题"></a>一、 一道面试题</h2><p>前段时间面试，考察比较多的是js异步编程方面的相关知识点，如今，正好轮到自己分享技术，所以想把js异步编程学习下，做个总结。<br>下面这个demo 概括了大多数面试过程中遇到的问题：</p>
<pre><code>for (var i = 0; i &lt; 3; i++) {
    setTimeout(function() {
        console.log(&#39;timeout&#39; + i);
    })
}
newPromise(function(resolve) {
    console.log(&#39;promise1&#39;);
    for (var i = 0; i &lt; 1000; i++) {
        i == 99 &amp;&amp; resolve();
    }
    console.log(&#39;promise2&#39;);
}).then(function() {
    console.log(&#39;then1&#39;);
})

console.log(&#39;global1&#39;);
</code></pre><p>通过验证可以得知这个demo的结果为：</p>
<p><img src="https://img.funteas.com/d5db7a51ac511fabe4cd13ee7b1774c3.png?imageView2/2/w/800" alt="1.png"></p>
<p>可是为什么会是这样的结果，我们可能需要先了解下下面两个知识点</p>
<h2 id="二、-二个前提知识点"><a href="#二、-二个前提知识点" class="headerlink" title="二、 二个前提知识点"></a>二、 二个前提知识点</h2><h3 id="2-1-浏览器内核的多线程"><a href="#2-1-浏览器内核的多线程" class="headerlink" title="2.1 浏览器内核的多线程"></a>2.1 浏览器内核的多线程</h3><p><img src="https://img.funteas.com/7820dc3a5b1b443bf902c2d3165ae786.png?imageView2/2/w/800" alt="2.png"></p>
<p>浏览器的内核是多线程的，他们在内核的控制下互相配合以保持同步，一个浏览器至少实现三个常驻的线程：javascript引擎线程，GUI渲染线程，浏览器事件触发线程。</p>
<p>1)js引擎，基于事件驱动单线程执行的，js引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。<br>2）GUI线程，当界面需要重绘或由于某种操作引发回流时，该线程就会执行。它和JS引擎是互斥的。<br>3）浏览器事件触发线程，当一个事件被触发时，该线程会把事件添加到待处理队列的队尾，等待js引擎的处理，这些事件可来自JavaScript引擎当前执行的代码块如，setTimeOut, 也可以来自浏览器内核的其他线程如鼠标点击，AJAX异步请求等，但由于JS的单线程关系，所有这些事件都得排队等待JS引擎处理。</p>
<h3 id="2-2-事件循环机制"><a href="#2-2-事件循环机制" class="headerlink" title="2.2 事件循环机制"></a>2.2 事件循环机制</h3><p><img src="https://img.funteas.com/811d82c0a84fe03d1000352c5e83a3b4.png?imageView2/2/w/800" alt="3.png"></p>
<p>1）任务队列又分为macro-task（宏任务）与micro-task（微任务），<br>在最新标准中，它们被分别称为task与jobs。</p>
<p>2）macro-task大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。</p>
<p>3）micro-task【先执行】大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)</p>
<p>setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。</p>
<p>事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的macro-task，这样一直循环下去。</p>
<p>通过这个事件循环的顺序，我们就知道，为什么上面提到的面试题为什么是这样的输出结果了。<br>接下来我们看下三类异步编程的实现。</p>
<h2 id="三、三类异步编程实现"><a href="#三、三类异步编程实现" class="headerlink" title="三、三类异步编程实现"></a>三、三类异步编程实现</h2><h3 id="3-1-回调函数"><a href="#3-1-回调函数" class="headerlink" title="3.1 回调函数"></a>3.1 回调函数</h3><p>demo1:</p>
<pre><code>// 一个简单的封装
function want() {
    console.log(&#39;这是你想要执行的代码&#39;);
}
function fn(want) {
    console.log(&#39;这里表示执行了一大堆各种代码&#39;); // 其他代码执行完毕，最后执行回调函数
    want &amp;&amp; want();
}

fn(want);
</code></pre><p>demo2:</p>
<pre><code>//callback hell

doSomethingAsync1(function() {
    doSomethingAsync2(function() {
        doSomethingAsync3(function() {
            doSomethingAsync4(function() {
                doSomethingAsync5(function() { // code...
                });
            });
        });
    });
});
</code></pre><p>可以发现一个问题，在回调函数嵌套层数不深的情况下，代码还算容易理解和维护，一旦嵌套层数加深，就会出现“回调金字塔”的问题，就像demo2那样，如果这里面的每个回调函数中又包含了很多业务逻辑的话，整个代码块就会变得非常复杂。从逻辑正确性的角度来说，上面这几种回调函数的写法没有任何问题，但是随着业务逻辑的增加和趋于复杂，这种写法的缺点马上就会暴露出来，想要维护它们实在是太痛苦了，这就是“回调地狱(callback hell)”。</p>
<p>回调函数还有一个问题就是我们在回调函数之外无法捕获到回调函数中的异常，一般我们用try catch来捕捉异常，我们尝试下捕捉回调中的异常</p>
<p><img src="https://img.funteas.com/3ba320fc1acdbda04fdef90394e67e6e.png?imageView2/2/w/800" alt="4.png"><br>可以看到，不能捕捉到callback中的异常。</p>
<h3 id="3-2-事件监听-事件发布-订阅"><a href="#3-2-事件监听-事件发布-订阅" class="headerlink" title="3.2 事件监听(事件发布/订阅)"></a>3.2 事件监听(事件发布/订阅)</h3><p>事件监听是一种非常常见的异步编程模式，它是一种典型的逻辑分离方式，对代码解耦很有用处。通常情况下，我们需要考虑哪些部分是不变的，哪些是容易变化的，把不变的部分封装在组件内部，供外部调用，需要自定义的部分暴露在外部处理。从某种意义上说，事件的设计就是组件的接口设计。<br>1）jQuery事件监听</p>
<pre><code>    $(&#39;#btn&#39;).on(&#39;myEvent&#39;, function(e) {
    console.log(&#39;There is my Event&#39;);
});
$(&#39;#btn&#39;).trigger(&#39;myEvent&#39;);
</code></pre><p>2）发布/订阅模式</p>
<pre><code>varPubSub = function() { this.handlers = {}; };
PubSub.prototype.subscribe = function(eventType, handler) {
    if (!(eventType inthis.handlers)) { this.handlers[eventType] = []; } this.handlers[eventType].push(handler);
    //添加事件监听器
    return this;
    //返回上下文环境以实现链式调用
};
PubSub.prototype.publish = function(eventType) {
    var _args = Array.prototype.slice.call(arguments, 1);
    for (var i = 0, _handlers = this.handlers[eventType]; i &lt; _handlers.length; i++) {
        _handlers[i].apply(this, _args); //遍历事件监听器
    }
    return this;
};
varevent = newPubSub; //构造PubSub实例
event.subscribe(&#39;list&#39;, function(msg) {
    console.log(msg);
});
event.publish(&#39;list&#39;, { data: [&#39;one,&#39;, &#39;two&#39;] });
//Object {data: Array[2]}
</code></pre><p>这种模式实现的异步编程，本质上还是通过回调函数实现的，所以3.1中提到的回调嵌套和无法捕捉异常的问题还是存在的，接下来我们看ES6提供的Promise对象，是否解决这两个问题。</p>
<h3 id="3-3-Promise对象"><a href="#3-3-Promise对象" class="headerlink" title="3.3 Promise对象"></a>3.3 Promise对象</h3><p>ES 6中原生提供了Promise对象，Promise对象代表了某个未来才会知道结果的事件(一般是一个异步操作)，并且这个事件对外提供了统一的API，可供进一步处理。<br>使用Promise对象可以用同步操作的流程写法来表达异步操作，避免了层层嵌套的异步回调，代码也更加清晰易懂，方便维护，也可以捕捉异常。</p>
<p>一个简单例子：</p>
<pre><code>function fn(num) {
    returnnewPromise(function(resolve, reject) {
        if (typeof num == &#39;number&#39;) {
            resolve();
        } else {
            reject();
        }
    }).then(function() {
        console.log(&#39;参数是一个number值&#39;);
    }).then(null, function() {
        console.log(&#39;参数不是一个number值&#39;);
    })
}
fn(&#39;haha&#39;);
fn(1234);
</code></pre><p>为什么Promise 可以这样实现异步编程，在这我们简单分析下Promise实现过程：<br>1）极简Promise雏形</p>
<pre><code>// 极简promise雏形
functionPromise(fn) {
    var value = null,
        callbacks = []; //callbacks为数组，因为可能同时有很多个回调
    this.then = function(onFulfilled) {
        callbacks.push(onFulfilled);
    };

    function resolve(value) {
        callbacks.forEach(function(callback) {
            callback(value);
        });
    }

    fn(resolve);
}
</code></pre><ul>
<li>如果promise内部的函数是同步函数，我们要加入一些处理，保证在resolve执行之前，then方法已经注册完所有的回调；</li>
<li>通过setTimeout机制，将resolve中执行回调的逻辑放置到JS任务队列末尾，以保证在resolve执行时，then方法的回调函数已经注册完成.</li>
</ul>
<p>2）加入延时处理</p>
<pre><code>// 极简promise雏形，加入延时处理
functionPromise(fn) {
    var value = null,
        callbacks = []; //callbacks为数组，因为可能同时有很多个回调
    this.then = function(onFulfilled) {
        callbacks.push(onFulfilled);
    };

    function resolve(value) {
        setTimeout(function() {
            callbacks.forEach(function(callback) {
                callback(value);
            });
        }, 0)
    }

    fn(resolve);
}
</code></pre><ul>
<li>如果Promise异步操作已经成功，这时，在异步操作成功之前注册的回调都会执行，但是在Promise异步操作成功这之后调用的then注册的回调就再也不会执行了，这显然不是我们想要的</li>
</ul>
<p>3）加入状态判断</p>
<pre><code>// 极简promise雏形，加状态判断
functionPromise(fn) {
    var state = &#39;pending&#39;,
        value = null,
        callbacks = [];
    this.then = function(onFulfilled) {
        if (state === &#39;pending&#39;) {
            callbacks.push(onFulfilled);
            returnthis;
        }
        onFulfilled(value);
        returnthis;
    };

    function resolve(newValue) {
        value = newValue;
        state = &#39;fulfilled&#39;;
        setTimeout(function() {
            callbacks.forEach(function(callback) {
                callback(value);
            });
        }, 0);
    }

    fn(resolve);
}
</code></pre><p>4）链式promise</p>
<pre><code>// 极简promise雏形，链式promise
functionPromise(fn) {
    var state = &#39;pending&#39;,
        value = null,
        callbacks = [];
    this.then = function(onFulfilled) {
        returnnewPromise(function(resolve) {
            handle({
                onFulfilled: onFulfilled || null,
                resolve: resolve
            });
        });
    };

    function handle(callback) {
        if (state === &#39;pending&#39;) {
            callbacks.push(callback);
            return;
        } //如果then中没有传递任何东西
        if (!callback.onResolved) {
            callback.resolve(value);
            return;
        }
        var ret = callback.onFulfilled(value);
        callback.resolve(ret);
    }

    function resolve(newValue) {
        if (newValue &amp;&amp; (typeof newValue === &#39;object&#39; || typeof newValue === &#39;function&#39;)) { varthen = newValue.then; if (typeofthen === &#39;function&#39;) { then.call(newValue, resolve); return; } }
        state = &#39;fulfilled&#39;;
        value = newValue;
        setTimeout(function() {
            callbacks.forEach(function(callback) {
                handle(callback);
            });
        }, 0);
    }

    fn(resolve);
}
</code></pre><h2 id="四、四个扩展点"><a href="#四、四个扩展点" class="headerlink" title="四、四个扩展点"></a>四、四个扩展点</h2><h3 id="4-1-Promise常用的应用场景：ajax"><a href="#4-1-Promise常用的应用场景：ajax" class="headerlink" title="4.1 Promise常用的应用场景：ajax"></a>4.1 Promise常用的应用场景：ajax</h3><p>利用Promise的知识，对ajax进行一个简单的封装。看看会是什么样子：</p>
<pre><code>//demo3 promise封装ajax
var url =&#39;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10&#39;;
function getJSON(url) {
    returnnewPromise(function(resolve, reject) {
        var XHR = newXMLHttpRequest();
        XHR.open(&#39;GET&#39;, url, true);
        XHR.send();

        XHR.onreadystatechange = function() {
            if (XHR.readyState == 4) {
                if (XHR.status == 200) {
                    try {
                        var response = JSON.parse(XHR.responseText);
                        resolve(response);
                    } catch ( e ) {
                        reject(e);
                    }
                } else {
                    reject(newError(XHR.statusText));
                }
            }
        }
    })
}
getJSON(url).then(resp =&gt; console.log(resp));
</code></pre><p>除了串行执行若干异步任务外，Promise还可以并行执行异步任务。</p>
<p>当有一个ajax请求，它的参数需要另外2个甚至更多请求都有返回结果之后才能确定，那么这个时候，就需要用到Promise.all来帮助我们应对这个场景。</p>
<h3 id="4-2-Promise-all"><a href="#4-2-Promise-all" class="headerlink" title="4.2 Promise.all"></a>4.2 Promise.all</h3><p>Promise.all接收一个Promise对象组成的数组作为参数，当这个数组所有的Promise对象状态都变成resolved或者rejected的时候，它才会去调用then方法。</p>
<pre><code>// demo4 promise.all
var url = &#39;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10&#39;;
var url1 = &#39;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-03-26/2017-06-10&#39;;

function renderAll() { returnPromise.all([getJSON(url), getJSON(url1)]); }

renderAll().then(function(value) {
            console.log(value); //将得到一个数组，里面是两个接口返回的值})
</code></pre><p>结果：</p>
<p><img src="https://img.funteas.com/dc947fc1c210056b601d495a739b3590.png?imageView2/2/w/800" alt="5.png"></p>
<p>有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现。</p>
<h3 id="4-3-Promise-race"><a href="#4-3-Promise-race" class="headerlink" title="4.3 Promise.race"></a>4.3 Promise.race</h3><p>与Promise.all相似的是，Promise.race都是以一个Promise对象组成的数组作为参数，不同的是，只要当数组中的其中一个Promsie状态变成resolved或者rejected时，就可以调用.then方法了</p>
<pre><code>// demo5 promise.race
function renderRace() {
    returnPromise.race([getJSON(url), getJSON(url1)]);
}

renderRace().then(function(value) {
    console.log(value);
})
</code></pre><p>这里then()传的value值将是接口返回比较快的接口数据，另外一个接口仍在继续执行，但执行结果将被丢弃。</p>
<p>结果：</p>
<p><img src="https://img.funteas.com/61de25f0a2f0a8ba9216fb4189c1978b.png?imageView2/2/w/800" alt="6.png"></p>
<h3 id="4-4-Generator-函数"><a href="#4-4-Generator-函数" class="headerlink" title="4.4 Generator 函数"></a>4.4 Generator 函数</h3><p>Generator函数是协程在ES 6中的实现，最大特点就是可以交出函数的执行权（暂停执行）。<br>注意：在node中需要开启–harmony选项来启用Generator函数。<br>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。</p>
<p>看个简单的例子：</p>
<pre><code>function* gen(x) {
    var y = yieldx + 2;
    return y;
}
var g = gen(1);
var r1 = g.next(); // { value: 3, done: false }
console.log(r1);
var r2 = g.next() // { value: undefined, done: true }
console.log(r2);
</code></pre><p>需要注意的是Generator函数的函数名前面有一个”*”。<br>上述代码中，调用Generator函数，会返回一个内部指针(即遍历器)g，这是Generator函数和一般函数不同的地方，调用它不会返回结果，而是一个指针对象。调用指针g的next方法，会移动内部指针，指向第一个遇到的yield语句，上例就是执行到x+2为止。<br>换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一个阶段。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>对Generator函数，只有一个感性认知，没有实践过，所以就先介绍到这了，后面还有ES7新的知识点async await，看了下网上的资料，理解得还不够，希望后面自己接触得更多再来这里补上，未完待续…</p>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[__proto__与prototype]]></title>
      <url>/%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E7%9A%84-proto-%E4%B8%8Eprototype.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当创建函数时，JavaScript 会为这个函数自动添加 prototype 属性，这个属性指向的是一个原型对象 Functionname.prototype。我们可以向这个原型对象添加属性或对象，甚至可以指向一个现有的对象</p>
<h2 id="傻傻分不清的proto与prototype"><a href="#傻傻分不清的proto与prototype" class="headerlink" title="傻傻分不清的proto与prototype"></a>傻傻分不清的<strong>proto</strong>与prototype</h2><p>今天小英童鞋问了我一个问题：</p>
<pre><code>functionFoo(firstName, lastName) { this.firstName = firstName;
    this.lastName = lastName; } Foo.prototype.logName = function() {
    Foo.combineName();
    console.log(this.fullName);
}
Foo.prototype.combineName = function() { this.fullName = `${this.firstName} ${this.lastName}` }
var foo = newFoo(&#39;Sanfeng&#39;, &#39;Zhang&#39;);
foo.logName(); // Uncaught TypeError: Foo.combineName is not a function
</code></pre><p>小英童鞋认为<code>Foo</code>的原型对象是<code>Foo.prototype</code>，所以<code>Foo</code>会继承<code>Foo.prototype</code>的属性，调用<code>Foo.combineName()</code>相当于调用<code>Foo.prototype.combineName()</code>，但结果<code>Foo.combineName()</code>不是一个方法。</p>
<p>会造成这个问题的原因一定是因为小英童鞋弄混了原型和继承的一些原理，下面我们来整理一下原型和继承的相关原理，找出问题的根本原因。</p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><code>prototype</code></h2><p><code>prototype</code>是一个只有函数才有的属性。</p>
<p>当创建函数时，<strong>JavaScript</strong> 会为这个函数自动添加<code>prototype</code>属性，这个属性指向的是一个原型对象<code>Functionname.prototype</code>。我们可以向这个原型对象添加属性或对象，甚至可以指向一个现有的对象。</p>
<h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h2><p>接下来我们说说继承，每个对象都有一个<code>__proto__</code>属性，这个属性是用来标识自己所继承的原型。</p>
<p>注意： <strong>JavaScript</strong> 中任意对象都有一个内置属性 <strong>[[Prototype]]</strong> ，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过<code>__proto__</code>来访问。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><strong>JavaScript</strong> 可以通过<code>prototype</code>和<code>__proto__</code>在两个对象之间创建一个关联，使得一个对象就可以通过委托访问另一个对象的属性和函数。</p>
<p>这样的一个关联就是原型链，一个由对象组成的有限对象链，用于实现继承和共享属性。</p>
<h2 id="构造函数创建对象实例"><a href="#构造函数创建对象实例" class="headerlink" title="构造函数创建对象实例"></a>构造函数创建对象实例</h2><p><strong>JavaScript</strong> 函数有两个不同的内部方法：<strong>[[Call]]</strong> 和 <strong>[[Construct]]</strong> 。</p>
<p>如果不通过<code>new</code>关键字调用函数，则执行 <strong>[[Call]]</strong> 函数，从而直接执行代码中的函数体。</p>
<p>当通过<code>new</code>关键字调用函数时，执行的是 <strong>[[Construct]]</strong> 函数，它负责创建一个实例对象，把实例对象的<code>__proto__</code>属性指向构造函数的<code>prototype</code>来实现继承构造函数<code>prototype</code>的所有属性和方法，将<code>this</code>绑定到实例上，然后再执行函数体。</p>
<p>模拟一个构造函数：</p>
<pre><code>functionFoo(firstName, lastName) { this.firstName = firstName;
    this.lastName = lastName; } Foo.prototype.logName = function() {
    Foo.combineName();
    console.log(this.fullName);
}
Foo.prototype.combineName = function() { this.fullName = `${this.firstName} ${this.lastName}` }
var foo = newFoo(&#39;Sanfeng&#39;, &#39;Zhang&#39;);
foo.logName(); // Uncaught TypeError: Foo.combineName is not a function
</code></pre><p>至此我们了解了<code>prototype</code>和<code>__proto__</code>的作用，也了解使用构造函数创建对象实例时这两个属性的指向，以下使用一张图来总结一下如何通过<code>prototype</code>和<code>__proto__</code>实现原型链。</p>
<p><img src="https://img.funteas.com/12d6bb072d101ff6e1966a63329cf806?imageView2/2/w/800" alt=""></p>
<p>从上图我们可以找出<code>foo</code>对象和<code>Foo</code>函数的原型链：</p>
<pre><code>foo.__proto__ = Foo.prototype;
foo.__proto__.__proto__ = Foo.prototype.__proto__ = Object.prototype;
foo.__proto__.__proto__.__proto__ = Foo.prototype.__proto__.__proto__ = Object.prototype.__proto__ = null;
</code></pre><p><img src="https://img.funteas.com/73c4353afa8b74a63baedfc94c583539?imageView2/2/w/800" alt=""></p>
<pre><code>Foo.__proto__ = Function.prototype;
Foo.__proto__.__proto__ = Function.prototype.__proto__;
Foo.__proto__.__proto__.__proto__ = Function.prototype.__proto__.__proto__ = Object.prototype.__proto__ = null;
</code></pre><p><img src="https://img.funteas.com/aa3de68a5dd2e76120d836d22adeb969?imageView2/2/w/800" alt=""></p>
<p>构造函数<code>Foo</code>的原型链上没有<code>Foo.prototype</code>，因此无法继承<code>Foo.prototype</code>上的属性和方法。而实例<code>foo</code>的原型链上有<code>Foo.prototype</code>，因此<code>foo</code>可以继承<code>Foo.prototype</code>上的属性和方法。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>到这里，我们可以很简单的解答小英童鞋的问题了，在<code>Foo</code>的原型链上没有<code>Foo.prototype</code>，无法继承<code>Foo.prototype</code>上的<code>combineName</code>方法，因此会抛出<code>Foo.combineName is not a function</code>的异常。要想使用<code>combineName</code>方法，可以这样<code>Foo.prototype.combineName</code>，或者这样<code>this.combineName</code>（<code>this</code>指向实例对象）。</p>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用合适的设计模式一步步优化前端代码]]></title>
      <url>/%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E6%AD%A5%E6%AD%A5%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>常见的设计模式有 23 种，如果单纯的按照模式名称 + 名词解释的方式来写这篇文章，可能太枯燥了或者很难理解记忆，所以我打算换一种方式。下面我们以一个例子开始我们今天的文章。</p>
<h2 id="使用合适的设计模式一步步优化前端代码"><a href="#使用合适的设计模式一步步优化前端代码" class="headerlink" title="使用合适的设计模式一步步优化前端代码"></a>使用合适的设计模式一步步优化前端代码</h2><blockquote>
<p>在后端语言中，设计模式应用的较为广泛。如Spring中常见的工厂模式、装饰者模式、单例模式、迭代器模式。但是在日常的前端开发中，设计模式使用的较少，或者大家的代码已经遵循了某某设计模式但是我们并不知道。常见的设计模式有23种，如果单纯的按照模式名称+名词解释的方式来写这篇文章，可能太枯燥了或者很难理解记忆，所以我打算换一种方式。下面我们以一个例子开始我们今天的文章。</p>
</blockquote>
<h5 id="假设我们有一个这样的需求："><a href="#假设我们有一个这样的需求：" class="headerlink" title="假设我们有一个这样的需求："></a>假设我们有一个这样的需求：</h5><pre><code>let page = {
    init: () =&gt; { //此处(placeA)有很多业务代码或者调用了很多page中的其他初始化函数
    },
    ....
};
</code></pre><p>现在业务迭代，需要我们在page.init()初始化代码块的最后增加一些功能，同时不影响原先的功能。按照正常的写法，我们可能会像下面这样写：</p>
<pre><code>let page = {
    init: () =&gt; { //placeA
        page.newFunction();
    },
    newFunction: () =&gt; { ... }
};
</code></pre><p>这样写是可以解决我们的需求，但是这样的代码是具有侵略性的，我们不得不在原先的代码的合适位置新增我们需要的代码。但我们思考一个问题，如果我们用了某个插件或者某个被ungly、minify之后的代码呢，我们怎么在找到合适的位置添加我们需要的功能呢？大家可以先自己思考一下，再看下面的内容。</p>
<h5 id="首先我们先看解决方案，再思考其背后的东西。"><a href="#首先我们先看解决方案，再思考其背后的东西。" class="headerlink" title="首先我们先看解决方案，再思考其背后的东西。"></a>首先我们先看解决方案，再思考其背后的东西。</h5><pre><code>//我们可以在Function的原型链上定义一个扩展函数，以实现我们的需求。
Function.prototype.fnAfter = function(fn) {
    var _self = this;
    returnfunction() {
        _self.apply(this, arguments);
        fn.apply(this, arguments);
    }
};

page.init = (page.init || function() {}).fnAfter(function() {
    console.log(&#39;我们要追加的功能成功啦~&#39;);
});

page.init();
</code></pre><p>上面的代码已经能够实现我们的需要了，但是其实还是不够好或者可以写的更灵活一些。因为我希望可以可以做到像jquery的链式调用那样，可以一直往后面追加新的功能。那么我们在上面代码的基础上再扩展下，其实很简单，我们只要再Function.prototype.fnAfter中再返回自身就好了。</p>
<pre><code>Function.prototype.fnAfter = function(fn) {
    var _self = this;
    returnfunction() {
        var fnOrigin = _self.apply(this, arguments);
        fn.apply(this, arguments);
        return fnOrigin;
    }
};
</code></pre><p>其实上面的代码写法还是可以优化的。比如：</p>
<pre><code>//每次扩展的时候我们都需要这么写
page.init = (page.init || function() {}).fnAfter(function() { //
    ...
}); //我们能不能再优化下，比如容错代码 || function(){} 在一个地方统一处理  
//或者我们新建一个工厂函数来帮我们统一做这样的事情，这里我们就不展开了，文章篇幅有限。
</code></pre><h5 id="我们上面的扩展其实就是遵循的是面向对象程序设计中的开放-封闭原则（OCP）。官方对OCP的解释是：软件实体（类、模块、函数…）应该是可以扩展的，但是不可修改。设计模式中有很多模式都遵循了开发-封闭原则，比如：发布-订阅者模式、模板方法模式、策略模式、代理模式。"><a href="#我们上面的扩展其实就是遵循的是面向对象程序设计中的开放-封闭原则（OCP）。官方对OCP的解释是：软件实体（类、模块、函数…）应该是可以扩展的，但是不可修改。设计模式中有很多模式都遵循了开发-封闭原则，比如：发布-订阅者模式、模板方法模式、策略模式、代理模式。" class="headerlink" title="我们上面的扩展其实就是遵循的是面向对象程序设计中的开放-封闭原则（OCP）。官方对OCP的解释是：软件实体（类、模块、函数…）应该是可以扩展的，但是不可修改。设计模式中有很多模式都遵循了开发-封闭原则，比如：发布-订阅者模式、模板方法模式、策略模式、代理模式。"></a>我们上面的扩展其实就是遵循的是面向对象程序设计中的开放-封闭原则（OCP）。官方对OCP的解释是：软件实体（类、模块、函数…）应该是可以扩展的，但是不可修改。设计模式中有很多模式都遵循了开发-封闭原则，比如：发布-订阅者模式、模板方法模式、策略模式、代理模式。</h5><p>有的时候我们通过扩展来提高代码的灵活性并不能解决所有的场景需要，在不可避免发生修改的时候，我们可以通过增加配置文件，让用户修改配置文件以实现个性化需求也是合理的。修改配置远比修改源代码要简单的多。</p>
<h5 id="有了上面的引入，我们来看几个前端开发中常见的设计模式。"><a href="#有了上面的引入，我们来看几个前端开发中常见的设计模式。" class="headerlink" title="有了上面的引入，我们来看几个前端开发中常见的设计模式。"></a>有了上面的引入，我们来看几个前端开发中常见的设计模式。</h5><ul>
<li>单例模式</li>
</ul>
<blockquote>
<p>单例模式顾名思义：保证一个类仅有一个实例，并且对外暴露一个能够访问到它的访问点。</p>
</blockquote>
<p>实现单例模式的核心就是保证一个类仅有一个实例，那么意思就是当创建一个对象时，我们需要判断下之前有没有创建过该实例，如果创建过则返回之前创建的实例，否则新建。</p>
<pre><code>var fn = function() { this.instance = null; };
fn.getInstance = function() { //写法1
    if (!this.instance) { this.instance = new fn(); }
    return this.instance; //写法2
    return this.instance || (this.instance = new fn());
};
var fnA = fn.getInstance();
var fnB = fn.getInstance();
console.log(fnA === fnB); //true
</code></pre><p>日常的业务场景中，单例模式也比较常见，比如：一个页面中的模态框只有一个，每次打开与关闭的都应该是同一个，而不是重复新建。而且为了性能优化，我们应该在需要时再创建，而不是页面初始化时就已经存在于dom中，这个就是<em>惰性单例模式</em>。</p>
<pre><code>//假设我们需要点击某个按钮时就显示出模态框，那么我们可以像下面这么
var createModal = (function() {
    var modal = null;
    returnfunction() {
        if (!modal) {
            modal = document.createElement(&#39;div&#39;); //...
            modal.style.display = &#39;none&#39;;
            document.getElementById(&#39;container&#39;).append(modal);
        }
        return modal;
    }
})();

document.getElementById(&#39;showModal&#39;).click(function() {
    var modal = createModal();
    modal.style.display = &#39;block&#39;;
});
</code></pre><p>上面的代码中，我们将创建对象和管理实例的逻辑都放在一个地方，违反了单一职责原则，我们应该单独新建一个用于创建单例的方法，这样我们不仅能创建唯一的modal实例，也能创建其他的，职责分开。</p>
<pre><code>var createSingleInstance = function(fn) {
    var instance = null;
    returnfunction() {
        if (!instance) {
            instance = fn.apply(this, arguments);
        }
        return instance;
    }
};
var createModal = function() {
    var modal = docuemnt.createElement(&#39;div&#39;); //...
    modal.style.display = &#39;none&#39;;
    document.getElementById(&#39;container&#39;).append(modal);
    return modal;
};
var modal = createSingleInstance(createModal);
</code></pre><ul>
<li>观察者模式</li>
</ul>
<blockquote>
<p>定义了对象与其他对象之间的依赖关系，当某个对象发生改变的时候，所有依赖到这个对象的地方都会被通知。</p>
<p>像knockout.js中的ko.compute以及vue中的computed函数其实就是这个模式的实践。实现观察者模式的核心就是我们需要有一个变量来保存所有的依赖，一个listen函数用于向变量中添加依赖，一个trigger函数用于触发通知。</p>
</blockquote>
<pre><code>var observal = {
    eventObj: {},
    listen: function(key, fn) { this.eventObj[key] = this.eventObj[key] || [];
        this.eventObj[key].push(fn); },
    trigger: function(key) { var eventList = this.eventObj[key]; if (!eventList || eventList.length &lt; 1) { return; } var length = eventList.length; for (var i = 0; i &lt; length; i++) { varevent = eventList[i];
            event.apply(this, arguments); } }
}; //定义要监听的事件
observal.listen(&#39;command1&#39;, function() {
    console.log(&#39;黑夜给了我夜色的眼睛~&#39;);
});
observal.listen(&#39;command1&#39;, function() {
    console.log(&#39;我却用它寻找光明~&#39;);
});
observal.listen(&#39;command2&#39;, function() {
    console.log(&#39;一花一世界~&#39;);
});
observal.listen(&#39;command2&#39;, function() {
    console.log(&#39;一码一人生~&#39;);
}); //触发某个监听的事件
observal.trigger(&#39;command1&#39;); //黑夜给了我夜色的眼睛~ 我却用它寻找光明~
observal.trigger(&#39;command2&#39;); //一花一世界~ 一码一人生~
</code></pre><p>使用观察者模式（发布-订阅模式）我们可以使得代码更灵活、健壮性更高。订阅者不需要了解消息来自哪一个发布者，发布者也不需要知道消息会发送给哪些订阅者。</p>
<p>同样的我们可以创建一个公用的函数库，里面存放创建observal的工具方法，需要用到的地方我们就用这个方法创建一个发布订阅对象。</p>
<ul>
<li>其他设计模式及设计原则</li>
</ul>
<p>设计模式有很多，这里篇幅有限就不再展开。GoF在1995年提出了23种设计模式。诸如策略者模式优化表单验证、代理模式、组合模式、装饰者模式、适配器模式…这些后期可以再简单探讨或者大家后面自己了解。常用的设计模式及设计原则可以参考下面的思维导图。<img src="https://user-gold-cdn.xitu.io/2017/10/27/f7ab0664b5fd4e34dbb16eaab5813c9d" alt="常用设计模式"><img src="https://user-gold-cdn.xitu.io/2017/10/27/038d561c77aba1ff095fa0c3cfc8c113" alt="六大设计原则"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>设计模式都是经过了大量的代码、软件实践而总结出来的优秀的组织实践方案。每种设计模式都有它的适应场景，有的场景也会使用多种设计模式。只有了解了更多的设计模式，掌握各个设计模式自己的适应场景，才能更好的为我们所用。</p>
<p>但是过早的优化不一定是好事或者不是必须的，有时候我们可以一开始并不去优化，等到某个应用场景下出现了代码组织混乱、需要额外扩展等问题，我们再优化重构，以防过早优化导致的不必要性或者只是增加了代码不必要的复杂性。就像redux，如果一个页面组件与组件之间有数据共享、需要在任意组件内部拿到某个数据、任意一个组件中某个行为导致的数据变化需要通知到所有用到的地方，那么这个时候可以使用redux，一些简单的表单页面或者展示页完全可以不用redux。</p>
]]></content>
      
        <categories>
            
            <category> javascript设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS3 transform特性教程]]></title>
      <url>/CSS3-transform%E7%89%B9%E6%80%A7%E6%95%99%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍的是css3新属性变形transform。</p>
<h2 id="CSS3-transform教程"><a href="#CSS3-transform教程" class="headerlink" title="CSS3 transform教程"></a>CSS3 transform教程</h2><p><a href="http://www.w3.org/TR/css3-2d-transforms/" target="_blank" rel="external">Transform</a> 字面上就是变形，改变的意思。在<a href="http://www.w3.org/TR/css3-roadmap/" target="_blank" rel="external">CSS3</a> 中<a href="http://www.w3.org/TR/css3-2d-transforms/" target="_blank" rel="external">transform</a> 主要包括以下几种：<strong>旋转rotate</strong>、<strong>扭曲skew</strong>、<strong>缩放scale</strong>和<strong>移动translate</strong>以及<strong>矩阵变形matrix</strong>。下面我们一起来看看CSS3中transform的旋转rotate、扭曲skew、缩放scale和移动translate具体如何实现，老样子，我们就从<a href="http://www.w3.org/TR/css3-2d-transforms/" target="_blank" rel="external">transform</a> 的语法开始吧。</p>
<p><strong>语法：</strong></p>
<pre><code>   transform ： none | &lt;transform-function&gt; [ &lt;transform-function&gt; ]* 
   也就是：
   transform: rotate | scale | skew | translate |matrix;
</code></pre><p>none:表示不进么变换；<transform-function>表示一个或多个变换函数，以空格分开；换句话说就是我们同时对一个元素进行transform的多种属性操作，例如rotate、scale、translate三种，但这里需要提醒大家的，以往我们叠加效果都是用逗号（“，”）隔开，但transform中使用多个属性时却需要有空格隔开。大家记住了是空格隔开。</transform-function></p>
<p>取值：</p>
<p>transform属性实现了一些可用SVG实现的同样的功能。它可用于内联(inline)元素和块级(block)元素。它允许我们旋转、缩放和移动元素 ，他有几个属性值参数：rotate;translate;scale;skew;matrix。下面我们分别来介绍这几个属性值参数的具体使用方法：</p>
<h3 id="一、旋转rotate"><a href="#一、旋转rotate" class="headerlink" title="一、旋转rotate"></a><strong>一、旋转rotate</strong></h3><p>rotate(<angle>) ：通过指定的角度参数对原元素指定一个<a href="http://www.w3.org/TR/SVG/coords.html#RotationDefined" target="_blank" rel="external">2D rotation</a> （2D 旋转），需先有transform-origin属性的定义。transform-origin定义的是旋转的基点，其中angle是指旋转角度，如果设置的值为正数表示顺时针旋转，如果设置的值为负数，则表示逆时针旋转。如：transform:rotate(30deg):</angle></p>
<p><img src="http://www.w3cplus.com/sites/default/files/rotate.png" alt=""> </p>
<h3 id="二、移动translate"><a href="#二、移动translate" class="headerlink" title="二、移动translate"></a><strong>二、移动translate</strong></h3><p>移动translate我们分为三种情况：translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）；translateX(x)仅水平方向移动（X轴移动）；translateY(Y)仅垂直方向移动（Y轴移动），具体使用方法如下：</p>
<p>1、translate(<translation-value>[, <translation-value>]) ：通过矢量[tx, ty]指定一个<a href="http://www.w3.org/TR/SVG/coords.html#TranslationDefined" target="_blank" rel="external">2D translation</a> ，tx 是第一个过渡值参数，ty 是第二个过渡值参数选项。如果 未被提供，则ty以 0 作为其值。也就是translate(x,y),它表示对象进行平移，按照设定的x,y参数值,当值为负数时，反方向移动物体，其基点默认为元素 中心点，也可以根据transform-origin进行改变基点。如transform:translate(100px,20px):</translation-value></translation-value></p>
<p><img src="http://www.w3cplus.com/sites/default/files/translate-x-y.png" alt=""> </p>
<p>2、translateX(<translation-value>) ： 通过给定一个X方向上的数目指定一个<a href="http://www.w3.org/TR/SVG/coords.html#TranslationDefined" target="_blank" rel="external">translation</a> 。只向x轴进行移动元素，同样其基点是元素中心点，也可以根据transform-origin改变基点位置。如：transform:translateX(100px):</translation-value></p>
<p><img src="http://www.w3cplus.com/sites/default/files/translate-x.png" alt=""> </p>
<p>3、translateY(<translation-value>) ：通过给定Y方向的数目指定一个<a href="http://www.w3.org/TR/SVG/coords.html#TranslationDefined" target="_blank" rel="external">translation</a> 。只向Y轴进行移动，基点在元素心点，可以通过transform-origin改变基点位置。如：transform:translateY(20px):</translation-value></p>
<p><img src="http://www.w3cplus.com/sites/default/files/translate-y.png" alt=""> </p>
<p><strong>三、缩放scale</strong></p>
<p>缩放scale和移动translate是极其相似，他也具有三种情况：scale(x,y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）；scaleX(x)元素仅水平方向缩放（X轴缩放）；scaleY(y)元素仅垂直方向缩放（Y轴缩放），但它们具有相同的缩放中心点和基数，其中心点就是元素的中心位置，缩放基数为1，如果其值大于1元素就放大，反之其值小于1，元素缩小。下面我们具体来看看这三种情况具体使用方法：</p>
<p>1、scale(<number>[, <number>])：提供执行[sx,sy]缩放矢量的两个参数指定一个<a href="http://www.w3.org/TR/SVG/coords.html#ScalingDefined" target="_blank" rel="external">2D scale</a> （2D缩放）。如果第二个参数未提供，则取与第一个参数一样的值。scale(X,Y)是用于对元素进行缩放，可以通过transform-origin对元素的基点进行设置，同样基点在元素中心位置；基中X表示水平方向缩放的倍数，Y表示垂直方向的缩放倍数，而Y是一个可选参数，如果没有设置Y值，则表示X，Y两个方向的缩放倍数是一样的。并以X为准。如：transform:scale(2,1.5):</number></number></p>
<p><img src="http://www.w3cplus.com/sites/default/files/scale-x-y.png" alt=""> </p>
<p>2、scaleX(<number>) ： 使用 [sx,1] 缩放矢量执行缩放操作，sx为所需参数。scaleX表示元素只在X轴(水平方向)缩放元素，他的默认值是(1,1)，其基点一样是在元素的中心位置，我们同样是通过transform-origin来改变元素的基点。如：transform:scaleX(2):</number></p>
<p><img src="http://www.w3cplus.com/sites/default/files/scale-x.png" alt=""> </p>
<p>3、scaleY(<number>) ： 使用 [1,sy] 缩放矢量执行缩放操作，sy为所需参数。scaleY表示元素只在Y轴（垂直方向）缩放元素，其基点同样是在元素中心位置，可以通过transform-origin来改变元素的基点。如transform:scaleY(2):</number></p>
<p><img src="http://www.w3cplus.com/sites/default/files/scale-y.png" alt=""> </p>
<p><strong>四、扭曲skew</strong></p>
<p>扭曲skew和translate、scale一样同样具有三种情况：skew(x,y)使元素在水平和垂直方向同时扭曲（X轴和Y轴同时按一定的角度值进行扭曲变形）；skewX(x)仅使元素在水平方向扭曲变形（X轴扭曲变形）；skewY(y)仅使元素在垂直方向扭曲变形（Y轴扭曲变形），具体使用如下：</p>
<p>1、skew(<angle> [, <angle>]) ：X轴Y轴上的<a href="http://www.w3.org/TR/SVG/coords.html#SkewXDefined" target="_blank" rel="external">skew transformation</a> （斜切变换）。第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则值为0，也就是Y轴方向上无斜切。skew是用来对元素进行扭曲变行，第一个参数是水平方向扭曲角度，第二个参数是垂直方向扭曲角度。其中第二个参数是可选参数，如果没有设置第二个参数，那么Y轴为0deg。同样是以元素中心为基点，我们也可以通过transform-origin来改变元素的基点位置。如：transform:skew(30deg,10deg):</angle></angle></p>
<p><img src="http://www.w3cplus.com/sites/default/files/skew-x-y.png" alt=""> </p>
<p>2、skewX(<angle>) ： 按给定的角度沿X轴指定一个<a href="http://www.w3.org/TR/SVG/coords.html#SkewXDefined" target="_blank" rel="external">skew transformation</a> （斜切变换）。skewX是使元素以其中心为基点，并在水平方向（X轴）进行扭曲变行，同样可以通过transform-origin来改变元素的基点。如：transform:skewX(30deg)</angle></p>
<p><img src="http://www.w3cplus.com/sites/default/files/skew-x.png" alt=""> </p>
<p>3、skewY(<angle>) ： 按给定的角度沿Y轴指定一个<a href="http://www.w3.org/TR/SVG/coords.html#SkewYDefined" target="_blank" rel="external">skew transformation</a> （斜切变换）。skewY是用来设置元素以其中心为基点并按给定的角度在垂直方向（Y轴）扭曲变形。同样我们可以通过transform-origin来改变元素的基点。如：transform:skewY（10deg）</angle></p>
<p><img src="http://www.w3cplus.com/sites/default/files/skew-y.png" alt=""> </p>
<p><strong>五、矩阵matrix</strong></p>
<p>matrix(<number>, <number>, <number>, <number>, <number>, <number>) ： 以一个含六值的(a,b,c,d,e,f)<a href="http://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined" target="_blank" rel="external">变换矩阵</a> 的形式指定一个2D变换，相当于直接应用一个[a b c d e f]变换矩阵。就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素,此属性值使用涉及到数学中的矩阵，我在这里只是简单的说一下CSS3中的transform有这么一个属性值，如果有感兴趣的朋友可以去了解更深层次的martix使用方法，这里就不多说了。</number></number></number></number></number></number></p>
<p><strong>改变元素基点transform-origin</strong></p>
<p>前面我们多次提到transform-origin这个东东，他的主要作用就是让我们在进行transform动作之前可以改变元素的基点位置，因为我们元素默认基点就是其中心位置，换句话说我们没有使用transform-origin改变元素基点位置的情况下，transform进行的rotate,translate,scale,skew,matrix等操作都是以元素自己中心位置进行变化的。但有时候我们需要在不同的位置对元素进行这些操作，那么我们就可以使用transform-origin来对元素进行基点位置改变，使元素基点不在是中心位置，以达到你需要的基点位置。下面我们主要来看看其使用规则：</p>
<p>transform-origin(X,Y):用来设置元素的运动的基点（参照点）。默认点是元素的中心点。其中X和Y的值可以是百分值,em,px，其中X也可以是字符参数值left,center,right；Y和X一样除了百分值外还可以设置字符值top,center,bottom，这个看上去有点像我们background-position设置一样；下面我列出他们相对应的写法：</p>
<p>1、top left | left top 等价于 0 0 | 0% 0%</p>
<p>2、top | top center | center top 等价于 50% 0</p>
<p>3、right top | top right 等价于 100% 0</p>
<p>4、left | left center | center left 等价于 0 50% | 0% 50%</p>
<p>5、center | center center 等价于 50% 50%（默认值）</p>
<p>6、right | right center | center right 等价于 100% 50%</p>
<p>7、bottom left | left bottom 等价于 0 100% | 0% 100%</p>
<p>8、bottom | bottom center | center bottom 等价于 50% 100%</p>
<p>9、bottom right | right bottom 等价于 100% 100%</p>
<p>其中 left,center right是水平方向取值，对应的百分值为left=0%;center=50%;right=100%而top center bottom是垂直方向的取值，其中top=0%;center=50%;bottom=100%;如果只取一个值，表示垂直方向值不变，我们分别来看看以下几个实例</p>
<p>(1)transform-origin:(left,top):</p>
<p><img src="http://www.w3cplus.com/sites/default/files/origin-x-y.png" alt=""> </p>
<p>(2)transform-origin:right</p>
<p><img src="http://www.w3cplus.com/sites/default/files/origin-x.png" alt=""> </p>
<p>(3)transform-origin(25%,75%)</p>
<p><img src="http://www.w3cplus.com/sites/default/files/origin-per.png" alt=""> </p>
<p>更多的改变中心基点办法，大家可以在本地多测试一下，多体会一下，这里还要提醒大家一点的是，transform-origin并不是transform中的属性值，他具有自己的语法，前面我也说过了，说简单一点就是类似于我们的background-position的用法，但又有其不一样，因为我们background-position不需要区别浏览器内核不同的写法，但transform-origin跟其他的css3属性一样，我们需要在不同的浏览内核中加上相应的前缀，下面列出各种浏览器内核下的语法规则：</p>
<pre><code>//Mozilla内核浏览器：firefox3.5+
  -moz-transform-origin: x y;
  //Webkit内核浏览器：Safari and Chrome
  -webkit-transform-origin: x y;
  //Opera
  -o-transform-origin: x y ;
  //IE9
  -ms-transform-origin: x y;
  //W3C标准
  transform-origin: x y ;
</code></pre><p><strong>transform在不同浏览器内核下的书写规则</strong></p>
<pre><code>//Mozilla内核浏览器：firefox3.5+
  -moz-transform: rotate | scale | skew | translate ;
 //Webkit内核浏览器：Safari and Chrome
  -webkit-transform: rotate | scale | skew | translate ;
 //Opera
  -o-transform: rotate | scale | skew | translate ;
 //IE9
  -ms-transform: rotate | scale | skew | translate ;
 //W3C标准
  transform: rotate | scale | skew | translate ;
</code></pre><p>上面列出是不同浏览内核transform的书写规则，如果需要兼容各浏览器的话，以上写法都需要调用。</p>
<p><strong>支持transform浏览器</strong></p>
<p><img src="http://www.w3cplus.com/sites/default/files/transform-browers.png" alt=""> </p>
<p>同样的transform在IE9下版本是无法兼容的，之所以有好多朋友说，IE用不了，搞这个做什么？个人认为，CSS3推出来了，他是一门相对前沿的技术，做为Web前端的开发者或者爱好者都有必要了解和掌握的一门新技术，如果要等到所有浏览器兼容，那我们只能对css3说NO，我用不你。因为IE老大是跟不上了，，，，纯属个人观点，不代表任何。还是那句话，感兴趣的朋友跟我一样，不去理会IE，我们继续看下去。</p>
<p>在上面我们详细介绍了CSS3中transform的各种属性值的设置以及其各自的参数，下面我们通过一个实例来看看每一种属性值的使用，为了节约空间和大家的时间，我们后面的实例都是在这个html基础上实现，主要是我们在下面的菜单中的a:hover中分别使用不同的transform的设置，换句话说，当你移动到链接上时，相应的每一个菜单项有不同的变化，因为我们在每个菜单中使用了transform。具体每一步我们可以看下面的实例：</p>
<p><strong>HTML Code:</strong></p>
<pre><code>&lt;divclass=&quot;menu&quot;&gt;
    &lt;ulclass=&quot;clearfix&quot;&gt;
        &lt;liclass=&quot;item translate&quot;&gt;
            &lt;ahref=&quot;#&quot;&gt;Translate&lt;/a&gt;
                &lt;/li&gt;
                &lt;liclass=&quot;item translate-x&quot;&gt;
                    &lt;ahref=&quot;#&quot;&gt;TranslateX&lt;/a&gt;
                        &lt;/li&gt;
                        &lt;liclass=&quot;item translate-y&quot;&gt;
                            &lt;ahref=&quot;#&quot;&gt;TranslateY&lt;/a&gt;
                                &lt;/li&gt;
                                &lt;liclass=&quot;item rotate&quot;&gt;
                                    &lt;ahref=&quot;#&quot;&gt;Rotate&lt;/a&gt;
                                        &lt;/li&gt;
                                        &lt;liclass=&quot;item scale&quot;&gt;
                                            &lt;ahref=&quot;#&quot;&gt;Scale&lt;/a&gt;
                                                &lt;/li&gt;
                                                &lt;liclass=&quot;item scale-x&quot;&gt;
                                                    &lt;ahref=&quot;#&quot;&gt;ScaleX&lt;/a&gt;
                                                        &lt;/li&gt;
                                                        &lt;liclass=&quot;item scale-y&quot;&gt;
                                                            &lt;ahref=&quot;#&quot;&gt;ScaleY&lt;/a&gt;
                                                                &lt;/li&gt;
                                                                &lt;liclass=&quot;item skew&quot;&gt;
                                                                    &lt;ahref=&quot;#&quot;&gt;Skew&lt;/a&gt;
                                                                        &lt;/li&gt;
                                                                        &lt;liclass=&quot;item skew-x&quot;&gt;
                                                                            &lt;ahref=&quot;#&quot;&gt;SkewX&lt;/a&gt;
                                                                                &lt;/li&gt;
                                                                                &lt;liclass=&quot;item skew-y&quot;&gt;
                                                                                    &lt;ahref=&quot;#&quot;&gt;SkewY&lt;/a&gt;
                                                                                        &lt;/li&gt;
                                                                                        &lt;liclass=&quot;item matrix&quot;&gt;
                                                                                            &lt;ahref=&quot;#&quot;&gt;Matrix&lt;/a&gt;
                                                                                                &lt;/li&gt;
                                                                                                &lt;/ul&gt;
                                                                                                &lt;/div&gt;
</code></pre><p>为了效果更好一点，我们给上面的导航菜单加上一点CSS样式：</p>
<pre><code>.menuul {
    border-top: 15px solid black;
    padding: 010px;
}

.menuullia {
    color: #fff;
    float: left;
    margin: 05px;
    font-size: 14px;
    height: 50px;
    line-height: 50px;
    text-align: center;
    width: 65px;
    padding: 10px 5px;
    background: #151515;
    -moz-border-radius: 005px 5px;
    -webkit-border-radius: 005px 5px;
    border-radius: 005px 5px;
    -moz-box-shadow: 001px #ccc, inset 002px #fff;
    -webkit-box-shadow: 001px #ccc, inset 002px #fff;
    box-shadow: 001px #ccc, inset 002px #fff;
    text-shadow: 01px 1px #686868;
    text-decoration: none;
}

.menuulli.translatea {
    background: #2EC7D2;
}

.menuulli.translate-xa {
    background: #8FDD21;
}

.menuulli.translate-ya {
    background: #F45917;
}

.menuulli.rotatea {
    background: #D50E19;
}

.menuulli.scalea {
    background: #cdddf2;
}

.menuulli.scale-xa {
    background: #0fDD21;
}

.menuulli.scale-ya {
    background: #cd5917;
}

.menuulli.skewa {
    background: #519;
}

.menuulli.skew-xa {
    background: #D50;
}

.menuulli.skew-ya {
    background: #E19;
}

.menuulli.matrixa {
    background: #919;
}
</code></pre><p>在这里我们使用了一些前面所进的CSS3的属性制作出来的导航，如果你跟着做的话，在你本地一定能看到一个非常靓丽的导航菜单，这里由于无法链接demo原页面，只好贴上缩略图，让大家有一个初步效果视觉初步的效果如下：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/transform-menu-dome.png" alt=""> (style=undefined)</p>
<p>从效果图上我们可以清楚的看到菜单上我们分别对应的是transform中的Translate、TranslateX、TranslateY、Rotate、Scale、ScaleX、ScaleY、Skew、SkewX、SkewY和Matrix，下面我们就在相应的a:hover加上各自的效果：</p>
<p><strong>1、transform:translate(x,y):</strong></p>
<pre><code>.menuulli.translatea:hover {
    -moz-transform: translate(-10px, -10px);
    -webkit-transform: translate(-10px, -10px);
    -o-transform: translate(-10px, -10px);
    -ms-transform: translate(-10px, -10px);
    transform: translate(-10px, -10px);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-translate-xy.png" alt=""></p>
<p><strong>2、transform:translateX(x)</strong></p>
<pre><code>.menuulli.translate-xa:hover {
    -moz-transform: translateX(-10px);
    -webkit-transform: translateX(-10px);
    -o-transform: translateX(-10px);
    -ms-transform: translateX(-10px);
    transform: translateX(-10px);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-translatex.png" alt=""></p>
<p><strong>3、transform:translateY(y)</strong></p>
<pre><code>.menuulli.translate-ya:hover {
    -moz-transform: translateY(-10px);
    -webkit-transform: translateY(-10px);
    -o-transform: translateY(-10px);
    -ms-transform: translateY(-10px);
    transform: translateY(-10px);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-translatey.png" alt=""></p>
<p><strong>4、transform:rotate(角度值)</strong></p>
<pre><code>.menuulli.rotatea:hover {
    -moz-transform: rotate(45deg);
    -webkit-transform: rotate(45deg);
    -o-transform: rotate(45deg);
    -ms-transform: rotate(45deg);
    transform: rotate(45deg);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-rotate.png" alt=""> </p>
<p><strong>5、transform:scale(x,y)</strong></p>
<pre><code>.menuulli.scalea:hover {
    -moz-transform: scale(0.8, 0.8);
    -webkit-transform: scale(0.8, 0.8);
    -o-transform: scale(0.8, 0.8);
    -ms-transform: scale(0.8, 0.8);
    transform: scale(0.8, 0.8);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-scalexy.png" alt=""> (style=undefined)</p>
<p><strong>6、transform:scaleX(x)</strong></p>
<pre><code>.menuulli.scale-xa:hover {
    -moz-transform: scaleX(0.8);
    -webkit-transform: scaleX(0.8);
    -o-transform: scaleX(0.8);
    -ms-transform: scaleX(0.8);
    transform: scaleX(0.8);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-scalex.png" alt=""></p>
<p><strong>7、transform:scaleY(y)</strong></p>
<pre><code>.menuulli.scale-ya:hover {
    -moz-transform: scaleY(1.2);
    -webkit-transform: scaleY(1.2);
    -o-transform: scaleY(1.2);
    -ms-transform: scaleY(1.2);
    transform: scaleY(1.2);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-scaley.png" alt=""></p>
<p><strong>8、transform:skew(x,y)</strong></p>
<pre><code>.menuulli.skewa:hover {
    -moz-transform: skew(45deg, 15deg);
    -webkit-transform: skew(45deg, 15deg);
    -o-transform: skew(45deg, 15deg);
    -ms-transform: skew(45deg, 15deg);
    transform: skew(45deg, 15deg);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-skewxy.png" alt=""> </p>
<p><strong>9、transform:skewX(x)</strong></p>
<pre><code>.menuulli.skew-xa:hover {
    -moz-transform: skewX(-30deg);
    -webkit-transform: skewX(-30deg);
    -o-transform: skewX(-30deg);
    -ms-transform: skewX(-30deg);
    transform: skewX(-30deg);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-skewx.png" alt=""> </p>
<p><strong>10、transform:skewY(y)</strong></p>
<pre><code>.menuulli.skew-ya:hover {
    -moz-transform: skewY(30deg);
    -webkit-transform: skewY(30deg);
    -o-transform: skewY(30deg);
    -ms-transform: skewY(30deg);
    transform: skewY(30deg);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-skewy.png" alt=""></p>
<p><strong>11、transform:matrix(a,b,c,d,e,f)</strong></p>
<pre><code>.menuulli.matrixa:hover {
    -moz-transform: matrix(1, 1, -1, 0, 0, 0);
    -webkit-transform: matrix(1, 1, -1, 0, 0, 0);
    -o-transform: matrix(1, 1, -1, 0, 0, 0);
    -ms-transform: matrix(1, 1, -1, 0, 0, 0);
    transform: matrix(1, 1, -1, 0, 0, 0);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-matrix.png" alt=""> </p>
<p>transform中的matrix是相对的复杂，如果感兴趣的朋友可以点<a href="http://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined" target="_blank" rel="external">这里</a> 进去学民更多有关于Matrix的用法，我在这里就不多说了，说了也讲不清楚。</p>
<p>下面我们来看看最终的效果图，如果你在本地跟着这个实例做了的话，那么你就能看到非常好的效果了。</p>
<p><img src="http://www.w3cplus.com/sites/default/files/transform-demo-hover.png" alt=""> </p>
<p>上面的实例效果展示了有关于transform中各种风格效果，这里需要提醒大家，我们上面的效果都是以元素自身的中心点为基点的，下面我们来看一个改变元素基点的实例</p>
<p>我们在前面的实例基础改变一下所有a标签基点位置为left top（前面默认是center center）</p>
<pre><code>.menuulli.transform-origina {
    -moz-transform-origin: left top;
    -webkit-transform-origin: left top;
    -o-transform-origin: left top;
    -ms-transform-origin: left top;
    transform-origin: left top;
}
</code></pre><p>大家一起看看改变了a标签基点后transform下各种效果有什么样的变化：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-origin-demo-hover.png" alt=""> </p>
<p>从效果图中大家可以明显的看出，改变元素的基点后。元素进行transform任何属性值的设置都会有影响，换句话说，我们transform进行任何动作变化都是以元素的中心为基点，同时我们可以通过transform-origin来改变任何元素的基点，从而达到不同的效果。感兴趣的朋友可以去了解更多有关这方面的知识。</p>
<p>最后我们再来看一个transform运用多个属性值的效果实例</p>
<pre><code>.demoa {
    width: 100px;
    padding: 5px;
    background: red;
    display: block;
}

.demoa:hover {
    -moz-transform: rotate(45deg)scale(0.8, 1.2)skew(60deg, -30deg);
    -webkit-transform: rotate(45deg)scale(0.8, 1.2)skew(60deg, -30deg);
    -o-transform: rotate(45deg)scale(0.8, 1.2)skew(60deg, -30deg);
    -ms-transform: rotate(45deg)scale(0.8, 1.2)skew(60deg, -30deg);
    transform: rotate(45deg)scale(0.8, 1.2)skew(60deg, -30deg);
}
</code></pre><p>这里需要注意的是使用多个属性值时，其之间不能用逗号（“，”）分隔，必须使用空格分隔，记住了是空格分隔，如上面代码所示。</p>
<p>那么到这有关于CSS3的transform就介绍完了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> css3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack简易配置入门]]></title>
      <url>/webpack%E7%AE%80%E6%98%93%E9%85%8D%E7%BD%AE%E5%85%A5%E9%97%A8.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>WebPack 可以看做是模块打包机：它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript 等），并将其转换和打包为合适的格式供浏览器使用</p>
<h2 id="webpack-简易配置入门教程"><a href="#webpack-简易配置入门教程" class="headerlink" title="webpack 简易配置入门教程"></a>webpack 简易配置入门教程</h2><p><img src="https://img.funteas.com/e54cfd22c67adc465dff62272b905fc7?imageView2/2/w/800" alt=""></p>
<p><code>webpack</code>是现在一款非常流行的<strong>模块化管理工具🔧</strong>，<strong><code>react+webpack+es6</code></strong>是很火的项目构建组合</p>
<blockquote>
<p><code>webpack</code>会将有依赖关系的文件都视为一个模块，比如<code>scss</code>,<code>sass</code>,<code>less</code>,<code>css</code>结尾的文件，这样会产生一个模块群，<code>webpack</code>处理过后会产生可以被浏览器识别的一些文件，比如<code>Js</code>,<code>css</code>,<code>html</code>等。</p>
<p><a href="https://webpack.github.io/" target="_blank" rel="external">Webpack</a>在面对大型工程项目时，非常有优势，它最大的特点是很轻，不会加载打包冗余的文件，只会打包项目中用的到的模块。这是<code>webpack</code>的<strong>代码分割</strong>特性～</p>
<p><code>webpack</code>的<strong>模块热更新</strong>特性：当项目文件发生变化时，不需要开发人员手动刷新浏览器，<code>webpack</code>会自动刷新页面，极大地提高了开发效率，是不是很神奇！</p>
</blockquote>
<p><strong>注意：本文的webpack环境是<code>3.5.5</code>由于webpack的更新很快，每次更新都会更新新的语法，所以学习webpack的本质就可以</strong>，具体语法可以看webpack官网：<strong><a href="https://webpack.github.io/" target="_blank" rel="external">https://webpack.github.io/</a></strong></p>
<p>那么让我们快速以一个webpack demo的形式开始我们的webpack的学习吧～</p>
<h3 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h3><p>在前端的项目开发中，总有大量的页面和样式需要处理，而维护这些文件也成了头疼的问题。</p>
<p>为了简化开发，于是就有很多好的开发方式，如：</p>
<ul>
<li><p>模块化开发。每个功能模块都分开成一个个独立的组件，需要的时候再引入。</p>
</li>
<li><p>scss等预处理器。</p>
</li>
<li><p>使用pug, jade 更快编写HTML。</p>
</li>
<li><p>…</p>
</li>
</ul>
<p>这些方式确实可以大大提高开发效率，但是每种方式都有自己的打包方式，还有兼容性处理，如果纯手动处理，必然会增加工作量。</p>
<p>但是，现在有了webpack，上述问题基本解决了，一个webpack就可以处理各种繁琐的过程，给你一个清爽，快速的开发环境。</p>
<blockquote>
<p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。</p>
</blockquote>
<p>简单的来说，在项目开发中，</p>
<ul>
<li><p>你可以使用js，es6/7，甚至ts开发。</p>
</li>
<li><p>es6/es7, .ts =&gt; .js</p>
</li>
<li><p>使用stylus, scss, less 等预处理器编写css</p>
</li>
<li><p>.scss/.less =&gt; .css</p>
</li>
</ul>
<p>webpack可以将你项目中的所有文件，处理成浏览器能识别的文件。</p>
<h3 id="开始使用webpack"><a href="#开始使用webpack" class="headerlink" title="开始使用webpack"></a>开始使用webpack</h3><p>先新建一个练手用的空文件夹 <code>$ mkdir webpack-demo</code> ，并进入该文件夹。</p>
<ol>
<li>新建 <code>package.json</code>.</li>
</ol>
<pre><code>$ npm init
</code></pre><ol>
<li>安装webpack及其基本插件。</li>
</ol>
<pre><code>$ npm i -D webpack extract-text-webpack-plugin html-webpack-plugin css-loader file-loader style-loader url-loader
</code></pre><p>其中：</p>
<ol>
<li>配置webpack。</li>
</ol>
<p>新建一个配置文件： <code>$ touch webpack.config.js</code></p>
<pre><code>var webpack = require(&#39;webpack&#39;);
var path = require(&#39;path&#39;);
varExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);
var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
var webpackConfig = { // 设置入口文件。
    entry: &#39;./src/js/index.js&#39;,
    output: { // 设置输出文件夹
        path: path.join(__dirname, &#39;dist&#39;), // 设置公用文件夹路径
        publicPath: &#39;/&#39;, // 设置输出的js文件的名字规则。// [name] 为chunk中的名称// [hash] 为webpack生成的哈希值
        filename: &quot;js/[name].[hash].bundle.js&quot;
    },
    module: {
        rules: [{ // 处理css文件
            test: /\.css$/,
            loader: &quot;style-loader!css-loader&quot;
        }, { // 处理html文件，并处理img 中 src 和 data-src 的引入路径
            test: /\.html$/,
            loader: &quot;html-loader?attrs=img:src img:data-src&quot;
        }, { // 处理字体文件
            test: /\.(woff|woff2|ttf|eot|svg)(\?v=[0-9]\.[0-9]\.[0-9])?$/,
            loader: &#39;file-loader?name=./fonts/[name].[ext]&#39;
        }, { // 处理图片，并将8k以下的图片转为base64编码
            test: /\.(png|jpg|gif)$/,
            loader: &#39;url-loader?limit=8192&amp;name=./img/[hash].[ext]&#39;
        }]
    },
    plugins: [ // 公共js提取
        new webpack.optimize.CommonsChunkPlugin({
            name: &#39;vendors&#39;, // 将公共模块提取，生成名为`vendors`的chunk 
            minChunks: 3 // 提取至少3个模块共有的部分
        }),
        // 提取公共css样式
        newExtractTextPlugin(&#39;./css/[name].css&#39;),
        // 处理html文件。
        newHtmlWebpackPlugin({
            filename: &#39;./view/index.html&#39;, //生成的html存放路径，相对于path
            template: &#39;./src/view/index.html&#39;, //html模板路径
            inject: &#39;body&#39;, //js插入的位置，true/&#39;head&#39;/&#39;body&#39;/false
            hash: true, //为静态资源生成hash值// 
            chunks: [&#39;vendors&#39;, allDirs[i] + &#39;/&#39; + matches[1]], //需要引入的chunk，不配置就会引入所有页面的资源
            minify: { //压缩HTML文件
                removeComments: true, //移除HTML中的注释
                collapseWhitespace: false //删除空白符与换行符
            }
        })
    ], // 设置开发服务器
    devServer: {
        contentBase: path.join(__dirname, &quot;dist/&quot;),
        host: &#39;localhost&#39;,
        port: 9090,
        inline: true
    }
}
module.exports = webpackConfig
</code></pre><ol>
<li>测试配置文件：<br>先设置开发文件夹目录：</li>
</ol>
<ul>
<li>webpack-demo<ul>
<li>node_modules</li>
</ul>
<ul>
<li>src<ul>
<li>js      // 存放js文件</li>
<li>css     // 存放css样式</li>
<li>view    // 存放模板文件</li>
</ul>
<ul>
<li>webpack.config.js</li>
<li>package.json</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>新建一个 html 文件：<br><code>$ touch ./src/view/index.html</code>。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

    &lt;head&gt;
        &lt;metacharset=&quot;UTF-8&quot;&gt;
            &lt;metaname=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
                &lt;metahttp-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
                    &lt;title&gt;Hello World&lt;/title&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;h2&gt;Hello World&lt;/h2&gt;
        &lt;p&gt;This is from webpack-demo&lt;/p&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p>新建css文件： <code>$ touch ./src/css/index.css</code>。</p>
<pre><code>h2 {
    color: red;
    opacity: 0.5;
    transform: rotateZ(-10 deg);
}
p {
    color: green;
}
</code></pre><p>新建js文件： <code>$ touch ./src/js/index.js</code>。</p>
<pre><code>// 引入css文件。
require(&#39;../css/index.css&#39;)

console.log(&#39;hello world&#39;);
</code></pre><p>测试打包： <code>$ webpack</code><br>OK!基本的配置就完成了。<br><img src="https://img.funteas.com/cdd0c8a3c4779a076a4af3de8a38cc86?imageView2/2/w/800" alt=""></p>
<p>我们可以看到，在项目中多了一个dist文件夹，里面存放的就是刚刚打包好的文件。打开index.html（需要在服务器中打开，并且服务器根目录为dist）可以看到，生成的html文件，征程显示我们写的内容，css样式则直接写入了style标签当中，而且自动引入了两个js文件，其中，vendors是带有公共部分的js文件，index则是我们一开始写的js逻辑文件。<br><img src="https://img.funteas.com/6b1a1edb6f9d049014899131b37a02b8?imageView2/2/w/800" alt=""></p>
<h3 id="处理scss文件。"><a href="#处理scss文件。" class="headerlink" title="处理scss文件。"></a>处理scss文件。</h3><p>既然都用到了webpack自动打包了，那也顺便使用webpack去处理scss文件（个人爱好是scss，less的处理同理），顺便也处理完css中的其他兼容性问题和浏览器前缀问题吧（程序员的思维就是，懒）。</p>
<p>现在css中需要处理的有：</p>
<ol>
<li><p>浏览器前缀和大部分兼容性问题： <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fpostcss%2Fautoprefixer" target="_blank" rel="external">autoprefixer</a> </p>
</li>
<li><p>flex 的兼容性问题： <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2F7rulnik%2Fpostcss-flexibility" target="_blank" rel="external">postcss-flexibility</a> </p>
</li>
<li><p>opacity 兼容IE： <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fiamvdo%2Fpostcss-opacity" target="_blank" rel="external">postcss-opacity</a> </p>
</li>
<li><p>颜色兼容性问题： <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fpostcss%2Fpostcss-color-rgba-fallback" target="_blank" rel="external">postcss-color-rgba-fallback</a> </p>
</li>
<li><p>scss文件处理： <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fsass-loader" target="_blank" rel="external">sass-loader</a>  同时需要依赖 <code>node-sass</code></p>
</li>
<li><p>压缩css文件： <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fben-eb%2Fcssnano" target="_blank" rel="external">cssnano</a> </p>
</li>
</ol>
<p>安装上书postcss-loader的插件： <code>$ npm i -D autoprefixer postcss-flexibility postcss-opacity postcss-color-rgba-fallback sass-loader node-sass</code></p>
<p>现在在webpack中处理css的问题，基本都是通过一个 <code>postcss-loader</code> 去完成所有的处理问题。</p>
<p>先新建一个文件夹，用于存放所有的scss文件： <code>$ mkdir ./src/scss</code></p>
<p>再新建一个index.scss, <code>$ touch ./src/scss/index.scss</code></p>
<pre><code>body {
    background: black;
    color: white;
    h2 {
        transform: translateX(10 px) rotateZ(-10 deg);
        color: red;
        opacity: 0.5;
    }
}
</code></pre><p>将postcss的加载器中需要的单独提取出来放在一个配置文件中： <code>$ touch postcss.config.js</code></p>
<pre><code>module.exports = {
    plugins: [ // minify css
        require(&#39;cssnano&#39;)({
            preset: &#39;default&#39;
        }), // 处理css前缀
        require(&#39;autoprefixer&#39;)({
            browserslist: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;Edge&quot;, &quot;ie &gt;= 9&quot;]
        }), // 处理flex浏览器兼容性
        require(&#39;postcss-flexibility&#39;), // 处理css中rgba颜色代码
        require(&#39;postcss-color-rgba-fallback&#39;), // 处理css中opacity的IE兼容性。
        require(&#39;postcss-opacity&#39;)
    ]
}
</code></pre><p>修改 webpack.config.js:</p>
<pre><code>var webpackConfig = { ...module: {
        rules: [{ // 处理css文件
            test: /\.(scss|sass|css)$/, // 
            loader: &quot;css-loader?importLoaders=1!postcss-loader!sass-loader&quot;, // loader执行顺序是从右到左：sass-loader -&gt; postcss-loader -&gt; css-loader
            use: [&quot;style-loader&quot;, {
                loader: &quot;css-loader&quot;,
                options: { // // 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader
                    importLoaders: 2
                }
            }, &#39;postcss-loader&#39;, &#39;sass-loader&#39;]
        }, ...]
    }...
}
module.exports = webpackConfig
</code></pre><p>修改一下入口文件中的样式引入： <code>$ vim ./src/js/index.js</code></p>
<pre><code>require(&#39;../scss/index.scss&#39;)

console.log(&#39;hello world&#39;);
</code></pre><p>打包测试：<br><img src="https://img.funteas.com/7161926ef76bbc56cd95b4e8fa3b3043?imageView2/2/w/800" alt=""><img src="https://img.funteas.com/b2ef241cadd633d504099ebfffbe9c57?imageView2/2/w/800" alt=""></p>
<p>完美通过。</p>
<h3 id="处理pug-jade文件"><a href="#处理pug-jade文件" class="headerlink" title="处理pug/jade文件"></a>处理pug/jade文件</h3><p>项目有很多的页面，而且页面之间也有很多相同的页面，之前写惯了vue的组件，所以注册我们也引入了pug作为前端模板引擎。 pug 的前身就是 jade ，所以语法什么都得基本都是一致的。具体的看 <a href="http://link.funteas.com/?target=https%3A%2F%2Fpugjs.org%2Fapi%2Fgetting-started.html" target="_blank" rel="external">官网</a>  。</p>
<p>和处理css的一样，先要安装加载器。<br><code>$ npm i -D pug pug-loader</code></p>
<p>新建一个简单的页面：<br><code>$ touch ./src/view/index.pug</code></p>
<pre><code>html
    title   Test.html
body
    h2  Welcome to pug.
    p   Thisisfrom index.pug
</code></pre><p>修改一下配置文件中的html模板入口：</p>
<pre><code>var webpackConfig = { ...
    plugins: [ // 公共js提取
        new webpack.optimize.CommonsChunkPlugin({
            name: &#39;vendors&#39;, // 将公共模块提取，生成名为`vendors`的chunk
        }), // 提取公共css样式
        newExtractTextPlugin(&#39;./css/[name].css&#39;), // 处理html文件。
        newHtmlWebpackPlugin({
            filename: &#39;./view/index.html&#39;, //生成的html存放路径，相对于pathtemplate:&#39;./src/view/index.pug&#39;,//html模板路径
            inject: &#39;body&#39;, //js插入的位置，true/&#39;head&#39;/&#39;body&#39;/false
            hash: true, //为静态资源生成hash值
            chunks: [&#39;vendors&#39;, &#39;index&#39;], //需要引入的chunk，不配置就会引入所有页面的资源
            minify: { //压缩HTML文件
                removeComments: true, //移除HTML中的注释
                collapseWhitespace: false //删除空白符与换行符
            }
        })
    ],
    ...
}
module.exports = webpackConfig
</code></pre><p>重新编译打包：<br><img src="https://img.funteas.com/f50d2630c41fc3722fb1e8c594b17df8?imageView2/2/w/800" alt=""><img src="https://img.funteas.com/b9a66e946d63f63b8afe51355f848299?imageView2/2/w/800" alt=""></p>
<h3 id="使用-babel-来“编译”你的js"><a href="#使用-babel-来“编译”你的js" class="headerlink" title="使用 babel 来“编译”你的js"></a>使用 babel 来“编译”你的js</h3><p>在项目开发中，难免会遇到使用 es6 ，甚至 es7 去编写js。但是大部分浏览器却不支持这些语法，这时候，就需要 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel-loader" target="_blank" rel="external">babel-loader</a>  来处理js，并将其转换为浏览器能识别的 es5 语法。</p>
<p>还是要安装依赖： <code>$ npm i -D babel-loader babel-core babel-preset-es2015</code></p>
<p>如果用上了es7 的语法，就要根据不同阶段语法提案的转码规则（共有4个阶段），选装一个：</p>
<pre><code>$ npm i -D babel-preset-stage-0
$ npm i -D babel-preset-stage-1
$ npm i -D babel-preset-stage-2
$ npm i -D babel-preset-stage-3
</code></pre><p>新建一个 <code>.babelrc</code> babel配置文件： <code>$ touch .babelrc</code></p>
<pre><code>{&quot;presets&quot;:[&quot;es2015&quot;],&quot;plugins&quot;:[]}
</code></pre><p>修改 webpack 配置文件：</p>
<pre><code>var webpackConfig = { ...module: {
        rules: [{
            test: /\.js$/, // 不编译 node_modules 下的文件
            exclude: /node_modules/,
            loader: &quot;babel-loader&quot;
        }]
    }...
}
module.exports = webpackConfig
</code></pre><p>在 index.js 中写个 es6 的语法：</p>
<pre><code>require(&#39;../scss/index.scss&#39;)

console.log(&#39;hello world&#39;);
((message) =&gt; {
    console.log(message);
})(&#39;message from es6&#39;)

let step = 2;
var add = number =&gt; number *= step

console.log(add(2));
</code></pre><p>来，打包看看：<br><img src="https://img.funteas.com/17f943bb3337dc33beee2c13805be376?imageView2/2/w/800" alt=""><img src="https://img.funteas.com/dcdad593279f1b2192a9f4ba9d5f28ff?imageView2/2/w/800" alt=""><br>完美。</p>
<h3 id="配置多文件入口"><a href="#配置多文件入口" class="headerlink" title="配置多文件入口"></a>配置多文件入口</h3><p>项目有多个页面，每个页面都对应着一个js入口和一个页面，但是，入口 entry 和 html-webpack-plugin 每次只能配置一个具体的入口文件，如果每增加一个页面就要去配置，那么这无形之中增加了工作量，因此，我们需要一个通用的入口文件。</p>
<p>既然在node中可以访问文件夹并读取其中的文件名，那么我们可以使用node来去循环读取文件夹下的js文件，并自动添加至入口配置中：</p>
<p>新建一个config 文件夹，以存放webpack可变的配置，方便以后修改： <code>$ mkdir config</code></p>
<p>因为遍历入口文件都是一样的操作流程，所以先写一个工具包：<code>$ touch config/utils.js</code></p>
<pre><code>var fs = require(&#39;fs&#39;); // 递归遍历文件夹，获取入口文件
function getAllFiles(dirRoot, type) {
    var filterReg = newRegExp(&#39;.&#39; + type + &#39;/div&gt;&#39;);
        function getAllFileFromDir(root) {
            var res = [],
                files = fs.readdirSync(root)
            files.forEach((file) =&gt; {
                var pathname = root + &#39;/&#39; + file,
                    state = fs.lstatSync(pathname)
                if (!state.isDirectory()) {
                    // 过滤相对应的文件
                    filterReg.test(pathname) &amp;&amp; res.push(pathname)
                    // res.push(pathname.replace(dir_root+&#39;/&#39;, &#39;&#39;))
                } else {
                    res = res.concat(getAllFileFromDir(pathname))
                }
            })
            return res
        }
        return getAllFileFromDir(dirRoot)
    }

    function getEntry(files, replaces) {
        var entry = {}
        for (var i = 0; i &lt; files.length; i++) {
            var filename = files[i]
            replaces.map((replace) =&gt; {
                filename = filename.replace(replace, &#39;&#39;)
            })
            entry[filename] = files[i]
        }
        return entry
    }

    module.exports = {
        getAllFiles,
        getEntry
    }
</code></pre><p>再新建一个 js 入口文件配置：<br><code>$ touch config/webpack.entry.js</code></p>
<pre><code>var path = require(&#39;path&#39;);
var utils = require(&#39;./utils.js&#39;) var dir_root = path.resolve(__dirname, &#39;../src/js&#39;); 
// console.log(getAllFiles(dir_root));
var allFiles = utils.getAllFiles(dir_root, &#39;js&#39;) var entry = utils.getEntry(allFiles, [&#39;js&#39;, dir_root + &#39;/&#39;])
console.log(entry);
module.exports = entry
</code></pre><p>同样的，页面入口文件也添加一个：<br> <code>$ touch config/webpack.plugins.js</code></p>
<pre><code>var webpack = require(&#39;webpack&#39;) var path = require(&#39;path&#39;);
var utils = require(&#39;./utils.js&#39;) varExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);
var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
var entry = require(&#39;./webpack.entry.js&#39;);
var plugins = [ // 公共js提取
    new webpack.optimize.CommonsChunkPlugin({
        name: &#39;vendors&#39;, // 将公共模块提取，生成名为`vendors`的chunk
        minChunks: 3 // 提取至少3个模块共有的部分
    }), // 提取公共css样式
    newExtractTextPlugin(&#39;./css/[name].css&#39;),
]
let dir_root = path.resolve(__dirname, &#39;../src/view&#39;);
var pugFiles = utils.getAllFiles(dir_root, &#39;pug&#39;)

pugFiles = utils.getEntry(pugFiles, [&#39;.pug&#39;, dir_root + &#39;/&#39;]) for (var key in pugFiles) {
    if (pugFiles.hasOwnProperty(key)) {
        let opt = {
            filename: &#39;./view/&#39; + key + &#39;.html&#39;,
            template: pugFiles[key],
            hash: true,
            minify: { //压缩HTML文件
                removeComments: true, //移除HTML中的注释
                collapseWhitespace: false //删除空白符与换行符
            }
        }
        if (entry.hasOwnProperty(key)) {
            opt[&#39;chunks&#39;] = [&#39;vendors&#39;, key]
            opt[&#39;inject&#39;] = &#39;body&#39;
        }
        console.log(opt);
        plugins.push(newHtmlWebpackPlugin(opt))
    }
}
module.exports = plugins
</code></pre><p>再次修改webpack的配置：</p>
<pre><code>var entry = require(&#39;./config/webpack.entry.js&#39;) var plugins = require(&#39;./config/webpack.plugins.js&#39;) var webpackConfig = {
    entry,
    plugins,
    ...
}
module.exports = webpackConfig
</code></pre><p><img src="https://img.funteas.com/281e607088b144d2c458949393222b8c?imageView2/2/w/800" alt=""><img src="https://img.funteas.com/40af51e0f7c22c574ec37d04126dec94?imageView2/2/w/800" alt=""><br>可以看到，dist文件夹下，多了几个html文件和js文件。</p>
<h3 id="其他处理"><a href="#其他处理" class="headerlink" title="其他处理"></a>其他处理</h3><ul>
<li>提取css到外部link，而非style标签<br>这个解决办法比较简单，只需要用 <code>extract-text-webpack-plugin</code> 插件将css提取出来即可：</li>
</ul>
<pre><code>{
    test: /\.(scss|sass|css)$/,
    use: ExtractTextPlugin.extract(
    {
        fallback: &quot;style-loader&quot;,
        use: [
        {
            loader: &quot;css-loader&quot;,
            options:
            { // // 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader
                importLoaders: 2
            }
        }, &#39;postcss-loader&#39;, &#39;sass-loader&#39;]
    })
}
</code></pre><p>再次打包的结果：<br><img src="https://img.funteas.com/c0d501d1dba2745f1a88a74039e29176?imageView2/2/w/800" alt=""></p>
<p>列出dis文件夹的目录树可以发现，多了一个css的文件夹。打开页面可以发现，页面中的style标签已经被link替代了。<br><img src="https://img.funteas.com/9b3e582b1d7799c98891be7786f8b751?imageView2/2/w/800" alt=""><img src="https://img.funteas.com/e9c1a1d5a71d0175912b4ad5b53bcd0a?imageView2/2/w/800" alt=""></p>
<ul>
<li>每次打包旧的文件依旧存在<br>每次执行webpack打包（当然在实际开发中应该使用热更新服务器，不需要频繁打包）都会产生一堆新的js文件。</li>
</ul>
<p>解决办法：</p>
<p>一是将打包的js文件的hash值去掉，这样就会新的打包js文件，将旧的覆盖。</p>
<p>二是使用 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fjohnagan%2Fclean-webpack-plugin" target="_blank" rel="external">clean-webpack-plugin</a> </p>
<pre><code>var CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;);
var plugins = [ // 每次打包前都清空dist文件
    newCleanWebpackPlugin([&#39;dist&#39;], {
        root: path.resolve(__dirname, &#39;../&#39;)
    }), // 公共js提取
    new webpack.optimize.CommonsChunkPlugin({
        name: &#39;vendors&#39;,
        // 将公共模块提取，生成名为`vendors`的chunk//
        minChunks: 3 // 提取至少3个模块共有的部分
    }), // 提取公共css样式
    newExtractTextPlugin(&#39;./css/[name].css&#39;),
]
</code></pre><ul>
<li>批量新建文件<br>因为每个页面基本都有3个文件：<code>page.pug</code>, <code>page.js</code>, <code>page.scss</code>，如果每次新加一个页面都要手动新建3个文件的话，效率太低下，能用命令行解决的，当然要用命令行解决啦。</li>
</ul>
<p>先写个小脚本 <code>newpage.sh</code>:</p>
<pre><code>#!/bin/shif[[ $1 ]];then
    filename=$1
    touch ./src/js/$filename.js
    touch ./src/view/$filename.pug
    touch ./src/scss/$filename.scss
fi
</code></pre><p>使用方式就是： <code>$ ./newpage.sh filename</code>，要运行该脚本，就需要先将脚本设置为可执行： <code>$ sudo chmod +x ./newpage.sh</code>。</p>
<p>还可以将它写进 npm 的 <code>package.json</code> 的命令中，则命令可以变为：<code>npm run new -- filename</code></p>
<pre><code>{&quot;script&quot;:{&quot;new&quot;:&quot;./newpage.sh&quot;}}
</code></pre><ul>
<li>定义路径常量<br>在编写js时，因为有可能js文件是在很多级的目录当中，如果每次都使用 <code>..</code> 来定位上一层目录的话，那么这个定位就会十分繁琐。这时可以使用 webpack 提供的 <a href="http://link.funteas.com/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fresolve%2F%23resolve-alias" target="_blank" rel="external">resolve.alias</a>  配置来使引入文件的时候变得更加方便简单。</li>
</ul>
<pre><code>resolve: {
    alias: {
        scss: path.resolve(__dirname, &#39;src/scss&#39;),
        js: path.resolve(__dirname, &#39;src/js&#39;),
        view: path.resolve(__dirname, &#39;src/view&#39;),
        assets: path.resolve(__dirname, &#39;src/assets&#39;)
    }
}
</code></pre><p>这样，在 <code>other.js</code> 中，就可以直接使用 <code>require(&#39;scss/about.scss&#39;)</code> 而不需要写繁琐的 <code>require(&#39;../../scss/about.scss&#39;)</code>。这样就方便多了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>看完这篇文章相信你对<code>webpack</code>的配置已经基本了解了，接下来如果你想了解<code>webpack</code>的更多基础知识，请看我的这篇<a href="http://pancakeawesome.ink/%E5%85%A5%E9%97%A8Webpack%EF%BC%8C%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.html">文章</a>，并且想实践中使用<code>webpack</code>，请看我的这篇<a href="http://pancakeawesome.ink/react%E5%AE%9E%E6%88%98-%E6%89%93%E9%80%A0%E7%94%BB%E5%BB%8A%E9%A1%B9%E7%9B%AE.html">文章</a></p>
]]></content>
      
        <categories>
            
            <category> 前端工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端工具 </tag>
            
            <tag> webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[react实战--打造画廊项目（二）]]></title>
      <url>/react%E5%AE%9E%E6%88%98-%E6%89%93%E9%80%A0%E7%94%BB%E5%BB%8A%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇博客中，我们把画廊应用的静态框架搭建好了，现在我们为舞台添加动态旋转和移动的效果。</p>
<h2 id="构建动态图片组件"><a href="#构建动态图片组件" class="headerlink" title="构建动态图片组件"></a>构建动态图片组件</h2><p>继续控制单个图片组件<code>ImgFigure</code>，为它加上动态效果。</p>
<h3 id="图片旋转"><a href="#图片旋转" class="headerlink" title="图片旋转"></a>图片旋转</h3><p>给图片加上旋转角度的效果样式。</p>
<ul>
<li>首先给存储所有图片样式信息的全局变量<code>imageDatasArr</code>加上<code>rotate</code>属性，用来存储每张图片的旋转信息。<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fl1qdd8kd2j30w50afaac.jpg" alt=""></li>
<li>添加<code>get30DegRandom</code>方法用来随机图片旋转的角度：<pre><code>function get30DegRandom() {
  return (Math.random() &gt; 0.5 ? &#39;&#39; : &#39;-&#39;) + Math.ceil(Math.random() * 30);
}
</code></pre><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fl1qhwj5r9j30ox08xmxf.jpg" alt=""></li>
<li>给每张图片设置随机过后旋转角度样式：<pre><code>// 如果图片的旋转角度有值且不为0则添加旋转角度
      if (this.props.arrange.rotate) {
          // 兼容低版本浏览器
          [&#39;MozTransform&#39;, &#39;msTransform&#39;, &#39;WebkitTransform&#39;, &#39;transform&#39;].forEach(function(value) {
            styleObj[value] = &#39;rotate(&#39; + this.props.arrange.rotate + &#39;deg)&#39;;
          }.bind(this));
      }
</code></pre><strong>注意：<code>transform: rotate(旋转角度deg)</code>可以旋转标签的角度。</strong><br><strong>添加浏览器前缀可以实现低版本浏览器样式兼容的效果。</strong></li>
</ul>
<h3 id="旋转控制"><a href="#旋转控制" class="headerlink" title="旋转控制"></a>旋转控制</h3><p>给图片加上点击图片，反转的效果。</p>
<ul>
<li>为<code>imgsArrangeArr</code>添加表示图片翻转信息的属性<code>isInvers</code>,<code>false</code>表示图片没有翻转。</li>
<li>添加翻转的样式。</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fl2u0yjtf3j30m906mwei.jpg" alt="给`ImgFigure`添加翻转样式"></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl2u209tkfj30w405ct91.jpg" alt="给图片背面添加样式"></p>
<blockquote>
<p><code>&amp;.className</code>:是<code>sass</code>的语法，意思是给父元素添加一个<code>class</code><br><code>transform</code>属性是Css3的新特性，它能够实现一些动态效果，比如rotate（旋转）、scale（缩放）、translate（平移）等。</p>
</blockquote>
<p><strong>具体<code>transform</code>属性如何使用呢？请看我的这篇文章<a href="http://pancakeawesome.ink/CSS3-transform%E7%89%B9%E6%80%A7%E6%95%99%E7%A8%8B.html">CSS3-transform特性教程</a></strong></p>
<ul>
<li>添加点击图片的处理函数<br>我们在<code>AppComponent</code>组件中添加<code>inverse</code>函数,用来将选定的图片在图片数组中对应的图片信息中的表示图片翻转的属性<code>isInverse</code>改为相应样式。</li>
</ul>
<pre><code>/**
     * 翻转图片
     * @param {int} index 输入当前被执行inverse操作的图片对应的图片信息数组的index值
     * @return {Function} 这是一个闭包函数，其内return一个真正待被执行的函数
     */
    inverse(index) {
        return function() {
            let imgsArrangeArr = this.state.imgsArrangeArr;
            imgsArrangeArr[index].isInverse = !imgsArrangeArr[index].isInverse;

            this.setState({
                imgsArrangeArr: imgsArrangeArr
            });
        }.bind(this);
    }
</code></pre><blockquote>
<p><strong>重要：为什么使用闭包函数</strong>，因为调用这个函数所在的作用域(<code>ImgFigure</code>)中没有权限去调用<code>AppComponent</code>里的<code>index</code>变量，这个变量是<code>AppComponent</code>初始化<code>render</code>的时候就固定好的，如果想要调用<code>index</code>这个变量而不是当前<code>ImgFigure</code>组件中的<code>index</code><strong>值</strong>，就必须使用闭包函数作为桥梁连接两个函数作用域，这样<code>ImgFigure</code>就可以使用另外一个作用域中的变量。</p>
<ul>
<li>给图片信息数组添加表示图片居中的属性，并在<code>AppComponent</code>组件中添加居中函数，处理图片居中效果。</li>
</ul>
</blockquote>
<pre><code>/**
     * 利用rearrange函数，居中对应index的图片
     * @param {int} index 输入当前被执行inverse操作的图片对应的图片信息数组的index值
     * @return {Function} 这是一个闭包函数，其内return一个真正待被执行的函数
     */
     center(index) {
         return function() {
             this.rearrange(index);
         }.bind(this);
     }
</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fl2usbzpg4j30kn0bs0sv.jpg" alt="`AppComponent`组件中"></p>
<ul>
<li><p>在<code>ImgFigure</code>组件中添加点击处理函数，<code>handleClick</code>。用来处理所有图片的点击事件，加上处理逻辑，实现点击周围图片，将图片居中，点击居中图片，实现图片翻转的效果。</p>
<pre><code>constructor(props) {
    super(props);

    this.handleClick = this.handleClick.bind(this);
    this.center = this.center.bind(this);
  }

  /**
   * imgFigure的点击事件
   */
  handleClick(e) {
      if (this.props.arrange.isCenter) {
          this.props.inverse();
      }else {
          this.props.center();
      }

      e.stopPropagation();
      e.preventDefault();
  }

  // 控制反转样式
  let imgFigureClassName = &#39;img-figure&#39;;
      imgFigureClassName += this.props.arrange.isInverse ? &#39; is-inverse&#39; : &#39;&#39;;
</code></pre></li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fl2upt0b7sj30wm0bj74v.jpg" alt="给`ImgFigure`组件加上事件监听器"></p>
<blockquote>
<p><strong>注意⚠️：</strong><code>React ES6</code>的写法中，组件的函数不是自动绑定<code>this</code>的，需要在<code>constructor</code>中手动给所有的成员方法绑定<code>this</code>。</p>
</blockquote>
<ul>
<li>给居中图片添加<code>z-index</code>样式，使其在页面的最顶层：<pre><code>// 如果图片居中，则给居中图片添加z-index样式，使其在整个页面的最顶层
      if (this.props.arrange.isCenter) {
          styleObj.zIndex = &#39;11&#39;;
      }
</code></pre></li>
</ul>
<h3 id="给图片加上切换动画"><a href="#给图片加上切换动画" class="headerlink" title="给图片加上切换动画"></a>给图片加上切换动画</h3><p>我们可以使用<code>css3</code>相关的<code>transform</code>样式。</p>
<ul>
<li><code>transition</code>:定义了一个元素在两种状态下切换时，显示的过渡动画效果。<br>值：<ul>
<li><code>transform</code>: 表示在发生<code>transform</code>变化时，发生的动画效果。</li>
<li><code>left</code>:表示在<code>left</code>值发生变化的时候发生的动画效果。</li>
<li><code>.6s</code>:动画的时长。</li>
<li><code>easy-in-out</code>:动画的速度曲线。三次的倍塞尔函数。  </li>
</ul>
</li>
<li><p><code>perspective</code>：景深样式，表示perspective-origin，3D观察点与z轴平面的距离，默认是无限大，类似我们平常2D的效果。值越小，我们能感受到的3D效果越深刻。<br><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fl2vorp47uj30hn0brmxy.jpg" alt="3D景深效果"></p>
</li>
<li><p><code>transform-origin</code>:表示<code>transform</code>变化的基点，默认是元素的中心点。这个属性很重要，通过这个属性和<code>translate</code>,<code>rotateY</code>结合，我们可以实现元素翻转的真实效果。</p>
<ul>
<li><code>rotateY(deg)</code>:表示以Y轴为纬轴旋转元素。</li>
<li><code>translate(px)</code>:表示以x轴平移元素。</li>
<li><code>translateZ(px)</code>:表示平移Z轴上的元素。</li>
</ul>
</li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl2wg3wc33j30c80cjwet.jpg" alt=""></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl2w5lpavxj30lr03k746.jpg" alt=""></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fl2w541kobj30j3018jr8.jpg" alt=""></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl2w32yg5ng30m60aywsx.gif" alt=""></p>
<h3 id="控制组件的构建"><a href="#控制组件的构建" class="headerlink" title="控制组件的构建"></a>控制组件的构建</h3><p>现在我们开始构建显示在画廊页面下方的控制条组件。</p>
<ul>
<li><p>创建控制条组件。</p>
<pre><code>// 构建控制组件
class ControllerUnit extends React.Component {
  constructor(props) {
    super(props);

    this.handleClick = this.handleClick.bind(this);
  }

  handleClick(e) {
      e.preventDefault();
      e.stopPropagation();
  }

  render() {
      return (
          &lt;span className=&quot;controller-unit&quot; onClick={this.handleClick}&gt;&lt;/span&gt;    
      );
  }
}
</code></pre></li>
<li>修饰控制组件<br>在css文件中，修饰控制组件在不同状态下的样式。</li>
</ul>
<pre><code>/* controller --- start */
.controller-nav {
  position: absolute;
  left: 0;
  bottom: 30px;
  z-index: 101;

  width: 100%;

  text-align: center;

  @at-root {
    .controller-unit {
      display: inline-block;
      margin: 0 5px;
      width: 30px;
      height: 30px;

      text-align: center;

      cursor: pointer;
      background-color: #aaa;
      border-radius: 50%;

      transform: scale(.5);

      &amp;.is-center {
        background-color: #888;

        transform: scale(1);

        // 使用伪元素添加字体文件
        &amp;::before {
          color: #fff;
          font-family: &quot;icons-turn-arrow&quot;;

            // 指定为元素的内容
          content: &quot;\e900&quot;;
        }
      }
    }
  }
}
/* controller --- end */
</code></pre><ul>
<li>构造按钮居中时的样式：</li>
</ul>
<pre><code>@font-face {
  font-family: &quot;icons-turn-arrow&quot;;
  src: url(&quot;../fonts/icons/turn-arrow.eot&quot;);
  src: url(&quot;../fonts/icons/turn-arrow.eot&quot;) format(&quot;embedded-opentype&quot;),
    url(&quot;../fonts/icons/turn-arrow.woff&quot;) format(&quot;woff&quot;),
    url(&quot;../fonts/icons/turn-arrow.ttf&quot;) format(&quot;truetype&quot;), 
    url(&quot;../fonts/icons/turn-arrow.svg&quot;) format(&quot;svg&quot;);
}
</code></pre><blockquote>
<p>引用字体文件来表示箭头</p>
</blockquote>
<pre><code>// 使用after伪元素添加字体文件
        &amp;::after {
          color: #fff;
          font-family: &quot;icons-turn-arrow&quot;;
          line-height: 30px;

            // 通过文件的unicode码，指定为元素的内容
          content: &quot;\e900&quot;;

          /* 开启chrome字体渲染的灰阶平滑 */
          -webkit-font-smoothing: antialiased;
          /* 开启Firefox在mac上的灰阶平滑 */
          -moz-osx-font-smoothing: grayscale;
        }
</code></pre><blockquote>
<p>css3新规范规定css伪元素修饰需要使用<strong>两个“:”</strong>来修饰，而<code>hover</code>伪类则用一<strong>个”:”</strong>修饰。<br>icon font的体积比图片小；icon font 是矢量图形，拉伸不变形，支持css对字体的样式修饰。<br>不同格式的字体文件是为了兼容不同浏览器对不同字体文件的支持。</p>
<pre><code>- `embedded-opentype`:ie
- `woff`:chrome,firefox
- `truetype`:chrome,firefox,safari,ios,android4.2以及之后的版本。
- `svg`:android4.1以及之前的版本
</code></pre><p>如果字体和背景都是浅色调，使用字体文件来代替图片渲染，会造成边缘呈现锯齿状的不平滑，为了解决这个问题，可以设置字体渲染引擎通过灰阶渲染和亚像素渲染来平滑字体文件的渲染。</p>
</blockquote>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl43x2xxqkj30gh03vjrh.jpg" alt=""></p>
<ul>
<li>构造按钮翻转时的样式：</li>
</ul>
<pre><code>&amp;.is-inverse {
        background-color: #555;

        transform: rotateY(180deg) translateZ(1px);
      }
</code></pre><ul>
<li>给控制按钮加上变化（transform, background-color）时的过渡动画效果：</li>
</ul>
<pre><code>transform: scale(.5);
      transition: transform .6s ease-in-out, background-color .3s;
</code></pre><ul>
<li>关联控制组件和图片组件，给不同状态下的控制组件添加相应的样式</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fl8mtfymcnj30yc0fst9f.jpg" alt="ControllerUnit"></p>
<ul>
<li>给控制组件添加点击事件，实现控制组件和绑定的图片的动画效果</li>
</ul>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fl8mx349tcj30nw0a1aa9.jpg" alt="ControllerUnit"></p>
<h3 id="收尾项目"><a href="#收尾项目" class="headerlink" title="收尾项目"></a>收尾项目</h3><p>到这里，画廊项目基本已经完成，我们可以检查一下项目的展现效果，找到错误的地方，然后逐一debug。</p>
<h4 id="测试代码的兼容性"><a href="#测试代码的兼容性" class="headerlink" title="测试代码的兼容性"></a>测试代码的兼容性</h4><p>首先测试代码在firefox下的兼容性（我在firefox15版本下，测试成功）。</p>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><blockquote>
<p>react渲染页面的核心思想是<code>virtual dom</code>:当react将组件插入到html dom文档树前，react会先将代码中的react组件插入到virtual dom中，然后react会检查virtual dom和html文档树中结构是否有不同的地方，如果发现不同，才会去插入virtual dom中的文档树节点，这样会极大地减少浏览器引擎渲染dom节点的速度。</p>
</blockquote>
<p>所以，我们在将图片组件和控制组件插入到AppComponent组件中时，可以给每个图片组件和控制组件都加上一个唯一表示的key，这样可以帮助react更好地区分每个<code>virtual dom</code>节点，这样比较两个文档树节点时，会消耗更少的时间。</p>
<h3 id="部署代码"><a href="#部署代码" class="headerlink" title="部署代码"></a>部署代码</h3><p>dist目录时项目部署到正是环境下的代码，我们在即将把我们代码部署到线上的时候，可以运行Webpack dist环境，将我们的代码以dist环境的参数运行打包，这样所有的代码都会在dist目录下，然后打开8000端口，在浏览器环境下调试dist环境下的代码。</p>
<p>在<code>package.json</code>配置文件中配置命令，可以在命令行中执行不同的环境的代码。</p>
<ul>
<li>执行本地调试(<code>src</code>目录下的代码)命令：</li>
</ul>
<pre><code>npm start
</code></pre><ul>
<li>执行dist打包，并执行<code>dist</code>环境下的代码：</li>
</ul>
<pre><code>// 将dist目录清空
npm run clean
</code></pre><pre><code>// 将静态资源文件复制到Dist目录下，并执行webpack打包命令（参数是dist环境）
npm run dist
</code></pre><ul>
<li>部署项目到gitpages上：<ul>
<li>在<code>cfg/default.js</code>中更改<code>publicPath</code>为相对路径（因为gitpages下的项目url路径是二级目录）</li>
</ul>
</li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl8qrgnltzj30kk069mx6.jpg" alt=""></p>
<pre><code>- 将`src/index.html`中的`js`引用地址改为相对路径
</code></pre><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;assets/app.js&quot;&gt;&lt;/script&gt;
</code></pre><pre><code>- 将`dist`目录上传到`gitpages`(git提供的html页面部署服务)
</code></pre><pre><code>git subtree push --prefix=dist origin gh-pages
</code></pre><pre><code>- 在浏览器中地址栏中输入`https://&lt;你的github账户名称&gt;.github.io/&lt;你的项目名称&gt;`
</code></pre><p>就可以看到你的画廊应用部署到线上了！激动么～</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl8r55fj7nj30d007xdg0.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> react </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> react </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于ES6语法的React重构]]></title>
      <url>/%E5%9F%BA%E4%BA%8EES6%E8%AF%AD%E6%B3%95%E7%9A%84React%E9%87%8D%E6%9E%84.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ES6</code>语法规范已经日渐被大家所接受，而且在开发过程中，这些新的语法特性，都很方便，一些开源框架和项目都已经使用了最新的<code>ES6</code>语法，比如<code>react</code>，一些老的语法已经逐渐被淘汰，为了跟上时代潮流，我们应该努力接受新的知识。</p>
<h2 id="React-js中常用的ES6写法总结"><a href="#React-js中常用的ES6写法总结" class="headerlink" title="React.js中常用的ES6写法总结"></a><code>React.js</code>中常用的<code>ES6</code>写法总结</h2><h3 id="一-模块"><a href="#一-模块" class="headerlink" title="一 模块"></a>一 模块</h3><h4 id="1-引入模块以便使用"><a href="#1-引入模块以便使用" class="headerlink" title="1 引入模块以便使用"></a>1 引入模块以便使用</h4><p>用import实现：</p>
<pre><code>import &#39;模块文件地址&#39;
import 组件 from &#39;模块文件地址&#39;
</code></pre><h4 id="2-导出模块"><a href="#2-导出模块" class="headerlink" title="2 导出模块"></a>2 导出模块</h4><p>用export default实现：</p>
<pre><code>export defaultclass MyComponent extends Component{
    ...
}
</code></pre><p>引用：</p>
<pre><code>import MyComponent from &#39;./MyComponent&#39;;
</code></pre><h3 id="二-组件"><a href="#二-组件" class="headerlink" title="二 组件"></a>二 组件</h3><h4 id="1-定义组件"><a href="#1-定义组件" class="headerlink" title="1 定义组件"></a>1 定义组件</h4><p>通过定义一个继承自React.Component的class来定义一个组件类：</p>
<pre><code>class Photo extends React.Component {
    render() {
       ...
    }
}
</code></pre><h4 id="2-定义组件方法"><a href="#2-定义组件方法" class="headerlink" title="2 定义组件方法"></a>2 定义组件方法</h4><p>直接用名字(){},很像java定义类方法的写法：</p>
<pre><code>class Photo extends React.Component {
    componentWillMount() {

    }
    render() {
        return (
            &lt;Imagesource={this.props.source} /&gt;
        );
    }
}
</code></pre><h4 id="3-定义组件的属性类型和默认属性"><a href="#3-定义组件的属性类型和默认属性" class="headerlink" title="3 定义组件的属性类型和默认属性"></a>3 定义组件的属性类型和默认属性</h4><p>统一使用static成员来实现：</p>
<pre><code>class Video extends React.Component {
    static defaultProps = {
        autoPlay: false,
        maxLoops: 10,
    };  // 注意这里有分号
    static propTypes = {
        autoPlay: React.PropTypes.bool.isRequired,
        maxLoops: React.PropTypes.number.isRequired,
        posterFrameSrc: React.PropTypes.string.isRequired,
        videoSrc: React.PropTypes.string.isRequired,
    };  // 注意这里有分号
    render() {
        return (
            &lt;View /&gt;
        );
    } // 注意这里既没有分号也没有逗号
}
</code></pre><p><strong>注意: 对React而言，static成员在IE10及之前版本不能被继承，而在IE11和其它浏览器上可以，有时会带来一些问题。React Native则不用担心这个问题。</strong></p>
<h4 id="4-初始化STATE"><a href="#4-初始化STATE" class="headerlink" title="4 初始化STATE"></a>4 初始化STATE</h4><p>在构造函数中初始化（这样可以根据需要做一些计算）：</p>
<pre><code>class Video extends React.Component {
    constructor(props){
        super(props);
        this.state = {
            loopsRemaining: this.props.maxLoops,
        };
    }
}
</code></pre><h4 id="5-把方法作为回调提供并使用"><a href="#5-把方法作为回调提供并使用" class="headerlink" title="5 把方法作为回调提供并使用"></a>5 把方法作为回调提供并使用</h4><p>ES5下可以这么做：</p>
<pre><code>//ES5var PostInfo = React.createClass({
    handleOptionsButtonClick: function(e) {// Here, &#39;this&#39; refers to the component instance.this.setState({showOptionsModal: true});
    },
    render: function(){return (
            &lt;TouchableHighlightonPress={this.handleOptionsButtonClick}&gt;&lt;Text&gt;{this.props.label}&lt;/Text&gt;&lt;/TouchableHighlight&gt;
        )
    },
});
</code></pre><p>在ES5下，<code>React.createClass</code>会把所有的方法都bind一遍，这样可以提交到任意的地方作为回调函数，而this不会变化。但官方现在认为这是不标准、不易理解的。</p>
<p>ES6下，需要通过bind来绑定this引用，或者使用箭头函数（它会绑定当前scope的this引用）来调用：</p>
<pre><code>//ES6class PostInfo extends React.Component
{
    handleOptionsButtonClick(e){
        this.setState({showOptionsModal: true});
    }
    render(){
        return (
            &lt;TouchableHighlightonPress={this.handleOptionsButtonClick.bind(this)}onPress={e=&gt;this.handleOptionsButtonClick(e)}
                &gt;
                &lt;Text&gt;{this.props.label}&lt;/Text&gt;&lt;/TouchableHighlight&gt;
        )
    },
}
</code></pre><p><em>箭头函数是在这里定义了一个临时的函数，箭头函数的箭头=&gt;之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。</em></p>
<p>即：箭头函数箭头前是参数，箭头后是函数体或返回值。</p>
<p>注意：</p>
<p><strong>不论是bind还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么必须自己保存这个引用：</strong></p>
<pre><code>// 错误的做法
class PauseMenu extends React.Component{
    componentWillMount(){
        AppStateIOS.addEventListener(&#39;change&#39;, this.onAppPaused.bind(this));
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener(&#39;change&#39;, this.onAppPaused.bind(this));
    }
    onAppPaused(event){
    }
}
</code></pre><pre><code>// 正确的做法
class PauseMenu extends React.Component{
    constructor(props){
        super(props);
        this._onAppPaused = this.onAppPaused.bind(this);//注意这里
    }
    componentWillMount(){
        AppStateIOS.addEventListener(&#39;change&#39;, this._onAppPaused); //还有这里
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener(&#39;change&#39;, this._onAppPaused);
    }
    onAppPaused(event){
    }
}
</code></pre><h3 id="三-Mixins"><a href="#三-Mixins" class="headerlink" title="三 Mixins"></a>三 Mixins</h3><p>ES5下，经常使用<code>mixin</code>来为类添加一些新的方法，如<code>PureRenderMixin</code>:</p>
<pre><code>var PureRenderMixin = require(&#39;react-addons-pure-render-mixin&#39;);
React.createClass({
  mixins: [PureRenderMixin],

  render: function() {return&lt;divclassName={this.props.className}&gt;foo&lt;/div&gt;;
  }
});
</code></pre><p>但React官方已经不再打算在ES6里继续推行Mixin,官方推荐，对于库编写者而言，应尽快放弃Mixin的编写方式，推荐一种新的编码方式：</p>
<pre><code>//Enhance.js
import { Component } from &quot;React&quot;;

export var Enhance = ComposedComponent =&gt; class extends Component {
    constructor() {
        this.state = { data: null };
    }
    componentDidMount() {
        this.setState({ data: &#39;Hello&#39; });
    }
    render() {
        return&lt;ComposedComponent {...this.props} data={this.state.data} /&gt;;
    }
};
//HigherOrderComponent.js
import { Enhance } from &quot;./Enhance&quot;;

class MyComponent {
    render() {
        if (!this.data) return&lt;div&gt;Waiting...&lt;/div&gt;;return&lt;div&gt;{this.data}&lt;/div&gt;;
    }
}

export default Enhance(MyComponent); // Enhanced component
</code></pre><p>用一个“增强函数”，来为某个类增加一些方法，并且返回一个新类，这无疑能实现mixin所实现的大部分需求。</p>
<h3 id="四-解构与属性延展"><a href="#四-解构与属性延展" class="headerlink" title="四 解构与属性延展"></a>四 解构与属性延展</h3><p>结合使用ES6+的解构和属性延展，在给子组件传递一批属性更为方便了。下面的例子把className以外的所有属性传递给div标签：</p>
<pre><code>class AutoloadingPostsGrid extends React.Component {
    render() {
        var {
            className,
            ...others,  // contains all properties of this.props except for className
        } = this.props;
        return (
            &lt;divclassName={className}&gt;&lt;PostsGrid {...others} /&gt;&lt;buttononClick={this.handleLoadMoreClick}&gt;Load more&lt;/button&gt;&lt;/div&gt;
        );
    }
}
</code></pre><p>下面这种写法，则是传递所有属性的同时，用新的<code>className</code>值进行覆盖（<code>{…this.props}</code>写在前边）：</p>
<pre><code>&lt;div {...this.props} className=&quot;override&quot;&gt;
    …
&lt;/div&gt;
</code></pre><p>这个例子则相反，如果属性中没有包含<code>className</code>，则提供默认的值，而如果属性中已经包含了，则使用属性中的值（<code>{…this.props}</code>写在后边）</p>
<pre><code>&lt;div className=&quot;base&quot; {...this.props}&gt;
    …
&lt;/div&gt;
</code></pre><p>更多ES6的细节可以参考阮一峰前辈的《ECMAScript 6入门》： <a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">http://es6.ruanyifeng.com/</a></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>ES6是大势所趋，建议大家日常使用js的时候逐渐的转到ES6上，适应ES6的新特性，这样才不会落伍哈。</p>
]]></content>
      
        <categories>
            
            <category> 前端框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react </tag>
            
            <tag> es6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[scrum敏捷开发]]></title>
      <url>/scrum%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>scrum是一种灵活的敏捷软件开发管理过程。这个名词来源于英式橄榄球。Scrum方法由Ken Schwaber和 Jeff Sutherland 提出，它将软件开发团队比作橄榄球队，全队有明确的最高目标：发布产品的重要性高于一切。团队高度自治，队员们熟悉开发过程中涉及到的各种技术，紧密合作，确保每个迭代都朝着最高目标推进。而且每隔2至6周，每个人都能看到能实际工作的软件，并且据此决定是发布这个版本还是继续开发以加强它的功能。</p>
<p>对于功能需求可能经常发生变化的项目来说，Scrum是它们最为理想的选择之一。在一个采用Scrum的项目中，首先要将所有需要完成的工作列在一个产品待开发项(Product Backlog)中，项目开发过程中需求的改变也要写进去。在每个迭代(Sprint)开始之前，要开一个迭代计划会议(Sprint Planning Meetting)。在会上，产品责任人(Product Owner)为 Product Backlog中的各功能需求确定优先级(或者是在会前完成)，随后Scrum开发团队按照优先级，从Product Backlog中挑选出他们认为能在本次迭代中完成的任务，把它们从Product Backlog中挪到Sprint Backlog中来。在Sprint进行过程中，Scrum团队每一天都要举行一个简短的每日立会(Daily Stand-up Meeting)，以便团队成员了解开发进度。Sprint结束之后，需要开评审会(Review Meeting)和反思会(Restrospective Meeting)。开发团队在评审会上把这个Sprint的开发成果展示给大家看；而在反思会上，团队成员们会回顾过去的这个Sprint，从中总结经验和教训。</p>
<h2 id="entries-of-backlog"><a href="#entries-of-backlog" class="headerlink" title="entries of backlog"></a>entries of backlog</h2><p>Product Backlog：根据初始需求分解出的任务列表，包括功能性的和非功能性的所有功能； 由Product Owner为Product Backlog中的任务确定优先级别；当开发团队开始做某个任务的时候，再精确定义和分解这个任务。<br><strong>Product Backlog是产品所要具备的所有功能的总纲。</strong></p>
<p>具体项目的任务分类：</p>
<ul>
<li>epic<ul>
<li>user story(jira)产品某一功能完整的需求<ul>
<li>condition<ul>
<li>themes(group user stories) for each developer in group<br>subtasks(可以为每个组员分配更加详细的子任务)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Scrum敏捷开发的简要步骤："><a href="#Scrum敏捷开发的简要步骤：" class="headerlink" title="Scrum敏捷开发的简要步骤："></a>Scrum敏捷开发的简要步骤：</h2><ul>
<li>need a vision:<br>项目开始，所有的成员包括开发和po一起去做一个产品的vision，也就是产品的愿景，我们需要将产品做成什么样，然后大家一起朝着这个目标进发。</li>
<li>维护backlog：<br>po根据产品的需求去第一次划分任务，是所有的任务。然后根据任务的重要程度<strong>去排列优先级</strong>，只有po有这个权限去维护backlog！。</li>
<li>拆分sprint：<br>把scrum拆分成一个一个的sprint也就是我们常说的迭代。并把上一步列出来的所有项目分到sprint中去。这就形成了一个简单的plan。</li>
<li>运行sprint plan<br>整个团队一起去开始sprint。通过backlog从优先级最高的item开始挑选，po开始讲解item的具体要求。然后大家将item细分成各个task。开发人员开始领task。</li>
<li>sprint planning meeting（迭代计划会）<br>在每个Sprint开始之前，需要召开Sprint计划会议，一般为4至8个小时。参加人员有产品责任人、Scrum Master、Scrum团队和其他感兴趣的人，比如管理层人员和客户代表。Product Owner从产品Backlog中挑选优先度高的任务，并与Scrum团队一起决定在这个Sprint中需要完成多少功能；Scrum团队将这些任务分解成小的功能模块； Scrum团队成员详细讨论如何能按需求完成这些功能模块，并估计完成每个功能模块所需的大概时间。</li>
<li>Daily Stand-up Meeting（每日立会）<br>即团队每日例会，条件允许的话，每天都应该在同样的时间和地点，所有成员站立着举行。由于是站立的状态开会，因此时间比较短，一般为15分钟左右。这个会议最好是在每天的早晨开，有利于团队成员们安排好当天的工作计划。只有团队成员可以在每日Scrum会议上发言，其他人员如果对项目进度有兴趣也可以参加，但只能旁听而不能发言。<br>  会议由Scrum Master（backlog owner）主持，Scrum团队的所有成员轮流回答上图中的三个问题，即：<ul>
<li>昨天我完成了什么工作；</li>
<li>今天我打算做什么；</li>
<li>我遇到了什么障碍。</li>
</ul>
</li>
<li>Review Meeting（Sprint评审会）<br>Sprint结束时召开；由开发团队展示这个Sprint中完成的功能；长度为两个小时左右；不需要PPT；一般是已完成的功能的Demo； 谁都可以参加：客户、管理层、Product Owner、其他开发人员等等。</li>
<li>Sprint Retrospective（sprint回顾会）<br>也就是一个sprint做完了，大家坐在一起聊一聊，总结一下这个迭代过程中有什么问题，有什么可以值得后续开发借鉴的啊。blabla～</li>
</ul>
<h2 id="backlog具体分析"><a href="#backlog具体分析" class="headerlink" title="backlog具体分析"></a>backlog具体分析</h2><h3 id="user-story-format"><a href="#user-story-format" class="headerlink" title="user story     format"></a>user story     format</h3><p>name and summary text format:</p>
<pre><code>as a/an &lt;type of user&gt;
i want &lt;some goal&gt;
so that &lt;some reason&gt;
</code></pre><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>jira:<br><strong>epic:</strong></p>
<ul>
<li>project:项目</li>
<li>type:任务类型：epic</li>
<li>epic name: epic name format</li>
<li>summary: same as above</li>
<li>描述：</li>
<li>优先级：任务的优先级</li>
<li>labels：标签</li>
<li>links：可以将文档或者其他epic，tasks，story关联到此任务上。</li>
</ul>
<h3 id="sprint中任务的各个状态"><a href="#sprint中任务的各个状态" class="headerlink" title="sprint中任务的各个状态"></a>sprint中任务的各个状态</h3><ul>
<li>todo:即将要做的任务</li>
<li>in progress： 正在做的任务</li>
<li>test in progress: 正在测试的任务</li>
<li>done: 已经完成测试的任务</li>
</ul>
<h3 id="scrum的三大神器"><a href="#scrum的三大神器" class="headerlink" title="scrum的三大神器"></a>scrum的三大神器</h3><p>production backlog, sprint backlog and burn down chart。</p>
<ul>
<li>production backlog:(产品代办事项)<br>是量化的用户需求，条目化地表达实际需要开发的需求。由po分化产品的backlog，比较详细。</li>
<li>sprint backlog:<br>是一次迭代中需要完成的任务，也是开发过程用得最多的Backlog，非常细化。将上面所生成的backlog，由开发人员再次细分，生成一个比较详细的backlog。</li>
<li>burn down chart:<br>用来统计每个sprint过程中，每天统计所有item的剩余时间，可以生成两种曲线，一种是现实的消耗，一种是项目预计的消耗，形成一个数据表格的形式。</li>
</ul>
<h3 id="scrum的四个计划会议"><a href="#scrum的四个计划会议" class="headerlink" title="scrum的四个计划会议"></a>scrum的四个计划会议</h3><ul>
<li>sprint planning meeting（迭代计划会）<br>在每个Sprint开始之前，需要召开Sprint计划会议，一般为4至8个小时。参加人员有产品责任人、Scrum Master、Scrum团队和其他感兴趣的人，比如管理层人员和客户代表。Product Owner从产品Backlog中挑选优先度高的任务，并与Scrum团队一起决定在这个Sprint中需要完成多少功能；Scrum团队将这些任务分解成小的功能模块； Scrum团队成员详细讨论如何能按需求完成这些功能模块，并估计完成每个功能模块所需的大概时间。</li>
<li>Daily Stand-up Meeting（每日立会）<br>即团队每日例会，条件允许的话，每天都应该在同样的时间和地点，所有成员站立着举行。由于是站立的状态开会，因此时间比较短，一般为15分钟左右。这个会议最好是在每天的早晨开，有利于团队成员们安排好当天的工作计划。只有团队成员可以在每日Scrum会议上发言，其他人员如果对项目进度有兴趣也可以参加，但只能旁听而不能发言。<br>  会议由Scrum Master（backlog owner）主持，Scrum团队的所有成员轮流回答上图中的三个问题，即：<ul>
<li>昨天我完成了什么工作；</li>
<li>今天我打算做什么；</li>
<li>我遇到了什么障碍。</li>
</ul>
</li>
<li>Review Meeting（Sprint评审会）<br>Sprint结束时召开；由开发团队展示这个Sprint中完成的功能；长度为两个小时左右；不需要PPT；一般是已完成的功能的Demo； 谁都可以参加：客户、管理层、Product Owner、其他开发人员等等。</li>
<li>Sprint Retrospective（sprint回顾会）<br>也就是一个sprint做完了，大家坐在一起聊一聊，总结一下这个迭代过程中有什么问题，有什么可以值得后续开发借鉴的啊。blabla～</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> 软件开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅析react]]></title>
      <url>/%E6%B5%85%E6%9E%90react.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> 前端框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端框架 </tag>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据可视化研究笔记]]></title>
      <url>/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="视觉感知与认知"><a href="#视觉感知与认知" class="headerlink" title="视觉感知与认知"></a>视觉感知与认知</h2><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p><strong>数据是符号的集合</strong>，是表达客观事物的未加工过的原始素材。<strong>数据模型是用来描述数据表达的底层模型</strong>：包含数据的定义和类型，以及对不同数据类型的操作功能。<br><strong>概念模型是对目标事物的状态和行为惊醒抽象的语义描述，并提供构建、推理支持等操作。</strong></p>
<h3 id="数据基础"><a href="#数据基础" class="headerlink" title="数据基础"></a>数据基础</h3><h4 id="数据分类"><a href="#数据分类" class="headerlink" title="数据分类"></a>数据分类</h4><p>从关系模型的角度来说，数据可以被分为实体和关系两部分。</p>
<ul>
<li>实体：被可视化的对象。</li>
<li>关系：定义了实体与其他实体之间的关系的结构和模型。</li>
</ul>
<h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><p>数据集是数据的实例。常见的数据集的表达方式有三类。</p>
<h5 id="数据记录集"><a href="#数据记录集" class="headerlink" title="数据记录集"></a>数据记录集</h5><p>数据记录由一组包含固定属性值的数据元素组成。有三种形式：数据矩阵，文档向量表示和事务处理数据。</p>
<ul>
<li>数据矩阵：数据对象可视为高维空间的点集，每个维度对应单个属性。这种数据集可以表达为一个mxn的矩阵。其中矩阵的每行对应一个数据对象，每列代表单个属性在数据集中的分布。数据矩阵类似于数据库中表对数据的存储方式。</li>
<li>文档向量表示：如果统计文档中所有单词出现的频率，则一个文档可以表示为一个向量，其长度是单词集的个数，每个分量记录单词集中每个单词在该文档中的频率。</li>
<li>事务处理数据：每个记录包含一组数据项。事务处理数据与数据矩阵的差别在于，事务处理数据的每个记录包含的个数和属性不固定，所以不能用矩阵这种大小确定的方式进行表达。</li>
</ul>
<h5 id="图数据集"><a href="#图数据集" class="headerlink" title="图数据集"></a>图数据集</h5><p>通常由图和树这种非结构化的数据结构来表示。后文将会详细介绍这种数据集。</p>
<h5 id="有序数据集"><a href="#有序数据集" class="headerlink" title="有序数据集"></a>有序数据集</h5><p>有序数据集是具有某种顺序的数据集。常见的有空间数据，时间数据，时空数据，顺序数据和基因测序数据。</p>
<p>数据集的另一种分类是考察数据模型的结构。可以用二维表结构逻辑表达实现的数据称为结构化数据。反之，如果不能用二维表结构逻辑表达实现的数据称为非结构化数据。</p>
<h4 id="数据相似度与密度"><a href="#数据相似度与密度" class="headerlink" title="数据相似度与密度"></a>数据相似度与密度</h4><p><strong>相似度</strong>是描述多个数据之间的相似程度的数值，通常位于0-1之间。与之对应的是相异度，其下限是0，上限和数据集有关，有可能会超过1.</p>
<p>计算相似度的方法：</p>
<ul>
<li>欧几里德距离。</li>
<li>明可夫斯基距离</li>
<li>余铉距离</li>
<li>jacccard相似度</li>
</ul>
<p>计算密度：</p>
<ul>
<li>欧几里得密度</li>
<li>概率密度</li>
<li>基于图结构的密度</li>
</ul>
<h3 id="数据获取和预处理"><a href="#数据获取和预处理" class="headerlink" title="数据获取和预处理"></a>数据获取和预处理</h3><h4 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h4><p>移动互联网时代，<strong>基于网络的多源数据交换占据主流</strong>。数据获取的挑战主要有<strong>数据格式变换</strong>和<strong>异构异质数据的获取协议</strong>两部分。</p>
<p>数据获取协议（DAP）作为一种通用的数据获取标准，在科研领域应用比较广泛。通过定义基于网络的数据获取句法，以完善数据交换机制，维护，发展和提升数据获取效率。它和网格ftp，http，srb、开放地理空间联盟（如wcs，wms，wfs）、天文学（siap，ssap，stap）等协议兼容。</p>
<h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><p>常见的数据元操作有：</p>
<ul>
<li>合并</li>
<li>采样</li>
<li>降维</li>
<li>特征子集选择</li>
<li>特征生成</li>
<li>离散化与二值化</li>
<li>属性变换</li>
</ul>
<h5 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h5><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> 数据可视化 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 数据可视化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nodejs初级教程]]></title>
      <url>/nodejs%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><del>~待更新</del></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> node.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RESTful API设计最佳实践]]></title>
      <url>/RESTful-API%E8%AE%BE%E8%AE%A1%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="RESTful-API-设计最佳实践"><a href="#RESTful-API-设计最佳实践" class="headerlink" title="RESTful API 设计最佳实践"></a>RESTful API 设计最佳实践</h2><p>项目资源的URL应该如何设计？用名词复数还是用名词单数？一个资源需要多少个URL？用哪种HTTP方法来创建一个新的资源？可选参数应该放在哪里？那些不涉及资源操作的URL呢？实现分页和版本控制的最好方法是什么？因为有太多的疑问，设计RESTful API变得很棘手。</p>
<h3 id="每个资源使用两个URL"><a href="#每个资源使用两个URL" class="headerlink" title="每个资源使用两个URL"></a>每个资源使用两个URL</h3><p>资源集合用一个URL，具体某个资源用一个URL：</p>
<pre><code>
/employees         #资源集合的URL

/employees/56      #具体某个资源的URL
</code></pre><h3 id="用名词代替动词表示资源"><a href="#用名词代替动词表示资源" class="headerlink" title="用名词代替动词表示资源"></a>用名词代替动词表示资源</h3><p>这让你的API更简洁，URL数目更少。不要这么设计：</p>
<pre><code>
/getAllEmployees

/getAllExternalEmployees

/createEmployee

/updateEmployee
</code></pre><p>更好的设计：</p>
<pre><code>
GET /employees

GET /employees?state=external

POST /employees

PUT /employees/56
</code></pre><h3 id="用HTTP方法操作资源"><a href="#用HTTP方法操作资源" class="headerlink" title="用HTTP方法操作资源"></a>用HTTP方法操作资源</h3><p>使用URL指定你要用的资源。使用HTTP方法来指定怎么处理这个资源。使用四种HTTP方法POST，GET，PUT，DELETE可以提供CRUD功能（创建，获取，更新，删除）。</p>
<ul>
<li><p>获取：使用GET方法获取资源。GET请求从不改变资源的状态。无副作用。GET方法是幂等的。GET方法具有只读的含义。因此，你可以完美的使用缓存。</p>
</li>
<li><p>创建：使用POST创建新的资源。</p>
</li>
<li><p>更新：使用PUT更新现有资源。</p>
</li>
<li><p>删除：使用DELETE删除现有资源。</p>
</li>
</ul>
<p>2个URL乘以4个HTTP方法就是一组很好的功能。看看这个表格：<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fkkbpxeexvj30j803cdfw.jpg" alt=""></p>
<h3 id="对资源集合的URL使用POST方法，创建新资源"><a href="#对资源集合的URL使用POST方法，创建新资源" class="headerlink" title="对资源集合的URL使用POST方法，创建新资源"></a>对资源集合的URL使用POST方法，创建新资源</h3><p>创建一个新资源的时，客户端与服务器是怎么交互的呢？</p>
<p>在资源集合URL上使用POST来创建新的资源过程： </p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkkbsd2qs5j30gh0akt90.jpg" alt=""></p>
<ol>
<li><p>客户端向资源集合URL<code>/employees</code>发送POST请求。HTTP body 包含新资源的属性 “Albert Stark”。</p>
</li>
<li><p>RESTful Web服务器为新员工生成ID，在其内部模型中创建员工，并向客户端发送响应。这个响应的HTTP头部包含一个Location字段，指示创建资源可访问的URL。</p>
</li>
</ol>
<h3 id="对具体资源的URL使用PUT方法，来更新资源"><a href="#对具体资源的URL使用PUT方法，来更新资源" class="headerlink" title="对具体资源的URL使用PUT方法，来更新资源"></a>对具体资源的URL使用PUT方法，来更新资源</h3><p>使用PUT更新已有资源： </p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkkbt00kzkj30gp0ao74j.jpg" alt=""></p>
<ol>
<li><p>客户端向具体资源的URL发送PUT请求<code>/employee/21</code>。请求的HTTP body中包含要更新的属性值（21号员工的新名称“Bruce Wayne”）。</p>
</li>
<li><p>REST服务器更新ID为21的员工名称，并使用HTTP状态码200表示更改成功。</p>
</li>
</ol>
<h3 id="推荐用复数名词"><a href="#推荐用复数名词" class="headerlink" title="推荐用复数名词"></a>推荐用复数名词</h3><p>推荐：</p>
<pre><code>
/employees

/employees/21
</code></pre><p>不推荐：</p>
<pre><code>
/employee

/employee/21
</code></pre><p>事实上，这是个人爱好问题，但复数形式更为常见。此外，在资源集合URL上用GET方法，它更直观，特别是<code>GET /employees?state=external</code>、<code>POST /employees</code>、<code>PUT /employees/56</code>。但最重要的是：避免复数和单数名词混合使用，这显得非常混乱且容易出错。</p>
<p>对可选的、复杂的参数，使用查询字符串（？）。</p>
<p>不推荐做法：</p>
<pre><code>
GET /employees

GET /externalEmployees

GET /internalEmployees

GET /internalAndSeniorEmployees
</code></pre><p>为了让你的URL更小、更简洁。为资源设置一个基本URL，将可选的、复杂的参数用查询字符串表示。</p>
<pre><code>
GET /employees?state=internal&amp;maturity=senior
</code></pre><h3 id="使用HTTP状态码"><a href="#使用HTTP状态码" class="headerlink" title="使用HTTP状态码"></a>使用HTTP状态码</h3><p>RESTful Web服务应使用合适的HTTP状态码来响应客户端请求</p>
<ul>
<li><p>2xx - 成功 - 一切都很好</p>
</li>
<li><p>4xx - 客户端错误 - 如果客户端发生错误（例如客户端发送无效请求或未被授权）</p>
</li>
<li><p>5xx – 服务器错误 - 如果服务器发生错误（例如，尝试处理请求时出错）<br>参考维基百科上的HTTP状态代码。但是，其中的大部分HTTP状态码都不会被用到，只会用其中的一小部分。通常会用到一下几个：</p>
</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkkbtr8ez8j30ir0503ym.jpg" alt=""></p>
<p>除了合适的状态码之外，还应该在HTTP响应正文中提供有用的错误提示和详细的描述。这是一个例子。<br>请求：</p>
<pre><code>
GET /employees?state=super
</code></pre><p>响应：</p>
<pre><code>
// 400 Bad Request

{

    &quot;message&quot;: &quot;You submitted an invalid state. Valid state values are &#39;internal&#39; or &#39;external&#39;&quot;,

    &quot;errorCode&quot;: 352,

    &quot;additionalInformation&quot; : 

    &quot;http://www.domain.com/rest/errorcode/352&quot;

}
</code></pre><h3 id="使用小驼峰命名法"><a href="#使用小驼峰命名法" class="headerlink" title="使用小驼峰命名法"></a>使用小驼峰命名法</h3><p>使用小驼峰命名法作为属性标识符。</p>
<pre><code>
{&quot;yearOfBirth&quot;:1982}
</code></pre><p>不要使用下划线（<code>year_of_birth</code>）或大驼峰命名法（<code>YearOfBirth</code>）。通常，RESTful Web服务将被JavaScript编写的客户端使用。客户端会将JSON响应转换为JavaScript对象（通过调用<code>var person = JSON.parse(response)</code>），然后调用其属性。因此，最好遵循JavaScript代码通用规范。<br>对比：</p>
<pre><code>
person.year_of_birth // 不推荐，违反JavaScript代码通用规范

person.YearOfBirth // 不推荐，JavaScript构造方法命名

person.yearOfBirth // 推荐
</code></pre><h3 id="在URL中强制加入版本号"><a href="#在URL中强制加入版本号" class="headerlink" title="在URL中强制加入版本号"></a>在URL中强制加入版本号</h3><p>从始至终，都使用版本号发布您的RESTful API。将版本号放在URL中以是必需的。如果您有不兼容和破坏性的更改，版本号将让你能更容易的发布API。发布新API时，只需在增加版本号中的数字。这样的话，客户端可以自如的迁移到新API，不会因调用完全不同的新API而陷入困境。<br>使用直观的 “v” 前缀来表示后面的数字是版本号。</p>
<pre><code>
/v1/employees
</code></pre><p>你不需要使用次级版本号（“v1.2”），因为你不应该频繁的去发布API版本。</p>
<p>提供分页信息</p>
<p>一次性返回数据库所有资源不是一个好主意。因此，需要提供分页机制。通常使用数据库中众所周知的参数offset和limit。</p>
<pre><code>
/employees?offset=30&amp;limit=15       #返回30 到 45的员工
</code></pre><p>如果客户端没有传这些参数，则应使用默认值。通常默认值是<code>offset = 0</code>和<code>limit = 10</code>。如果数据库检索很慢，应当减小<code>limit</code>值。</p>
<pre><code>
/employees       #返回0 到 10的员工
</code></pre><p>此外，如果您使用分页，客户端需要知道资源总数。例：<br>请求：</p>
<pre><code>
GET /employees
</code></pre><p>响应：</p>
<pre><code>
{

  &quot;offset&quot;:0,

  &quot;limit&quot;:10,

  &quot;total&quot;:3465,

  &quot;employees&quot;:[

    //...

  ]

}
</code></pre><h3 id="非资源请求用动词"><a href="#非资源请求用动词" class="headerlink" title="非资源请求用动词"></a>非资源请求用动词</h3><p>有时API调用并不涉及资源（如计算，翻译或转换）。例：</p>
<pre><code>
GET /translate?from=de_DE&amp;to=en_US&amp;text=Hallo

GET/calculate?para2=23&amp;para2=432
</code></pre><p>在这种情况下，API响应不会返回任何资源。而是执行一个操作并将结果返回给客户端。因此，您应该在URL中使用动词而不是名词，来清楚的区分资源请求和非资源请求。</p>
<h3 id="考虑特定资源搜索和跨资源搜索"><a href="#考虑特定资源搜索和跨资源搜索" class="headerlink" title="考虑特定资源搜索和跨资源搜索"></a>考虑特定资源搜索和跨资源搜索</h3><p>提供对特定资源的搜索很容易。只需使用相应的资源集合URL，并将搜索字符串附加到查询参数中即可。</p>
<pre><code>
GET /employees?query=Paul
</code></pre><p>如果要对所有资源提供全局搜索，则需要用其他方法。前文提到，对于非资源请求URL，使用动词而不是名词。因此，您的搜索网址可能如下所示：</p>
<pre><code>
GET /search?query=Paul   //返回 employees, customers, suppliers 等等.
</code></pre><h3 id="在响应参数中添加浏览其它API的链接"><a href="#在响应参数中添加浏览其它API的链接" class="headerlink" title="在响应参数中添加浏览其它API的链接"></a>在响应参数中添加浏览其它API的链接</h3><p>理想情况下，不会让客户端自己构造使用REST API的URL。让我们思考一个例子。<br>客户端想要访问员工的薪酬表。为此，他必须知道他可以通过在员工URL（例如<code>/employees/21/salaryStatements</code>）中附加字符串“salaryStatements”来访问薪酬表。这个字符串连接很容易出错，且难以维护。如果你更改了访问薪水表的REST API的方式（例如变成了<code>/employees/21/salary-statement</code>或<code>/employees/21/paySlips</code>），所有客户端都将中断。<br>更好的方案是在响应参数中添加一个<code>links</code>字段，让客户端可以自动变更。<br>请求：</p>
<pre><code>
GET /employees/
</code></pre><p>响应：</p>
<pre><code>
//...

   {

      &quot;id&quot;:1,

      &quot;name&quot;:&quot;Paul&quot;,

      &quot;links&quot;: [

         {

            &quot;rel&quot;: &quot;salary&quot;,

            &quot;href&quot;: &quot;/employees/1/salaryStatements&quot;

         }

      ]

   },

//...
</code></pre><p>如果客户端完全依靠<code>links</code>中的字段获得薪资表，你更改了API，客户端将始终获得一个有效的URL（只要你更改了<code>link</code>字段，请求的URL会自动更改），不会中断。另一个好处是，你的API变得可以自我描述，需要写的文档更少。<br>在分页时，您还可以添加获取下一页或上一页的链接示例。只需提供适当的偏移和限制的链接示例。</p>
<pre><code>
GET /employees?offset=20&amp;limit=10
</code></pre><pre><code>
{

  &quot;offset&quot;:20,

  &quot;limit&quot;:10,

  &quot;total&quot;:3465,

  &quot;employees&quot;:[

    //...

  ],

  &quot;links&quot;: [

     {

        &quot;rel&quot;: &quot;nextPage&quot;,

        &quot;href&quot;: &quot;/employees?offset=30&amp;limit=10&quot;

     },

     {

        &quot;rel&quot;: &quot;previousPage&quot;,

        &quot;href&quot;: &quot;/employees?offset=10&amp;limit=10&quot;

     }

  ]

}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>RESTful api设计可以极大地提高项目管理效率，提高开发</p>
]]></content>
      
        <categories>
            
            <category> 前端架构设计 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 前端架构设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[三种web会话管理的方式]]></title>
      <url>/%E4%B8%89%E7%A7%8Dweb%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="3-种-web-会话管理的方式"><a href="#3-种-web-会话管理的方式" class="headerlink" title="3 种 web 会话管理的方式"></a>3 种 web 会话管理的方式</h2><p>http是无状态的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。当然它知道是哪个客户端地址发过来的，但是对于我们的应用来说，我们是靠用户来管理，而不是靠客户端。所以对我们的应用而言，它是需要有状态管理的，以便服务端能够准确的知道http请求是哪个用户发起的，从而判断他是否有权限继续这个请求。这个过程就是常说的会话管理。它也可以简单理解为一个用户从登录到退出应用的一段期间。本文总结了3种常见的实现web应用会话管理的方式：</p>
<ol>
<li><p>基于server端session的管理方式</p>
</li>
<li><p>cookie-base的管理方式</p>
</li>
<li><p>token-base的管理方式</p>
</li>
</ol>
<p>这些内容可以帮助加深对web中用户登录机制的理解，对实际项目开发也有参考价值，欢迎阅读与指正。</p>
<h3 id="基于server端session的管理"><a href="#基于server端session的管理" class="headerlink" title="基于server端session的管理"></a>基于server端session的管理</h3><p>在早期web应用中，通常使用服务端session来管理用户的会话。快速了解服务端session:</p>
<ol>
<li><p>服务端session是用户第一次访问应用时，服务器就会创建的对象，代表用户的一次会话过程，可以用来存放数据。服务器为每一个session都分配一个唯一的sessionid，以保证每个用户都有一个不同的session对象。</p>
</li>
<li><p>服务器在创建完session后，会把sessionid通过cookie返回给用户所在的浏览器，这样当用户第二次及以后向服务器发送请求的时候，就会通过cookie把sessionid传回给服务器，以便服务器能够根据sessionid找到与该用户对应的session对象。</p>
</li>
<li><p>session通常有失效时间的设定，比如2个小时。当失效时间到，服务器会销毁之前的session，并创建新的session返回给用户。但是只要用户在失效时间内，有发送新的请求给服务器，通常服务器都会把他对应的session的失效时间根据当前的请求时间再延长2个小时。</p>
</li>
<li><p>session在一开始并不具备会话管理的作用。它只有在用户登录认证成功之后，并且往sesssion对象里面放入了用户登录成功的凭证，才能用来管理会话。管理会话的逻辑也很简单，只要拿到用户的session对象，看它里面有没有登录成功的凭证，就能判断这个用户是否已经登录。当用户主动退出的时候，会把它的session对象里的登录凭证清掉。所以在用户登录前或退出后或者session对象失效时，肯定都是拿不到需要的登录凭证的。</p>
</li>
</ol>
<p>以上过程可简单使用流程图描述如下：<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fkk5mboalij30e2087t8y.jpg" alt=""></p>
<p>主流的web开发平台（java,.net,php）都原生支持这种会话管理的方式，而且开发起来很简单，相信大部分后端开发人员在入门的时候都了解并使用过它。它还有一个比较大的优点就是安全性好，因为在浏览器端与服务器端保持会话状态的媒介始终只是一个sessionid串，只要这个串够随机，攻击者就不能轻易冒充他人的sessionid进行操作；除非通过CSRF或http劫持的方式，才有可能冒充别人进行操作；即使冒充成功，也必须被冒充的用户session里面包含有效的登录凭证才行。但是在真正决定用它管理会话之前，也得根据自己的应用情况考虑以下几个问题：</p>
<ol>
<li><p>这种方式将会话信息存储在web服务器里面，所以在用户同时在线量比较多时，这些会话信息会占据比较多的内存；</p>
</li>
<li><p>当应用采用集群部署的时候，会遇到多台web服务器之间如何做session共享的问题。因为session是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建session的服务器，这样他就拿不到之前已经放入到session中的登录凭证之类的信息了；</p>
</li>
<li><p>多个应用要共享session时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好cookie跨域的处理。</p>
</li>
</ol>
<p>针对问题1和问题2，我见过的解决方案是采用redis这种中间服务器来管理session的增删改查，一来减轻web服务器的负担，二来解决不同web服务器共享session的问题。针对问题3，由于服务端的session依赖cookie来传递sessionid，所以在实际项目中，只要解决各个项目里面如何实现sessionid的cookie跨域访问即可，这个是可以实现的，就是比较麻烦，前后端有可能都要做处理。</p>
<p>如果不考虑以上三个问题，这种管理方式比较值得使用，尤其是一些小型的web应用。但是一旦应用将来有扩展的必要，那就得谨慎对待前面的三个问题。如果真要在项目中使用这种方式，推荐结合单点登录框架如CAS一起用，这样会使应用的扩展性更强。</p>
<h3 id="cookie-based的管理方式"><a href="#cookie-based的管理方式" class="headerlink" title="cookie-based的管理方式"></a>cookie-based的管理方式</h3><p>由于前一种方式会增加服务器的负担和架构的复杂性，所以后来就有人想出直接把用户的登录凭证直接存到客户端的方案，当用户登录成功之后，把登录凭证写到cookie里面，并给cookie设置有效期，后续请求直接验证存有登录凭证的cookie是否存在以及凭证是否有效，即可判断用户的登录状态。使用它来实现会话管理的整体流程如下：</p>
<ol>
<li><p>用户发起登录请求，服务端根据传入的用户密码之类的身份信息，验证用户是否满足登录条件，如果满足，就根据用户信息创建一个登录凭证，这个登录凭证简单来说就是一个对象，最简单的形式可以只包含用户id，凭证创建时间和过期时间三个值。</p>
</li>
<li><p>服务端把上一步创建好的登录凭证，先对它做数字签名，然后再用对称加密算法做加密处理，将签名、加密后的字串，写入cookie。cookie的名字必须固定（如ticket），因为后面再获取的时候，还得根据这个名字来获取cookie值。这一步添加数字签名的目的是防止登录凭证里的信息被篡改，因为一旦信息被篡改，那么下一步做签名验证的时候肯定会失败。做加密的目的，是防止cookie被别人截取的时候，无法轻易读到其中的用户信息。</p>
</li>
<li><p>用户登录后发起后续请求，服务端根据上一步存登录凭证的cookie名字，获取到相关的cookie值。然后先做解密处理，再做数字签名的认证，如果这两步都失败，说明这个登录凭证非法；如果这两步成功，接着就可以拿到原始存入的登录凭证了。然后用这个凭证的过期时间和当前时间做对比，判断凭证是否过期，如果过期，就需要用户再重新登录；如果未过期，则允许请求继续。</p>
</li>
</ol>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fkk5n047egj30e108fglt.jpg" alt=""></p>
<p>这种方式最大的优点就是实现了服务端的无状态化，彻底移除了服务端对会话的管理的逻辑，服务端只需要负责创建和验证登录cookie即可，无需保持用户的状态信息。对于第一种方式的第二个问题，用户会话信息共享的问题，它也能很好解决：因为如果只是同一个应用做集群部署，由于验证登录凭证的代码都是一样的，所以不管是哪个服务器处理用户请求，总能拿到cookie中的登录凭证来进行验证；如果是不同的应用，只要每个应用都包含相同的登录逻辑，那么他们也是能轻易实现会话共享的，不过这种情况下，登录逻辑里面数字签名以及加密解密要用到的密钥文件或者密钥串，需要在不同的应用里面共享，总而言之，就是需要算法完全保持一致。</p>
<p>这种方式由于把登录凭证直接存放客户端，并且需要cookie传来传去，所以它的缺点也比较明显：</p>
<ol>
<li><p>cookie有大小限制，存储不了太多数据，所以要是登录凭证存的消息过多，导致加密签名后的串太长，就会引发别的问题，比如其它业务场景需要cookie的时候，就有可能没那么多空间可用了；所以用的时候得谨慎，得观察实际的登录cookie的大小；比如太长，就要考虑是非是数字签名的算法太严格，导致签名后的串太长，那就适当调整签名逻辑；比如如果一开始用4096位的RSA算法做数字签名，可以考虑换成1024、2048位；</p>
</li>
<li><p>每次传送cookie，增加了请求的数量，对访问性能也有影响；</p>
</li>
<li><p>也有跨域问题，毕竟还是要用cookie。</p>
</li>
</ol>
<p>相比起第一种方式，cookie-based方案明显还是要好一些，目前好多web开发平台或框架都默认使用这种方式来做会话管理，比如php里面yii框架，这是我们团队后端目前用的，它用的就是这个方案，以上提到的那些登录逻辑，框架也都已经封装好了，实际用起来也很简单；asp.net里面forms身份认证，也是这个思路，这里有一篇好文章把它的实现细节都说的很清楚：</p>
<p><a href="http://www.cnblogs.com/fish-li/archive/2012/04/15/2450571.html" target="_blank" rel="external">http://www.cnblogs.com/fish-li/archive/2012/04/15/2450571.html</a></p>
<p>前面两种会话管理方式因为都用到cookie，不适合用在native app里面：native app不好管理cookie，毕竟它不是浏览器。这两种方案都不适合用来做纯api服务的登录认证。要实现api服务的登录认证，就要考虑下面要介绍的第三种会话管理方式。</p>
<h3 id="token-based的管理方式"><a href="#token-based的管理方式" class="headerlink" title="token-based的管理方式"></a>token-based的管理方式</h3><p>这种方式从流程和实现上来说，跟cookie-based的方式没有太多区别，只不过cookie-based里面写到cookie里面的ticket在这种方式下称为token，这个token在返回给客户端之后，后续请求都必须通过url参数或者是http header的形式，主动带上token，这样服务端接收到请求之后就能直接从http header或者url里面取到token进行验证：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkk5o3um32j30ef07bq34.jpg" alt=""></p>
<p>这种方式不通过cookie进行token的传递，而是每次请求的时候，主动把token加到http header里面或者url后面，所以即使在native app里面也能使用它来调用我们通过web发布的api接口。app里面还要做两件事情：</p>
<ol>
<li><p>有效存储token，得保证每次调接口的时候都能从同一个位置拿到同一个token；</p>
</li>
<li><p>每次调接口的的代码里都得把token加到header或者接口地址里面。</p>
</li>
</ol>
<p>看起来麻烦，其实也不麻烦，这两件事情，对于app来说，很容易做到，只要对接口调用的模块稍加封装即可。</p>
<p>这种方式同样适用于网页应用，token可以存于localStorage或者sessionStorage里面，然后每发ajax请求的时候，都把token拿出来放到ajax请求的header里即可。不过如果是非接口的请求，比如直接通过点击链接请求一个页面这种，是无法自动带上token的。所以这种方式也仅限于走纯接口的web应用。</p>
<p>这种方式用在web应用里也有跨域的问题，比如应用如果部署在a.com，api服务部署在b.com，从a.com里面发出ajax请求到b.com，默认情况下是会报跨域错误的，这种问题可以用CORS（跨域资源共享）的方式来快速解决，相关细节可去阅读前面给出的CORS文章详细了解。</p>
<p>这种方式跟cookie-based的方式同样都还有的一个问题就是ticket或者token刷新的问题。有的产品里面，你肯定不希望用户登录后，操作了半个小时，结果ticket或者token到了过期时间，然后用户又得去重新登录的情况出现。这个时候就得考虑ticket或token的自动刷新的问题，简单来说，可以在验证ticket或token有效之后，自动把ticket或token的失效时间延长，然后把它再返回给客户端；客户端如果检测到服务器有返回新的ticket或token，就替换原来的ticket或token。</p>
<h3 id="安全问题在web应用里面，会话管理的安全性始终是最重要的安全问题，这个对用户的影响极大。"><a href="#安全问题在web应用里面，会话管理的安全性始终是最重要的安全问题，这个对用户的影响极大。" class="headerlink" title="安全问题在web应用里面，会话管理的安全性始终是最重要的安全问题，这个对用户的影响极大。"></a>安全问题在web应用里面，会话管理的安全性始终是最重要的安全问题，这个对用户的影响极大。</h3><p>首先从会话管理凭证来说，第一种方式的会话凭证仅仅是一个session id，所以只要这个session id足够随机，而不是一个自增的数字id值，那么其它人就不可能轻易地冒充别人的session id进行操作；第二种方式的凭证（ticket）以及第三种方式的凭证（token）都是一个在服务端做了数字签名，和加密处理的串，所以只要密钥不泄露，别人也无法轻易地拿到这个串中的有效信息并对它进行篡改。总之，这三种会话管理方式的凭证本身是比较安全的。</p>
<p>然后从客户端和服务端的http过程来说，当别人截获到客户端请求中的会话凭证，就能拿这个凭证冒充原用户，做一些非法操作，而服务器也认不出来。这种安全问题，可以简单采用https来解决，虽然可能还有http劫持这种更高程度的威胁存在，但是我们从代码能做的防范，确实也就是这个层次了。</p>
<p>最后的安全问题就是CSRF（跨站请求伪造）。这个跟代码有很大关系，本质上它就是代码的漏洞，只不过一般情况下这些漏洞，作为开发人员都不容易发现，只有那些一门心思想搞些事情的人才会专门去找这些漏洞，所以这种问题的防范更多地还是依赖于开发人员对这种攻击方式的了解，包括常见的攻击形式和应对方法。不管凭证信息本身多么安全，别人利用CSRF，就能拿到别人的凭证，然后用它冒充别人进行非法操作，所以有时间还真得多去了解下它的相关资料才行。举例来说，假如我们把凭证直接放到url后面进行传递，就有可能成为一个CSRF的漏洞：当恶意用户在我们的应用内上传了1张引用了他自己网站的图片，当正常的用户登录之后访问的页面里面包含这个图片的时候，由于这个图片加载的时候会向恶意网站发送get请求；当恶意网站收到请求的时候，就会从这个请求的Reffer header里面看到包含这个图片的页面地址，而这个地址正好包含了正常用户的会话凭证；于是恶意用户就拿到了正常用户的凭证；只要这个凭证还没失效，他就能用它冒充用户进行非法操作。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>总结前面这三种方式，各自有各自的优点及使用场景，我觉得没有哪个是最好的，做项目的时候，根据项目将来的扩展情况和架构情况，才能决定用哪个是最合适的。本文的目的也就是想介绍这几种方式的原理，以便掌握web应用中登录验证的关键因素。</p>
<p>作为一个前端开发人员，本文虽然介绍了3种会话管理的方式，但是与前端关系最紧密的还是第三种方式，毕竟现在前端开发SPA应用以及hybrid应用已经非常流行了，所以掌握好这个方式的认证过程和使用方式，对前端来说，显然是很有帮助的。好在这个方式的技术其实早就有很多实现了，而且还有现成的标准可用，这个标准就是JWT(json-web-token)。</p>
<p>JWT本身并没有做任何技术实现，它只是定义了token-based的管理方式该如何实现，它规定了token的应该包含的标准内容以及token的生成过程和方法。目前实现了这个标准的技术已经有非常多。</p>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[react实战--打造画廊项目（一）]]></title>
      <url>/react%E5%AE%9E%E6%88%98-%E6%89%93%E9%80%A0%E7%94%BB%E5%BB%8A%E9%A1%B9%E7%9B%AE.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用<code>yeoman+bower+gulp+webpack</code>等前端自动化解决方案来构建<code>react+sass</code>的前端画廊应用。<br><em>这是画廊项目的效果图，点击相应的图片，图片会居中显示</em></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fl0o41biu3g30ze0ic4r6.gif" alt=""></p>
<p><strong>注意：此项目的react语法是基于es6的最新语法，如果看到不会的，亲子行REACT官网查看<a href="https://reactjs.org/docs/react-without-es6.html#setting-the-initial-state" target="_blank" rel="external">doc</a></strong></p>
<h2 id="yeoman脚手架生成项目初始的代码结构"><a href="#yeoman脚手架生成项目初始的代码结构" class="headerlink" title="yeoman脚手架生成项目初始的代码结构"></a>yeoman脚手架生成项目初始的代码结构</h2><ul>
<li>首先安装nodejs环境，不会的请自行百度～ </li>
<li>安装yeoman<pre><code>npm install yo -g
</code></pre>如果有童鞋对yeoman不是很了解，请看我以前的博客<a href="http://pancakeawesome.ink/yeoman+bower+gulp-grunt%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE.html">yeoman+bower+gulp-grunt构建现代化前端项目</a></li>
<li>去yeoman官网去搜寻基于<code>webpack</code>的react的项目生成器（generator）<br>安装generator:<pre><code>npm install -g generator-react-webpack
</code></pre><strong>TIPS：如何查看全局环境下npm安装的模块</strong><pre><code>npm ls -g --depth=1 2&gt;/dev/null | grep generator-
</code></pre><em>depth=1：因为npm中各个模块都是有依赖关系的，所以npm会以树状图的形式显示所有模块</em><br><em>2&gt;/dev/null:表示将执行bash命令过程中的错误输出到null设备中，<strong>注意：npm经常会报错。</strong>这里的设备是null，也就是空设备，意思是错误将不会展现出来。</em><br><em>grep generator：表示输出的内容仅显示generator开头的内容</em></li>
<li>在github等代码托管平台中生成一个仓库，将项目down下来。</li>
</ul>
<pre><code>git clone &lt;你的远程代码仓库的地址&gt;
</code></pre><ul>
<li>进入项目的文件夹，用yeoman生成react的初始项目结构：</li>
</ul>
<pre><code>yo react-webpack &lt;项目名称&gt;
</code></pre><p><em>国内使用npm下载包实在太慢，建议使用淘宝源下载软件：<strong>使用cnpm替换npm下载包：</strong></em></p>
<pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fkkfh53akkj31340k3jt2.jpg" alt=""></p>
<p><strong>通常生成项目初始结构很慢，耐心等待</strong></p>
<h3 id="项目根目录结构："><a href="#项目根目录结构：" class="headerlink" title="项目根目录结构："></a>项目根目录结构：</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkkfz14akcj30460anjre.jpg" alt=""></p>
<ul>
<li>babelrc: es6相关的配置。</li>
<li>node_modules:项目编译所需的node组件所在的目录。</li>
<li>cfg:<strong>类比于webpack.config文件中的webpack配置信息：</strong></li>
</ul>
<pre><code>/**
 * Build the webpack configuration
 * @param  {String} wantedEnv The wanted environment
 * @return {Object} Webpack config
 */
function buildConfig(wantedEnv) {
  let isValid = wantedEnv &amp;&amp; wantedEnv.length &gt; 0 &amp;&amp; allowedEnvs.indexOf(wantedEnv) !== -1;
  let validEnv = isValid ? wantedEnv : &#39;dev&#39;;
  let config = require(path.join(__dirname, &#39;cfg/&#39; + validEnv));
  return config;
}

module.exports = buildConfig(env);
</code></pre><p><em>这段webpack.config.js文件中的代码表明用cfg文件夹中相应环境的代码去完成webpack的配置</em></p>
<ul>
<li><code>dist</code>: dist环境的目录。</li>
<li><code>src</code>：源代码所在目录。</li>
<li><code>test</code>：测试代码所在目录。</li>
<li><code>editorconfig</code>：用来统一不同编辑器，ide的代码编辑风格。写代码的同时，自动将你的代码格式统一为editorconfig支持的编辑器的格式。<em>支持很多编辑器和ide，<a href="http://editorconfig.org/" target="_blank" rel="external">官网</a></em></li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fkkgqbin8cj30lr0hdgme.jpg" alt=""></p>
<ul>
<li><code>gitignore</code>:git仓库相关的配置文件。</li>
<li><code>eslintrc/jshintrc</code>:代码风格检测工具🔧，eslint比jshint多支持jsx语法。</li>
<li><code>yo-rc.json</code>：yeoman的配置文件，用来记录当前项目的信息。</li>
<li><code>karma.conf.js</code>:karma测试框架的配置文件。</li>
<li><code>package.json</code>:node项目的配置文件，声明当前的项目的信息，依赖了哪些npm包等等。</li>
<li><code>webpack.config.js</code>：webpack的配置文件。</li>
</ul>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>在<code>pacakge.json</code>文件中已经配置好了：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fkkh9uo9w3j30ka03bt8u.jpg" alt=""></p>
<pre><code>npm start 或者
npm run serve
</code></pre><p><strong>源代码结构</strong></p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkkhfhh7c7j304506nt8l.jpg" alt=""></p>
<ul>
<li><code>favicon.ico</code>:项目首页的图标，通常放在项目根目录。</li>
<li><code>index.html</code>:项目的入口文件。<br>在index页面中有这么一个脚本，这个脚本和chrome的扩展插件 react developer tools有关。<br><em>react developer tools：是chrome浏览器的一款扩展插件，可以很方便地用来调试react代码。下载地址：chrome应用商店搜索<strong>react developer tools</strong></em></li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fkmho8iwabj30ol07cq36.jpg" alt=""></p>
<p><strong>而<code>react developer tools</code>的工作原理是页面加载的时候，通过<code>__REACT_DEVTOOLS_GLOBAL_HOOK__</code>这个全局变量和页面通信。而我们项目的真实代码其实是写在一个yeoman自带的框架页面之中，也就是一个iframe，这个<code>__REACT_DEVTOOLS_GLOBAL_HOOK__</code>变量其实是存在顶层的框架页面中，如果我们需要在我们的iframe页面中使用这个这个插件，就得重新取得这个全局变量，以供插件来通信。</strong></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fkmhtkh4kuj30mc07bglx.jpg" alt=""></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fkkhieotwnj30mh01zt8p.jpg" alt="这里的parent代表的顶层页面window变量"></p>
<h2 id="webpack配置详解"><a href="#webpack配置详解" class="headerlink" title="webpack配置详解"></a><code>webpack</code>配置详解</h2><p><code>webpack</code>配置代码在<code>cfg/default.js</code>中。</p>
<p><em>目录结构：</em></p>
<ul>
<li><code>default.js</code>:相关<code>loader</code>配置</li>
<li><code>base.js</code>:<code>webpack</code>基本配置。</li>
<li><code>dev.js</code>:本地环境<code>webpack</code>配置。</li>
<li><code>dist.js</code>:正式环境<code>webpack</code>配置。</li>
<li><code>test.js</code>:测试环境<code>webpack</code>配置。</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fkukr0hwrkj307p04da9w.jpg" alt=""></p>
<h3 id="dev环境配置"><a href="#dev环境配置" class="headerlink" title="dev环境配置"></a>dev环境配置</h3><p>dev环境是项目本地调试所需的代码目录。在cfg/dev.js文件中配置相关webpack配置。</p>
<h4 id="plugins参数"><a href="#plugins参数" class="headerlink" title="plugins参数"></a>plugins参数</h4><ul>
<li>webpack.HotModuleReplacementPlugin：用来实现在本地调试项目时的模块热更新的功能</li>
<li>webpack.NoErrorsPlugin：保证编译过程不能出错。</li>
</ul>
<h3 id="dist环境配置"><a href="#dist环境配置" class="headerlink" title="dist环境配置"></a>dist环境配置</h3><p>dist环境是项目正式上线所需的代码目录。在cfg/dist.js文件中配置相关webpack配置。</p>
<h4 id="plugins参数-1"><a href="#plugins参数-1" class="headerlink" title="plugins参数"></a>plugins参数</h4><ul>
<li><code>webpack.optimize.DedupePlugin</code>：用来检测相似的文件，去除输出的<code>js</code>文件中冗余的代码。</li>
<li><code>webpack.optimize.UglifyJsPlugin</code>：压缩输出的<code>js</code>代码。</li>
<li><code>webpack.optimize.OccurenceOrderPlugin</code>：按照引用频度来排序各个模块bundle的id，引用频度越高，id值越短，达到见效文件大小的效果。</li>
<li><code>webpack.optimize.AggressiveMergingPlugin</code>：合并相似的chunk，提取公共部分。</li>
<li><code>webpack.NoErrorsPlugin</code>：保证编译过程不能出错。</li>
</ul>
<h2 id="舞台构建"><a href="#舞台构建" class="headerlink" title="舞台构建"></a>舞台构建</h2><p>开始基于脚手架项目骨架快速搭建项目环境。</p>
<h3 id="autoprefixer-loader"><a href="#autoprefixer-loader" class="headerlink" title="autoprefixer-loader"></a><code>autoprefixer-loader</code></h3><p><code>autoprefixer-loader</code>可以为css表达式自动添加一些浏览器前缀，来达到浏览器兼容的效果。</p>
<ul>
<li>安装loader,并将包写入到项目<code>package.json</code>中的本地依赖中（devDependencies）<ul>
<li>安装<code>autoprefixer-loader</code><pre><code>npm install autoprefixer-loader --save-dev
</code></pre></li>
<li>安装<code>sass-loader</code><br>由于yeoman并没有为我们自动安装处理sass文件相关的loader，我们得手动安装依赖包。<pre><code>npm install sass-loader node-sass webpack --save-dev
</code></pre></li>
</ul>
</li>
<li>修改loader配置<pre><code>{
      test: /\.scss/,
      loader: &#39;style-loader!css-loader!autoprefixer-loader?{browsers:[\&quot;last 2 version\&quot;]}!sass-loader?outputStyle=expanded&#39;
    },
</code></pre></li>
</ul>
<h3 id="引入图片资源"><a href="#引入图片资源" class="headerlink" title="引入图片资源"></a>引入图片资源</h3><ul>
<li>根据<code>VCD</code>原则（<code>V:view, C:controller, D:data</code>），在项目跟目录新建一个data目录存放项目所需的数据文件。<br>新建<code>imageDatas.json</code>文件存放图片文件的信息。<pre><code>[
  {
      &quot;fileName&quot;: &quot;1.jpg&quot;,
      &quot;title&quot;: &quot;heaven of time&quot;,
      &quot;desc&quot;: &quot;here is the heaven of time&quot;
  }
]
</code></pre></li>
<li>入口文件中处理图片信息。<br><strong>构建出的工作环境<code>webpack</code>默认版本为1.x，不包含<code>json-loader</code>.</strong><br><strong>解析<code>.json</code>文件一种解决办法是安装<code>json-loader</code>，并在<code>default.js</code>中配置。<code>json-loader</code></strong><br><strong>另一种解决办法是全局安装webpack2.x及以上版本，自带有<code>json-loader</code></strong><pre><code>npm install -g webpack@2.x
</code></pre><ul>
<li><code>json-loader</code>处理<code>json</code>文件。<ul>
<li>安装<code>json-loader</code><pre><code>npm install --save-dev json-loader
</code></pre></li>
<li>配置<code>json-loader</code><pre><code>  {
test: /\.json$/,
loader: &#39;json-loader&#39;
},
</code></pre>注：require时都必须加上json!前缀</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>let imageDatas = require(&#39;json!../data/imageDatas.json&#39;);
// 利用自执行函数，将图片名信息转成图片URL路径信息
imageDatas = (function genImageURL(imageDatasArr) {
    for (var i = imageDatasArr.length - 1; i &gt;= 0; i--) {
        let singleImageData = imageDatasArr[i];

        singleImageData.imageURL = require(&#39;../images/&#39; + singleImageData.fileName);

        imageDatasArr[i] = singleImageData;
    }
    return imageDatasArr;
})(imageDatas);
</code></pre><ul>
<li>构建页面框架（<code>html</code>， <code>css</code>）<br><em>入口文件</em><pre><code>class AppComponent extends React.Component {
render() {
  return (
    &lt;section className=&quot;stage&quot;&gt;
        &lt;section className=&quot;image-sec&quot;&gt;&lt;/section&gt;
        &lt;nav className=&quot;controller-nav&quot;&gt;&lt;/nav&gt;
    &lt;/section&gt;
  );
}
}
</code></pre><strong>这里创建组件的方式是react最新的语法，支持了es6的class和extend语法。</strong></li>
</ul>
<h2 id="构建图片组件"><a href="#构建图片组件" class="headerlink" title="构建图片组件"></a>构建图片组件</h2><h3 id="构建单个图片组件"><a href="#构建单个图片组件" class="headerlink" title="构建单个图片组件"></a>构建单个图片组件</h3><p>可以看出我们的画廊应用是由一些重复的单个图片组件形成，所以我们可以单独建立单个图片的组件，然后复用这个组件，形成多张图片的样式。</p>
<ul>
<li>创建单个图片组件<pre><code>// 构建单幅画的组件
class ImgFigure extends React.Component {
  render() {
      return (
          &lt;figure className=&#39;img-figure&#39;&gt;
            &lt;img src={this.props.data.imageURL} alt={this.props.data.title} /&gt;
            &lt;figcaption&gt;
              &lt;h2 className=&quot;img-title&quot;&gt;{this.props.data.title}&lt;/h2&gt;
              &lt;div className=&quot;img-back&quot;&gt;
                &lt;p&gt;&lt;/p&gt;
              &lt;/div&gt;
            &lt;/figcaption&gt;
          &lt;/figure&gt;
      );
  }
}
</code></pre><strong><code>figure</code>是h5语义化标签，标签内建议存放<code>自包含</code>（单独拿出也能有意义）的内容，而且其中<code>firgcaptiopn</code>标签可以描述<code>figure</code>内容的标题，很适合现在的场景。</strong></li>
<li><p>通过管理者<code>APPComponent</code>管理数据和数据交换，将组件插入到<code>APPComponent</code>中。</p>
<pre><code>// “大管家”：掌握一切的数据和数据之间的切换
class AppComponent extends React.Component {
render() {
    let controllerUnits = [],
            imgFigures = [];

    imageDatas.forEach( function(value, index) {
        // 用图片数据填充imageFigure组件
        imgFigures.push(&lt;ImgFigure data={value} key={index} ref={&#39;imgFigure&#39; + index}&gt;&lt;/ImgFigure&gt;);
    });

  return (
    &lt;section className=&quot;stage&quot;&gt;
        &lt;section className=&quot;image-sec&quot;&gt;
            {imgFigures}
        &lt;/section&gt;
        &lt;nav className=&quot;controller-nav&quot;&gt;&lt;/nav&gt;
    &lt;/section&gt;
  );
}
}
</code></pre><p><strong>注意：⚠️通过<code>require json</code>文件得到的<code>imageDatas</code>是一个数组对象，react需更新组件时是通过DOM与virtual DOM的对比来实现，如果有变化就重新渲染，因此在每次forEach循环添加节点都应给组件添加一个key，<code>&lt;ImgFigure data={value} key={index} ref={&#39;imgFigure&#39; + index}&gt;&lt;/ImgFigure&gt;)</code>以优化对比</strong><br><strong>REACTC自定义的组件命名必须是大写字母开头，笔者当初被坑了好久。怪我粗心了～</strong></p>
</li>
<li><p>定义组件的样式：</p>
<pre><code>/* image --- start */
.image-sec {
position: relative;
width: 100%;
height: 100%;
overflow: hidden;
background-color: #ddd;
@at-root {
  // at-root 系统mixin会在编译css文件时将内部的选择器放到最外层
  .img-figure {
    position: absolute;

    width: 320px;
    height: 360px;
    margin: 0;
    padding: 40px;

    background-color: #fff;

    box-sizing: border-box;
  }

  figcaption {
    text-align: center;

    .img-title {
      margin-top: 20px;

      color: #a7a0a7;

      font-size: 16px;
    }
  }
}
}
/* image --- end */
</code></pre><p><strong><code>at-root 系统mixin</code>会在编译css文件时将内部的选择器放到最外层,以防止选择器嵌套过深。</strong></p>
</li>
</ul>
<h3 id="划分舞台区域"><a href="#划分舞台区域" class="headerlink" title="划分舞台区域"></a>划分舞台区域</h3><p>将舞台粗略划分为五个区域，左侧区域，右侧区域，上侧区域，下侧区域，中心区域。为了不影响控制组件，图片只显示在左中右三个区域。</p>
<ul>
<li>计算各个区域的范围。</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fkvzl8mgh0j30pq0dtq50.jpg" alt="左分区和右分区位置排布"></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fkvzm1t2m3j30pm0dogn5.jpg" alt="上分区位置排布"></p>
<ul>
<li><p>为组件田间表示范围的常量：    </p>
<pre><code>constructor(props) {
      super(props);

      // 存储排布的可取范围
      this.Constant = {
          // 中心图片的位置点
          centerPos: {
              left: 0,
              right: 0
          },
          // 水平方向的取值范围
          hPosRange: {
              leftSecX: [0, 0],
              rightSecX: [0, 0],
              y: [0, 0]
          },
          // 垂直方向的取值范围
          vPosRange: {
              x: [0, 0],
              topY: [0, 0]
          }
      };
  }
</code></pre><p><strong>注意：这里给组件添加自定义属性使用了es6 class的新语法。</strong></p>
</li>
<li>当组件被渲染进页面时，为每张图片计算其范围：</li>
</ul>
<pre><code>var stageDOM = ReactDOM.findDOMNode(this.refs.stage),
      stageW = stageDOM.scrollWidth,
      stageH = stageDOM.scrollHeight,
      halfStageW = Math.ceil(stageW / 2),
      halfStageH = Math.ceil(stageH / 2);

    // 取得ImgFigure大小
    var imgFigureDOM = ReactDOM.findDOMNode(this.refs.imgFigure0),
      imgW = imgFigureDOM.scrollWidth,
      imgH = imgFigureDOM.scrollHeight,
      halfImgW = Math.ceil(imgW / 2),
      halfImgH = Math.ceil(imgH / 2);

    // 计算中间区域图片排布的位置
    this.Constant.centerPos = {
      left: halfStageW - halfImgW,
      top: halfStageH - halfImgH
    };

    // 计算左、右侧图片排布区域的位置
    this.Constant.hPosRange = {
      leftSecX: [-halfImgW, halfStageW - halfImgW * 3],
      rightSecX: [halfStageW + halfImgW, stageW - halfImgW],
      y: [-halfImgH, stageH - halfImgH]
    };

    // 计算上侧区域图片排布的位置
    this.Constant.vPosRange = {
      topY: [-halfImgH, halfStageH - halfImgH * 3],
      x: [halfStageW - imgW, halfStageW]
    };

    this.rearrange(0);
</code></pre><p><strong>注意：<code>ReactDOM.findDOMNode</code>是<code>REACT</code>顶层结构的全局变量<code>ReactDOM</code>的一个辅助方法，需要单独引入。</strong></p>
<pre><code>- es5写法：
</code></pre><pre><code>var ReactDOM = require(&#39;react-dom&#39;);
</code></pre><pre><code>- es6写法：
</code></pre><pre><code>import ReactDOM from &#39;react-dom&#39;;
</code></pre><ul>
<li><p>给imagdatas的毁掉函数绑定组件到<code>this</code>上，并且给每张图片初始化位置信息。</p>
<pre><code>imageDatas.forEach(function(value, index) {
          // 判断当前图片的位置信息是否已经初始化，如果没有初始化，则初始化图片的位置信息
          if (!this.state.imgsArrangeArr[index]) {
              this.state.imgsArrangeArr[index] = {
                  pos: {
                      left: 0,
                      top: 0
                  }
              }
          }

          // 用图片数据填充imageFigure组件
          imgFigures.push(
              &lt;ImgFigure data={value} key={index} ref={&#39;imgFigure&#39; + index}&gt;&lt;/ImgFigure&gt;
          );
      }.bind(this));
</code></pre></li>
<li><p>创建重新布局的方法：</p>
<pre><code>rearrange(centerIndex) {
      let imgsArrangeArr = this.state.imgsArrangeArr,
          Constant = this.Constant,
          centerPos = Constant.centerPos,
          hPosRange = Constant.hPosRange,
          vPosRange = Constant.vPosRange,
          hPosRangeLeftSecx = hPosRange.leftSecX,
          hPosRangeRightSecx = hPosRange.rightSecX,
          hPosRangeY = hPosRange.y,
          vPosRangeTopY = vPosRange.topY,
          vPosRangex = vPosRange.x,
          // 存储显示在上侧区域的图片信息
          imgsArrangeTopArr = [],
          // 取一个或者不取
          topImgNum = Math.ceil(Math.random() * 2),
          topImgSpliceIndex = 0,
          imgsArrangeCenterArr = imgsArrangeArr.splice(centerIndex, 1);

      // 首先居中centerIndex的图片
      imgsArrangeCenterArr[0].pos = centerPos;

      // 取出要布局上侧的图片的状态信息
      topImgSpliceIndex = Math.ceil(Math.random() * (imgsArrangeArr.length - topImgNum));
      imgsArrangeTopArr = imgsArrangeArr.splice(topImgSpliceIndex, 1);

      // 布局位于上侧的图片
      imgsArrangeTopArr.forEach(function(value, index) {
          imgsArrangeTopArr[index].pos = {
              top: getRangeRandom(vPosRangeTopY[0], vPosRangeTopY[1]),
              left: getRangeRandom(vPosRangex[0], vPosRangex[1])
          }
      });

      // 布局两侧图片
      for (let i = 0, j = imgsArrangeArr.length, k = j / 2; i &lt; j; i++) {
          let hPosRangeLORX = null;

          // 前半部分布局左边，右半部分布局右边
          if (i &lt; k) {
              hPosRangeLORX = hPosRangeLeftSecx;
          } else {
              hPosRangeLORX = hPosRangeRightSecx;
          }

          imgsArrangeArr[i].pos = {
              top: getRangeRandom(hPosRangeY[0], hPosRangeY[1]),
              left: getRangeRandom(hPosRangeLORX[0], hPosRangeLORX[1])
          }
      }

      // 将之前取出来的上侧图片再放回去
      if (imgsArrangeTopArr &amp;&amp; imgsArrangeTopArr[0]) {
          imgsArrangeArr.splice(topImgSpliceIndex, 0, imgsArrangeTopArr[0]);
      }
      // 将之前取出来的中心图片再放回去
      imgsArrangeArr.splice(centerIndex, 0, imgsArrangeCenterArr[0]);

      // 设置state，触发组件的重新渲染
      this.setState({
          imgsArrangeArr: imgsArrangeArr
      });
  }
</code></pre></li>
<li><p>从<code>imgsArrangeArr</code>中取出每张图片新的位置信息，并设置每张图片的新的位置样式，重新渲染组件：</p>
<pre><code>// 构建单幅画的组件
class ImgFigure extends React.Component {
  render() {
      let styleObj = {};

      // 如果props属性中指定了这张图片的位置，则使用
      if (this.props.arrange.pos) {
          styleObj = this.props.arrange.pos;
      }

      return (
          &lt;figure className=&#39;img-figure&#39; style={styleObj}&gt;
                &lt;img src={this.props.data.imageURL} alt={this.props.data.title} /&gt;
                &lt;figcaption&gt;
                      &lt;h2 className=&quot;img-title&quot;&gt;{this.props.data.title}&lt;/h2&gt;
                      &lt;div className=&quot;img-back&quot;&gt;
                        &lt;p&gt;&lt;/p&gt;
                  &lt;/div&gt;
                &lt;/figcaption&gt;
          &lt;/figure&gt;
      );
  }
}
</code></pre></li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这样我们的画廊舞台的基本框架就搭好了，接下来就是给我们的画廊加上动态效果，请移步我的另一片博客。<br><img src="http://ww4.sinaimg.cn/mw690/e75a115bgw1f3rrbzv1m8g209v0diqv7.gif" alt=""></p>
]]></content>
      
        <categories>
            
            <category> react </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> react </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[compass重要功能之精灵图合图]]></title>
      <url>/compass%E9%87%8D%E8%A6%81%E5%8A%9F%E8%83%BD%E4%B9%8B%E7%B2%BE%E7%81%B5%E5%9B%BE%E5%90%88%E5%9B%BE.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>精灵图合图相关功能集合。可以说是compass在日常工程中的最佳实践，非常实用也非常重要。<br><strong>想象一下设计人员（通常是漂亮的小姐姐们～不好意思责怪人家呀=。=）将sprites图中的一个图标，并且很有可能影响到了其他的图标，开发人员就要吐血地在项目中修改所有被影响的样式代码，这真的是巨痛苦无比呀</strong><br><strong>而有了compass的精灵图合图功能，我们只需要将项目中用想要合图的图片文件（现在只支持png格式的文件）放到一个相应的目录下，compass将会自动帮我们把图片文件生成为一个雪碧图，无论这些文件怎么变化，我们都不需要再去更改代码中的内容！</strong><br>精灵图合图可以说是compass的最重要的功能模块，我这里说下我的理解。<br>compass相关的知识请进<a href="http://pancakeawesome.ink/2017/09/28/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E4%B9%8Bcompass/">传送门</a></p>
<h2 id="在compass项目中使用精灵合图功能"><a href="#在compass项目中使用精灵合图功能" class="headerlink" title="在compass项目中使用精灵合图功能"></a>在compass项目中使用精灵合图功能</h2><h3 id="在项目中引入sprites模块"><a href="#在项目中引入sprites模块" class="headerlink" title="在项目中引入sprites模块"></a>在项目中引入sprites模块</h3><ul>
<li>在scss目录下新建一个_icons.scss文件来专门处理项目的雪碧图（个人习惯，也可以写在screen.scss中）</li>
<li>在screen.scss文件中引入_icons.scss，不知道screen.scss文件作用的同学请看我的上一篇<a href="http://pancakeawesome.ink/2017/09/28/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E4%B9%8Bcompass/">博客</a><br>引入sprites模块<pre><code>_icons.scss文件中：
@import &#39;compass/utilities/sprites&#39;;
</code></pre></li>
<li>将一些logo文件放入images文件夹下的logo文件夹，用来作为合图的资源。并在_icons.scss文件中引入。<br><strong>compass会在合图文件夹下生成一个不被写入硬盘的隐藏SCss文件</strong>引这种入方式在compass中被称为<strong>compass import</strong><pre><code>@import &quot;logo/*.png&quot;;
</code></pre><em>意思是引入logo文件夹下的所有格式是png的图片文件，后面字符是compass为合图文件添加的cache-buster</em><br>编译项目，可以看见images文件夹下生成了一张合图文件。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fkfqhk9vakj306w04zmx5.jpg" alt=""></li>
<li>调用all-<code>合图文件的最后一级目录名</code>-sprites这个mixin<pre><code>@include all-logo-sprites()
</code></pre>编译之后，我们会发现相应的css文件中会自动根据合图文件生成一个一个对应的样式类。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fkfqmypiezj30nh0hzaat.jpg" alt=""><br><strong>那么这个mixin是从哪来的呢？</strong><br>其实就是在上面那句<strong>magic import生成的隐藏scss文件中</strong><h3 id="使用合图"><a href="#使用合图" class="headerlink" title="使用合图"></a>使用合图</h3>在index文件中给元素添加生成的相应的css样式即可。<h4 id="其他样式类的元素应用特定的图片样式？"><a href="#其他样式类的元素应用特定的图片样式？" class="headerlink" title="其他样式类的元素应用特定的图片样式？"></a>其他样式类的元素应用特定的图片样式？</h4>只需给相应的样式引入logo-sprite(<code>$图片名</code>)<pre><code>/*
  其余类想使用某张图片，可以不使用这个类名，直接引入图片类即可
*/
.main-logo {
  @include logo-sprite(&#39;btn&#39;);
}
</code></pre><h4 id="元素不同状态下显示不同的图片？"><a href="#元素不同状态下显示不同的图片？" class="headerlink" title="元素不同状态下显示不同的图片？"></a>元素不同状态下显示不同的图片？</h4>只要将合图资源文件命名为<code>文件名_hover</code>的格式（或者<code>active</code>），compass就会自动生成图片设置为<code>文件名</code>样式的不同状态的css。<br><strong><code>-</code>也可以</strong><br><strong>以下代码可以消除以上伪类形容不同状态样式的功能</strong><pre><code>/*
  是否关闭精灵图合图模块默认的伪类样式
*/
$disable-magic-sprite-selectors: true;
</code></pre><h4 id="设置精灵合的排列布局"><a href="#设置精灵合的排列布局" class="headerlink" title="设置精灵合的排列布局"></a>设置精灵合的排列布局</h4>设置<code>logo-layout</code>变量</li>
<li>vertical(垂直（默认布局方式）)</li>
<li>horizontal(水平)</li>
<li>diagonal(斜对角线)</li>
<li>smart(最节省空间的布局方式)<pre><code>/*
  精灵合图的默认排列方式
*/
$logo-layout: smart;
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>compass的精灵图合图功能在实际项目过程中时非常有用的功能，希望大家都能掌握这种技能～谢谢🙏观看～</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端技术 </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[yeoman+bower+gulp/grunt构建现代化前端项目]]></title>
      <url>/yeoman+bower+gulp-grunt%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE.html</url>
      <content type="html"><![CDATA[<p><del>待更新</del></p>
]]></content>
      
        <categories>
            
            <category> 前端工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端必备技能之compass]]></title>
      <url>/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E4%B9%8Bcompass.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先介绍下<a href="http://compass-style.org/" target="_blank" rel="external">compass</a>，compass是一款优秀的开源的<strong>css书写框架</strong>，什么叫书写框架呢？众所周知，<code>sass</code>中有很多便捷的语法特性，比如<code>mixin</code>,<code>function</code>等，<code>compass</code>正是一个强大的函数仓库，compass封装了很多在平常工程过程中能用到的css效果的函数，比如清楚浮动，设置表格样式等等。<br><em>至于sass和css之间的关系请看我的上篇<a href="http://pancakeawesome.ink/2017/09/18/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8sass/">博客</a></em>，讲的很详细。<br><strong>这里是我写的一个compass的demo，可以对照着看</strong><br><strong>如果把<code>sass</code>必做钉子，那么<code>compass</code>就是一个锤子🔨，可以方便快捷地构建你的<code>css</code>工程化代码</strong></p>
<h2 id="compass的安装-amp-amp-项目的构建"><a href="#compass的安装-amp-amp-项目的构建" class="headerlink" title="compass的安装&amp;&amp;项目的构建"></a>compass的安装&amp;&amp;项目的构建</h2><h3 id="compass的安装"><a href="#compass的安装" class="headerlink" title="compass的安装"></a>compass的安装</h3><p>如果你是<code>Mac os</code>系统，那么你的电脑预装了ruby的环境，那么就会有<code>gem</code>这个ruby的包管理器。如果你的电脑是windows的，那么请先安装<code>ruby</code>，具体安装方法我就不赘述了，请大家自行谷歌。</p>
<pre><code>gem install compass
</code></pre><p><em>如果大家在gem install过程中发现速度很慢，甚至卡住了</em>，请谷歌：<strong>gem源</strong>，具体原因我就不说了=,=</p>
<h3 id="compass项目的运行"><a href="#compass项目的运行" class="headerlink" title="compass项目的运行"></a>compass项目的运行</h3><ul>
<li>正式编译，<strong>会将项目目录下的<code>scss</code>文件编译成<code>css</code>文件并执行scss文件中的函数在</strong>命令行环境下：<pre><code>compass compile
</code></pre><em>加上<code>--force</code>会强制编译</em></li>
<li>自动编译，会自动监听文件的更改而随之编译文件。<pre><code>compass watch
</code></pre><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3>下面通过compass搭建你的项目：<pre><code>compass create &lt;project name&gt;
</code></pre>成功之后你会在命令行中查看到compass项目成功搭建的提示：<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fk0rttcy1sj30z70k4ack.jpg" alt=""><br>看一下项目的目录:<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fk0rv00m1dj308b04t0sk.jpg" alt=""><br>这就是compass构建的项目初始目录<h2 id="compass的各大模块"><a href="#compass的各大模块" class="headerlink" title="compass的各大模块"></a>compass的各大模块</h2>compass中有各个功能不一的模块，每个模块都封装了大量的minxin和function。<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fk0s3r3nlpj30ry0dfjrx.jpg" alt=""><br><strong>其中reset模块和layout模块是特殊的核心模块，需要单独制定引入</strong>，<strong>而其他五大模块则只需要引入compass，就自动引入了</strong><pre><code>@import &#39;compass&#39;;
</code></pre><em>下面就分别介绍一下各个核心模块，但是由于精力有限，每个模块我只会介绍一些项目开发过程中常见的功能函数，其他的函数，请直接移步compass的 api <a href="http://compass-style.org/reference/compass/css3/" target="_blank" rel="external">doc</a></em><h2 id="reset模块"><a href="#reset模块" class="headerlink" title="reset模块"></a>reset模块</h2>reset模块是负责将浏览器默认样式统一，以减少浏览器之间差异性。<h3 id="reset模块引入"><a href="#reset模块引入" class="headerlink" title="reset模块引入"></a>reset模块引入</h3>/sass/screen.ccss文件中：<br><strong>screen.scss文件负责站点主体的样式</strong><pre><code>@import &quot;compass/reset&quot;;
</code></pre><h3 id="css样式效果展示"><a href="#css样式效果展示" class="headerlink" title="css样式效果展示"></a>css样式效果展示</h3><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fk0sic433gj30vb0izwg9.jpg" alt=""><h3 id="normalize模块"><a href="#normalize模块" class="headerlink" title="normalize模块"></a>normalize模块</h3><strong>用normalize模块来代替compass默认的reset模块</strong><br>其实可以看出reset模块很粗暴，它会把所有浏览器默认属性重置，这样在实际工程中回造成很多麻烦，我们可以很方便的normalize模块来替代reset,normalize模块会将大多数常用到的标签属性重置。<h4 id="normalize模块-1"><a href="#normalize模块-1" class="headerlink" title="normalize模块"></a>normalize模块</h4>normalize常用的子模块有：</li>
<li>html5模块：用来统一html5属性</li>
<li>base：用来统一一般的html属性</li>
<li>links:用来统一<code>&lt;a&gt;</code>标签相关的属性<h4 id="normalize的安装"><a href="#normalize的安装" class="headerlink" title="normalize的安装"></a>normalize的安装</h4><pre><code>gem install normalize
</code></pre><em>用homebrew，npm也可以安装</em></li>
</ul>
<h4 id="normalize的引入"><a href="#normalize的引入" class="headerlink" title="normalize的引入"></a>normalize的引入</h4><ul>
<li>在工程目录下的<code>config.rb</code>下将normalize通过require语法引入<pre><code>require &#39;compass-normalize&#39;
</code></pre></li>
<li>在screen.scss文件中将normalize模块引入<pre><code>/*
  引入normalize模块
*/
@import &quot;normalize&quot;;
</code></pre><strong>screen.css文件中的生成效果</strong><br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fk0t5ugeiaj30us0gqaat.jpg" alt=""><br>你也可以根据需求分别引入normalize的各个子模块:<br><strong>注意：如果要引入子模块，必须要先引入normalize-version模块</strong><pre><code>/*
  引入normalize子模块之前需要引入normalize-version
*/
@import &quot;normalize-version&quot;;
/*
  normalize子模块一
*/
@import &quot;normalize/html5&quot;;
/*
  normalize子模块二
*/
@import &quot;normalize/base&quot;;
/*
  normalize子模块三
*/
@import &quot;normalize/links&quot;;
</code></pre>具体这些子模块的作用可以去去normalize的官网去查看<a href="https://necolas.github.io/normalize.css/" target="_blank" rel="external">doc</a><br><code>screen.css</code>文件的显示效果:(以html5模块举例)<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fk0tb4jv4lj30vi0ie0tp.jpg" alt=""><h2 id="layout模块"><a href="#layout模块" class="headerlink" title="layout模块"></a>layout模块</h2>如果说reset模块事使用起来最简单的模块（因为只需引进来即可，不需要多余操作），那么layout模块就是使用率最低的模块。layout模块提供页面的布局控制能力。<br><strong>layout模块不属于compass自带的模块，需要在scss文件中单独引入</strong><br>layout模块又分为三个子模块：</li>
<li>grid-background</li>
<li>sticky-footer</li>
<li>stretching<h3 id="grid-background模块："><a href="#grid-background模块：" class="headerlink" title="grid-background模块："></a>grid-background模块：</h3>提供为元素提供定宽定高或者自适应格式宽高的背景的功能。<br><strong>这个功能不常用，在webapp电子书在线阅读等场景需求下可以用到，有需要的去doc仔细看看</strong></li>
<li>引入：<pre><code>@import &#39;compass/layout/grid-background&#39;;
</code></pre></li>
<li>相关mixin：<ul>
<li><strong>grid-background($total, $column, $gutter, $baseline, $offset, $column-color, $gutter-color, $baseline-color, $force-fluid)</strong><ul>
<li>功能：提供为元素提供定宽定高或者自适应格式宽高的背景的功能</li>
<li>参数：</li>
<li>示例：<pre><code>screen.scss文件:
/*
grid-background模块
*/
#root {
@include grid-background();
}
</code></pre>screen.css文件中:<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fk5dydolwaj30tu0gugoy.jpg" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="stretching模块："><a href="#stretching模块：" class="headerlink" title="stretching模块："></a>stretching模块：</h3><p>提供子元素拉伸填满整个父元素的能力。</p>
<ul>
<li>引入：<pre><code>@import &#39;compass/layout/stetching&#39;;
</code></pre></li>
<li>相关mixin：<ul>
<li><strong>stretch($offset-top, $offset-right, $offset-bottom, $offset-left)</strong><ul>
<li>功能：将子元素填满父元素</li>
<li>参数：绝对定位上右下左的位置</li>
<li>示例：<pre><code>screen.scss文件:
/*
stretching模块
*/
.stretch-full {
@include stretch();
}
screen.css文件中:
/* line 119, ../sass/screen.scss */
.stretch-full {
position: absolute;
top: 0;
bottom: 0;
left: 0;
right: 0;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="sticky-footer模块"><a href="#sticky-footer模块" class="headerlink" title="sticky-footer模块"></a>sticky-footer模块</h3><p>提供页面中的页脚始终在页面最底部的功能：<br>提供子元素拉伸填满整个父元素的能力。</p>
<ul>
<li>引入：<ul>
<li>在html文件中引入以下标签：<pre><code>&lt;body&gt;
&lt;div id=&quot;root&quot;&gt;
&lt;div id=&quot;root_footer&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;footer&quot;&gt;
Footer content goes here.
&lt;/div&gt;
&lt;/body&gt;
</code></pre></li>
<li>在screen.scss文件中引入footer模块<pre><code>@import &#39;compass/layout/sticky-footer&#39;;
</code></pre></li>
</ul>
</li>
<li>相关mixin：<ul>
<li><strong>sticky-footer($footer-height, $root-selector, $root-footer-selector, $footer-selector)</strong><ul>
<li>功能：当主体内容不超过浏览器窗口大小时，页脚始终在窗口底部；当主体内容超过浏览器窗口大小时，页脚将随浏览器内容在页面底部</li>
<li>参数：footer的高度</li>
<li>示例：<pre><code>screen.scss文件:
/*
sticky-footer模块
*/
@include sticky-footer(30px);
screen.css文件中:
html, body {
height: 100%;
}
#root {
clear: both;
min-height: 100%;
height: auto !important;
height: 100%;
margin-bottom: -30px;
}
#root #root_footer {
height: 30px;
}
#footer {
clear: both;
position: relative;
height: 30px;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="css3-amp-amp-browser-support模块"><a href="#css3-amp-amp-browser-support模块" class="headerlink" title="css3&amp;&amp;browser support模块"></a>css3&amp;&amp;browser support模块</h2><p>css3模块:提供css3特性的一些功能函数，support模块提供规定compass支持哪些浏览器的功能。如果说layout模块使用率最低，那么css3一定是主动使用率最高的模块，因为我们在使用css特性时，都会用到browser support模块来做浏览器的兼容,配置compass模块默认支持哪些浏览器。<br>引入css3模块：</p>
<pre><code>@import &quot;compass/css3&quot;;
</code></pre><p>引入browser support模块：<br><em>其实可以不用引入，因为css3模块自动引入support模块</em></p>
<pre><code>@import &quot;compass/support&quot;;
</code></pre><h3 id="常用的browser-support子功能："><a href="#常用的browser-support子功能：" class="headerlink" title="常用的browser support子功能："></a>常用的browser support子功能：</h3><p><strong>介绍一些常用的，其他的请看官网的doc</strong></p>
<ul>
<li><strong>browsers()</strong><ul>
<li>返回值是compass目前版本支持的浏览器list</li>
</ul>
</li>
<li><strong>$supported-browsers: chrome,ie</strong><ul>
<li>功能：声明compass支持的浏览器list</li>
<li>参数：浏览器的list（逗号分隔）</li>
</ul>
</li>
<li><strong>$browser-minimum-versions: (“ie”: “8”);</strong><ul>
<li>功能：声明compass支持的最低浏览器版本</li>
<li>参数：浏览器和版本号对应的键值对（map形式）</li>
</ul>
</li>
</ul>
<h3 id="常用的css3子功能："><a href="#常用的css3子功能：" class="headerlink" title="常用的css3子功能："></a>常用的css3子功能：</h3><p><strong>介绍一些常用的，其他的请看官网的doc</strong><br><strong>所有的css属性的编译结果（css文件中）都是依照support模块设置的浏览器版本</strong><br><em>我的实例结果都是在没有设置support中的功能前提下而得出的</em></p>
<ul>
<li><p><strong>box-shadow</strong></p>
<ul>
<li>box-shadow()<ul>
<li>功能：添加元素的box-shadow样式，并自动根据browsersupport中的浏览器，添加浏览器前缀</li>
<li>参数：上右下左边框阴影样式的高度和颜色</li>
<li>示例：<pre><code>screen.scss文件:
.webdemo-sec {
@include box-shadow(1px 2px 3px 4px #cfcecf);
}
screen.css文件中:
.webdemo-sec {
-moz-box-shadow: 1px 2px 3px 4px #cfcecf;
-webkit-box-shadow: 1px 2px 3px 4px #cfcecf;
box-shadow: 1px 2px 3px 4px #cfcecf;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>opacity</strong></p>
<ul>
<li>opacity($opacity)<ul>
<li>功能：提供元素透明度样式的功能</li>
<li>参数：透明度</li>
<li>示例：<pre><code>screen.scss文件:
.opacity-test {
@include opacity(.5);
}
screen.css文件中:
.opacity-test {
filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=50);
opacity: 0.5;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>inline-block</strong></p>
<ul>
<li>inline-block($alignment, $ie-alignment)<ul>
<li>功能：提供元素display是inline-block的功能（兼容）</li>
<li>参数：</li>
<li>示例：<pre><code>screen.scss文件:
.inlineblock-test {
@include inline-block();
}
screen.css文件中:
.inlineblock-test {
display: inline-block;
vertical-align: middle;
*vertical-align: auto;
*zoom: 1;
*display: inline;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>flex</strong><br><strong>提供相关flexbox布局特性的功能并做浏览器兼容，这个我经常用到很好用</strong></p>
<ul>
<li>相关mixin<ul>
<li>display-flex($display)</li>
<li>flex-direction($direction)</li>
<li>justify-content($justify-content)</li>
<li>align-items($align-items)</li>
<li>功能：提供相关flexbox布局特性的功能并做浏览器兼容</li>
<li>参数：</li>
<li>示例：<pre><code>screen.scss文件:
.flex-test {
@include display-flex();
@include flex-direction(row);
@include justify-content(center);
@include align-items(center);
}
screen.css文件中:
.flex-test {
display: -webkit-flex;
display: flex;
-webkit-flex-direction: row;
flex-direction: row;
-webkit-justify-content: center;
justify-content: center;
-webkit-align-items: center;
align-items: center;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="typography模块"><a href="#typography模块" class="headerlink" title="typography模块"></a>typography模块</h2><p>typography模块主要用来修饰文本样式，垂直韵律等。<br>typography又分为四个子模块：</p>
<ul>
<li>links</li>
<li>list</li>
<li>text</li>
<li>vertical rhythm</li>
</ul>
<p>引入typography模块：</p>
<pre><code>@import &quot;compass/typography&quot;;
</code></pre><h3 id="links子模块："><a href="#links子模块：" class="headerlink" title="links子模块："></a>links子模块：</h3><p>修饰<code>&lt;a&gt;</code>标签超链接的样式。<br>我们对<code>&lt;a&gt;</code>标签通常有两种场景修饰它的样式：</p>
<ul>
<li><p><strong>hover-link()</strong></p>
<ul>
<li>功能：正常状态下掉下划线，hover和focus状态下才显示a标签的下划线<ul>
<li>参数：</li>
<li>示例：<pre><code>screen.scss文件:
a {
@include hover-link(); 
}
screen.css文件中:
a {
text-decoration: none;
}
a:hover, a:focus {
text-decoration: underline;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>不同状态下改变a标签的颜色</p>
<ul>
<li><strong>link-colors($normal, $hover, $active, $visited, $focus)</strong><ul>
<li>功能：修改不同状态下超链接的颜色</li>
<li>参数：不同状态下超链接的颜色，只有第一个参数是必须的</li>
<li>示例：<pre><code>screen.scss文件:
a {
@include link-colors(#cc0, #c0c, #0cc, #00c, #c00);
}
screen.css文件中:
a {
color: #cc0;
}
a:visited {
color: #00c;
}
a:focus {
color: #c00;
}
a:hover {
color: #c0c;
}
a:active {
color: #0cc;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>unstyled-link()</strong></p>
<pre><code>  -     功能：消除超链接原来的样式，让其在非正常状态的样式和其所在文本一样
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
a {
  @include unstyled-link();
}
screen.css文件中:
a {
color: inherit;
text-decoration: inherit;
cursor: inherit;
}
a:active, a:focus {
outline: none;
}
</code></pre></li>
</ul>
<h3 id="list子模块"><a href="#list子模块" class="headerlink" title="list子模块"></a>list子模块</h3><p>修饰<code>ul</code>和<code>ol</code>列表的样式。</p>
<ul>
<li><p><strong>no-bullets()</strong></p>
<pre><code>  -     功能：消除`ul`和`ol`元素之前所有`li`的默认点的样式。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.list-unstyled {
  @include no-bullets();
}
screen.css文件中:
.list-unstyled {
list-style: none;
}
.list-unstyled li {
list-style-image: none;
list-style-type: none;
margin-left: 0;
}
</code></pre></li>
<li><p><strong>no-bullet()</strong></p>
<pre><code>  -     功能：消除`ul`和`ol`元素之前单个`li`的默认点的样式。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.list-unstyled-list {
  @include no-bullet();
}
screen.css文件中:
.list-unstyled-list {
list-style-image: none;
list-style-type: none;
margin-left: 0;
}
</code></pre></li>
<li><p><strong>inline-list()</strong></p>
<pre><code>  -     功能：通过设置`li`元素的display值为inline,实现横向`ul`或`ol`列表的样式。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.list-inline {
  @include inline-list();
}
screen.css文件中:
.list-inline {
list-style-type: none;
}
.list-inline, .list-inline li {
margin: 0;
padding: 0;
display: inline;
}
</code></pre></li>
<li><p><strong>horizontal-list(0, right)</strong></p>
<pre><code>  -     功能：相比于上例，我们要实现横向list时，由于上例的li都是inline的样式，所有没有高度，这样我们想给li设置一些必须有高度的样式修饰时，就会出现麻烦，horizontal-list()这个mixin可以通过浮动的方式实现横向list且每个li都有高度。
  -     参数：第一个参数时li元素padding的值，第二个元素浮动的方向，设置成false，不设置padding值以兼容ie
  -     示例：
</code></pre><pre><code>screen.scss文件:
.list-horizontal {
  @include horizontal-list(0, right);
}
screen.css文件中:
.list-horizontal {
margin: 0;
padding: 0;
border: 0;
overflow: hidden;
*zoom: 1;
}
.list-horizontal li {
list-style-image: none;
list-style-type: none;
margin-left: 0;
white-space: nowrap;
float: right;
display: inline;
padding-left: 0;
padding-right: 0;
}
.list-horizontal li:first-child, .list-horizontal li.first {
padding-right: 0;
}
.list-horizontal li:last-child {
padding-left: 0;
}
.list-horizontal li.last {
padding-left: 0;
}
</code></pre></li>
<li><p><strong>horizontal-list(0, right)</strong></p>
<pre><code>  -     功能：通过设置li元素为的display属性为inline-block来实现横向list。
  -     参数：li的padding值
  -     示例：
</code></pre><pre><code>screen.scss文件:
.list-inline-block {
  @include inline-block(7px);
}
screen.css文件中:
.list-inline-block {
display: inline-block;
vertical-align: 7px;
*vertical-align: auto;
*zoom: 1;
*display: inline;
}
</code></pre></li>
</ul>
<h3 id="text子模块"><a href="#text子模块" class="headerlink" title="text子模块"></a>text子模块</h3><p>文本操作，操作过长文本的样式。</p>
<ul>
<li><p><strong>force-wrap()</strong></p>
<pre><code>  -     功能：强行使长文本换行。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.wrap-text {
  @include force-wrap();
}
screen.css文件中:
.wrap-text {
white-space: pre;
white-space: pre-wrap;
white-space: pre-line;
white-space: -pre-wrap;
white-space: -o-pre-wrap;
white-space: -moz-pre-wrap;
white-space: -hp-pre-wrap;
word-wrap: break-word;
}
</code></pre></li>
<li><p><strong>nowrap()</strong></p>
<pre><code>  -     功能：无论何时都不换行。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.nowrap-text {
  @include nowrap();
}
screen.css文件中:
.nowrap-text {
white-space: nowrap;
}
</code></pre></li>
<li><p><strong>ellipsis()</strong></p>
<pre><code>  -     功能：不换行的时候文本超出容器的宽度，出现省略号。
</code></pre><ul>
<li>引入： firefox不能很好的支持text-overflow属性，所以需要相关的xml文件来hack，compass已经封装好了，直接引用就好</li>
</ul>
</li>
</ul>
<pre><code>compass install compass/ellipsis
</code></pre><pre><code>    -     参数：
    -     示例：
</code></pre><pre><code>screen.scss文件:
$use-mozilla-ellipsis-binding: true;
.text-ellipsis {
    @include ellipsis();
}
screen.css文件中:
.text-ellipsis {
  white-space: nowrap;
  overflow: hidden;
  -ms-text-overflow: ellipsis;
  -o-text-overflow: ellipsis;
  text-overflow: ellipsis;
  -moz-binding: url(&#39;xml/ellipsis.xml#ellipsis&#39;);
}
</code></pre><ul>
<li><p><strong>hide-text()</strong></p>
<pre><code>  -     功能：背景图片和标签文本重复时，隐藏标签文本，用图片替换文本内容，这个mixin用来隐藏文字。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.text-hide {
  @include hide-text();
}
screen.css文件中:
.text-hide {
text-indent: -119988px;
overflow: hidden;
text-align: left;
text-transform: capitalize;
}
</code></pre></li>
<li><p><strong>squish-text()</strong></p>
<pre><code>  -     功能：功能同上，字体设置为透明，来隐藏文字。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.text-hide {
  @include squish-text();
}
screen.css文件中:
.text-hide {
font: 0/0 serif;
text-shadow: none;
color: transparent;
}
</code></pre></li>
<li><p><strong>replace-text()</strong></p>
<pre><code>  -     功能：隐藏文字后，添加背景图片。
  -     参数：第一个参数是图片的url地址（可以使服务器资源的地址也可以是本地图片的地址），第二个和第三个参数是图片的background-position的值。
  -     示例：
</code></pre><pre><code>screen.scss文件:
.bind-img {
  @include replace-text(&quot;http://img3.mukewang.com/5452ffeb0001b82401000100-40-40.jpg&quot;, 50%, .50%);
}
screen.css文件中:
.bind-img {
text-indent: -119988px;
overflow: hidden;
text-align: left;
text-transform: capitalize;
background-image: url(http://img3.mukewang.com/5452ffeb0001b82401000100-40-40.jpg);
background-repeat: no-repeat;
background-position: 50% 0.5%;
}
</code></pre></li>
<li><p><strong>replace-text-with-dimensions()</strong></p>
<pre><code>  -     功能：功能同上，但是会自动隐藏超出容器的多余图片的边框。
  -     参数：第一个参数是图片的url地址（可以使服务器资源的地址也可以是本地图片的地址）
  -     示例：
</code></pre><pre><code>screen.scss文件:
.bind-img {
  @include replace-text-with-dimensions(image-url(&#39;1503616769997479025.jpg&#39;));
}
screen.css文件中:
.bind-img {
text-indent: -119988px;
overflow: hidden;
text-align: left;
text-transform: capitalize;
background-image: url(http://img3.mukewang.com/5452ffeb0001b82401000100-40-40.jpg);
background-repeat: no-repeat;
background-position: 50% 0.5%;
}
</code></pre></li>
</ul>
<h3 id="vertical-rythm子模块"><a href="#vertical-rythm子模块" class="headerlink" title="vertical rythm子模块"></a>vertical rythm子模块</h3><p>修饰文本的垂直韵律。修饰文本行与行之间的样式。<br><em>这个功能不是很长用到，如果做页面大段文本布局的童鞋可以深入理解一下，请入doc <a href="http://compass-style.org/reference/compass/typography/" target="_blank" rel="external">api</a></em></p>
<h2 id="helpers模块"><a href="#helpers模块" class="headerlink" title="helpers模块"></a>helpers模块</h2><p>helpers模块是用来提供许多工具function的内部模块。<br><strong>helpers模块中有很多不适很常用的function，这里不多讲，如果有需要的童鞋请进入doc <a href="http://compass-style.org/reference/compass/typography/" target="_blank" rel="external">api</a></strong><br><strong>这里只介绍常用的功能</strong><br><strong>安装</strong>：</p>
<pre><code>compass install helpers
</code></pre><p><strong>引入</strong>：</p>
<pre><code>@import &#39;compass/helpers&#39;;
</code></pre><h3 id="inline-image"><a href="#inline-image" class="headerlink" title="inline-image()"></a>inline-image()</h3><pre><code>    -     功能：将图片base64编码压缩。
    -     参数：图片本地地址
    -     示例：
</code></pre><pre><code>screen.scss文件:
.analyze-logo {    
    background-image: inline-image(&#39;1503616769997479025.jpg&#39;);
}
</code></pre><p><em>screen.css</em>文件中:<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fkdgggqdmxj30zk0ewn0k.jpg" alt=""><br><strong>这种方法会很消耗内存，在项目中不适很常用到，compass的另一个比较常用的模块–精灵合图绘很适合这样的场景，大力推荐！</strong></p>
<h3 id="image-url"><a href="#image-url" class="headerlink" title="image-url()"></a>image-url()</h3><pre><code>    -     功能：直接使用文件的名称来代替文件的本地路径，compass会直接根据config.rb文件中配置来寻路，并且可以给生成css文件中图片地址加上cache-buster（时间戳和版本号，通常在图片路径中问号的后面。图片每次更新都会更改这个值。会造成大量的缓存垃圾。）
    -     参数：图片本地地址
    -     注意：这里的参数直接使用了图片的文件名称，相对路径图片的引用自动根据图片改变而改变,URL后面的cache会据config中的httppath配置项去自动加上http域名,config文件中的relative-assets配置项来配置是否使用相对路径来引用资源文件。
</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fkdgorxruoj30ma07eq3c.jpg" alt=""></p>
<pre><code>    -     示例：
</code></pre><pre><code>screen.scss文件:
.analyze-logo {
    background-image: image-url(&#39;1503616769997479025.jpg&#39;);
}
screen.css文件中:
.analyze-logo {
  background-image: url(&#39;../images/1503616769997479025.jpg?1506223791&#39;);
}
</code></pre><p><strong>功能类似的还有stylesheet-url和font-url用来指向css目录和font目录，可以查询doc api</strong></p>
<h3 id="font-files"><a href="#font-files" class="headerlink" title="font-files()"></a>font-files()</h3><pre><code>    -     功能：在项目目录中寻路font字体文件，并加上cache-buster
    -     参数：font字体文件的文件名列表
    -     注意：**在config.rb文件中配置font字体文件的路径。**
</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fkdh3hrs8kj309u0drjrq.jpg" alt=""></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fkdgorxruoj30ma07eq3c.jpg" alt=""></p>
<pre><code>    -     示例：
</code></pre><pre><code>screen.scss文件:
@debug font-files(&quot;fontawesome-webfont.eot&quot;, &quot;fontawesome-webfont.ttf&quot;, &quot;fontawesome-webfont.svg&quot;, &quot;fontawesome-webfont.woff&quot;, &quot;FontAwesome.otf&quot;);
</code></pre><p>命令行中：<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fkdgzlxvuaj313h046t9h.jpg" alt=""></p>
<h3 id="font-face"><a href="#font-face" class="headerlink" title="font-face()"></a>font-face()</h3><pre><code>    -     功能：相比于font-url，font-face会额外根据字体文件帮我们生成对应的format的值
    -     参数：字体文件的url，可以和font-files配合
    -     示例：
</code></pre><pre><code>screen.scss文件:
@include font-face(&quot;FontAwesome&quot;,
font-files(&quot;fontawesome-webfont.eot&quot;, &quot;fontawesome-webfont.ttf&quot;, &quot;fontawesome-webfont.svg&quot;, &quot;fontawesome-webfont.woff&quot;, &quot;FontAwesome.otf&quot;));
screen.css文件中:
@font-face {
  font-family: &quot;FontAwesome&quot;;
  src: url(&#39;../fonts/fontawesome-webfont.eot?1478142484&#39;) format(&#39;embedded-opentype&#39;), url(&#39;../fonts/fontawesome-webfont.ttf?1478142484&#39;) format(&#39;truetype&#39;), url(&#39;../fonts/fontawesome-webfont.svg?1478142484&#39;) format(&#39;svg&#39;), url(&#39;../fonts/fontawesome-webfont.woff?1478142484&#39;) format(&#39;woff&#39;), url(&#39;../fonts/FontAwesome.otf?1478142484&#39;) format(&#39;opentype&#39;);
}
</code></pre><p>命令行中：<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fkdgzlxvuaj313h046t9h.jpg" alt="3123"></p>
<h3 id="append-selector"><a href="#append-selector" class="headerlink" title="append-selector()"></a>append-selector()</h3><pre><code>    -     功能：将选择器嵌套起来
    -     参数： 将第二个选择弃嵌套到第一个参数的选择器中
    -     注意：**在选择器里面要引用sass的变量需要加上#{}sass的变量包裹器**
    -     示例：
</code></pre><pre><code>screen.scss文件:
#{append-selector(&#39;p, span, div&#39;, &#39;.bar&#39;)} {
    color: #000;
}
screen.css文件中:
p.bar, span.bar, div.bar {
  color: #000;
}
</code></pre><h2 id="utilities模块"><a href="#utilities模块" class="headerlink" title="utilities模块"></a>utilities模块</h2><p>辅助工具类🔧的模块。与helpers模块不同的是，utilities模块都是mixin。<br><em>引入：</em></p>
<pre><code>@import &#39;compass/utilities&#39;;
</code></pre><p>utilities模块又分为以下5个子模块：</p>
<ul>
<li>color</li>
<li>generak</li>
<li>print</li>
<li>tables</li>
<li><strong>sprites</strong>（精灵图合图相关工具的集合,<strong>这个功能模块是使用compass的重中之重！</strong>详见我的另一篇博客）</li>
</ul>
<h3 id="color子模块"><a href="#color子模块" class="headerlink" title="color子模块"></a>color子模块</h3><p>颜色相关的模块。</p>
<ul>
<li><strong>brightness()</strong><pre><code>  -     功能：返回相关颜色的亮度值，计算hsl的亮度值（l）
  -     参数：色值
</code></pre></li>
</ul>
<h3 id="print子模块"><a href="#print子模块" class="headerlink" title="print子模块"></a>print子模块</h3><p>打印场景下相关功能的模块。这个场景很少见，估计是打印页面相关的样式。</p>
<ul>
<li><strong>print-utilities();</strong><pre><code>  -     功能：适配打印页面。产生打印页面才显示的样式。
  -     参数：media文件，默认print.
  -     注意：**需要print.scss中做适配**
</code></pre><ul>
<li>引入    ：</li>
</ul>
</li>
</ul>
<pre><code>index.html文件中：
&lt;link href=&quot;stylesheets/print.css&quot; media=&quot;print&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;
</code></pre><pre><code>-     示例
</code></pre><pre><code>print.scss文件中：
@import &quot;compass/utilities/print&quot;;

@include print-utilities();
screen.scss文件:
@include print-utilities(screen);
screen.css文件中:
.print-only {
  display: none;
}
</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fkdhvt5ihdj31240lemzn.jpg" alt="print.css文件"></p>
<h3 id="tables子模块"><a href="#tables子模块" class="headerlink" title="tables子模块"></a>tables子模块</h3><p>table样式的相关样式集合。<br><em>用一个实例来说明这些mixin</em><br><strong>需要在index.html文件中引入相关格式的html代码：</strong></p>
<pre><code>index.html文件中：
&lt;div class=&#39;example&#39;&gt;
    &lt;table class=&quot;good-price&quot; cellspacing=&#39;0&#39;&gt;
        &lt;thead&gt;
            &lt;tr class=&#39;odd&#39;&gt;
                &lt;th&gt;Title&lt;/th&gt;
                &lt;th&gt;One&lt;/th&gt;
                &lt;th&gt;Two&lt;/th&gt;
                &lt;th&gt;Three&lt;/th&gt;
                &lt;th&gt;Four&lt;/th&gt;
                &lt;th&gt;Row Total&lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            &lt;tr class=&#39;even&#39;&gt;
                &lt;th&gt;Single&lt;/th&gt;
                &lt;td class=&#39;numeric&#39;&gt;1.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;2.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;3.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;4.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;10.0&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr class=&#39;odd&#39;&gt;
                &lt;th&gt;Tens&lt;/th&gt;
                &lt;td class=&#39;numeric&#39;&gt;10.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;20.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;30.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;40.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;100.0&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/tbody&gt;
        &lt;tfoot&gt;
            &lt;tr class=&#39;even&#39;&gt;
                &lt;th&gt;Total&lt;/th&gt;
                &lt;td class=&#39;numeric&#39;&gt;11.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;22.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;33.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;44.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;110.0&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/tfoot&gt;
    &lt;/table&gt;
&lt;/div&gt;
</code></pre><pre><code>screen.scss文件中：
.good-price {
    $table-color: #7a98c6;

    @include outer-table-borders();
    @include inner-table-borders(1px,darken($table-color, 40%)); 
    // th标题居中对齐，普通文本左对齐，竖直右对齐，并填充padding
    @include table-scaffolding(); 
    // 奇偶行不同色，相邻纵列不同色
    @include alternating-rows-and-columns($table-color,adjust-hue($table-color, -120deg),#222222);
}
screen.css文件中：
.good-price {
  border: 2px solid black;
}
.good-price thead th {
  border-bottom: 2px solid black;
}
.good-price tfoot th, .good-price tfoot td {
  border-top: 2px solid black;
}
.good-price th:first-child, .good-price th.first {
  border-right: 2px solid black;
}
.good-price th, .good-price td {
  border-right: 1px solid #233551;
  border-bottom: 1px solid #233551;
  border-left-width: 0;
  border-top-width: 0;
}
.good-price th:last-child, .good-price td:last-child {
  border-right-width: 0;
}
.good-price th.last, .good-price td.last {
  border-right-width: 0;
}
.good-price tbody tr:last-child th, .good-price tbody tr:last-child td, .good-price tfoot tr:last-child th, .good-price tfoot tr:last-child td {
  border-bottom-width: 0;
}
.good-price tbody tr.last th, .good-price tbody tr.last td, .good-price tfoot tr.last th, .good-price tfoot tr.last td {
  border-bottom-width: 0;
}
.good-price th {
  text-align: center;
  font-weight: bold;
}
.good-price td,
.good-price th {
  padding: 2px;
}
.good-price td.numeric,
.good-price th.numeric {
  text-align: right;
}
.good-price th {
  background-color: white;
}
.good-price th.even, .good-price th:nth-child(2n) {
  background-color: #dddddd;
}
.good-price tr.odd td, .good-price tr:nth-child(2n+1) td {
  background-color: #98c67a;
}
.good-price tr.odd td.even, .good-price tr.odd td:nth-child(2n), .good-price tr:nth-child(2n+1) td.even, .good-price tr:nth-child(2n+1) td:nth-child(2n) {
  background-color: #76a458;
}
.good-price tr.even td {
  background-color: #7a98c6;
}
.good-price tr.even td.even, .good-price tr.even td:nth-child(2n) {
  background-color: #5876a4;
}
.good-price tfoot th, .good-price tfoot td {
  background-color: white;
}
.good-price tfoot th.even, .good-price tfoot th:nth-child(2n), .good-price tfoot td.even, .good-price tfoot td:nth-child(2n) {
  background-color: #dddddd;
}
</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fkdic3j8rmj30cp04iq34.jpg" alt="table样式"></p>
<h3 id="general子模块"><a href="#general子模块" class="headerlink" title="general子模块"></a>general子模块</h3><p>一些常见的样式的相关样式集合。</p>
<ul>
<li><p><strong>clearfix()</strong></p>
<pre><code>  -     功能：overflow:hidden的方法清除浮动。
  -     示例
</code></pre><pre><code>screen.scss文件:
.clearfix {
  @include pie-clearfix();
}
screen.css文件中:
.clearfix {
  /*
      子元素超出父元素会overflow: hidden
   */
overflow: hidden;
*zoom: 1;
}
</code></pre></li>
<li><p><strong>pie-clearfix()</strong></p>
<pre><code>  -     功能：伪类的方法清除浮动。
  -     示例
</code></pre><pre><code>screen.scss文件:
.clearfix {
  @include pie-clearfix();
}
screen.css文件中:
.clearfix {
*zoom: 1;
}
.clearfix:after {
content: &quot;&quot;;
display: table;
clear: both;
}
</code></pre></li>
<li><p><strong>float()</strong></p>
<pre><code>  -     功能：根据你在browser support中配置的浏览器环境，兼容ie6浮动布局。
</code></pre><ul>
<li>注意：需要在browser support中配置</li>
</ul>
</li>
</ul>
<pre><code>$browser-minimum-versions: (&quot;ie&quot;: &quot;6&quot;);
</code></pre><pre><code>- 参数：浮动的方向
    -     示例
</code></pre><pre><code>screen.scss文件:
.pull-left {
    @include float(left);
}
screen.css文件中:
.pull-left {
  float: left;
  display: inline;
}
</code></pre><h4 id="hacks子模块"><a href="#hacks子模块" class="headerlink" title="hacks子模块"></a>hacks子模块</h4><p>很多兼容ie的hack集合。</p>
<ul>
<li><p><strong>has-layout()</strong></p>
<pre><code>  -     功能：激活兼容ie属性。
</code></pre><ul>
<li>参数：激活ie的方式，推荐zoom         <ul>
<li>示例<pre><code>screen.scss文件:
.need-has-layout {
@include has-layout();
}
screen.css文件中:
.need-has-layout {
*zoom: 1;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>underscore-hack()</strong></p>
<pre><code>  -     功能：正常情况下属性是某种值，ie下hack成另一种值。
</code></pre><ul>
<li>参数：第一个参数是属性的key，第二个是正常情况下的value，第三个是hack情况下的value        <ul>
<li>示例：<pre><code>screen.scss文件:
.underscore-hack-display {
@include underscore-hack(display,block,inline);
}
screen.css文件中:
.underscore-hack-display {
display: block;
_display: inline;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>min-height()</strong></p>
<pre><code>  -     功能：下划线的方式hack min-height和min-width属性。
</code></pre><ul>
<li>参数：相应的height或者width值<ul>
<li>示例：<pre><code>screen.scss文件:
.test-min-height {
@include min-height(10px);
}
screen.css文件中:
.test-min-height {
min-height: 10px;
height: auto;
_height: 10px;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="标签云模块"><a href="#标签云模块" class="headerlink" title="标签云模块"></a>标签云模块</h4><p>compass封装了一个简单的标签云功能模块，以一个例子来说明：</p>
<pre><code>screen.scss文件:
.tag-cloud-container {
    @include tag-cloud(24px);
}
screen.css文件中:
.tag-cloud-container {
  font-size: 24px;
  line-height: 28.8px;
}
.tag-cloud-container .xxs, .tag-cloud-container .xs, .tag-cloud-container .s, .tag-cloud-container .l, .tag-cloud-container .xl, .tag-cloud-container .xxl {
  line-height: 28.8px;
}
.tag-cloud-container .xxs {
  font-size: 12px;
}
.tag-cloud-container .xs {
  font-size: 16px;
}
.tag-cloud-container .s {
  font-size: 18px;
}
.tag-cloud-container .l {
  font-size: 32px;
}
.tag-cloud-container .xl {
  font-size: 36px;
}
.tag-cloud-container .xxl {
  font-size: 48px;
}
</code></pre><p><strong>在index.html文件中不同的标签加上不同的类，从而实现一个简单的标签云，效果如下：</strong><br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fkdj3zidjrj316c0qp0uz.jpg" alt="index.html"></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fkdj344tjyj30lp017q2v.jpg" alt="标签云效果demo"></p>
<h2 id="sprites模块"><a href="#sprites模块" class="headerlink" title="sprites模块"></a>sprites模块</h2><p>精灵图合图相关功能集合。可以说是compass在日常工程中的最佳实践，非常实用也非常重要。<br><strong>想象一下设计人员（通常是漂亮的小姐姐们～不好意思责怪人家呀=。=）将sprites图中的一个图标，并且很有可能影响到了其他的图标，开发人员就要吐血地在项目中修改所有被影响的样式代码，这真的是巨痛苦无比呀</strong><br>由于sprites模块很重要，我将它放到了另外一个博客中，以便详细讲解～<a href="http://pancakeawesome.ink/2017/10/10/compass%E9%87%8D%E8%A6%81%E5%8A%9F%E8%83%BD%E4%B9%8B%E7%B2%BE%E7%81%B5%E5%9B%BE%E5%90%88%E5%9B%BE/">传送门</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>compass是一个很好用的前端自动化工具，它给sass插上了一双翅膀，极大地提高了我们的开发效率！<br><strong>这里是我写的一个compass的demo，可以对照着看</strong></p>
]]></content>
      
        <categories>
            
            <category> 前端工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端技术 </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo+githubio+material搭建你的个人博客网站（优化篇）]]></title>
      <url>/hexo+githubio+material%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99(%E4%BC%98%E5%8C%96%E7%AF%87).html</url>
      <content type="html"><![CDATA[<h2 id="网站-SEO-优化—如何让你的博客在搜索结果中排名第一"><a href="#网站-SEO-优化—如何让你的博客在搜索结果中排名第一" class="headerlink" title="网站 SEO 优化—如何让你的博客在搜索结果中排名第一"></a>网站 SEO 优化—如何让你的博客在搜索结果中排名第一</h2><p>关于网站 SEO 这一块我主要参考了这位小姐姐的<a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F590b451a0ce46300588c43a0" target="_blank" rel="external">这篇文章</a>,但是有些发现她有些地方写的不是很清楚,自己也在这一块设置时也摸索了半天,所以直接像大家分享一下我的踩坑经验.</p>
<h3 id="让百度收录你的站点"><a href="#让百度收录你的站点" class="headerlink" title="让百度收录你的站点"></a>让百度收录你的站点</h3><p>我们直接在百度中搜索<code>site:你的域名</code>就可以查看百度是否已经收录你的网站,如果没有收录的话,你就要去去登录<a href="https://link.juejin.im?target=http%3A%2F%2Fzhanzhang.baidu.com" target="_blank" rel="external">百度站长平台</a>在站点管理中点击添加网站,然后输入你的站点地址, 注意,这里需要输入我们自己购买的域名,不能使用<code>xxx.github.io</code>之类域名.</p>
<p>步骤如下:</p>
<ol>
<li>输入网站: 添加域名时建议是不带上<code>www</code>的前缀</li>
<li>站点属性: 选择自己网站类型</li>
<li><p>验证网站: 验证网站的所有权,这里主要有以下三种</p>
<ul>
<li>文件验证: 文件验证文件存放的位置需要放在source文件夹下,txt 格式的不会被 hexo 预编译,其他格式要在头部加上<code>layout: false</code></li>
<li>HTML 标签验证: 将他给你的代码添加到网站首页的 head 标签内</li>
<li>CNAME 验证: <strong>推荐使用</strong>,将对应的 CNAME 文件放在你的 source 文件夹中即可,只要在其中写上你的域名地址就行;除此之外还会要求你到自己的域名提供商(我的是万网)上添加 CNAME 的解析(会面在国内外分流这一块会与更详细的解析说明);</li>
</ul>
</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2017/7/12/ee30fa072724e1141dfae134f4693f86?imageView2/0/w/1280/h/960" alt=""><br><strong>你需要到你的域名管理商那里更改百度的域名解析如：(以<a href="https://netcn.console.aliyun.com/core/domain/tclist" target="_blank" rel="external">万网</a>举例)</strong><br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fk1jiu2w2gj30ou01umx0.jpg" alt=""></p>
<h3 id="生成网站地图-—-sitemap"><a href="#生成网站地图-—-sitemap" class="headerlink" title="生成网站地图 — sitemap"></a>生成网站地图 — sitemap</h3><p> 这里需要我们安装下面两个插件,先执行下面命令</p>
<pre><code> npm i hexo-generator-sitemap hexo-generator-baidu-sitemap -S
</code></pre><p> 再在你的站点配置文件中修改 URL 为你的站点地址<br> <img src="https://ws2.sinaimg.cn/large/006tNc79gy1fjtqfn861bj30mk0953z5.jpg" alt=""></p>
<p> 当你在 <code>hexo g</code> 时,会在<code>public</code>文件夹中生成<code>sitemap.xml</code> 和<code>baidusitemap.xml</code> 两个文件,如果你已经提前将你的 hexo 部署到网上,这是可以直接打开<code>http://yoururl/sitemap.xml</code>和<code>http://yoururl/baidusitemap.xml</code>来查看.(这两者的区别在于 <code>baidusitemap.xml</code>        是百度搜索引擎的专用文件,另一个是通用).</p>
<h3 id="向百度提交链接"><a href="#向百度提交链接" class="headerlink" title="向百度提交链接"></a>向百度提交链接</h3><p><strong>现在百度好像不能抓去github上面的数据了</strong><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fk3qrgy8egj30oy0233yi.jpg" alt=""></p>
<blockquote>
<p>如何选择链接提交方式</p>
<p>   1、主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。</p>
<p>   2、自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。</p>
<p>   3、sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。</p>
<p>  4、手动提交：一次性提交链接给百度，可以使用此种方式。</p>
</blockquote>
<p>这里我推荐大家<strong>使用主动推送</strong>,当你主动推送时,可以缩短百度爬虫发现您站点新链接的时间,使新发布的页面可以在第一时间被百度收录;对于网站的最新原创内容，使用主动推送功能可以快速通知到百度，使内容可以在转发之前被百度发现.</p>
<h4 id="使用主动推送"><a href="#使用主动推送" class="headerlink" title="使用主动推送"></a>使用主动推送</h4><ul>
<li>需要先安装插件<code>npm i hexo-baidu-url-submit -S</code></li>
<li>然后再在站点配置文件中按如下方式新增字段<pre><code>baidu_url_submit:
count: 100 # 提交最新的链接数
host: pancakeawesome.com # 在百度站长平台中注册的域名,虽然官方推荐要带有 www, 但可以不带.
token:  XXXXX # 你的秘钥,每个人都不一样,获取方法在下面
path: baidu_urls.txt # 文本文档的地址,新链接会保存在此文本文档里
</code></pre></li>
<li>然后加入新的 </li>
</ul>
<pre><code>deploydeploy:
     - type:baidu_url_submitter
</code></pre><p><strong>注意</strong>,这里多个 type 的写法应该这么写,前面那个 type 是我推送到 <code>Gitub</code> 与 <code>Coding</code> 的<code>page</code>页面的配置,后面再讲这个.</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fjtqhkscohj30qp0inmyv.jpg" alt=""></p>
<p>密钥的获取位置在<code>网页抓取</code>中的<code>链接提交</code>这一块,如下所示:<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/0995148de59688b95330f5e2c99daa58?imageView2/0/w/1280/h/960" alt=""></p>
<ul>
<li>最后当你执行<code>hexo d</code>时新的连接就会被推送上去.</li>
<li>推送成功时,会有如下终端提示,各种不同的推送反馈字段说明在<a href="https://link.juejin.im?target=http%3A%2F%2Fzhanzhang.baidu.com%2Fcollege%2Fcourseinfo%3Fid%3D267%26amp%3Bpage%3D2%23h2_article_title8" target="_blank" rel="external">这里</a>查看,一般来说,推送失败都是地址不相符造成的,我们只需对比<code>baidu_url_submit</code>在<code>public</code>中生成的<code>baidu_urls.txt</code>的地址,与自己填写在<code>host</code>字段中是否一样即可,这里需要注意的是,多加<code>www</code>会导致上传失败(血的教训…)</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fjttndgvr1j30uw0icmzj.jpg" alt=""></p>
<h3 id="让-Google-收录你的网站"><a href="#让-Google-收录你的网站" class="headerlink" title="让 Google 收录你的网站"></a>让 Google 收录你的网站</h3><ul>
<li><p>登录 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.google.com%2Fwebmasters%2F%23%3Fmodal_active%3Dnone" target="_blank" rel="external">Google 网络站长</a>,点击<code>添加属性</code>按要求添加你的网站</p>
</li>
<li><p>验证你的网站所有权,我推荐使用 HTML 文件上传的方式,将他给你的html 文件放入 <code>sources</code> 文件夹下,但 html 文件默认会被 hexo 预编译,所以这里,我们要手动设置让 hexo 不要编译该文件,在文件开始添加<code>layout:false</code>即可.<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/d08c34f269cb81e388eeef1e70a5d2bc?imageView2/0/w/1280/h/960" alt=""></p>
</li>
<li><p>添加 sitemap : 进入 Google Search Console - 抓取 - 站点地图,点击「添加/测试站点地图」,输入你的博客网址. 若无报错则站点地图提交成功<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fjtuhe4at2j30xj0c0jrn.jpg" alt="">)</p>
</li>
<li>提交 robots.txt:<blockquote>
<p>robots.txt 是一种存放于网站根目录下的 ASCII 编码的文本文件，它的作用是告诉搜索引擎此网站中哪些内容是可以被爬取的，哪些是禁止爬取的。robots.txt 放在博客目录下的 source 文件夹中，博客生成后在站点目录 /public/ 下。</p>
</blockquote>
</li>
</ul>
<p>我的 robots.txt 文件内容如下：</p>
<pre><code>    User-agent: *
    Allow: /
    Allow: /archives/
    Allow: /categories/
    Allow: /about/
    Disallow: /vendors/
    Disallow: /js/
    Disallow: /css/
    Disallow: /fonts/
    Disallow: /vendors/
    Disallow: /fancybox/
</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fjtuilil2dj30w90dc0tc.jpg" alt="">)</p>
<ul>
<li><em>提交谷歌索引</em><br>在这里我们填上我们需要抓取的url,不填这表示抓取首页，抓取方式可以选择桌面，智能手机等等，自行根据需要选择。填好url之后，点击抓取。然后可能会出现几种情况，如:完成、部分完成、重定向等，自由这三种情况是可以提交的。<br>提交完成后，提交至索引，根据提示操作就可以了，我的提交：<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fjtukpj4edj30x90bw0tg.jpg" alt="">)<h3 id="优化你的-URL"><a href="#优化你的-URL" class="headerlink" title="优化你的 URL"></a>优化你的 URL</h3></li>
</ul>
<blockquote>
<p>这段话参考自<a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F590b451a0ce46300588c43a0" target="_blank" rel="external">上面那个小姐姐的文章</a>,写的很好,这里我直接拿来用下<br>seo搜索引擎优化认为，网站的最佳结构是用户<strong>从首页点击三次就可以到达任何一个页面</strong>，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，所以我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下：</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2017/7/12/7f12922620fc0c865bffafd8ce4a2f97?imageView2/0/w/1280/h/960" alt=""></p>
<h2 id="将你的网站同时托管到-Github-和-Coding-上-国内外分流"><a href="#将你的网站同时托管到-Github-和-Coding-上-国内外分流" class="headerlink" title="将你的网站同时托管到 Github 和 Coding 上,国内外分流"></a>将你的网站同时托管到 Github 和 Coding 上,国内外分流</h2><p>Coding 类似于中国的 Github 一样,也提供了 Pages 服务,但对我们而言,跟 Github 不同的地方在于免费用户能拥有五个私人仓库,这个可以用来部署自己的一些私人代码,而且配合 Github 可以做到国内IP 访问 Coding 的 Pages 页面,国外访问 Github 上面的 Pages 页面.大致配置过程如下:</p>
<ul>
<li>在 Coding 上创建仓库: 这里注意要去创建一个公有的仓库,私有仓库是没有 pages 服务的.</li>
<li>将你的公钥传上去.这里网上关于自己公钥的相关教程很多,我就不多叙述了.</li>
<li><p>修改 hexo 的站点配置文件中的 deploy 选项,配置你的 Github 与 Coding 仓库,需要注意的是其中 Github 的仓库名<code>xxx.github.io</code>必须跟你的 Github 名称一样:<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/395865e456887d0a62adc65769fdb73b?imageView2/0/w/1280/h/960" alt=""><br>每次上传的时候都需要输入你的账号密码之类的信息,可以直接将你账号密码写在上传地址中,这样就不用每次更新都输入你的账号密码了例如你的账号为<span class="hljs-selector-pseudo">:crown3,密码为 BBB;<br>那你的repo填写为下面这样即可</span></p>
<pre><code>github: https://crown3:BBB@github.com/crown3/crown3.github.io.git
coding: https://crown3:BBB@git.coding.net/crown3/仓库名.git
</code></pre></li>
<li><p>设置 coding 的 pages 服务:在pages页面将部署来源选择为master分支，然后将自定义域名填写自己购买的域名就可以了</p>
</li>
<li>设置域名解析: 在你的域名提供商那里修改你的域名解析就行,例如我的是万网,按照下图所示,添加这五条解析即可做到国内外访问分流.<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/f1bbfa32ee6b74ef8d1d3e87bd25083c?imageView2/0/w/1280/h/960" alt=""></li>
</ul>
<h2 id="将自己的代码托管到私有仓库"><a href="#将自己的代码托管到私有仓库" class="headerlink" title="将自己的代码托管到私有仓库"></a>将自己的代码托管到私有仓库</h2><p>当我们将自己的代码托管到<strong>私有仓库</strong>后,就可以在任何一台电脑上将你的 hexo 部署代码下载下来进行编辑,而且可以将你的一些个人密钥什么的直接推送到你的代码仓库去,这样更便利于我们的管理维护.</p>
<p>在上文我已经说过了,国内 Coding 的免费用户可以创建五个私有仓库,这是可以直接拿来使用,但是如果你对国内的私有仓库安全性存有怀疑,也可以去使用国外专门做私有仓库托管的<a href="https://link.juejin.im?target=https%3A%2F%2Fbitbucket.org%2F" target="_blank" rel="external">bitbucket</a>,在这里私有仓库是可以免费使用的.具体上传之类的使用方法我就不再细述了,都是基于 git 做的代码管理,使用方法都大同小异.</p>
<h2 id="使用-Gulp-压缩你的代码"><a href="#使用-Gulp-压缩你的代码" class="headerlink" title="使用 Gulp 压缩你的代码"></a>使用 Gulp 压缩你的代码</h2><p>代码压缩可以明显减小我们的文件大小,加载速度,这里我会直接提供我使用的脚本,大家可以直接拿来使用,有需要了解相关知识的可以去<code>gulp</code>官网去做相关了解.</p>
<ul>
<li><p>先安装<code>Gulp</code>以及我们需要使用的一系列插件:</p>
<pre><code>npm i gulp gulp-clean-css gulp-htmlclean gulp-htmlmin gulp-imagemin gulp-uglify del run-sequence -S
</code></pre></li>
<li><p>接着创建<code>gulpfile.js</code>: 在你的博客根目录(跟你站点配置文件同一层)下创建<code>gulpfile.js</code>这个文件,然后在里面填入如下脚本即可,里面有相关注释,感兴趣的可以去了解一下.</p>
</li>
</ul>
<pre><code>var gulp = require(&#39;gulp&#39;);
    var minifycss = require(&#39;gulp-clean-css&#39;);
    var uglify = require(&#39;gulp-uglify&#39;);
    var htmlmin = require(&#39;gulp-htmlmin&#39;);
    var htmlclean = require(&#39;gulp-htmlclean&#39;);
    var imagemin = require(&#39;gulp-imagemin&#39;);
    var del = require(&#39;del&#39;);
    var runSequence = require(&#39;run-sequence&#39;);
    var Hexo = require(&#39;hexo&#39;);
    // 清除public文件夹
    gulp.task(&#39;clean&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return del([&#39;public/**/*&#39;]);
    });
    // 利用Hexo API 来生成博客内容， 效果和在命令行运行： hexo g 一样
    // generate html with &#39;hexo generate&#39;
    var hexo = new Hexo(process.cwd(), {});
    gulp.task(&#39;generate&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;(cb) {
        hexo.init().then(&lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
            return hexo.call(&#39;generate&#39;, {
                watch: false
            });
        }).then(&lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
            return hexo.exit();
        }).then(&lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
            return cb()
        }).catch(&lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;(err) {
            console.log(err);
            hexo.exit(err);
            return cb(err);
        })
    })
    // 压缩public目录下的所有css
    gulp.task(&#39;minify-css&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return gulp.src(&#39;./public/**/*.css&#39;)
            .pipe(minifycss({
                compatibility: &#39;ie8&#39;
            }))
            .pipe(gulp.dest(&#39;./public&#39;));
    });
    // 压缩public目录下的所有html
    gulp.task(&#39;minify-html&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return gulp.src(&#39;./public/**/*.html&#39;)
            .pipe(htmlclean())
            .pipe(htmlmin({
                removeComments: true,
                minifyJS: true,
                minifyCSS: true,
                minifyURLs: true,
            }))
            .pipe(gulp.dest(&#39;./public&#39;))
    });
    // 压缩public目录下的所有js
    gulp.task(&#39;minify-js&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return gulp.src(&#39;./public/**/*.js&#39;)
            .pipe(uglify())
            .pipe(gulp.dest(&#39;./public&#39;));
    });
    // 压缩public目录下的所有img： 这个采用默认配置
    gulp.task(&#39;minify-img&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return gulp.src(&#39;./public/images/**/*.*&#39;)
            .pipe(imagemin())
            .pipe(gulp.dest(&#39;./public/images&#39;))
    })
    // 同上，压缩图片，这里采用了： 最大化压缩效果。
    gulp.task(&#39;minify-img-aggressive&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return gulp.src(&#39;./public/images/**/*.*&#39;)
            .pipe(imagemin(
            [imagemin.gifsicle({&#39;optimizationLevel&#39;: &lt;span class=&quot;hljs-number&quot;&gt;3}), 
            imagemin.jpegtran({&#39;progressive&#39;: true}), 
            imagemin.optipng({&#39;optimizationLevel&#39;: &lt;span class=&quot;hljs-number&quot;&gt;7}), 
            imagemin.svgo()],
            {&#39;verbose&#39;: true}))
            .pipe(gulp.dest(&#39;./public/images&#39;))
    })
    // 用run-sequence并发执行，同时处理html，css，js，img
    gulp.task(&#39;compress&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;(cb) {
        runSequence([&#39;minify-html&#39;, &#39;minify-css&#39;, &#39;minify-js&#39;, &#39;minify-img-aggressive&#39;], cb);
    });
    // 执行顺序： 清除public目录 -&amp;gt; 产生原始博客内容 -&amp;gt; 执行压缩混淆
    gulp.task(&#39;build&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;(cb) {
        runSequence(&#39;clean&#39;, &#39;generate&#39;, &#39;compress&#39;, cb)
    });
    gulp.task(&#39;default&#39;, [&#39;build&#39;])
</code></pre><ul>
<li>执行<code>gulp</code>: 在命令行中输入<code>gulp build</code>即可<br>这里要说明的是,这里利用Hexo API 来生成博客内容,效果和在命令行运行： <code>hexo g</code> 一样,所以当我们在执行<code>gulp build</code>时,会根据我们的相关博文来直接生成相应的<code>public</code>文件夹中的内容,并直接进行压缩,接下来我们运行<code>hexo d</code>上传上去的代码会是已经进行相应压缩了的.</li>
</ul>
<h2 id="使用七牛图床来处理我们的图片"><a href="#使用七牛图床来处理我们的图片" class="headerlink" title="使用七牛图床来处理我们的图片"></a>使用七牛图床来处理我们的图片</h2><p><strong>推荐使用<code>智图+ipic+七牛</code>来管理博客的图床</strong></p>
<p>选中一张图片 =&gt; 用智图进行相应压缩处理 =&gt; 使用 iPic 快捷键一键上传到七牛云(cmd + u) =&gt; 在文章中直接粘贴已经复制到剪贴板的图片地址</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/7/12/1bdc660c52243514a6d7a96a5f7624ae?imageView2/0/w/1280/h/960" alt=""></p>
<p><em>选择智图来压缩是因为<code>iPic</code>这个软件自带的上传压缩效果没有智图的好</em><br><strong>具体使用七牛的方法：</strong></p>
<h3 id="增加七牛图床"><a href="#增加七牛图床" class="headerlink" title="增加七牛图床"></a>增加七牛图床</h3><p>增加七牛图床就是要将我们电脑上的图片上传至七牛，然后获得外链，在我们使用md写博客的时候直接插入外链，更方便的是可以直接获取带水印、压缩、剪裁过后的图片~</p>
<h4 id="注册七牛"><a href="#注册七牛" class="headerlink" title="注册七牛"></a>注册七牛</h4><p>万年不变的第一步，注册。官网：<a href="https://link.juejin.im?target=https%3A%2F%2Fportal.qiniu.com%2Fsignup%3Fcode%3D3lnd6wvc103f6" target="_blank" rel="external">七牛云</a></p>
<h4 id="上传资源"><a href="#上传资源" class="headerlink" title="上传资源"></a>上传资源</h4><p>在登录成功之后，点击对象存储</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/5/5/1c58d10d6b4022bb745c679f6e34a447?imageView2/0/w/1280/h/960" alt="上传资源至七牛"><br>上传完图片之后，关闭上传页面，可以在图片列表的最后面有一个眼睛的icon，点击之后就会在右下角找到该图片的外链，在用md写博客的时候就可以直接加入外链就好~也可以对上传的源文件进行重命名，因为大部分我上传到七牛上的图片都是相册中使用的，所以我将源文件的名字都改成统一的形式，在引用的时候只需要修改最后的数字就可以~<br><img src="https://user-gold-cdn.xitu.io/2017/5/5/e748be6d8cd158b3529748beae2082ad?imageView2/0/w/1280/h/960" alt="上传资源至七牛"></p>
<h4 id="添加水印"><a href="#添加水印" class="headerlink" title="添加水印"></a>添加水印</h4><p>使用七牛图床最棒的地方在于可以对图片进行处理，我就只拿添加水印来举例。<br>七牛可以对上传的图片添加图片样式</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/5/5/32770706a230e5f50687ce8f301a28ff?imageView2/0/w/1280/h/960" alt="增加图片样式"><br>增加图片样式就是对图片进行处理，这里的处理方式有很多，比如缩放方式、裁剪、增加图片水印、设置输出格式。<br><img src="https://user-gold-cdn.xitu.io/2017/5/5/54bd4a7d42e7179e2ced2db70325b638?imageView2/0/w/1280/h/960" alt="增加图片样式"><br>在设置了图片样式之后我们要怎么使用呢，开始我也是一脸懵逼的，不知道怎么使用，百度之后才知道，你直接访问获取的外链就是你上传的原图，在外链的后面加上连接符和你的样式名称访问的就是经过处理后的图片，有没有很赞~既可以访问到你的原图片，也可以访问到经过处理后的图片，只不过是连接不同，还可以给一个图片增加多个样式访问，就不需要我们一张一张对图片进行处理了~简直不能太赞~(～￣▽￣)～比如:我的原图地址是：<a href="https://link.juejin.im?target=http%3A%2F%2Foova2i5xh.bkt.clouddn.com%2FIMG49.jpg" target="_blank" rel="external">oova2i5xh.bkt.clouddn.com/IMG49.jpg</a> ，可以看到是一张很大的不带水印的图片<br><img src="https://user-gold-cdn.xitu.io/2017/5/5/7304dbe593b950f42197dbc5e364cdcb?imageView2/0/w/1280/h/960" alt="这里写图片描述"><br>然后在该地址后加上我设置的连接符,”-“和我的样式名称：<a href="https://link.juejin.im?target=http%3A%2F%2Foova2i5xh.bkt.clouddn.com%2FIMG49.jpg-cherryblogImg" target="_blank" rel="external">oova2i5xh.bkt.clouddn.com/IMG49.jpg-c…</a> ，就可以看到是一张带水印的小图，我进行了缩放和加水印<br><img src="https://user-gold-cdn.xitu.io/2017/5/5/0f6012ba8e1ee3bf84eb53a9f6793ffa?imageView2/0/w/1280/h/960" alt="这里写图片描述"></p>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo+githubio+material搭建你的个人博客网站（主题篇）]]></title>
      <url>/hexo+githubio+material%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99(%E4%B8%BB%E9%A2%98%E7%AF%87).html</url>
      <content type="html"><![CDATA[<h1 id="Hexo博客搭建详细教程-从搭建-SEO-国内外分流到部署"><a href="#Hexo博客搭建详细教程-从搭建-SEO-国内外分流到部署" class="headerlink" title="Hexo博客搭建详细教程 : 从搭建 , SEO , 国内外分流到部署"></a>Hexo博客搭建详细教程 : 从搭建 , SEO , 国内外分流到部署</h1><blockquote>
<p>本文主要包括以下内容:</p>
<ul>
<li>Hexo 博客搭建</li>
<li>Hexo 主题选择以及应用</li>
<li>关于 Hexo Meterial 主题的相关配置</li>
<li>网站 SEO 优化</li>
<li>将你的网站同时托管到 Github 和 Coding 上,国内外分流</li>
<li>将自己的代码托管到私有仓库</li>
<li>使用 Gulp 来压缩你的代码</li>
<li>如何简单高效地使用七牛图床</li>
</ul>
<p>主题这里我选择的是 Hexo Meterial 主题( Github Hexo 主题中 star 数排第三,前两名分别是 next 和 yilia).</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="为什么写这篇文章"><a href="#为什么写这篇文章" class="headerlink" title="为什么写这篇文章?"></a>为什么写这篇文章?</h3><p>我发现网上关于 Next 主题的相关配置比较多,但是关于这个 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fviosey%2Fhexo-theme-material" target="_blank" rel="external">Meterial</a> 主题的完整配置过程文档却相当难找,但这个主题在我看来,不管是颜值,还是功能来说,都明显不该被埋没在next的大海之中,所以在自己折腾了一整子后,将自己记录的相关过程整理分享给大家,毕竟这个主题颜值辣么高,功能辣么强……(除了主题不通之外,其他相关配置都是可以拿来参考的,甚至直接拿来用的,所以其他主题的童靴先不要逃…)</p>
</blockquote>
<p><a href="http://pancakeawesome.ink/">Demo演示</a></p>
<h2 id="Hexo-博客搭建"><a href="#Hexo-博客搭建" class="headerlink" title="Hexo 博客搭建"></a>Hexo 博客搭建</h2><h3 id="Hexo-安装环境"><a href="#Hexo-安装环境" class="headerlink" title="Hexo 安装环境"></a>Hexo 安装环境</h3><p>Hexo 是基于<code>Node.js</code>,所以不管是 mac 还是 win 都需要提前安装好<code>Node.js</code>以及<code>NPM</code>才能进行下一步,这里关于 Node 与 NPM 的安装我就不在这里多说了,请大家自行 Google 解决.</p>
<h3 id="Hexo-的相关安装搭建"><a href="#Hexo-的相关安装搭建" class="headerlink" title="Hexo 的相关安装搭建"></a>Hexo 的相关安装搭建</h3><h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>首先我们要在命令行里直接执行如下命令,全局安装<code>Hexo</code>.</p>
<pre><code>npm install -g hexo
</code></pre><h4 id="初始化你的-Hexo-博客"><a href="#初始化你的-Hexo-博客" class="headerlink" title="初始化你的 Hexo 博客"></a>初始化你的 Hexo 博客</h4><p>然后需要你去找到一个你想要安装的文件夹,在里面执行如下命令来进行安装初始化你的hexo博客.</p>
<pre><code>hexo init hexo_blog   //在当前目录下新建一个叫 `hexo_blog`文件夹并在其中初始化生成 `Hexo `相关代码
cd `hexo_blog`//进入到 `hexo_blog `这个文件夹中并安装相关依赖包
npm install
</code></pre><p>生成的相关目录如下:</p>
<pre><code>-- hexo_blog
    ├── node_modules//NPM安装依赖包
    ├── scaffolds
    ├── source
    |   └── _posts//新建文件存放位置
    ├── themes//相关主题存放位置
    ├── _config.yml//Hexo 博客站点配置文件
    ├── .gitignore
    ├── db.json
    └── package.json
</code></pre><p>这里需要下载速度比较慢的童鞋需要注意一下, npm 中默认使用的是国外的 npm 源,这意味着你在你执行 npm install 相关命令式会有比较高的延迟,甚至部分包下载不下来的情况,所以这里推荐国内用户用<code>nrm</code>切换成淘宝的镜像源来使用(但还是会有部分依赖包必须从国外下载,所以还是推荐自己去学会科学上网),使用方法如下:</p>
<pre><code>npm i nrm -g//全局安装 nrm 这个插件
nrm test //测试哪个镜像源跟自己的延迟比较低,我的是 taobao
nrm use taobao //切换到taobao 这个镜像源上
npm i ...//之后继续使用 npm 来安装相关依赖就行
</code></pre><p><img src="https://user-gold-cdn.xitu.io/2017/7/12/b363cb55a2f09865dcb715e2cf4e2860?imageView2/0/w/1280/h/960" alt=""></p>
<p>之后你就可以在当前文件夹下执行<code>hexo server --debug</code>来让你的博客进入<code>debug</code>模式,一般默认是在<code>4000</code>这个端口下执行,直接在浏览器输入<code>localhost:4000</code>就可以查看自己本地生成的<code>Hexo</code>博客了.</p>
<pre><code>在`debug`模式下,你可以直接对你的博客进行相关修改,刷新网页来查看效果.
</code></pre><h2 id="Hexo-主题选择以及应用"><a href="#Hexo-主题选择以及应用" class="headerlink" title="Hexo 主题选择以及应用"></a>Hexo 主题选择以及应用</h2><p>现在网上关于 <code>Hexo</code> 的主题一搜一大把,这里推荐大家在选择主题时可以去选择一些关注度比较高的主题,这种主题一般相应的配套使用插件和文档比较丰富,使用起来也比较方便,主题选择的话可以去一些<a href="https://hexo.io/themes/" target="_blank" rel="external">主题库</a>中查找,也可以直接去<code>Github</code>中搜索<code>hexo theme</code>等关键字来查找— <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fsearch%3Fo%3Ddesc%26amp%3Bq%3Dhexo%2Btheme%26amp%3Bs%3Dstars%26amp%3Btype%3DRepositories%26amp%3Butf8%3D%25E2%259C%2593" target="_blank" rel="external">点击查看搜索结果</a>.</p>
<pre><code>这里我们要注意的一点是在 Hexo 中,通常有两份配置文件,一个是站点根目录下(例如我的就是`.../hexo_blog/_config.yml`)的 `_config.yml`;另外一个是主题目录(例如我的就是`.../hexo_blog/themes/material/_config.yml`)下的 `_config.yml`.为了描述方便,在以下说明中,将前者称为 `站点配置文件`,后者称为`主题配置文件`.
</code></pre><ol>
<li>去找到你喜欢的主题,然后将其下载下来存放到你的 Themes 这个文件夹下,可以使用<code>NPM</code>,<code>Git</code>等一系列方法下载下来,一般主题的文档里面都会有其下载方法的介绍,例如我使用的 <code>Material</code> 主题的<a href="https://material.viosey.com/start/#install-material" target="_blank" rel="external">下载方法</a>.</li>
<li>复制完成后,修改主题文件夹名称,将其修改为 <code>AAA</code>(你的主题名称),然后打开<code>站点配置文件</code>,找到<code>theme</code>字段,并将其值更改为<code>AAA</code>.</li>
<li>运行<code>hexo s --debug</code> 并访问<code>http://localhost:4000</code>即可查看你的主题修改效果.<pre><code>文件夹名称可自由修改,并不是唯一的,只需要 `theme` 字段与之对应即可.这里有一点必须要注意,**配置项之间必须要有一个空格**,例如`theme:material`这种情况是会报错的,要向下面这样.
</code></pre><img src="https://user-gold-cdn.xitu.io/2017/7/12/536f099650be34b06798a19f8ea24cb1?imageView2/0/w/1280/h/960" alt=""></li>
</ol>
<h2 id="关于-Hexo-Material-主题的相关配置"><a href="#关于-Hexo-Material-主题的相关配置" class="headerlink" title="关于 Hexo Material 主题的相关配置"></a>关于 Hexo Material 主题的相关配置</h2><p>这里我会将分享我关于<code>Material</code>配置时的一些踩坑经验,使用其他主题的童鞋可以直接跳过这一段,去看后面的其他优化配置.</p>
<p><code>Material</code>的相关配置文档可以直接查看<a href="https://link.juejin.im?target=https%3A%2F%2Fmaterial.viosey.com%2F" target="_blank" rel="external">官网配置文档</a>,但是我在配置的一些过程中发现该网站中的文档部分没有跟上最新发布的版本,例如关于文章评论这一块,并没有网易云跟帖的相关说明,但是在最新的版本中,已经跟新了对网易云跟帖的支持.推荐大家直接去查看其 Github 上面的文档—<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fviosey%2Fmaterial-theme-docs" target="_blank" rel="external">material-theme-docs</a>,这里更新的比较及时.</p>
<ul>
<li><code>站点配置文件</code>:<code>.../hexo_blog/_config.yml</code></li>
<li><code>主题配置文件</code>: <code>.../hexo_blog/themes/material/_config.yml</code></li>
</ul>
<h3 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h3><p>这里我主要介绍一下关于博客使用语言的设置,其默认的是英语,我们可以编辑<code>站点配置文件</code>,将<code>language</code>设置成你想要的语言,常用的几种如下:</p>
<ul>
<li>英语: <code>en</code></li>
<li>简体中文: <code>zh-CN</code></li>
<li>繁体中文: <code>zh-TW</code></li>
<li>language: zh-CN</li>
</ul>
<h4 id="代码高亮设置"><a href="#代码高亮设置" class="headerlink" title="代码高亮设置"></a>代码高亮设置</h4><p>这里可以使用 <code>hexo-prism-plugin</code>这个插件来让我们文章中的代码实现高亮，具体文档官方已经写得很详细了,这里我就不再多说,大家直接去参考 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fele828%2Fhexo-prism-plugin" target="_blank" rel="external">Hexo-Prism-Plugin 插件文档</a>即可.</p>
<h3 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h3><p>这里我直接贴出我的配置文件,大家可以结合官方文档参考下,但我会在下面一些有可能踩坑的地方做出一些相关注释,大家可以配合着一起看下.</p>
<pre><code># .../hexo_blog/themes/material/_config.yml
---------------------------------------------------------------
# Site Information Settings
#---------------------------------------------------------------

# Head info
head:
    favicon: &quot;/img/favicon_c.png&quot;//网站的 favicon
    high_res_favicon: &quot;/img/favicon_c.png&quot;//高清 favicon
    apple_touch_icon: &quot;/img/favicon_c.png&quot;  //IOS 主屏按钮图标
    keywords: 前端,全栈,Web,自学编程,学习分享  //网站关键词,文章的关键字会结合你对文章打上的相应标签来一起显示
    site_verification:  //向搜索引擎验证你对站点的所有权,后面会专门做这方面的 SEO
        google:
        baidu:

    # Enable generate structured-data as JSON+LD for SEO or not.
    #        Set as &#39;false&#39; if it cause some wrong when `hexo g`.
    structured_data: true  //用于改善搜索引擎对你网站的 SEO, 建议开启

# Jump Links Settings
url:
    rss:  //设置生成的 rss 或 atom url
    daily_pic: &quot;#&quot; //设置 daily_pic 模块 点击时跳转的 url
    logo: &quot;#&quot; //设置 logo 点击时跳转的 url

# ---------------------------------------------------------------
# Style Settings
# ---------------------------------------------------------------

# Shemes  //主题选择设置,现在只有默认的 Paradox 和至简模式的 Isolation,去掉对应的 # 号就可使用
scheme: Paradox
#scheme: Isolation

# UI &amp;amp; UX: slogan, color, effect
uiux:
    slogan: &quot;XXXXXXXXXXX&quot;
    theme_color: &quot;#607D8B&quot;
    theme_sub_color: &quot;#00838F&quot;
    hyperlink_color: &quot;#00838F&quot;
    button_color: &quot;#757575&quot;
    android_chrome_color: &quot;#607D8B&quot;
    nprogress_color: &quot;#29d&quot;
    nprogress_buffer: &quot;800&quot;
</code></pre><h4 id="slogan-—-网站标语"><a href="#slogan-—-网站标语" class="headerlink" title="slogan — 网站标语"></a>slogan — 网站标语</h4><p><code>slogan</code>: 显示在<code>blog_info</code>模块中的标语,我们可以将其可以设置成单行或者多行,支持 HTML 标签.</p>
<ul>
<li>单行格式: <code>slogan: &quot;我爱吃土豆&quot;</code></li>
<li>多行格式:(注意缩进)</li>
</ul>
<pre><code>    slogan: 
        - &quot;我爱吃土豆&quot;
        - &quot;我爱吃番茄&quot;
</code></pre><p>我继续接上面开始说明 <code>.../hexo_blog/themes/material/_config.yml</code>中的相关代码.</p>
<pre><code># JS Effect Switches --- 用来控制 Material 主题中自带的多种 js 特性
js_effect:
    fade: true
    smoothscroll: false
# Reading experience --- 首页文章输出摘要的字符长度
reading:
    entry_excerpt: 80

# Thumbnail Settings --- 用于设置文章缩略图相关
thumbnail:
    purecolor:
    random_amount: 19

# Background Settings
# bing available parameter:
#     new | color= | type=
#         color available value: black, blue, brown, green, multi, orange, pink, purple, red, white, yellow
#         type available value: A (animal), C (culture), N (nature), S (space), T (travel)
background:
    purecolor: &quot;#F5F5F5&quot;
    #bgimg: &quot;/img/bg.png&quot;
#   开启bing随机背景
    bing:
        enable: false
        parameter:

# Images Settings
img:
    logo: &quot;/img/logo_c.png&quot;
    avatar: &quot;/img/avatar.JPG&quot;
    daily_pic: &quot;/img/daily_pic.jpg&quot;
    sidebar_header: &quot;/img/sidebar_header.jpg&quot;
    random_thumbnail: &quot;/img/random/material-&quot;
    footer_image:
        #upyun_logo:
            #link: &quot;https://www.upyun.com/&quot;
            #src: &quot;/img/upyun_logo.svg&quot;

# Custom Fonts
#   family: the font-family which will be used in the theme
#   host: uri of fonts host.
#       Available value of &quot;host&quot;: google | baomitu | ustc | custom
fonts:
    family: Roboto, &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;微软雅黑&quot;, Arial, sans-serif
    use: baomitu
    custom_font_host:

# Card Elevation Level
card_elevation: 2

# Code highlight#代码高亮提示
# You can only enable one of them to avoid issues.
# Also you need to disable highlight option in hexo&#39;s _config.yml.
#
#    Prettify
#        theme: # Available value in /source/css/prettify/[theme].min.css
prettify:
    enable: false
    theme: &quot;github-v2&quot;

#    Hanabi (https://github.com/egoist/hanabi)
#        line_number: [true/false] # Show line number for code block
#        includeDefaultColors: [true/false] # Use default hanabi colors
#        customColors: This value accept a string or am array to setting for hanabi colors.
#                    - If `includeDefaultColors` is true, this will append colors to the color pool
#                    - If `includeDefaultColors` is false, this will instead default color pool
hanabi:
    enable: true
    line_number: true
    includeDefaultColors: true
    customColors: 

# Copyright
# Specify the date when the site was setup.
#   For example, if you set it as 2015, then footer will show &#39;© 2015 - 2017&#39;
copyright_since: 2017

# Qrcode for redirect at other device
#   use: choose which method to generate the qrcode for each posts.
#       Available value of &quot;use&quot;: plugin | online
#           - When use &quot;plugin&quot;, you need to install the hexo-helper-qrcode.
#           - When use &quot;online&quot;, the qrcode will be generated by &#39;pan.baidu.com&#39; in China.
qrcode:
    enable: true
    use: plugin

# ---------------------------------------------------------------
# Menu Settings
# ---------------------------------------------------------------

# TOC Button

toc:
#   use: choose whether the line_number of toc will show or not.
#       Available value of &quot;linenumber&quot;: true | false
    linenumber: true

# SNS Menu
sns:
    email: xxx@email.com
    facebook: 
    twitter: 
    googleplus: 
    weibo:
    instagram:
    tumblr:
    github: &quot;https://www.github.com/xxx&quot;
    linkedin: &quot;https://www.linkedin.com/in/xxx/&quot;
    zhihu: &quot;https://www.zhihu.com/people/xxx&quot;
    bilibili:
    telegram:

# SNS Share Switch
sns_share:
    twitter: true
    facebook: true
    googleplus: true
    weibo: true
    linkedin: true
    qq: true
    telegram: false

# Sidebar Customize
sidebar:
    dropdown:
        Email Me:
            link: &quot;mailto:xxx@email.com&quot;
            icon: email
    homepage:
        use: true
        icon: home
        divider: false
    categories:
        use: true
        icon: chrome_reader_mode
        divider: false
    tags:
        use: true
        icon: chrome_reader_mode
        divider: false
    archives:
        use: true
        icon: timeline
        divider: false
    pages:
        标签云:
            link: &quot;/tags&quot;
            icon: cloud_circle
            divider: true
        Timeline:
            link: &quot;/timeline&quot;
            icon: send
            divider: false
        Gallery:
            link: &quot;/gallery&quot;
            icon: photo_library
            divider: false
        About Me:
            link: &quot;/test&quot;
            icon: person_pin
            divider: true
    article_num:
        use: true
        divider: false
    footer:
        divider: false
        theme: false
        support: false
        feedback: false
        material: false
</code></pre><h4 id="code-highlight"><a href="#code-highlight" class="headerlink" title="code highlight"></a>code highlight</h4><p>代码高亮提示，有两种方法，pretify和hanbi，推荐hanbi，彩色的代码提示，很美观<br> <img src="https://ws2.sinaimg.cn/large/006tNc79gy1fjtty8bs0aj30lh07jt8v.jpg" alt=""><br> <img src="https://ws2.sinaimg.cn/large/006tNc79gy1fjttythnfsj30is0e70t7.jpg" alt=""></p>
<h4 id="sidebar-—-侧边栏"><a href="#sidebar-—-侧边栏" class="headerlink" title="sidebar — 侧边栏"></a>sidebar — 侧边栏</h4><p>关于侧边栏的一些相关配置这里有些部分我需要说明一下: 图标选择网站是<a href="https://link.juejin.im?target=https%3A%2F%2Fmaterial.io%2Ficons%2F" target="_blank" rel="external">这个</a>(需要翻墙),只需要向下面一样把 icon 对应的配置项换掉就可以切换图标.</p>
<ul>
<li><code>homepage</code>: 主页</li>
<li><code>catagories</code>: 文章分类</li>
<li><code>tags</code>: 文章打上的标签</li>
<li><code>archives</code>: 文章按时间归档</li>
<li><code>pages</code>: 用于设置一些独立页面的<strong>入口</strong>(相关页面需要自己开启,后面后有相关说明),格式如下:</li>
</ul>
<pre><code>链接名称:
    link: &quot;/xxx&quot; //url 地址
    icon: xxxx   // 图标样式
    divider: true/false //是否显示下划线
</code></pre><ul>
<li><code>article_num</code>: 是否显示文章数目统计</li>
<li><code>footer</code>: 配置侧边栏的底部</li>
</ul>
<pre><code># ---------------------------------------------------------------
# Integrated Services
# ---------------------------------------------------------------

# MaterialCDN
# When you set &#39;use&#39; as true, the needed css, js, font file will have a new src.
# The new src will have the base domain you configured in &#39;base&#39;.
materialcdn: 
    use: false 
    base: xxxx

# Comment Systems
# Available value of &quot;use&quot;:
#     disqus | disqus_click | changyan | livere | gitment | valine
# If you want to use gitment,you should get the client_id and client_secret form https://github.com/settings/applications/new
# If you want to use valine,you should get the app_id and app_key form https://leancloud.cn ,more setting please see https://github.com/xCss/Valine
comment:
    use: changyan
    shortname: # duoshuo or disqus shortname
    changyan_appid: xxxxxxx
    changyan_conf: xxxxxxxxxx
    changyan_thread_key_type: path
    livere_data_uid:
    gitment_repo:   # git repo of the hexo
    gitment_owner:  # git repo&#39;s owner
    gitment_client_id:  # github app client id 
    gitment_client_secret :  # github app client secret 
    valine_leancloud_appId: # leancloud application app id
    valine_leancloud_appKey: # leancloud application app key

# Search Systems
# Available value:
#     swiftype | google | local
search:
    use: swiftype
    swiftype_key: xxxxxxxxx

# Analytics Systems
# Available value:
#     baidu | google | cnzz
analytics:
    google_site_id: 
    baidu_site_id: xxxxxxxxxx
    cnzz_site_id:

# Leancloud Views
leancloud:
    enable: false
    app_id: #你的 app_id
    app_key: #你的 app_key
    av_core_mini: &quot;xxxxxxxxxxxxxxxxxxx&quot;

# Busuanzi 不蒜子 Views
busuanzi:
    enable: true
    all_site_uv: true
    post_pv: true
    busuanzi_pure_mini_js: &quot;xxxxxxxxxxxx&quot;

sitemap: 
  path: sitemap.xml
baidusitemap:
  path: baidusitemap.xml
</code></pre><h4 id="集成服务"><a href="#集成服务" class="headerlink" title="集成服务"></a>集成服务</h4><ul>
<li><code>materialcdn</code>: 使用 cdn 来加速 Material 主题需要使用到的一些静态资源,例如 jq 等,但我感觉效果不是很明显,所以没有使用.</li>
<li><p><code>comment</code>: 文章使用的评论系统,内置的目前有四种</p>
<ul>
<li><code>Disqus/Disqus_click</code>: 这两个区别不是很大,后者需要点击才显示评论,但在国内环境下,<strong>加载速度很慢</strong>,不建议使用<ul>
<li><code>changyan</code>: 畅言,推荐使用。唯一缺点就是<em>国内使用需要域名提前备案<strong>,</strong></em>但是备案的话可以随便先填一个正规的（百度搜）等通过审核了，再把域名改成自己的**，是不是很机智～</li>
<li><del><code>163gentie</code>: 网易云跟帖,这个配置起来很简单,不关风格还是功能都比较完善,推荐使用,只需要去注册一下<a href="https://link.juejin.im?target=https%3A%2F%2Fgentie.163.com%2F" target="_blank" rel="external">网易云跟帖</a>,然后设置好自己的评论格式,再在<code>gentie_productKey</code>这一栏当中填入你的 key 就行.这个 key 在<code>获取代码</code>中的 <code>WEB 代码</code>当中,如下图:</del><strong>网易跟贴不幸被封了</strong>～<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/177c5e346a95cf5d2118b83cec24cb51?imageView2/0/w/1280/h/960" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><code>search</code>: 推荐使用swiftype，搜索界面比百度谷歌搜索美观，搜索速度很快，且配置简单。<br>¬去swiftype官网注册账号，创建引擎，按照步骤把域名填入，swiftype的爬虫会自动抓取你当前域名下的页面，点击安装搜索，在代码中找到图下这段代码，填入主题配置文件中的swiftype_key中，如下。即可配置成功。<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fjttehawrtj30hb05ct8u.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fjttflowokj30ob04l0sw.jpg" alt=""><br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fjttgg2l7hj309g05j0sp.jpg" alt="效果图"></li>
<li><p><code>analytics</code>: 网站的数据统计与分析,关于这一块推荐使用国内的<code>baidu</code>,百度在这一方面确实做得更加符合国情一些,而且我们还可以绑定微信公众号,随时了解自己网站的相关统计数据.</p>
</li>
<li><p>百度统计: 只需要登录<a href="https://link.juejin.im?target=http%3A%2F%2Ftongji.baidu.com%2F" target="_blank" rel="external">百度统计</a>,在站点的代码获取页面复制<code>hm.js?</code>后面那串统计脚本id,填入<code>site_id</code>即可.<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/516434ae0998dc249bf5b2e14dcafc9b?imageView2/0/w/1280/h/960" alt=""></p>
</li>
<li><code>Leancloud</code>/<code>busuanzi</code>: <code>Pv&amp;amp;UV</code>统计,这里我偷懒直接使用的不蒜子的服务,使用不蒜子仅需在<strong>主题配置文件</strong>中将<code>busuanzi: enable:</code> 的值设置为 <code>true</code><ul>
<li>enable: 默认为 false。</li>
<li>all_site_uv: 默认为 false,可统计全站的独立访客人数，即可在 <code>blog_info</code> 模块的 <code>Menu</code> 菜单中看到</li>
<li>post_pv: 默认为 false,统计每篇文章的页面浏览次数，在文章页的 <strong>分享按钮</strong> 菜单中可看到</li>
<li>busuanzi_pure_mini_js: 统计 <code>js</code>,调用不蒜子统计<code>js</code>文件，可将该文件保存至你的 WebServer 或 CDN 中，然后在这里填入 URL</li>
</ul>
</li>
<li><code>sitemap</code>/<code>baidusitemap</code>: 关于搜索引擎优化,会在下面进行说明.<br>以下页面配置好后只是已经存在于你的博客里面了,可以直接输入相应地址查看,但是要想在侧边栏新建快捷入口,<strong>请参考该文<code>侧边栏</code>中<code>pages</code>的相关配置.</strong></li>
</ul>
<h4 id="创建友情链接页面"><a href="#创建友情链接页面" class="headerlink" title="创建友情链接页面"></a>创建<code>友情链接</code>页面</h4><h5 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h5><p>在 hexo 目录下的 <code>source</code> 文件夹中内创建一个名为 <code>links</code>的文件夹。</p>
<p>然后在文件内创建一个名为 <code>index.md</code> 的 Markdown 文件。</p>
<p>最后在 <code>index.md</code> 文件内写入如下内容即可。</p>
<pre><code>    ---
    title: links
    date:
    layout: links
    ---
</code></pre><p>这里要注意的是<code>title</code>(对应的链接名称) 可修改，<code>layout</code> 不可修改。</p>
<h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5><p>只需我们同样在 hexo 目录下的 <code>source</code> 文件夹内创建一个名为 <code>_data</code>（禁止改名）的文件夹。</p>
<p>然后在文件内创建一个名为 <code>links.yml</code> 的文件,在其中添加相关数据即可。</p>
<p>这里单个友情链接的格式为：</p>
<pre><code>    Name:
        link: http://example.com
        avatar: http://example.com/avatar.png
        descr: &quot;这是一个描述&quot;
</code></pre><p>添加多个友情链接，我们只需要根据上面的格式重复填写即可。</p>
<ul>
<li>将 <code>Name</code> 改为友情链接的名字，例如 <code>Viosey</code>。</li>
<li><code>http://example.com</code> 为友情链接的地址。</li>
<li><code>http://example.com/avatar.png</code> 为友情链接的头像。</li>
<li><code>这是一个描述</code> 为友情链接描述。</li>
</ul>
<h4 id="创建「图库」页面"><a href="#创建「图库」页面" class="headerlink" title="创建「图库」页面"></a>创建「图库」页面</h4><h5 id="创建页面-1"><a href="#创建页面-1" class="headerlink" title="创建页面"></a>创建页面</h5><p>在 hexo 目录下的 <code>source</code> 文件夹内创建一个名为 <code>gallery</code>的文件夹。</p>
<p>然后在文件内创建一个名为 <code>index.md</code> 的 Markdown 文件。</p>
<p>在 <code>index.md</code> 文件内写入如下内容即可。</p>
<pre><code>    ---
    title: gallery
    date:
    layout: gallery
    ---
</code></pre><p><code>title</code> 可修改，<code>layout</code> 不可修改(同上)。</p>
<h5 id="添加数据-1"><a href="#添加数据-1" class="headerlink" title="添加数据"></a>添加数据</h5><p>在 hexo 目录下的 <code>source</code> 文件夹内创建一个名为 <code>_data</code>（禁止改名）的文件夹。</p>
<p>然后在文件内创建一个名为 <code>gallery.yml</code> 的文件,在其中添加如下格式的数据即可。</p>
<p>其中单个图片的格式为：</p>
<pre><code>    Name:
        full_link: http://example.com/full-image.png
        thumb_link: http://example.com/thumb-image.png
        descr: &quot;这是一个描述&quot;
</code></pre><p>添加多张图片，只需要根据上面的格式重复填写即可。</p>
<ul>
<li>将 <code>Name</code> 改为图片名字，例如 <code>Material</code>。</li>
<li><code>http://example.com/full-image.png</code> 为完整图片的地址。</li>
<li><code>http://example.com/thumb-image.png</code> 为图片缩略图的地址，如果没有缩略图也可使用完整图片的地址。</li>
<li><code>这是一个描述</code> 为图片描述。</li>
</ul>
<h4 id="创建「标签云」页面"><a href="#创建「标签云」页面" class="headerlink" title="创建「标签云」页面"></a>创建「标签云」页面</h4><h5 id="创建页面-2"><a href="#创建页面-2" class="headerlink" title="创建页面"></a>创建页面</h5><p>在 hexo 目录下的 <code>source</code> 文件夹内创建一个名为 <code>tags</code>（只是建议，可根据自己喜好修改）的文件夹。</p>
<p>然后在文件内创建一个名为 <code>index.md</code> 的 Markdown 文件。</p>
<p>在 <code>index.md</code> 文件内写入如下内容。</p>
<pre><code>    ---
    title: tags
    date:
    layout: tags
    ---
</code></pre><p><code>title</code> 可修改，<code>layout</code> 不可修改。</p>
<h4 id="创建「时间轴」页面"><a href="#创建「时间轴」页面" class="headerlink" title="创建「时间轴」页面"></a>创建「时间轴」页面</h4><h5 id="创建页面-3"><a href="#创建页面-3" class="headerlink" title="创建页面"></a>创建页面</h5><p>在 hexo 目录下的 <code>source</code> 文件夹内创建一个名为 <code>timeline</code>（只是建议，可根据自己喜好修改）的文件夹。</p>
<p>然后在文件内创建一个名为 <code>index.md</code> 的 Markdown 文件。</p>
<p>在 <code>index.md</code> 文件内写入如下内容即可。</p>
<pre><code>    ---
    title: timeline
    date:
    layout: timeline
    ---
</code></pre><p><code>title</code> 可修改，<code>layout</code> 不可修改。</p>
<p>到此,关于<code>Material</code>主题的相关配置我觉得已经说得算是比较清楚了,至于上面提到的blog网站的seo优化在我的另一篇博客中有详细阐述.<a href="http://pancakeawesome.ink/2017/09/23/%E7%BD%91%E7%AB%99%20SEO%20%E4%BC%98%E5%8C%96/">传送门</a></p>
<h2 id="如何操作该博客"><a href="#如何操作该博客" class="headerlink" title="如何操作该博客"></a>如何操作该博客</h2><p>相信应该有部分童鞋看完前面所有的配置估计已经被绕的云里雾里的,但不要担心不要害怕,当你配置好后接下来的使用简便.这里我简单的说下按照我这个流程配置完后,日常的使用操作吧.</p>
<h3 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h3><ol>
<li><del><code>hexo g</code>: 生成当前博客</del> 重新编写后的 gulp 任务可以直接生成完成<code>public</code>文件夹中的生成以及压缩.</li>
<li><code>gulp build~~</code>: 生成文件后再压缩已生成的代码,图片等</li>
<li><code>hexo d</code>: 将最终代码推送上去</li>
</ol>
<h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><h4 id="使用命令行"><a href="#使用命令行" class="headerlink" title="使用命令行"></a>使用命令行</h4><pre><code>    hexo new &lt;你的文章名&gt;
</code></pre><h4 id="手动创建"><a href="#手动创建" class="headerlink" title="手动创建"></a>手动创建</h4><p>在 hexo 主目录下 <code>source／_posts</code> 新建以 <code>.md</code> 为后缀的文件。</p>
<h4 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h4><p>Front-matter 是文件最上方以 <code>---</code> 分隔的一块区域,主要用于指定个别文件的变量来设置我们的相关文章等页面,具体位置如下</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fhexo.io%2Fzh-cn%2Fdocs%2Ffront-matter.html" target="_blank" rel="external">Front-matter - 官方介绍</a></p>
<table><br>    <thead><br>        <tr><br>            <th>参数</th><br>            <th>描述</th><br>            <th>默认值</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td><code>layout</code></td><br>            <td>布局</td><br>            <td>post</td><br>        </tr><br>        <tr><br>            <td><code>title</code></td><br>            <td>标题</td><br>            <td>文件名</td><br>        </tr><br>        <tr><br>            <td><code>date</code></td><br>            <td>建立日期</td><br>            <td>文件建立日期</td><br>        </tr><br>        <tr><br>            <td><code>updated</code></td><br>            <td>更新日期</td><br>            <td>文件更新日期</td><br>        </tr><br>        <tr><br>            <td><code>tags</code></td><br>            <td>标签（不适用于分页）</td><br>            <td></td><br>        </tr><br>        <tr><br>            <td><code>categories</code></td><br>            <td>分类（不适用于分页）</td><br>            <td></td><br>        </tr><br>        <tr><br>            <td><code>permalink</code></td><br>            <td>覆盖文章网址</td><br>            <td></td><br>        </tr><br>        <tr><br>            <td><code>thumbnail</code></td><br>            <td>缩略图地址</td><br>            <td></td><br>        </tr><br>        <tr><br>            <td><code>toc</code></td><br>            <td>显示 TOC 按钮</td><br>            <td>true</td><br>        </tr><br>        <tr><br>            <td><code>comment</code></td><br>            <td>显示评论</td><br>            <td>true</td><br>        </tr><br>        <tr><br>            <td><code>notag</code></td><br>            <td>不生成标签按钮</td><br>            <td>false</td><br>        </tr><br>        <tr><br>            <td><code>top</code></td><br>            <td>置顶</td><br>            <td>false</td><br>        </tr><br>        <tr><br>            <td><code>mathJax</code></td><br>            <td>启用 Mathjax</td><br>            <td>false</td><br>        </tr><br>        <tr><br>            <td><strong>description</strong></td><br>            <td><strong>每篇文章在搜索结果中显示的链接描述</strong></td><br>            <td>站点配置文件中的 description</td><br>        </tr><br>    </tbody><br></table>

<h4 id="缩略图功能"><a href="#缩略图功能" class="headerlink" title="缩略图功能"></a>缩略图功能</h4><p>在 Material 主题中，每个 Scheme 都有缩略图功能。<br>    只需要在 <code>Front-matter</code> 中添加参数 <code>thumbnail:</code>，然后填入缩略图地址即可。</p>
<h3 id="修改你的文章模板"><a href="#修改你的文章模板" class="headerlink" title="修改你的文章模板"></a>修改你的文章模板</h3><p>当你每次使用<code>hexo new 你的文章名</code>时,默认生成的模板是这个样子的</p>
<pre><code>    ---
    title: XXXX
    tag: XXXX
    date: XXXX
    ---
</code></pre><p>但这种这种文章模板没有一大堆描述属性,例如<code>description</code>,<code>thumbnail</code>等,明显不能满足我们的日常需求,所以我们这是一般会去修改我们的默认模板来满足我们的需求.这是我们只需修改<code>/scaffolds/</code>下相应的文件即可.</p>
<pre><code>    post.md  =&gt;  对应hexo new 生成的md模板
    page.md  =&gt;  对应hexo new page生成的categories模板
</code></pre><p>例如我修改的就是<code>/scaffolds/post.md</code>:</p>
<pre><code>    ---
    title: {{ title }} //文章标题
    tags: [] //文章的标签
    categories: 文章的分类
    description: 文章的搜索结果描述
    thumbnail: &#39;文章缩略图位置&#39;
    date: {{ date }} //时间
    ---
</code></pre><p>这里还可以添加一些文章公共的开头等文字</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后,关于我自己这篇博客的折腾过程基本上是说清楚了,如果那里有写的不够清楚或者有问题的地方,欢迎大家来邮箱或者qq（<a href="http://pancakeawesome.ink/">博客网站首页</a>有)交流指正.</p>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[系统入门sass（语法篇）]]></title>
      <url>/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8sass(%E8%AF%AD%E6%B3%95%E7%AF%87).html</url>
      <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>定义变量的语法：<br>在有些编程语言中（如，JavaScript）声明变量都是使用关键词“var”开头，但是在 Sass 不使用这个关键词，而是使用大家都喜欢的美元符号<code>“$”</code>开头。我想用一张图来解释，我一直坚信，一图胜千言万语：<br><img src="http://img.mukewang.com/551e065c0001435e07870307.jpg" alt=""><br>上图非常清楚告诉了大家，Sass 的变量包括三个部分：</p>
<ul>
<li>声明变量的符号“$”</li>
<li>变量名称</li>
<li>赋予变量的值<br>来看一个简单的示例，假设你的按钮颜色可以给其声明几个变量：<pre><code>$brand-primary : darken(#428bca, 6.5%) !default; // #337ab7
$btn-primary-color : #fff !default;
$btn-primary-bg : $brand-primary !default;
$btn-primary-border : darken($btn-primary-bg, 5%) !default;
</code></pre>如果值后面加上!default则表示默认值。<br>注：了解 Bootstrap 的 Sass 版本的同学，就一眼能看出，上面的示例代码是 Bootstrap 定义 primarybutton 的颜色。</li>
</ul>
<h4 id="如果变量需要镶嵌在字符串之中，就必须需要写在-之中。"><a href="#如果变量需要镶嵌在字符串之中，就必须需要写在-之中。" class="headerlink" title="如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。"></a>如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。</h4><pre><code> $side : left;

 　　.rounded {

 　　　　border-#{$side}-radius: 5px;

 　　}
</code></pre><h3 id="计算功能"><a href="#计算功能" class="headerlink" title="计算功能"></a>计算功能</h3><p>SASS允许在代码中使用算式：</p>
<pre><code> body {

 　　　　margin: (14px/2);

 　　　　top: 50px + 100px;

 　　　　right: $var  * 10%;

 　　}
</code></pre><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a><strong>嵌套</strong></h3><p>SASS允许选择器嵌套。比如，下面的CSS代码：</p>
<pre><code> div h1 {

 　　　　color : red;

 　　}
</code></pre><p>可以写成：</p>
<pre><code> div {

 　　　　hi {

 　　　　　　color:red;

 　　　　}

 　　}
</code></pre><p>属性也可以嵌套，比如border-color属性，可以写成：</p>
<pre><code> p {

 　　　　border: {

 　　　　　　color: red;

 　　　　}

 　　}
</code></pre><p><strong>注意，border后面必须加上冒号。</strong></p>
<p>在嵌套的代码块内，可以使用<code>&amp;</code>引用父元素。比如<code>a:hover</code>伪类，可以写成：</p>
<pre><code> a {

　\&amp;:hover { color: #ffb3ff; }

　}
</code></pre><p><strong>注意&amp;后面的<code>:</code>后面不能加空格</strong></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h3><p>SASS共有两种注释风格。</p>
<ul>
<li>标准的CSS注释 <code>/* comment */</code>，会保留到编译后的文件。</li>
<li>单行注释<code>// comment</code>，只保留在<code>SASS源文件</code>中，编译后被省略。</li>
</ul>
<p>在<code>/*</code>后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。</p>
<pre><code> /*! 

 　　　　重要注释！

 　　*/
</code></pre><h2 id="代码的重用"><a href="#代码的重用" class="headerlink" title="代码的重用"></a><strong>代码的重用</strong></h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><p>SASS允许一个选择器，继承另一个选择器。比如，现有<code>class1</code>：</p>
<pre><code> .class1 {

 　　　　border: 1px solid #ddd;

 　　}
</code></pre><p>class2要继承class1，就要使用<code>@extend</code>命令：</p>
<pre><code> .class2 {

 　　　　@extend .class1;

 　　　　font-size:120%;

 　　}
</code></pre><p><strong>注意：</strong></p>
<ul>
<li>sass不支持嵌套选择器的继承，比如:</li>
</ul>
<pre><code>.b .c {
    color: red;
}

.a {
    @extend .b .c;
}
</code></pre><p><strong>这样写是错误的❌,sass不会编译成功</strong></p>
<ul>
<li>如果你只想让某个样式只用来继承给别的样式，而不想让这个样式输出到css文件中（就像接口一样），可以使用%去修饰样式，这样这个样式就只能用来继承，不能输出到css文件中<pre><code>%error {
  color: red;
}
.serious-error {
  @extend %error;
}
</code></pre></li>
</ul>
<h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h3><p>Mixin有点像C语言的宏<code>（macro）</code>，是可以重用的代码块。</p>
<p>使用<code>@mixin</code>命令，定义一个代码块。</p>
<pre><code> @mixin left {

 　　　　float: left;

 　　　　margin-left: 10px;

 　　}
</code></pre><p>使用<code>@include</code>命令，调用这个mixin。</p>
<pre><code> div {

 　　　　@include left;

 　　}
</code></pre><p>mixin的强大之处，在于可以指定参数和缺省值。</p>
<pre><code> @mixin left($value: 10px) {

 　　　　float: left;

 　　　　margin-right: $value;

 　　}
</code></pre><p>使用的时候，根据需要加入参数：</p>
<pre><code> div {

 　　　　@include left(20px);

 　　}
</code></pre><p>下面是一个mixin的实例，用来生成浏览器前缀。</p>
<pre><code> @mixin rounded($vert, $horz, $radius: 10px) {

 　　　　border-#{$vert}-#{$horz}-radius: $radius;

 　　　　-moz-border-radius-#{$vert}#{$horz}: $radius;

 　　　　-webkit-border-#{$vert}-#{$horz}-radius: $radius;

 　　}
</code></pre><p>使用的时候，可以像下面这样调用：</p>
<pre><code> #navbar li { @include rounded(top, left); }

 　　#footer { @include rounded(top, left, 5px); }
</code></pre><h3 id="颜色函数"><a href="#颜色函数" class="headerlink" title="颜色函数"></a><strong>颜色函数</strong></h3><p>SASS提供了一些内置的颜色函数，以便生成系列颜色。</p>
<pre><code> lighten(#cc3, 10%)  // #d6d65c

 　　darken(#cc3, 10%)  //  #a3a329

 　　grayscale(#cc3) // #808080

 　　complement(#cc3) // #33c
</code></pre><h3 id="插入文件"><a href="#插入文件" class="headerlink" title="插入文件"></a><strong>插入文件</strong></h3><p><code>@import</code>命令，用来插入外部文件。</p>
<pre><code> @import &quot;path/filename.scss&quot;;
</code></pre><p>如果插入的是<code>.css</code>文件，则等同于css的<code>import</code>命令。</p>
<pre><code> @import &quot;foo.css&quot;;
</code></pre><h2 id="五、高级用法"><a href="#五、高级用法" class="headerlink" title="五、高级用法"></a><strong>五、高级用法</strong></h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a><strong>条件语句</strong></h3><p><code>@if</code>可以用来判断：</p>
<pre><code> p {

 　　　　@if 1 + 1 == 2 { border: 1px solid; }

 　　　　@if 5 &amp;lt; 3 { border: 2px dotted; }

 　　}
</code></pre><p>配套的还有<code>@else</code>命令：</p>
<pre><code> @if lightness($color) &amp;gt; 30% {

 　　　　background-color: #000;

 　　} @else {

 　　　　background-color: #fff;

 　　}
</code></pre><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a><strong>循环语句</strong></h3><p>SASS支持<code>for循环</code>：</p>
<pre><code> @for $i from 1 to 10 {

 　　　　.border-#{$i} {

 　　　　　　border: #{$i}px solid blue;

 　　　　}

 　　}
</code></pre><p>也支持<code>while循环</code>：</p>
<pre><code> $i: 6;

 　　@while $i &amp;gt; 0 {

 　　　　.item-#{$i} { width: 2em * $i; }

 　　　　$i: $i - 2;

 　　}
</code></pre><p><code>each</code>命令，作用与<code>for</code>类似：</p>
<pre><code> @each $member in a, b, c, d {

 　　　　.#{$member} {

 　　　　　　background-image: url(&quot;/image/#{$member}.jpg&quot;);

 　　　　}

 　　}
</code></pre><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a><strong>自定义函数</strong></h3><p>SASS允许用户编写自己的函数。</p>
<pre><code> @function double($n) {

 　　　　@return $n * 2;

 　　}

 　　#sidebar {

 　　　　width: double(5px);

 　　}
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[系统入门sass（基础篇）]]></title>
      <url>/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8sass(%E5%9F%BA%E7%A1%80%E7%AF%87).html</url>
      <content type="html"><![CDATA[<h2 id="什么是-CSS-预处理器？"><a href="#什么是-CSS-预处理器？" class="headerlink" title="什么是 CSS 预处理器？"></a>什么是 CSS 预处理器？</h2><p>定义：<br>CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。<br>通俗的说，“CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题”，例如你可以在 <strong>CSS 中使用变量、简单的逻辑程序、函数</strong>（如右侧代码编辑器中就使用了变量<code>$color</code>）等等在编程语言中的一些基本特性，<strong>可以让你的 CSS 更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处</strong>。<br>其它 CSS 预处理器语言：<br>CSS 预处理器技术已经非常的成熟，而且也涌现出了很多种不同的 <strong>CSS 预处理器语言</strong>，比如说：</p>
<ul>
<li>Sass（SCSS）</li>
<li>LESS</li>
<li>Stylus</li>
<li>Turbine</li>
<li>Swithch CSS</li>
<li>CSS Cacheer</li>
<li>DT CSS<br>如此之多的 CSS 预处理器，那么<code>“我应该选择哪种 CSS 预处理器？”</code>也相应成了最近网上的一大热门话题，在 Linkedin、Twitter、CSS-Trick、知乎以及各大技术论坛上，很多人为此争论不休。相比过去我们对是否应该使用 CSS 预处理器的话题而言，这已经是很大的进步了。<br>到目前为止，在众多优秀的 CSS 预处理器语言中就属 Sass、LESS 和 Stylus 最优秀，讨论的也多，对比的也多。<h2 id="Sass-和-SCSS-有什么区别？"><a href="#Sass-和-SCSS-有什么区别？" class="headerlink" title="Sass 和 SCSS 有什么区别？"></a>Sass 和 SCSS 有什么区别？</h2>Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass，两者之间不同之处有以下两点：</li>
</ul>
<ol>
<li>文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名</li>
<li>语法书写方式不同，Sass 是以严格的<span style="color:#B22222;">缩进式</span>语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。</li>
</ol>
<p>先来看一个示例：</p>
<p><strong>Sass 语法</strong></p>
<pre><code class="sass">$font-stack: Helvetica, sans-serif  //定义变量
$primary-color: #333 //定义变量

body
  font: 100% $font-stack
  color: $primary-color
</code></pre>
<p><strong>SCSS 语法</strong></p>
<pre><code class="scss">$font-stack: Helvetica, sans-serif;
$primary-color: #333;

body {
  font: 100% $font-stack;
  color: $primary-color;
  }
</code></pre>
<p><strong>编译出来的 CSS</strong></p>
<pre><code class="css">body {
  font: 100% Helvetica, sans-serif;
  color: #333;
}
</code></pre>
<h2 id="Sass-编译"><a href="#Sass-编译" class="headerlink" title="Sass 编译"></a>Sass 编译</h2><p>常常有人会问，使用 Sass 进行开发，那么是不是直接通过<code>“&lt;link&gt;”</code>引用<code>“.scss”</code>或<code>“.sass</code>”文件呢？</p>
<p>那么这里告诉大家，在项目中还是引用“.css”文件，Sass 只不过是做为一个预处理工具，提前帮你做事情，只有你需要时候，他才有攻效。</p>
<p>这样一来，也就有了这章需要介绍的内容—— Sass 的编译。因为 Sass 开发之后，要让 Web 页面能调用 Sass 写好的东西，就得有这么一个过程，这个过程就称之为 Sass 编译过程。Sass 的编译有多种方法：</p>
<ul>
<li>命令编译</li>
<li>GUI工具编译</li>
<li>自动化编译</li>
</ul>
<h3 id="命令编译"><a href="#命令编译" class="headerlink" title="命令编译"></a>命令编译</h3><p>命令编译是指使用你电脑中的命令终端，通过输入 Sass 指令来编译 Sass。这种编译方式是最直接也是最简单的一种方式。因为只需要在你的命令终端输入：</p>
<p><strong>单文件编译：</strong></p><br><code>bash
sass &lt;要编译的Sass文件路径&gt;/style.scss:&lt;要输出CSS文件路径&gt;/style.css</code><br><p>这是对一个单文件进行编译，如果想对整个项目所有 Sass 文件编译成 CSS 文件，可以这样操作：</p>

<p><strong>多文件编译：</strong></p><br><code>bash
sass sass/:css/</code><br><p>上面的命令表示将项目中“sass”文件夹中所有“.scss”(“.sass”)文件编译成“.css”文件，并且将这些 CSS 文件都放在项目中“css”文件夹中。</p>

<p><strong>缺点及解决方法：</strong></p>

<p>在实际编译过程中，你会发现上面的命令，只能一次性编译。每次个性保存“.scss”文件之后，都得重新执行一次这样的命令。如此操作太麻烦，其实还有一种方法，就是在编译 Sass 时，<span style="color:#B22222;">开启“<strong>watch</strong>”功能，这样只要你的代码进行任保修改，都能自动监测到代码的变化，并且给你直接编译出来：</span></p><br><code>bash
sass --watch &amp;lt;要编译的Sass文件路径&amp;gt;/style.scss:&amp;lt;要输出CSS文件路径&amp;gt;/style.css</code><br><p>当然，使用 sass 命令编译时，可以带很多的参数：</p>

<p><a href="http://img.mukewang.com/54f54b7a00014d3006690586.jpg" target="_blank" rel="external"><img alt="" src="http://img.mukewang.com/54f54b7a00014d3006690586.jpg" style="width: 355px;"></a></p>

<p><strong>watch 举例：</strong></p>

<p></p><p>来看一个简单的示例，假设我本地有一个项目，我要把项目中“bootstrap.scss”编译出“bootstrap.css”文件，并且将编译出来的文件放在“css”文件夹中，我就可以在我的命令终端中执行：</p><p></p>
<pre><code class="bash">sass --watch sass/bootstrap.scss:css/bootstrap.css
</code></pre>
<p></p><p>一旦我的 bootstrap.scss 文件有任何修改，只要我重新保存了修改的文件，命令终端就能监测，并重新编译出文件：<br><img src="http://img.mukewang.com/54f54bcb00016b1005680288.jpg" alt=""></p>
<h3 id="GUI-界面工具编译"><a href="#GUI-界面工具编译" class="headerlink" title="GUI 界面工具编译"></a>GUI 界面工具编译</h3><p>或许你会说，我一直讨厌使用命令来做事情，我喜欢那种能看得到的界面操作。那么你可以考虑使用 GUI 界面工具来对 Sass 进行编译。当然不同的 GUI 工具操作方法略有不同。</p>
<p>我比较推荐使用以下两个:<br><a href="http://www.w3cplus.com/preprocessor/sass-gui-tool-koala.html" target="_blank" rel="external">Koala</a><br><a href="http://www.w3cplus.com/preprocessor/sass-gui-tool-codekit.html" target="_blank" rel="external">CodeKit</a></p>
<h3 id="自动化编译"><a href="#自动化编译" class="headerlink" title="自动化编译"></a>自动化编译</h3><p>喜欢自动化研究的同学，应该都知道 <span style="color:#B22222;"><strong>Grunt </strong></span>和 <span style="color:#B22222;"><strong>Gulp </strong></span>这两个东东。如果您正在使用其中的任何一种，那么你也可以通过他们来配置 Sass 的编译。这里仅列出两个示例代码（具体情况要根据您的项目环境来做一定的修改，不建议生搬硬套，容易发生命案，呵呵。</p>
<p><strong>1、<span style="color:#B22222;">Grunt </span>配置 Sass 编译的示例代码</strong></p>
<pre class="code">module.exports = function(grunt) {
    grunt.initConfig({
        pkg: grunt.file.readJSON('package.json'),
        sass: {
            dist: {
                files: {
                    'style/style.css' : 'sass/style.scss'
                }
            }
        },
        watch: {
            css: {
                files: '**/*.scss',
                tasks: ['sass']
            }
        }
    });
    grunt.loadNpmTasks('grunt-contrib-sass');
    grunt.loadNpmTasks('grunt-contrib-watch');
    grunt.registerTask('default',['watch']);
}</pre>

<p><strong>2、<span style="color:#B22222;">Gulp </span>配置 Sass 编译的示例代码</strong></p>
<pre class="code">var gulp = require('gulp');
var sass = require('gulp-sass');

gulp.task('sass', function () {
    gulp.src('./scss/*.scss')
        .pipe(sass())
        .pipe(gulp.dest('./css'));
});

gulp.task('watch', function() {
    gulp.watch('scss/*.scss', ['sass']);
});

gulp.task('default', ['sass','watch']);</pre>

<h2 id="常见的编译错误"><a href="#常见的编译错误" class="headerlink" title="常见的编译错误"></a>常见的编译错误</h2><p>在编译 Sass 代码时常常会碰到一些错误，让编译失败。这样的错误有系统造成的也有人为造成的，但大部分都是人为过失引起编译失败。<br>而最为常见的一个错误就是<strong>字符编译</strong>引起的。在Sass的编译的过程中，是不是支持“GBK”编码的。所以在创建 Sass 文件时，就需要将文件编码设置为“utf-8”。<br>另外一个错误就是路径中的<strong>中文字符</strong>引起的。建议在项目中文件命名或者文件目录命名不要使用中文字符。而至于人为失误造成的编译失败，在编译过程中都会有具体的说明，大家可以根据编译器提供的错误信息进行对应的修改。</p>
<h2 id="不同样式风格的输出方法"><a href="#不同样式风格的输出方法" class="headerlink" title="不同样式风格的输出方法"></a>不同样式风格的输出方法</h2><p>众所周知，每个人编写的 CSS 样式风格都不一样，有的喜欢将所有样式代码都写在同一行，而有的喜欢将样式分行书写。在 Sass 中编译出来的样式风格也可以按不同的样式风格显示。其主要包括以下几种样式风格：</p>
<ul>
<li>嵌套输出方式 nested</li>
<li>展开输出方式 expanded  </li>
<li>紧凑输出方式 compact </li>
<li>压缩输出方式 compressed<h3 id="嵌套输出方式-nested"><a href="#嵌套输出方式-nested" class="headerlink" title="嵌套输出方式 nested"></a>嵌套输出方式 nested</h3><h4 id="嵌套输出方式-nested-1"><a href="#嵌套输出方式-nested-1" class="headerlink" title="嵌套输出方式 nested"></a>嵌套输出方式 nested</h4>Sass 提供了一种嵌套显示 CSS 文件的方式。例如</li>
</ul>
<pre><code>nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}
</code></pre><p>在编译的时候带上参数“ <code>--style nested</code>”:<br><code>sass --watch test.scss:test.css --style nested</code><br>编译出来的 CSS 样式风格：</p>
<pre><code>nav ul {
  margin: 0;
  padding: 0;
  list-style: none; }
nav li {
  display: inline-block; }
nav a {
  display: block;
  padding: 6px 12px;
  text-decoration: none; }
</code></pre><p>如下图所示：<br><img src="http://img.mukewang.com/54f54dab00019a0504880296.jpg" alt=""></p>
<h3 id="展开输出方式-expanded"><a href="#展开输出方式-expanded" class="headerlink" title="展开输出方式 expanded"></a>展开输出方式 expanded</h3><h4 id="嵌套输出方式-expanded"><a href="#嵌套输出方式-expanded" class="headerlink" title="嵌套输出方式 expanded"></a>嵌套输出方式 expanded</h4><pre><code>nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}
</code></pre><p>在编译的时候带上参数<code>“ --style expanded”:
sass --watch test.scss:test.css --style expanded</code><br>这个输出的 CSS 样式风格和 nested 类似，<strong>只是大括号在另起一行</strong>，同样上面的代码，编译出来：</p>
<pre><code>nav ul {
  margin: 0;
  padding: 0;
  list-style: none;
}
nav li {
  display: inline-block;
}
nav a {
  display: block;
  padding: 6px 12px;
  text-decoration: none;
}
</code></pre><p><img src="http://img.mukewang.com/54f54e2c0001c2c004850281.jpg" alt=""></p>
<h3 id="紧凑输出方式-compact"><a href="#紧凑输出方式-compact" class="headerlink" title="紧凑输出方式 compact"></a>紧凑输出方式 compact</h3><h4 id="嵌套输出方式-compact"><a href="#嵌套输出方式-compact" class="headerlink" title="嵌套输出方式 compact"></a>嵌套输出方式 compact</h4><pre><code>nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}
</code></pre><p>在编译的时候带上参数<code>“ --style compact”:
sass --watch test.scss:test.css --style compact</code><br>该方式适合那些喜欢单行 CSS 样式格式的朋友，编译后的代码如下：</p>
<pre><code>nav ul { margin: 0; padding: 0; list-style: none; }
nav li { display: inline-block; }
nav a { display: block; padding: 6px 12px; text-decoration: none; }
</code></pre><p><img src="http://img.mukewang.com/54f7b4bb00014f9908020299.jpg" alt=""></p>
<h3 id="压缩输出方式-compressed"><a href="#压缩输出方式-compressed" class="headerlink" title="压缩输出方式 compressed"></a>压缩输出方式 compressed</h3><h4 id="压缩输出方式-compressed-1"><a href="#压缩输出方式-compressed-1" class="headerlink" title="压缩输出方式 compressed"></a>压缩输出方式 compressed</h4><pre><code>nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}
</code></pre><p>在编译的时候带上参数<code>“ --style compressed”:
sass --watch test.scss:test.css --style compressed</code><br>压缩输出方式会去掉标准的 Sass 和 CSS 注释及空格。也就是压缩好的 CSS 代码样式风格：</p>
<pre><code>nav ul{margin:0;padding:0;list-style:none}nav li{display:inline-block}nav a{display:block;padding:6px 12px;text-decoration:none}
</code></pre><p><img src="http://img.mukewang.com/54f5511d0001b5c206660401.jpg" alt=""></p>
<p>编译出来的CSS样式风格的选择完全是个人喜好问题，可以根据自己喜欢的风格选择参数。<br><strong>一段时间之后，你实际上就不再需要写 CSS 代码了，只用写 Sass 代码。在这种情况下，你只需要设定输出格式为压缩格式，知道输出的 CSS 代码可以直接使用即可。</strong></p>
<h2 id="Sass-的调试"><a href="#Sass-的调试" class="headerlink" title="Sass 的调试"></a>Sass 的调试</h2><p><img src="http://img.mukewang.com/54f7b71d0001bb0b05050268.jpg" alt=""></p>
<ul>
<li>Sass 调试一直以来都是一件头痛的事情，使用 Sass 的同学都希望能在浏览器中直接调试 Sass 文件，能找到对应的行数。值得庆幸的是，现在实现并不是一件难事，只要你的浏览器支持“<code>sourcemap</code>”功能即可。早一点的版本，需要在编译的时候添加<code>“--sourcemap”</code>  参数：<pre><code>sass --watch --scss --sourcemap style.scss:style.css
</code></pre>在 Sass3.3 版本之上（我测试使用的版本是 3.4.7），不需要添加这个参数也可以：<pre><code>sass --watch style.scss:style.css
</code></pre>在命令终端，你将看到一个信息：<pre><code>&gt;&gt;&gt; Change detected to: style.scss
write style.css
write style.css.map
</code></pre></li>
<li>在 chrome://flags/ 中启用 Developer Tools Experiments (开发者工具实验)</li>
<li>在 Developer tools 设置 Experiments 选项下开启File system folders in Sources Panel，再重启Developer tools，就会多出Workspace选项。</li>
</ul>
<p><em>这时你就可以像前面展示的 gif 图一样，调试你的 Sass 代码。</em></p>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[三分钟入门markdown]]></title>
      <url>/%E4%B8%89%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8markdown.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>经常会用markdown来编写博客，这些语法你需要知道</strong></p>
<h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><p><code>wiki释义:</code></p>
<blockquote>
<p><code>Markdown</code> 是一种轻量级<code>标记语言</code>，创始人为约翰·格鲁伯（John Gruber）和亚伦·斯沃茨（Aaron Swartz）。<br>它允许人们“使用易读易写的纯文本格式编写文档，然后<strong>转换成有效的XHTML(或者HTML)文档</strong>”。<br>这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>
</blockquote>
<p>Markdown的优点包括但不限于以下几点:</p>
<ul>
<li>纯文本，所以兼容性极强，可以用所有文本编辑器打开。</li>
<li>让你专注于文字而不是排版。</li>
<li>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。</li>
<li>Markdown 的标记语法有极好的可读性。</li>
</ul>
<h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a><a href="#Markdown_u8BED_u6CD5" title="Markdown语法"></a>Markdown语法</h2><p>Markdown语法简洁明了、容易学习，下面一一介绍。</p>
<h3 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a><a href="#u57FA_u672C_u7B26_u53F7" title="基本符号"></a>基本符号</h3><ul>
<li><code>*</code>, <code>-</code> , <code>+</code>： 这3个符号的效果都一样， 被称为Markdown符号</li>
<li><code>空白行</code> : 表示另起一个段落,对应HTML中的 <code>&lt;p&gt;</code> 元素</li>
<li><code>` </code>  表示 <code>内联代码</code>， <code>tab</code>是用来标记<code>代码段</code>，分别对应HTML的 <code>code</code> ， <code>pre</code> 元素</li>
</ul>
<h3 id="段落换行"><a href="#段落换行" class="headerlink" title="段落换行"></a><a href="#u6BB5_u843D_u6362_u884C" title="段落换行"></a>段落换行</h3><ul>
<li><code>单个回车</code>会被解释为<code>空格</code></li>
<li>一个空白行(即<code>两个回车</code>)变成单一段落<code>&amp;lt;p&amp;gt;</code></li>
<li>连续3个Markdown符号，然后回车，表示<code>&amp;lt;hr&amp;gt;</code>横线</li>
<li><strong>连续多个空格会被解释为单个空格</strong><br><a id="more"></a></li>
</ul>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a><a href="#u6807_u9898" title="标题"></a>标题</h3><ul>
<li>在文字前面加上1-6个<code>#</code>来实现, 代表HTML中的六级标题 <code>h1</code>-<code>h6</code></li>
<li>在文字左右各加1-3各符号，可本别实现斜体<code>&lt;i&gt;</code>、加粗<code>&lt;&gt;</code>和斜体加粗</li>
</ul>
<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题

*斜体*

**加粗**

***加粗斜体***


### 引用

*   在第一行加上 `&gt;` 和一个`空格`，表示引用，还可以嵌套, 对应HTML中的`&lt;blockquote&gt;`标签

### [](#u5217_u8868 &quot;列表&quot;)列表

*   使用*,+,-加上一个空格来表示,对应HTML中的`&lt;ul&gt;`标签
*   可以支持嵌套
*   有序列表用 `数字`+`.`+`空格` 来表示,对应HTML中的`&lt;ol&gt;`标签
*   如果列表内容很长，不需要手工输入换行符，css控制段落的宽度，会自动的缩放的
</code></pre><p><strong>无序列表:</strong></p>
<pre><code>- 无序列表 1
- 无序列表 2
- 无序列表 3
</code></pre><p><strong>有序列表:</strong></p>
<pre><code>1. 有序列表 1
2. 有序列表 2
3. 有序列表 3
</code></pre><p><strong>列表嵌套:</strong></p>
<pre><code>- One
    + What
    + Why
    + How
- Two
- Three
</code></pre><p><strong>或者每级列表前面加上两个空格 表示向下一级缩进</strong></p>
<pre><code>- One
    - waht
    - why
    - how        
- Two
- Three
</code></pre><p><strong>效果如下</strong></p>
<p><strong>无序列表:</strong></p>
<ul>
<li>无序列表 1</li>
<li>无序列表 2</li>
<li>无序列表 3</li>
</ul>
<p><strong>有序列表:</strong></p>
<ol>
<li>有序列表 1</li>
<li>有序列表 2</li>
<li>有序列表 3</li>
</ol>
<p><strong>列表嵌套:</strong></p>
<ul>
<li>One<ul>
<li>What</li>
<li>Why</li>
<li>How</li>
</ul>
</li>
<li>Two</li>
<li>Three<br><strong>或者每级列表前面加上两个空格 表示向下一级缩进</strong></li>
<li>One<ul>
<li>What</li>
<li>Why</li>
<li>How</li>
</ul>
</li>
<li>Two</li>
<li>Three</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="#u94FE_u63A5" title="链接"></a>链接</h3><p>在 Markdown 中，插入链接只需要使用 <code>[显示文本](连接地址)</code>这种格式，<br>插入图片只需要使用<code>![图片描述](图片链接地址)</code>这种格式即可,其中前者对应于<br>HTML中的<code>a</code>标签，后者对应<code>img</code>标签，方括号中的图片描述为img标签的的<code>alt</code>属性值</p>
<p>还有一种建立链接的方式，称为<code>参考式</code>, 参考式的链接是在链接文字的括号后面再接上另一个方括号， 而在第二个方括号里面要填入用以辨识链接的标记: <code>[显示文本][id]</code>或<code>![图片描述][id]</code>. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来：<code>[id]: http://example.com/</code></p>
<p>示例:</p>
<pre><code>个人信息:

[Wentong](http://pancakeawesome.com/)

- [GitHub][1]
- [Facebook][]
- [Twitter][Weblog]

[1]: https://github.com/pancakeawesome/
[Facebook]: https://facebook.com/pancakeawesome/
[Weblog]: https://twitter.com/pancakeawesome/
</code></pre><p><strong>效果如下:</strong></p>
<p>个人信息:</p>
<p><a href="http://www.fangwentong.com/" target="_blank" rel="external">Wentong</a></p>
<ul>
<li><a href="https://github.com/fangwentong/" target="_blank" rel="external">GitHub</a></li>
<li><a href="https://facebook.com/fangwentong/" target="_blank" rel="external">Facebook</a></li>
<li><a href="https://twitter.com/fangwentong/" target="_blank" rel="external">Twitter</a></li>
</ul>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a><a href="#u8868_u683C" title="表格"></a>表格</h3><table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:right">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td>col 3 is</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符<code>$$</code>包裹 <code>TeX</code> 或 <code>LaTeX</code> 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 <code>Mathjax</code>对数学公式进行渲染。如：</p>
<pre><code>$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $$
$$
x \href{why-equal.html}{=} y^2 + 1
$$
</code></pre><p>同时也支持 HTML 属性，如：</p>
<pre><code>$$ (x+1)^2 = \class{hidden}{(x+1)(x+1)} $$
$$
(x+1)^2 = \cssId{step1}{\style{visibility:hidden}{(x+1)(x+1)}}
$$
</code></pre><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a><a href="#u7279_u6B8A_u7B26_u53F7" title="特殊符号"></a>特殊符号</h3><ul>
<li>用<code>\</code> 来转义，表示文本中的markdown符号</li>
</ul>
<h3 id="兼容HTML语法"><a href="#兼容HTML语法" class="headerlink" title="兼容HTML语法"></a><a href="#u517C_u5BB9HTML_u8BED_u6CD5" title="兼容HTML语法"></a>兼容HTML语法</h3><p>我们知道，Markdown最终要通过Markdown解释器转换为HTML文档, 而Markdown是一种书写的格式，它的语法种类很少，只对应HTML标记中的一小部分, 不在Markdown涵盖范围内的标签， 可以直接在文档中用HTML书写.</p>
<h3 id="自定义Markdown样式"><a href="#自定义Markdown样式" class="headerlink" title="自定义Markdown样式"></a><a href="#u81EA_u5B9A_u4E49Markdown_u6837_u5F0F" title="自定义Markdown样式"></a>自定义Markdown样式</h3><p>注意到，Markdown解释器将Markdown文本转换为HTML文档，我们编写CSS，并在生成的HTML文档中引用这个样式表, 可以达到自定义Markdown显示风格的效果.</p>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo+githubio+material搭建你的个人博客（基础篇）]]></title>
      <url>/hexo+githubio+material%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(%E5%9F%BA%E7%A1%80%E7%AF%87).html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><del><em>本帖为更新贴</em></del><br>之前用的是csdn的blog，经常写一些学习笔记📒和it相关的技术，但是总觉得自己是做前端的，总用第三方的blog平台感觉不是很合适。于是狠下心来花了两三天终于通过githubio和hexo把静态博客网站给搭起来了，参照了一些网上blog的教程，但是因为环境和版本的愿意还是有很多坑，走了很多弯路，但还好最终都一步一步淌过来了，今天才把blog给完善好，但是收获很多：资源部署，域名解析，seo，资源打包📦压缩等等技术，让我受益匪浅。<br><del><strong>今天实在太累，加上还在公司实习，没时间把blog相关的技术分享给大家，之后两三天之类会发出来～</strong></del><br><img src="https://raw.githubusercontent.com/jeasonstudio/images/8b550fd8d102bf7625f47511b35489612626636d/20160526/gitlogo.jpg" alt="GitHub Logo"></p>
<p><img src="https://raw.githubusercontent.com/jeasonstudio/images/8b550fd8d102bf7625f47511b35489612626636d/20160526/Hexologo.gif" alt="Hexo Logo"></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a><a href="#环境配置" title="环境配置"></a><strong>环境配置</strong></h2><p><a href="https://hexo.io/docs" target="_blank" rel="external">Hexo官网</a>上本就有对Hexo安装及使用的详细介绍，墙裂推荐。这里来讲述自己安装的亲身步骤，或有区别。</p>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a><a href="#Node-js" title="Node.js"></a>Node.js</h3><p>用来生成静态页面。移步<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js官网</a>，下载v5.5.0 Stable 一路安装即可。</p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a><a href="#Git" title="Git"></a>Git</h3><p>用来将本地Hexo内容提交到Github上。Xcode自带Git，这里不再赘述。如果没有Xcode可以参考<a href="https://hexo.io/docs" target="_blank" rel="external">Hexo官网</a>上的安装方法。    </p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><a href="#安装Hexo" title="安装Hexo"></a><strong>安装Hexo</strong></h2><p>当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：</p>
<pre><code>$ sudo npm install -g hexo
</code></pre><p>输入管理员密码（Mac登录密码）即开始安装 (<code>sudo</code>:linux系统管理指令  <code>-g</code>:全局安装)</p>
<blockquote>
<p>注意坑一：<a href="https://hexo.io/docs" target="_blank" rel="external">Hexo官网</a>上的安装命令是<code>$ npm install -g hexo-cli</code>，安装时不要忘记前面加上<code>sudo</code>，否则会因为权限问题报错。</p>
</blockquote>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><a href="#初始化" title="初始化"></a>初始化</h3><p>终端cd到一个你选定的目录，执行<code>hexo init</code>命令：</p>
<pre><code>$ hexo init blog
</code></pre><p><code>blog</code>是你建立的文件夹名称。cd到<code>blog</code>文件夹下，执行如下命令，安装npm：</p>
<pre><code>$ npm install
</code></pre><p>执行如下命令，开启hexo服务器：</p>
<pre><code>$ hexo s
</code></pre><p>此时，浏览器中打开网址<a href="http://0.0.0.0:4000" target="_blank" rel="external">http://localhost:4000</a>，能看到如下页面：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fjo3tmedk7j30m00cn3z1.jpg" alt=""></p>
<p>本地设置好后，接下来开始关联Github。</p>
<h2 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a><a href="#关联Github" title="关联Github"></a><strong>关联Github</strong></h2><h3 id="添加ssh-key到Github"><a href="#添加ssh-key到Github" class="headerlink" title="添加ssh key到Github"></a><a href="#添加ssh-key到Github" title="添加ssh key到Github"></a>添加ssh key到Github</h3><h4 id="检查SSH-keys是否存在Github"><a href="#检查SSH-keys是否存在Github" class="headerlink" title="检查SSH keys是否存在Github"></a><a href="#检查SSH-keys是否存在Github" title="检查SSH keys是否存在Github"></a>检查SSH keys是否存在Github</h4><p>执行如下命令，检查SSH keys是否存在。如果有文件<code>id_rsa.pub</code>或<code>id_dsa.pub</code>，则直接进入步骤1.3将SSH key添加到Github中，否则进入下一步生成SSH key。</p>
<pre><code>$ ls -al ~/.ssh
</code></pre><h4 id="生成新的ssh-key"><a href="#生成新的ssh-key" class="headerlink" title="生成新的ssh key"></a><a href="#生成新的ssh-key" title="生成新的ssh key"></a>生成新的ssh key</h4><p>执行如下命令生成public/private rsa key pair，注意将<code>your_email@example.com</code>换成你自己注册Github的邮箱地址。</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;
</code></pre><p>默认会在相应路径下（<code>~/.ssh/id_rsa.pub</code>）生成<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件。</p>
<h4 id="将ssh-key添加到Github中"><a href="#将ssh-key添加到Github中" class="headerlink" title="将ssh key添加到Github中"></a><a href="#将ssh-key添加到Github中" title="将ssh key添加到Github中"></a>将ssh key添加到Github中</h4><p>Find前往文件夹<code>~/.ssh/id_rsa.pub</code>打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。</p>
<p>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:</p>
<p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方<code>Add key</code>绿色按钮即可。</p>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a><a href="#创建仓库" title="创建仓库"></a>创建仓库</h3><p>登录你的Github帐号，新建仓库，名为<code>用户名.github.io</code>固定写法，如<code>pancakeawesome.github.io</code>,如下图所示：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fjnv225vpoj30ro0gkjsn.jpg" alt="exam"></p>
<p>本地的<code>blog</code>文件夹下内容为：</p>
<table>
<thead>
<tr>
<th style="text-align:left">1</th>
<th style="text-align:left">config.yml</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">db.json</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">node_modules</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">package.json</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">scaffolds</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">source</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">themes</td>
</tr>
</tbody>
</table>
<p>终端cd到<code>blog</code>文件夹下，<code>vim</code>打开<code>_config.yml</code>，命令如下：</p>
<pre><code>$ vim _config.yml
</code></pre><p>打开后往下滑到最后，修改成下边的样子：</p>
<pre><code>deploy:
    type: git
    repository: https://github.com/pancakeawesome/pancakeawesome.github.io.git
   branch: master
</code></pre><p>   你需要将<code>repository</code>后<code>pancakeawesome</code>换成你自己的用户名，地址在上图<code>2</code>位置获取。hexo 3.1.1版本后<code>type:</code>值为<code>git</code>。</p>
<p>注意坑二：在配置所有的<code>_config.yml</code>文件时（包括theme中的），在所有的冒号<code>:</code>后边都要加一个空格，否则执行hexo命令会报错，切记 切记</p>
<p>在<code>blog</code>文件夹目录下执行生成静态页面命令：</p>
<pre><code>   $ hexo generate        或者：hexo g
</code></pre><p>此时若出现如下报错：</p>
<pre><code>ERROR Local hexo not found in ~/blog
ERROR Try runing: &#39;npm install hexo --save&#39;
</code></pre><p>则执行命令：</p>
<pre><code>npm install hexo --save
</code></pre><p>若无报错，自行忽略此步骤。</p>
<p>再执行配置命令：</p>
<pre><code>$ hexo deploy            或者：hexo d
</code></pre><blockquote>
<p>注意坑三：若执行命令<code>hexo deploy</code>仍然报错：无法连接git，则执行如下命令来安装<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="external">hexo-deployer-git</a>：</p>
<pre><code>$ npm install hexo-developer-git --save
</code></pre></blockquote>
<p>再次执行<code>hexo generate</code>和<code>hexo deploy</code>命令</p>
<p>此时，浏览器中打开网址<a href="http://pancakeawesome.github.io" target="_blank" rel="external">http://pancakeawesome.github.io</a>（将<code>pancakeawesome</code>换成你的用户名）能看到和打开<code>http://localhost:4000</code>时一样的页面。</p>
<h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a><a href="#发布文章" title="发布文章"></a>发布文章</h3><p>终端cd到<code>blog</code>文件夹下，执行如下命令新建文章：</p>
<pre><code>hexo new &quot;postName&quot;
</code></pre><p>名为<code>postName.md</code>的文件会建在目录<code>/blog/source/_posts</code>下。你当然可以用vim来编辑文章。</p>
<blockquote>
<p>在此说明一下，我一直都在用微软的 VSCode编辑器来编写MarkDown，如果你有什么更好的建议，我会非常感激的。<br>另外MarkDown格式的语法教程，前面的博文里有，但我知道你懒，<a href="http://pancakeawesome.ink/2017/09/18/%E4%B8%89%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8markdown/">传送门</a>。</p>
</blockquote>
<p>文章编辑完成后，终端cd到<code>blog</code>文件夹下，执行如下命令来发布：</p>
<pre><code>hexo generate             //生成静态页面
hexo deploy            //将文章部署到Github&amp;lt;/pre&amp;gt;
</code></pre><hr>
<p><strong>至此，Mac上搭建基于Github的Hexo博客就完成了。下面的内容是介绍安装theme，添加评论功能和绑定个人域名，如果有兴趣且还有耐心的话，请继续吧。</strong></p>
<h2 id="安装theme"><a href="#安装theme" class="headerlink" title="安装theme"></a><a href="#安装theme" title="安装theme"></a><strong>安装theme</strong></h2><p>你可以到<a href="https://hexo.io/themes/" target="_blank" rel="external">Hexo官网主题页</a>去搜寻自己喜欢的theme。这里以<a href="https://material.viosey.com/" target="_blank" rel="external">hexo-theme-material</a>为例</p>
<p>终端cd到 <code>blog</code> 目录下执行如下命令：</p>
<pre><code>$ git clone https://github.com/viosey/hexo-theme-material themes/material
</code></pre><p>将<code>blog</code>目录下<code>_config.yml</code>里<code>theme</code>的名称<code>landscape</code>修改为<code>material</code></p>
<p>终端cd到<code>blog</code>目录下执行如下命令(每次部署文章的步骤)：</p>
<pre><code>$ hexo clean           //清除缓存文件 (db.json) 和已生成的静态文件 (public)
$ hexo g             //生成缓存和静态文件
hexo d             //重新部署到服务器
</code></pre><p>至于更改theme内容，比如名称，描述，头像等去修改<code>blog/_config.yml</code>文件和<code>blog/themes/material/_config.yml</code>文件中对应的属性名称即可， 不要忘记冒号<code>:</code>后加空格。  <a href="https://material.viosey.com/" target="_blank" rel="external"> Material 使用文档</a>里有极详细的介绍。</p>
<h2 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a><a href="#绑定个人域名" title="绑定个人域名"></a><strong>绑定个人域名</strong></h2><p>现在使用的域名是Github提供的二级域名，也可以绑定为自己的个性域名。购买域名，可以到<a href="https://sg.godaddy.com/zh/" target="_blank" rel="external">GoDaddy官网</a>，网友亲切称呼为：狗爹，也可以到<a href="http://wanwang.aliyun.com/" target="_blank" rel="external">阿里万网</a>购买。</p>
<h3 id="Github端"><a href="#Github端" class="headerlink" title="Github端"></a><a href="#Github端" title="Github端"></a>Github端</h3><p>在<code>/blog/themes/landscape/source</code>目录下新建文件名为：<code>CNAME</code>文件，注意没有后缀名！直接将自己的域名如：<code>pancakeawesome.com</code>写入。</p>
<p>终端cd到<code>blog</code>目录下执行如下命令重新部署：</p>
<pre><code>$ hexo clean
$ hexo g
$ hexo d
</code></pre><blockquote>
<p>注意坑四：网上许多都是说在Github上直接新建<code>CNAME</code>文件，如果这样的话，在你下一次执行<code>hexo d</code>部署命令后<code>CNAME</code>文件就消失了，因为本地没有此文件嘛。</p>
</blockquote>
<h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a><a href="#域名解析" title="域名解析"></a>域名解析</h3><p>如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。</p>
<p>登录你注册域名的网站，比如万网，在你购买的域名后边点击：解析 –&gt; 添加解析</p>
<p>记录类型：CNAME</p>
<p>主机记录：将域名解析为example.com（不带www），填写@或者不填写</p>
<p>记录值：pancakeawesome.github.io.    (不要忘记最后的<code>.</code>，<code>pancakeawesome</code>改为你自己的用户名)，点击保存即可。</p>
<p>此时，大功告成！</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a><a href="#后记" title="后记"></a><strong>后记</strong></h2><p>参考<a href="http://pancakeawesome.ink/">pancakeawesome博客：pancakeawesome</a>，希望对大家有所帮助，欢迎吐槽～</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><a href="#参考链接" title="参考链接"></a><strong>参考链接</strong></h2><ul>
<li><a href="https://hexo.io/docs" target="_blank" rel="external">Hexo官网</a></li>
<li><a href="http://leopardpan.github.io/2015/08/12/hexo/" target="_blank" rel="external">HEXO</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动态规划迷思]]></title>
      <url>/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%BF%B7%E6%80%9D.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在刷leetcode发现很多线性表的算法题都都可以用<strong><code>dp（dynamic programming）</code></strong>去做，如果你了解dp的思想，其实很多复杂的问题都能化为简单的问题，非常棒～<br><em>let’s start~</em></p>
<h2 id="动态规划中递推式的求解方法不是动态规划的本质。"><a href="#动态规划中递推式的求解方法不是动态规划的本质。" class="headerlink" title="动态规划中递推式的求解方法不是动态规划的本质。"></a>动态规划中递推式的求解方法不是动态规划的本质。</h2><ol>
<li>动态规划的本质，是对问题<strong><em>状态的定义</em></strong>和<strong><em>状态转移方程</em>的定义</strong>。<br>引自维基百科<blockquote>
<p><strong>dynamic programming</strong> is a method for solving a complex problem by <strong>breaking it down into a collection of simpler subproblems</strong>.</p>
</blockquote>
</li>
</ol>
<p>动态规划是通过<strong>拆分问题，</strong>定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。<br>本题下的其他答案，大多都是在说递推的求解方法，但<strong>如何拆分问题</strong>，才是动态规划的核心。<br>而<strong>拆分问题</strong>，靠的就是<strong><em>状态的定义</em></strong>和<strong><em>状态转移方程</em>的定义</strong>。</p>
<h2 id="什么是状态的定义？"><a href="#什么是状态的定义？" class="headerlink" title="什么是状态的定义？"></a>什么是<strong>状态的定义？</strong></h2><p><strong><br>首先想说大家千万不要被下面的数学式吓到，这里只涉及到了函数相关的知识。</strong><br>我们先来看一个动态规划的教学必备题：</p>
<blockquote>
<p>给定一个数列，长度为N，<br>求这个数列的最长上升（递增）子数列（LIS）的长度.<br>以<br>1 7 2 8 3 4<br>为例。<br>这个数列的最长递增子数列是 1 2 3 4，长度为4；<br>次长的长度为3， 包括 1 7 8; 1 2 3 等.</p>
</blockquote>
<p>要解决这个问题，我们首先要<strong>定义这个问题</strong>和这个问题的子问题。<br>有人可能会问了，题目都已经在这了，我们还需定义这个问题吗？需要，原因就是这个问题在字面上看，找不出子问题，而没有子问题，这个题目就没办法解决。<br>所以我们来重新定义这个问题：</p>
<blockquote>
<p>给定一个数列，长度为N，<br>设<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">为：以数列中第k项结尾的最长递增子序列的长度.<br>求<img src="https://www.zhihu.com/equation?tex=F_%7B1%7D..F_%7BN%7D" alt="F_{1}..F_{N}"> 中的最大值.</p>
</blockquote>
<p>显然，这个新问题与原问题等价。<br>而对于<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">来讲，<img src="https://www.zhihu.com/equation?tex=F_%7B1%7D+..+F_%7Bk-1%7D" alt="F_{1} .. F_{k-1}">都是<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">的子问题：因为以第k项结尾的最长递增子序列（下称LIS），包含着以第<img src="https://www.zhihu.com/equation?tex=1..k-1" alt="1..k-1">中某项结尾的LIS。</p>
<p>上述的新问题<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">也可以叫做状态，定义中的“<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">为数列中第k项结尾的LIS的长度”，就叫做对状态的定义。<br>之所以把<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">做“状态”而不是“问题” ，一是因为避免跟原问题中“问题”混淆，二是因为这个新问题是数学化定义的。</p>
<p>对状态的定义只有一种吗？<em>当然不是</em>。<br>我们甚至可以二维的，以完全不同的视角定义这个问题：</p>
<blockquote>
<p>给定一个数列，长度为N，<br>设<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D" alt="F_{i, k}">为：<br>在前i项中的，长度为k的最长递增子序列中，最后一位的最小值. <img src="https://www.zhihu.com/equation?tex=1%5Cleq+k%5Cleq+N" alt="1\leq k\leq N">.<br>若在前i项中，不存在长度为k的最长递增子序列，则<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D" alt="F_{i, k}">为正无穷.<br>求最大的x，使得<img src="https://www.zhihu.com/equation?tex=F_%7BN%2Cx%7D" alt="F_{N,x}">不为正无穷。</p>
</blockquote>
<p>这个新定义与原问题的等价性也不难证明，请读者体会一下。<br>上述的<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D" alt="F_{i, k}">就是状态，定义中的“<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D" alt="F_{i, k}">为：在前i项中，长度为k的最长递增子序列中，最后一位的最小值”就是对状态的定义。</p>
<h2 id="什么是状态转移方程？"><a href="#什么是状态转移方程？" class="headerlink" title="什么是状态转移方程？"></a>什么是<strong>状态转移方程</strong>？</h2><p>上述状态定义好之后，状态和状态之间的关系式，就叫做<strong>状态转移方程。</strong><br>比如，对于LIS问题，我们的第一种定义：</p>
<blockquote>
<p>设<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">为：以数列中第k项结尾的最长递增子序列的长度.设A为题中数列，状态转移方程为：<br><img src="https://www.zhihu.com/equation?tex=F_%7B1%7D+%3D+1" alt="F_{1} = 1"> （根据状态定义导出边界情况）<br><img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D%3Dmax%28F_%7Bi%7D%2B1+%7C+A_%7Bk%7D%3EA_%7Bi%7D%2C+i%5Cin+%281..k-1%29%29+" alt="F_{k}=max(F_{i}+1 | A_{k}"><img src="https://www.zhihu.com/equation?tex=%28k%3E1%29" alt="(k"></p>
</blockquote>
<p>用文字解释一下是：<br>以第k项结尾的LIS的长度是：保证第i项比第k项小的情况下，以第i项结尾的LIS长度加一的最大值，取遍i的所有值（i小于k）。<br>第二种定义：</p>
<blockquote>
<p>设<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D" alt="F_{i, k}">为：在数列前i项中，长度为k的递增子序列中，最后一位的最小值设A为题中数列，状态转移方程为：<br>若<img src="https://www.zhihu.com/equation?tex=A_%7Bi%7D%3EF_%7Bi-1%2Ck-1%7D" alt="A_{i}">则<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2Ck%7D%3Dmin%28A_%7Bi%7D%2CF_%7Bi-1%2Ck%7D%29+" alt="F_{i,k}=min(A_{i},F_{i-1,k}) "><br>否则：<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2Ck%7D%3DF_%7Bi-1%2Ck%7D+" alt="F_{i,k}=F_{i-1,k} "></p>
</blockquote>
<p>（边界情况需要分类讨论较多，在此不列出，需要根据状态定义导出边界情况。）<br>大家套着定义读一下公式就可以了，应该不难理解，就是有点绕。</p>
<p>这里可以看出，这里的状态转移方程，就是定义了问题和子问题之间的关系。<br>可以看出，状态转移方程就是带有条件的递推式。</p>
<h2 id="动态规划迷思"><a href="#动态规划迷思" class="headerlink" title="动态规划迷思"></a>动态规划迷思</h2><h3 id="“缓存”，“重叠子问题”，“记忆化”："><a href="#“缓存”，“重叠子问题”，“记忆化”：" class="headerlink" title="“缓存”，“重叠子问题”，“记忆化”："></a>“缓存”，“重叠子问题”，“记忆化”：</h3><p>这三个名词，都是在阐述递推式求解的技巧。以Fibonacci数列为例，计算第100项的时候，需要计算<u>第99项</u>和98项；在计算第101项的时候，需要第100项和<u>第99项</u>，这时候你还需要重新计算第99项吗？不需要，你只需要在第一次计算的时候把它记下来就可以了。<br>上述的需要再次计算的“第99项”，就叫“重叠子问题”。如果没有计算过，就按照递推式计算，如果计算过，直接使用，就像“缓存”一样，这种方法，叫做“记忆化”，这是递推式求解的技巧。这种技巧，通俗的说叫“花费空间来节省时间”。<strong>都不是动态规划的本质，**</strong>不是动态规划的核心。**</p>
<h3 id="“递归”："><a href="#“递归”：" class="headerlink" title="“递归”："></a>“递归”：</h3><p>递归是递推式求解的方法，连技巧都算不上。</p>
<h3 id="“无后效性”，“最优子结构”："><a href="#“无后效性”，“最优子结构”：" class="headerlink" title="“无后效性”，“最优子结构”："></a>“无后效性”，“最优子结构”：</h3><p>上述的状态转移方程中，等式右边不会用到下标大于左边i或者k的值，这是”无后效性”的通俗上的数学定义，符合这种定义的状态定义，我们可以说它具有“最优子结构”的性质，在动态规划中我们要做的，就是找到这种“最优子结构”。<br><strong>在对状态和状态转移方程的定义过程中，满足“最优子结构”是一个隐含的条件（否则根本定义不出来）。对状态和“最优子结构”的关系的进一步解释，<a href="http://www.zhihu.com/question/23995189/answer/35429905" target="_blank" rel="external">什么是动态规划？动态规划的意义是什么？ - 王勐的回答</a> 写的很好，大家可以去读一下。</strong></p>
<p>需要注意的是，一个问题可能有多种不同的状态定义和状态转移方程定义，存在一个有后效性的定义，<em><strong>不代表该问题不适用动态规划</strong></em>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>动态规划方法要寻找符合“最优子结构“的状态和状态转移方程的定义<em>，</em>在找到之后，这个问题就可以以“记忆化地求解递推式”的方法来解决。而寻找到的定义，才是动态规划的本质。</strong></p>
]]></content>
      
        <categories>
            
            <category> 算法思想 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法思想 </tag>
            
            <tag> 知乎 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[入门Webpack，看这篇就够了]]></title>
      <url>/%E5%85%A5%E9%97%A8Webpack%EF%BC%8C%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>webpack</code>是现在一款非常流行的<strong>模块化管理工具🔧</strong>，<strong><code>react+webpack+es6</code></strong>是很火的项目构建组合。</p>
<p><img src="https://img.funteas.com/e54cfd22c67adc465dff62272b905fc7?imageView2/2/w/800" alt=""></p>
<blockquote>
<p><code>webpack</code>会将有依赖关系的文件都视为一个模块，比如<code>scss</code>,<code>sass</code>,<code>less</code>,<code>css</code>结尾的文件，这样会产生一个模块群，<code>webpack</code>处理过后会产生可以被浏览器识别的一些文件，比如<code>Js</code>,<code>css</code>,<code>html</code>等。</p>
<p><a href="https://webpack.github.io/" target="_blank" rel="external">Webpack</a>在面对大型工程项目时，非常有优势，它最大的特点是很轻，不会加载打包冗余的文件，只会打包项目中用的到的模块。这是<code>webpack</code>的<strong>代码分割</strong>特性～</p>
<p><code>webpack</code>的<strong>模块热更新</strong>特性：当项目文件发生变化时，不需要开发人员手动刷新浏览器，<code>webpack</code>会自动刷新页面，极大地提高了开发效率，是不是很神奇！</p>
</blockquote>
<p><strong>注意：本文的webpack环境是<code>3.5.5</code>由于webpack的更新很快，每次更新都会更新新的语法，所以学习webpack的本质就可以</strong>，具体语法可以看webpack官网：<strong><a href="https://webpack.github.io/" target="_blank" rel="external">https://webpack.github.io/</a></strong></p>
<p>那么让我们快速以一个webpack demo的形式开始我们的webpack的学习吧～</p>
<h2 id="webpack处理资源文件：webpack版本：3-5-5"><a href="#webpack处理资源文件：webpack版本：3-5-5" class="headerlink" title="webpack处理资源文件：webpack版本：3.5.5"></a>webpack处理资源文件：webpack版本：3.5.5</h2><p><strong>因为每个版本的文档都会变化所以坑很多，请注意自己的版本</strong></p>
<h2 id="如何在terminal中安装webpack"><a href="#如何在terminal中安装webpack" class="headerlink" title="如何在terminal中安装webpack"></a>如何在terminal中安装webpack</h2><ul>
<li>新建project目录</li>
<li>初始化npm:<pre><code>npm init
</code></pre></li>
<li>安装webpack<pre><code>npm install webpack --save-dev
</code></pre></li>
<li>注意:dev参数是安装到本地项目文件夹下，并将webpack写入到package.json配置文件中的devdependecies参数中。</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkp0uuy0zxj30di04vwek.jpg" alt=""></p>
<ul>
<li>直接对js文件执行打包：<pre><code>webpack [source.file] [target.file]
</code></pre></li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fkp16i9tk2j30l905u74n.jpg" alt=""></p>
<p><strong>打包执行结果在命令行中的参数：</strong></p>
<ul>
<li><code>hash</code>:这次打包结果文件的hash值。</li>
<li><code>version</code>:webpack的版本。</li>
<li><code>time</code>：这次打包的所耗时间。</li>
<li><code>asset</code>：打包的结果文件。</li>
<li><code>size</code>：打包文件的大小。</li>
<li><code>chunks</code>：打包的入口文件的分块。</li>
<li><code>chunk names</code>：分块的名称。</li>
</ul>
<p>看一下打包结果文件hello.bundle.js的结构：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fkp19bxi7uj30s40bb3yt.jpg" alt=""></p>
<pre><code>/* 2 */
/***/ (function(module, exports, __webpack_require__) {
</code></pre><p>这段代码其实是webpack利用内置的<code>__webpack_require__</code>函数来代替源代码中的require方法来引用相关的文件并插入到bundle文件中：</p>
<p>hello.js入口文件：</p>
<pre><code>require(&#39;./world.js&#39;);
require(&#39;./style.css&#39;);

function function_name(argument) {
    // body...
    alert(argument);
}

function_name(&#39;hello!&#39;);
</code></pre><h2 id="建立项目的webpack配置文件"><a href="#建立项目的webpack配置文件" class="headerlink" title="建立项目的webpack配置文件"></a>建立项目的webpack配置文件</h2><p>新建项目初始目录：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fkp1lrxcrkj304d084glk.jpg" alt=""></p>
<ul>
<li>src：项目源代码目录。<ul>
<li>app.js:打包的入口文件。</li>
<li>components：项目组件目录。</li>
<li>assets:静态资源（图片）目录。</li>
<li>css：css资源目录。</li>
</ul>
</li>
<li>dist：打包后的静态资源目录。</li>
<li><strong>webpack.config.js:webpack的配置文件。</strong><br>以commonjs的模块化方式建立配置文件的框架,添加入口出口文件：</li>
</ul>
<pre><code>module.exports = {
  entry: __dirname + &#39;/src/app.js&#39;;
  output: {
      path: __dirname + &#39;/dist&#39;,
      filename: &#39;js/[name].bundle.js&#39;
  }
}
</code></pre><h3 id="webpack命令方式"><a href="#webpack命令方式" class="headerlink" title="webpack命令方式"></a>webpack命令方式</h3><p><code>npm run webpack</code>命令行运行参数：<br><code>npm run webpack --config webpack.config.js --progress  --colors --display-reasons --watch</code><br><em>这些参数具体的作用后文有写</em></p>
<h3 id="npm脚本执行方式"><a href="#npm脚本执行方式" class="headerlink" title="npm脚本执行方式"></a>npm脚本执行方式</h3><p>在npm的配置文件package.json中的scripts参数配置webpack：</p>
<pre><code>&quot;scripts&quot;: {
    &quot;webpack&quot;: &quot;webpack --config webpack.config.js --progress --colors&quot;
  }
</code></pre><p><em>常用的webpack执行参数：</em></p>
<pre><code>webpack --config webpack.config.js --progress  --colors --display-reasons --watch
</code></pre><ul>
<li><code>--config &lt;指定的webpack配置文件名称&gt;</code>: 指定webpack配置文件来执行webpack命令。</li>
<li><code>progress</code>:打包的过程。</li>
<li><code>--colors</code>:结果输出在命令行是彩色的。</li>
<li><code>--display-reasons</code>:打包的原因。</li>
<li><code>--watch</code>:自动监听项目代码文件的变化，自动执行webpack命令。</li>
</ul>
<h2 id="webpack的打包入口和出口文件配置"><a href="#webpack的打包入口和出口文件配置" class="headerlink" title="webpack的打包入口和出口文件配置"></a>webpack的打包入口和出口文件配置</h2><p>打包文件的路径设置在<em>webpack.config.js</em>文件中的output参数。</p>
<ul>
<li>entry:打包入口文件；<ul>
<li>string:单个入口文件路径。</li>
<li>array:多个入口文件路径。</li>
<li>object:多页面应用中的多个入口文件<ul>
<li>key: 不同页面的代号。</li>
<li>value: 和上面的value规定一样，可以是数组也可以是string。</li>
</ul>
</li>
</ul>
</li>
<li>output:打包出口文件。<ul>
<li><code>path</code>:生成出口文件的存储路径。</li>
<li><code>filename</code>:打包文件的名称（使用相对路径，不要使用绝对路径）</li>
<li><code>publicPath</code>:上线之后的项目路径。一旦配置了这个路径，所有路径都以这种路径为主。<br>具体配置如下：<pre><code>entry: __dirname + &#39;src/app.js&#39;,
output: {
  /**
   * __dirname: absolute file path
   * @type {[type]}
   */
  path:__dirname + &#39;/dist&#39;,
  /**
   * [name]: entry&#39;s chunck&#39;s key
   * [chunkhash]: file&#39;s md5 value(file version)
   * @type {String}
   */
  filename: &#39;js/[name].bundle.js&#39;,
  publicPath: &#39;http://cdn.com/&#39;
}
</code></pre><strong><code>path</code>之前要加<code>__dirname</code>，否则会报错，这是个坑，<code>__dirname</code>在nodejs语法中代表文件所在目录的绝对路径。</strong></li>
</ul>
</li>
</ul>
<h2 id="Webpack如何在项目自动生成html文件"><a href="#Webpack如何在项目自动生成html文件" class="headerlink" title="Webpack如何在项目自动生成html文件"></a>Webpack如何在项目自动生成html文件</h2><p>由于我们index页面中1引用的js文件有可能会带hash（每次打包都会变化）。这样我们每次都得手动改变INDEX页面中引用js的代码，非常麻烦。</p>
<p>那么如何在html中使用动态生成的打包后的文件呢？</p>
<ul>
<li>通过<code>html-webpack-plugin</code>这个插件自定义<code>html</code>，并且通过模版和其参数，使用外联的方式传入<code>scirpt</code>动态文件；<ul>
<li>我们可以使用WEbpakc的另一个核心的功能：<strong><code>plugins</code></strong><br>在webpack配置文件中配置<code>plugins</code>参数：</li>
</ul>
</li>
</ul>
<pre><code>plugins: [
        new htmlWebpackPlugin()
    ]
</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fkp2oj1rzvj30oi03474i.jpg" alt="打包效果：生成了相应的INDEX.html"><br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fkp2pvnon8j30v801tq2y.jpg" alt="dist打包目录下index页面中引入了相应的出口文件:bundle.js"></p>
<ul>
<li><p>通过向上述插件的模版中传入参数：</p>
<ul>
<li>一个对象：<ul>
<li><code>filename</code>:生成html文件的名称</li>
<li><code>template</code>:模版文件的相对路径（<strong>上下文环境是webpack.config.js文件的路径</strong>）</li>
<li><code>injecet</code>:script文件嵌入到html文件的哪个部分。</li>
<li><code>chunks</code>:</li>
<li><code>minify</code>:压缩选项。<ul>
<li><code>removeComments</code>:删除注释</li>
<li><code>collapseWhitespace</code>：删除空格<pre><code>plugins: [
new htmlWebpackPlugin({
filename: &#39;index.html&#39;,
template: &#39;index.html&#39;,
injecet: &#39;body&#39;,
chunks: [&#39;main&#39;],
minify: {
  removeComments: true,
  collapseWhitespace: true
}
})
]
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>同时htmlwebpackplugin也支持从WEbpack.config.js文件中向html页面中传入参数，支持ejs的语法形式，比如我们在htmlwebpackplugin传入相应参数：</p>
<pre><code>plugins: [
      new htmlWebpackPlugin({
          filename: &#39;index.html&#39;,
          template: &#39;index.html&#39;,
          // the position of script file to the html
          inject: &#39;body&#39;,
          title: &#39;this is c.html&#39;,
          date: new Date(),
      })
  ]
</code></pre><p>在模版文件中加入下列测试代码来引用传入的title和date变量：</p>
<pre><code>&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title%&gt;&lt;/title&gt;
</code></pre></li>
</ul>
<ul>
<li>如何通过上述插件<code>inline</code>的形式引用出口<code>js</code>文件：<ul>
<li>我们可以通过webpack暴露给我们的引用变量去获取相应的js文件。<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
  &lt;%= compilation.assets[htmlWebpackPlugin.files.chunks.main.entry.substr(htmlWebpackPlugin.files.publicPath.length)].source() %&gt;
&lt;/script&gt;
</code></pre><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fkp41iss8ej30v80ifwg3.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fkp48exje5j30ni0cc74p.jpg" alt="这样也会将相应的出口打包js文件引入进html文件中"></li>
</ul>
</li>
<li>我们也可以通过外链的形式在模版文件中自定义引入特定的js文件。<pre><code>&lt;% for(var k in htmlWebpackPlugin.files.chunks) { %&gt;
      &lt;% if(k != &#39;main&#39;) { %&gt;
          &lt;script type=&quot;text/javascript&quot; src=&#39;&lt;%= htmlWebpackPlugin.files.chunks[k].entry%&gt;&#39;&gt;&lt;/script&gt;
      &lt;% }%&gt;
  &lt;% }%&gt;
</code></pre><strong>以上代码可以实现main的js文件以内联的形式引入到html文件中，而其他js文件以外链的形式引入到html文件。</strong></li>
</ul>
<h3 id="多页面应用的配置"><a href="#多页面应用的配置" class="headerlink" title="多页面应用的配置"></a>多页面应用的配置</h3><p>多页面应用环境下，需要配置多个入口文件，配置多个htmlwebpackplugin插件从而生成多个html文件。<br>配置如下：</p>
<pre><code>module.exports = {
    entry: {
        main: &#39;./src/script/main.js&#39;,
        a: &#39;./src/script/a.js&#39;,
        b: &#39;./src/script/b.js&#39;,
        c: &#39;./src/script/c.js&#39;,
    },
    plugins: [
        new htmlWebpackPlugin({
            filename: &#39;a.html&#39;,
            template: &#39;index.html&#39;,
            // the position of script file to the html
            inject: false,
            title: &#39;this is a.html&#39;,
            // param can be got in html
            date: new Date(),
            chunks: [&#39;main&#39;,&#39;a&#39;]
        }),
        new htmlWebpackPlugin({
            filename: &#39;b.html&#39;,
            template: &#39;index.html&#39;,
            // the position of script file to the html
            inject: false,
            title: &#39;this is b.html&#39;,
            date: new Date(),
            chunks: [&#39;b&#39;]
        }),
        new htmlWebpackPlugin({
            filename: &#39;c.html&#39;,
            template: &#39;index.html&#39;,
            // the position of script file to the html
            inject: false,
            title: &#39;this is c.html&#39;,
            date: new Date(),
            excludeChunks: [&#39;c&#39;]
        })
    ]
}
</code></pre><p><em><code>chunks</code>:定义引入的chunk文件。</em><br><em><code>excludeChunks</code>:定义不引入的chunk文件。</em></p>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>loader和plugins无疑是<code>webpack</code>重要的两个概念。</p>
<h3 id="什么是Loader？"><a href="#什么是Loader？" class="headerlink" title="什么是Loader？"></a>什么是Loader？</h3><p>loader可以用来处理资源文件，接受资源文件作为参数，loader处理之后返回一个新的文件。</p>
<h3 id="Loader的特性"><a href="#Loader的特性" class="headerlink" title="Loader的特性"></a>Loader的特性</h3><ul>
<li>可串联</li>
<li>同步和异步的</li>
<li>可以接受参数</li>
<li>可以根据文件的正则表达式来处理特定文件</li>
<li>可以根据<code>npm</code>安装</li>
<li>获取webpack config的配置</li>
<li>loader可以生成额外的文件</li>
</ul>
<h3 id="使用loader的方式"><a href="#使用loader的方式" class="headerlink" title="使用loader的方式"></a>使用loader的方式</h3><ul>
<li>在require声明的路径前面配置。</li>
<li><strong>配置文件中配置（webpack.config.js）</strong></li>
<li>cli：在命令行中通过参数指定loader。</li>
</ul>
<h3 id="使用babel-loader转换es6语法"><a href="#使用babel-loader转换es6语法" class="headerlink" title="使用babel-loader转换es6语法"></a>使用babel-loader转换es6语法</h3><ul>
<li>安装babel-loader<br><em>命令行安装<code>babel-loader</code></em>：<pre><code>npm install babel-loader babel-core webpack --save-dev
</code></pre></li>
<li>配置babel-loader：<ul>
<li>配置test属性<br>test属性是一个正则表达式，loader会处理相应后缀的文件。</li>
<li>配置options属性<br>给options添加一个presets对象，值是一个数组，数组里面的值是指定loader如何去处理js文件，如果参数是<code>env</code>，代表用最新的es6语法去处理js文件。<ul>
<li>需要安装<code>presets</code>插件:<pre><code>npm install babel-preset-env --save-dev
</code></pre></li>
<li>配置presets属性<pre><code>      options: {
          // set the version of es6
          presets: [&#39;env&#39;]
      }
</code></pre></li>
</ul>
</li>
<li>配置<code>exclude</code>和<code>include</code>属性<br>配置exclude 和 include属性可以指定babel-loader处理的文件范围。<br><strong>注意⚠️：include和exclude属性必须是绝对路径，且使用绝对路径会加快loader找到相应文件的速度。</strong><br><strong>我们可以使用nodejs自带的api–path将相对路径解析相应的绝对路径：</strong><pre><code>var path = require(&#39;path&#39;);
path.resolve(__dirname, &#39;./node_modules&#39;);
</code></pre><em><code>__dirname</code>是<code>nodejs</code>中的绝对路径变量。</em></li>
</ul>
</li>
</ul>
<h3 id="使用loader处理css文件"><a href="#使用loader处理css文件" class="headerlink" title="使用loader处理css文件"></a>使用loader处理css文件</h3><ul>
<li>处理css文件<ul>
<li>安装<code>css-loader</code>,<code>style-loader</code>,<code>postcss-loader</code><pre><code>npm install --save-dev css-loader style-loader postcss-loader
</code></pre></li>
<li>入口文件app.js中引入css文件<pre><code>import &#39;./css/common.css&#39;;
</code></pre></li>
<li>配置对css文件的处理设置：<ul>
<li>use属性：loader数组。<br>使用多个loader对css文件处理。<br><strong>注意：⚠️loader处理方式是从右到左，数组的话就是从下往上。</strong></li>
</ul>
</li>
<li><code>postcss-loader</code>处理css文件<br><code>postcss-loader</code>是处理css文件的后处理器，可以实现加浏览器前缀等等功能。<code>postcss-loader</code>应该最先处理css文件。<br><strong>plugins属性是一个函数，这个函数会返回一个引入的插件的数组</strong><ul>
<li>配置<code>postcss-loader</code><ul>
<li>安装<code>autoprefixer</code>插件。<br><code>autoprefixer</code>插件可以自动根据浏览器版本种类添加前缀。<pre><code>npm install autoprefixer --save-dev
</code></pre></li>
<li>配置相应的plugins参数:<br><code>root</code>参数：表明插件处理文件的路径的根路径（从哪开始解析）</li>
<li>安装<code>postcss-import</code>    插件<br>处理在css文件中通过<code>@import</code>进来的资源文件。        </li>
<li>配置相应的plugins参数：<br><code>broswers</code>参数是处理浏览器版本的列表。<code>&#39;last 5 versions&#39;</code>代表支持最新的五个版本的浏览器。<pre><code>options: {
plugins: function () {
    return [
        require(&#39;postcss-import&#39;)({
        // this represent loader variable
            root:this.resourcePath
        }),
        require(&#39;autoprefixer&#39;)({
            broswers: [&#39;last 5 versions&#39;]
        })
      ]
}
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>注意postcss-loader预处理器的配置</em><br><strong><code>css-loader</code>保证webpack可以打包css模块</strong><br><strong><code>style-loader</code>保证可以在<code>js</code>文件中引入<code>css</code>代码，以<code>&lt;style&gt;</code>标签的形式加入到<code>html</code>中并显示其效果</strong></p>
<h3 id="使用less-loader，sass-loader处理css易处理语言"><a href="#使用less-loader，sass-loader处理css易处理语言" class="headerlink" title="使用less-loader，sass-loader处理css易处理语言"></a>使用less-loader，sass-loader处理css易处理语言</h3><p><strong>步骤</strong>：先用<code>less-loader</code>去处理<code>less</code>文件转换成<code>css</code>文件，再将<code>css</code>文件用<code>postcss-loader</code>预处理<code>css</code>文件，加上前缀等之类的功能，再用<code>css-loader</code>处理<code>css</code>文件中的<code>url</code>引用表达式，然后解析相关引用资源，最后使用<code>style-loader</code>处理<code>css</code>文件，将<code>css</code>代码插入到页面上。</p>
<ul>
<li>安装<code>less-loader</code>和<code>sass-loader</code><pre><code>npm install --save-dev less-loader sass-loader
</code></pre></li>
<li>配置<code>loader</code><pre><code>// less loader
    {
      test: /\.less$/,
      use: [
          {
          loader: &quot;style-loader&quot; // creates style nodes from JS strings 
        }, 
        {
            loader: &quot;css-loader&quot; // translates CSS into CommonJS 
              },
              { 
                loader: &#39;postcss-loader&#39;,
                // some plugins of postcss-loader:some options
                options: {
                    plugins: function () {
                        return [
                            require(&#39;postcss-import&#39;)({
                                root:this.resourcePath
                            }),
                            require(&#39;autoprefixer&#39;)({
                                broswers: [&#39;last 5 versions&#39;]
                            })
                        ]
                    }
                  }
              },
              {
               loader: &quot;less-loader&quot; // compiles Less to CSS 
             }
         ]
    },
    // sass loader
    {
      test: /\.scss$/,
      use: [
          {
          loader: &quot;style-loader&quot; // creates style nodes from JS strings 
        }, 
        {
            loader: &quot;css-loader&quot; // translates CSS into CommonJS 
              },
              { 
                loader: &#39;postcss-loader&#39;,
                // some plugins of postcss-loader:some options
                options: {
                    plugins: function () {
                        return [
                            require(&#39;postcss-import&#39;)({
                                root:this.resourcePath
                            }),
                            require(&#39;autoprefixer&#39;)({
                                broswers: [&#39;last 5 versions&#39;]
                            })
                        ]
                    }
                  }
              },
              {
               loader: &quot;sass-loader&quot; // compiles Less to CSS 
             }
         ]
    }
</code></pre></li>
</ul>
<h3 id="loader处理模版文件"><a href="#loader处理模版文件" class="headerlink" title="loader处理模版文件"></a>loader处理模版文件</h3><p>模版文件通常是生成html文件的模版。webpack有很多loader处理这些模版文件，包括ejs，jade或者html等等编写的模版。</p>
<h4 id="html-loader"><a href="#html-loader" class="headerlink" title="html-loader"></a><code>html-loader</code></h4><p><code>html-loader</code>会将html模版文件当成<strong>字符串</strong>来处理。<br>安装<code>html-loader</code></p>
<pre><code>npm install --save-dev html-loader
</code></pre><ul>
<li>html格式的模版文件<pre><code>&lt;div class=&quot;layer&quot;&gt;
  &lt;div&gt;this is html template file&lt;/div&gt;
&lt;/div&gt;
</code></pre></li>
<li>在js文件中引入tpl模版文件<pre><code>import tpl from &#39;./layer.tpl&#39;;
function layer() {
  return {
      name: &#39;layer&#39;,
      tpl: tpl 
  }
}
export default layer;
</code></pre><em>layer.js</em></li>
<li>在入口文件中引用<pre><code>import Layer from &#39;./components/layer/layer.js&#39;;
const App = function () {
  let dom = document.getElementById(&#39;app&#39;);
  let layer = Layer();
  // layer is a function
  dom.innerHTML = layer.tpl;
}
new App();
</code></pre><em>app.js</em><h4 id="ejs-loader"><a href="#ejs-loader" class="headerlink" title="ejs-loader"></a><code>ejs-loader</code></h4><code>ejs-loader</code>可以处理<code>ejs</code>,<code>tpl</code>格式的模版文件。</li>
<li>用ejs语法编写tpl文件<pre><code>&lt;div class=&quot;layer&quot;&gt;
  &lt;div&gt;this is &lt;%= name%&gt; layer&lt;/div&gt;
  &lt;% for(let i = 0;i &lt; arr.length; i ++) { %&gt;
      &lt;%= arr[i] %&gt;
  &lt;% }%&gt;
&lt;/div&gt;
</code></pre></li>
<li><p>在js文件中引入tpl模版文件。</p>
<pre><code>import tpl from &#39;./layer.tpl&#39;;
function layer() {
  return {
      name: &#39;layer&#39;,
      tpl: tpl 
  }
}
export default layer;
</code></pre><p><em>layer.js</em></p>
</li>
<li><p>在入口文件中引用</p>
<pre><code>import Layer from &#39;./components/layer/layer.js&#39;;
const App = function () {
  let dom = document.getElementById(&#39;app&#39;);
  let layer = Layer();
  // layer is a function
  dom.innerHTML = layer.tpl({
      name: &#39;Jobs&#39;,
      arr: [&#39;apple&#39;,&#39;xiaomi&#39;,&#39;oppo&#39;]
  });
}
new App();
</code></pre><p><em><code>app.js</code></em></p>
</li>
</ul>
<h3 id="loader处理图片资源文件"><a href="#loader处理图片资源文件" class="headerlink" title="loader处理图片资源文件"></a>loader处理图片资源文件</h3><p>图片往往是影响网页加载速度的罪魁祸首，<code>webpack</code>可以在项目上线之前通过loader处理大量的资源文件，优化网页加载速度。</p>
<h4 id="项目中通常三个地方会用到图片"><a href="#项目中通常三个地方会用到图片" class="headerlink" title="项目中通常三个地方会用到图片"></a>项目中通常三个地方会用到图片</h4><ul>
<li>根目录的<code>index.html</code>入口文件里使用；</li>
<li><code>less</code>,<code>sass</code>,<code>css</code>样式文件中引用图片；</li>
<li>模版文件中引用图片；<br><strong> 注意 ：</strong>如果在模版文件中如果要使用相对路径引用文件，<strong>则必须使用<code>require</code>引用文件</strong><pre><code>    &lt;img src=&quot;${ require(&#39;../../assets/logo36x36.png&#39;) }&quot;&gt;
</code></pre><em>模版文件中的图片引用</em></li>
</ul>
<h4 id="处理图片文件的loader通常有"><a href="#处理图片文件的loader通常有" class="headerlink" title="处理图片文件的loader通常有"></a>处理图片文件的loader通常有</h4><ul>
<li><code>file-loader</code>：可以处理引用本地图片文件。</li>
<li><code>url-loader</code>：可以按情况处理图片或者其他文件,通常处理重复性不高的http请求的小文件。当文件大小大于指定<code>limit</code>参数（byte为单位），则交给<code>file-loader</code>处理，如果小于这个<code>limit</code>则将图片和文件转位<a href="https://www.baidu.com/link?url=nBogYLNyNQjNiBpP1-dQPajqi7kfFr7JQIidMwG3Df2kmrGeX3sRBICHh3YWgg3uFUxAzTWAERCqc8Jf17ogTq&amp;wd=&amp;eqid=b931441300012bda0000000659ef4dd4" target="_blank" rel="external">BASE64</a>编码。</li>
<li><code>image-webpack-loader</code>: 压缩http请求的图片。</li>
</ul>
<h4 id="使用上述三个loader处理图片文件"><a href="#使用上述三个loader处理图片文件" class="headerlink" title="使用上述三个loader处理图片文件"></a>使用上述三个loader处理图片文件</h4><p><em><code>loader</code>配置</em></p>
<pre><code>// picture loader
            {
                test: /\.(png|jpg|gif|svg)$/,
                use: [
                    {
                        loader: &#39;file-loader&#39;,
                        options: {
                            name: &#39;assets/[name]-[hash:5].[ext]&#39;
                        }
                    },
                    // {
                    //     loader: &#39;url-loader&#39;,
                    //     options: {
                    //         limit: 200000,
                    //         name: `assets/[name]-[hash:5].[ext]`
                    //     }
                    // },
                    {
                        loader: &#39;image-webpack-loader&#39;
                    }
                ]
            },
</code></pre><ul>
<li><strong>重复性大的图片推荐通过http请求，这样会有缓存，优化加载速度</strong></li>
<li><strong>小的图片重复性不大的图片可以用base64编码，使用<code>url-loader</code>去处理</strong></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个webpack的demo工程我都亲自在Mac环境下测试并运行成功，上传到了github，这里是地址：<br><a href="https://github.com/PancakeAwesome/webpack-demo-test" target="_blank" rel="external">demo1传送门</a><br><a href="https://github.com/PancakeAwesome/PancakeAwesome.github.io" target="_blank" rel="external">demo2传送门</a><br>下面贴下我完整的<code>webpack.config.js</code>和<code>pacakge.json</code>的代码：<strong>由于webpack版本更新很快情注意自己的版本，最新语法去<a href="https://webpack.github.io/" target="_blank" rel="external">官网查看</a></strong></p>
<p><code>webpack.config.js</code></p>
<pre><code>var htmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
var path = require(&#39;path&#39;);

module.exports = {    
    // the door file of webpack packaging
    // entry: &#39;./src/script/main.js&#39;,
    // entry: [&#39;./src/script/main.js&#39;,&#39;./src/script/a.js&#39;],
    entry: __dirname + &#39;/src/app.js&#39;,
    output: {
        /**
         * __dirname: absolute file path
         * @type {[type]}
         */
        path:__dirname + &#39;/dist&#39;,
        /**
         * [name]: entry&#39;s chunck&#39;s key
         * [chunkhash]: file&#39;s md5 value(file version)
         * @type {String}
         */
        filename: &#39;js/[name].bundle.js&#39;,
    },
    /**
     * webpack loader param
     * @type {Object}
     */
    module: {
        loaders: [
            // html loader
            {
                test: /\.html$/,
                loader: &#39;html-loader&#39;
            },
            // ejs loader (template loader)
            {
                test: /\.tpl$/,
                loader: &#39;ejs-loader&#39;
            },
            // js loader(babel loader)
            {
                test: /\.js$/,
                loader: &#39;babel-loader&#39;,
                include: path.resolve(__dirname,&#39;src&#39;),
                // exclude: __dirname + &#39;./node_modules/&#39;,
                exclude: path.resolve(__dirname,&#39;node_modules&#39;),
                // param of loader
                options: {
                    // set the version of es6
                    presets: [&#39;env&#39;]
                }
            },
            // css loader : postcss-loader,css-loader,style-loader
            {
        test: /\.css$/,
        use: [
            {
                  loader:&#39;style-loader&#39;
              },
              {
                loader:&#39;css-loader&#39;
              },
              { 
                  loader: &#39;postcss-loader&#39;,
                  // some plugins of postcss-loader:some options
                  options: {
                      plugins: (loader) =&gt; [
                          require(&#39;postcss-import&#39;)({
                              // this represent loader variable
                              root:loader.resourcePath
                          }),
                          require(&#39;autoprefixer&#39;)({
                              broswers: [&#39;last 5 versions&#39;]
                          })
                      ]
                    }
                }
            ]    
            },
          // less loader
          {
            test: /\.less$/,
            use: [
                {
                loader: &quot;style-loader&quot; // creates style nodes from JS strings 
              }, 
              {
              loader: &quot;css-loader&quot; // translates CSS into CommonJS 
                },
                { 
                  loader: &#39;postcss-loader&#39;,
                  // some plugins of postcss-loader:some options
                  options: {
                      plugins: function () {
                          return [
                              require(&#39;postcss-import&#39;)({
                                  root:this.resourcePath
                              }),
                              require(&#39;autoprefixer&#39;)({
                                  broswers: [&#39;last 5 versions&#39;]
                              })
                              ]
                      }
                    }
                },
                {
                 loader: &quot;less-loader&quot; // compiles Less to CSS 
               }
               ]
          },
          // sass loader
          {
            test: /\.scss$/,
            use: [
                {
                loader: &quot;style-loader&quot; // creates style nodes from JS strings 
              }, 
              {
                  loader: &quot;css-loader&quot; // translates CSS into CommonJS 
                },
                { 
                  loader: &#39;postcss-loader&#39;,
                  // some plugins of postcss-loader:some options
                  options: {
                      plugins: function () {
                          return [
                              require(&#39;postcss-import&#39;)({
                                  root:this.resourcePath
                              }),
                              require(&#39;autoprefixer&#39;)({
                                  broswers: [&#39;last 5 versions&#39;]
                              })
                              ]
                      }
                    }
                },
                {
                 loader: &quot;sass-loader&quot; // compiles sess to CSS 
               }
               ]
          },
            // picture loader
            {
                test: /\.(png|jpg|gif|svg)$/,
                // loaders: [
                //     // &#39;file-loader?name=assets/[name]-[hash:5].[ext]&#39;,
                //     &#39;url-loader?limit=200000&amp;name=assets/[name]-[hash:5].[ext]&#39;,
                //     &#39;image-webpack-loader&#39;
                // ]
                use: [
                    {
                        loader: &#39;file-loader&#39;,
                        options: {
                            name: &#39;assets/[name]-[hash:5].[ext]&#39;
                        }
                    },
                    // {
                    //     loader: &#39;url-loader&#39;,
                    //     options: {
                    //         limit: 200000,
                    //         name: `assets/[name]-[hash:5].[ext]`
                    //     }
                    // },
                    {
                        loader: &#39;image-webpack-loader&#39;
                    }
                ]
            },
        ]
    },
    plugins: [
        new htmlWebpackPlugin({
            filename: &#39;index.html&#39;,
            template: &#39;index.html&#39;,
            injecet: &#39;body&#39;
        })
    ]
}
</code></pre><p><code>pacage.json</code></p>
<pre><code>{
  &quot;name&quot;: &quot;webpack-demo&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;webpack&quot;: &quot;webpack --config webpack.config.js --progress  --colors&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;autoprefix&quot;: &quot;^1.0.1&quot;,
    &quot;babel-core&quot;: &quot;^6.26.0&quot;,
    &quot;babel-loader&quot;: &quot;^7.1.2&quot;,
    &quot;babel-preset-env&quot;: &quot;^1.6.0&quot;,
    &quot;babel-preset-latest&quot;: &quot;^6.24.1&quot;,
    &quot;css-loader&quot;: &quot;^0.28.7&quot;,
    &quot;ejs-loader&quot;: &quot;^0.3.0&quot;,
    &quot;file-loader&quot;: &quot;^0.11.2&quot;,
    &quot;html-loader&quot;: &quot;^0.5.1&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;,
    &quot;image-webpack-loader&quot;: &quot;^3.4.2&quot;,
    &quot;less&quot;: &quot;^2.7.2&quot;,
    &quot;less-loader&quot;: &quot;^4.0.5&quot;,
    &quot;node-sass&quot;: &quot;^4.5.3&quot;,
    &quot;postcss-import&quot;: &quot;^10.0.0&quot;,
    &quot;postcss-loader&quot;: &quot;^2.0.6&quot;,
    &quot;sass&quot;: &quot;^1.0.0-beta.2&quot;,
    &quot;sass-loader&quot;: &quot;^6.0.6&quot;,
    &quot;style-loader&quot;: &quot;^0.18.2&quot;,
    &quot;url-loader&quot;: &quot;^0.5.9&quot;,
    &quot;webpack&quot;: &quot;^3.5.5&quot;
  }
}
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
