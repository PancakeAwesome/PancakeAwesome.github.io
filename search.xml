<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[弄懂CNN卷积神经网络？看这一篇就够了！]]></title>
      <url>/%E5%BC%84%E6%87%82CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C?%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86!.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是卷积神经网络？又为什么很重要？"><a href="#什么是卷积神经网络？又为什么很重要？" class="headerlink" title="什么是卷积神经网络？又为什么很重要？"></a>什么是卷积神经网络？又为什么很重要？</h3><p>卷积神经网络(Convolutional Neural Networks, ConvNets or CNNs)是一种在图像识别与分类领域被证明特别有效的神经网络。卷积网络已经成功地识别人脸、物体、交通标志，应用在机器人和无人车等载具。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqpaoct8mtj30zk0dhgo5.jpg" alt="图1"></p>
<p>在上面的<strong>图1</strong>当中，卷积网络能够识别场景而系统可以自动推荐相关标签如“桥”、“铁路”、“网球”等。<strong>图2</strong>则展示了卷积网络识别日常事物如人、动物的例子。最近，卷积网络也已经在自然语言处理上显示出了威力（比如句子分类）。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqpaoxt3zdj30zk0d9wgu.jpg" alt="图2"><br>卷积网络，在今天的绝大多数机器学习应用中都是极重要的工具。但是，理解卷积网络并首次学着使用，这体验有时并不友好。本文的主旨在于帮助读者理解，卷积神经网络是如何作用于图片的。</p>
<p>如果你对神经网络还是完全陌生的，可以阅读一些CNN的基础博客来掌握一些基本概念。</p>
<ul>
<li><a href="http://pancakeawesome.ink/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84.html">CNN卷积神经网络的模型结构</a></li>
<li><a href="http://pancakeawesome.ink/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95.html">CNN卷积神经网络的前向传播算法</a></li>
<li><a href="http://pancakeawesome.ink/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95.html">CNN卷积神经网络的反向传播算法</a></li>
</ul>
<p>在本文，多层感知机(Multi-Layer Perceptrons, MLP)也被记作全连接层(Fully Connected Layers)。</p>
<h2 id="LeNet架构-1990年代）"><a href="#LeNet架构-1990年代）" class="headerlink" title="LeNet架构(1990年代）"></a>LeNet架构(1990年代）</h2><p>LeNet是最早用于深度学习了领域的卷积神经网络之一。Yann LeCun的这一杰作<code>LeNet5</code>得名于他自1988年以来的系列成功迭代。彼时LeNet架构还主要被用于识别邮政编码等任务。</p>
<p>下面我们将直观地感受一下，LeNet是如何学习识别图像的。近几年已经出现了很多建立在LeNet之上的新架构，但是基本概念还是来自于LeNet，并且理解了LeNet再学其他的也会更简单。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqpaqhnu3vj30zk08ht9a.jpg" alt="图3：简单的ConvNet"><br><strong>图3</strong>的卷积神经网络与LeNet的原始架构十分接近，把图片分入四个类别：狗，猫，船，鸟（LeNet最早主要就是用来做这些）。如上图所示，当获得一张船图作为输入的时候，网络正确的给船的分类赋予了最高的概率(0.94)。输出层的各个概率相加应为1.</p>
<p><strong>图3</strong>的卷积神经网络主要执行了四个操作：</p>
<ol>
<li>卷积</li>
<li>非线性(ReLU)</li>
<li>池化或下采样</li>
<li>分类（全连接层）</li>
</ol>
<p>这些操作也是所有卷积神经网络的基石，所以理解好这些工作对于理解整个神经网络至关重要。接下来我们将尝试最直观地理解以上操作。</p>
<h2 id="图片是像素值的矩阵"><a href="#图片是像素值的矩阵" class="headerlink" title="图片是像素值的矩阵"></a>图片是像素值的矩阵</h2><p>本质上来讲，每个图片都可以表示为像素值组成的矩阵</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqparr0hvpj30ho06674o.jpg" alt="图4：像素值矩阵"></p>
<p><code>通道</code>是代指图片特定成分的习语。常见数码相机拍出来的照片有三个通道——红、绿、蓝-可以想象为是三个2d矩阵（每种颜色对应一个）叠在一起，每个矩阵的值都在0-255之间。</p>
<p>另一方面，<code>灰度</code>图像只有单通道。本文为简单起见只考虑灰度图像，这样就是一个2d矩阵。矩阵中的每个像素值还是0到255——0表示黑，255表示白。</p>
<hr>
<h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>卷积网络是因为<code>“卷积”操作</code>而得名的。卷积的根本目的是从输入图片中提取特征。卷积用一个小方阵的数据学习图像特征，可以保留像素之间的空间关系。这里不深入探讨卷积的数学原理，重在理解工作过程。</p>
<p>如上所述，每个图片都是像素值矩阵。考虑一个5x5的图像，其像素值为0和1，下面的绿色矩阵是灰度图的特例（常规灰度图的像素值取值0-255），同时考虑如下的3x3矩阵：</p>
<p> <img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqpaxtpnk3j30lc090glr.jpg" alt=""></p>
<p>然后，5x5图像和3x3矩阵之间的卷积计算，可由下图的动画所表示：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqpay58vuog307g05g3yx.gif" alt="图5：卷积操作。输出矩阵叫卷积特征或特征映射">图5：卷积操作。输出矩阵叫卷积特征或特征映射</p>
<p>想一想以上操作是如何完成的，我们在原始图片（绿色）上1像素、1像素地滑动橙色矩阵（也称’stride’），并且在每个位置上，我们都对两个矩阵的对应元素相乘后求和得到一个整数，这就是输出矩阵（粉色）的元素。注意，3x3矩阵每次只“看见”输入图片的一部分。</p>
<p>3x3矩阵也叫“<strong>滤波器</strong>”、“核”或“特征探测器”，在原图上滑动滤波器、点乘矩阵所得的矩阵称为“卷积特征”、“激励映射”或“<strong>特征映射</strong>”。这里的重点就是，理解滤波器对于原输入图片来说，是个特征探测器。</p>
<p>对于同一张照片，不同的滤波器将会产生不同的特征映射。</p>
<p>下表可见各种不同卷积核对于上图的效果。只需调整滤波器的数值，我们就可以执行诸如边缘检测、锐化、模糊等效果——这说明不同的滤波器会从图片中探测到不同的特征，比如边缘、曲线等。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqpb22t76uj30ia0u23zt.jpg" alt=""></p>
<p>另一种对卷积操作很好的理解方式就是观察<strong>图6</strong>的动画：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqpb2p6wlqg30dc07ku0y.gif" alt="图6：卷积操作"></p>
<p>一个滤波器（红框）在图片上滑动（卷积）产生特征映射。在同一个图片上，另一个滤波器（绿框）的卷积产生了不同的特征映射。须知，卷积操作捕捉的是原图的局部依赖性。另外，注意观察两个不同的滤波器怎样产生不同的特征映射。其实不管是图片，还是两个滤波器，本质上都不过是我们刚才看过的数值矩阵而已。</p>
<p>在实践当中，卷积神经网络在训练过程中学习滤波器的值，当然我们还是要在训练之前需要指定一些参数：滤波器的个数，滤波器尺寸、网络架构等等。滤波器越多，从图像中提取的特征就越多，模式识别能力就越强。</p>
<p>特征映射的尺寸由三个参数控制，我们需要在卷积步骤之前就设定好：</p>
<ul>
<li>深度(Depth)： 深度就是卷积操作中用到的滤波器个数。如<strong>图7</strong>所示，我们对原始的船图用了三个不同的滤波器，从而产生了三个特征映射。你可以认为这三个特征映射也是堆叠的2d矩阵，所以这里特征映射的“深度”就是3。</li>
</ul>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqpb3w7rdjj30ma0b6mxg.jpg" alt="图7"></p>
<ul>
<li><p>步幅(Stride)：步幅是每次滑过的像素数。当<code>Stride=1</code>的时候就是逐个像素地滑动。当<code>Stride=2</code>的时候每次就会滑过2个像素。步幅越大，特征映射越小。</p>
</li>
<li><p>补零(Zero-padding)：有时候在输入矩阵的边缘填补一圈0会很方便，这样我们就可以对图像矩阵的边缘像素也施加滤波器。补零的好处是让我们可以控制特征映射的尺寸。补零也叫宽卷积，不补零就叫窄卷积。</p>
</li>
</ul>
<h2 id="非线性"><a href="#非线性" class="headerlink" title="非线性"></a>非线性</h2><p>如<strong>图3</strong>所示，每个卷积操作之后，都有一个叫<strong>ReLU</strong>的附加操作。ReLU的全称是纠正线性单元(Rectified Linear Unit)，是一种非线性操作，其输出如下：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqpb4bs3u1j30tr09cweg.jpg" alt="图8:ReLU"></p>
<p>ReLU是以像素为单位生效的，其将所有负值像素替换为0。ReLU的目的是向卷积网络中引入非线性，因为真实世界里大多数需要学习的问题都是非线性的（单纯的卷积操作时线性的——矩阵相乘、相加，所以才需要额外的计算引入非线性）。</p>
<p>图9可以帮助我们清晰地理解，ReLU应用在<strong>图6</strong>得到的特征映射上，输出的新特征映射也叫“纠正”特征映射。（黑色被抹成了灰色）</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqpb4mswgnj30zk0dbgmq.jpg" alt="图9:ReLU"></p>
<p>其他非线性方程比如<strong>tanh</strong>或<strong>sigmoid</strong>也可以替代ReLU，但多数情况下ReLU的表现更好。</p>
<h2 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h2><p>空间池化（也叫亚采样或下采样）降低了每个特征映射的维度，但是保留了最重要的信息。空间池化可以有很多种形式：最大(Max)，平均(Average)，求和(Sum)等等。</p>
<p>以最大池化为例，我们定义了空间上的邻域（2x2的窗）并且从纠正特征映射中取出窗里最大的元素。除了取最大值以额外，我们也可以取平均值（平均池化）或者把窗里所有元素加起来。实际上，最大池化已经显示了最好的成效。</p>
<p><strong>图10</strong>显示了对纠正特征映射的最大池化操作（在卷积+ReLU之后），使用的是2x2的窗。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqpb53x88tj30rg0neaaq.jpg" alt="图10:最大池化"></p>
<p>我们以2格的步幅(Stride)滑动2x2的窗，并且取每个区域的最大值。<strong>图10</strong>同样显示了池化可以减少特征映射的维度。</p>
<p>在<strong>图11</strong>所示的网络中，池化操作分别应用于每个特征映射（注意正因如此，我们从三个输入映射得到了三个输出映射）。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqpb5e1jqaj30ma0c7t92.jpg" alt="图11:对纠正特征映射应用池化"></p>
<p><strong>图12</strong>即为池化操作施加在<strong>图9</strong>所得纠正特征映射上的效果。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqpb5q2zcvj30z20eywfj.jpg" alt="图12:池化"></p>
<p>池化的功能室逐步减少输入表征的空间尺寸。特别地，池化</p>
<ul>
<li>使输入表征（特征维度）更小而易操作</li>
<li>减少网络中的参数与计算数量，从而遏制过拟合</li>
<li>增强网络对输入图像中的小变形、扭曲、平移的鲁棒性（输入里的微小扭曲不会改变池化输出——因为我们在局部邻域已经取了最大值/平均值）。</li>
<li>帮助我们获得不因尺寸而改变的等效图片表征。这非常有用，因为这样我们就可以探测到图片里的物体，不论那个物体在哪。</li>
</ul>
<p>截至目前：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqpb624vq1j30zk08gmxr.jpg" alt="图13"></p>
<hr>
<p>至此我们已经了解了卷积、ReLU和池化是如何运转的，这些层对于所有的卷积神经网络都是最基础的单元。如<strong>图13</strong>所示，我们有两组“卷积+ReLU+池化”层——其中第二组对第一组的输出施加了六个滤波器，产生了六个特征映射。ReLU分别作用域这六个特征映射，再对生成的纠正特征映射使用最大池化。</p>
<p>这些层合力提取出有用的特征，为网络引入了非线性并降低了维度，还使特征对尺寸和平移保持不变性。</p>
<p>第二个池化层的输出相当于全连接层的输入，我们将在下一节继续探讨。</p>
<h2 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h2><p>全连接层(Fully Connected layer)就是使用了softmax激励函数作为输出层的多层感知机(Multi-Layer Perceptron)，其他很多分类器如支持向量机也使用了softmax。“全连接”表示上一层的每一个神经元，都和下一层的每一个神经元是相互连接的。</p>
<p>卷积层和池化层呢个的输出代表了输入图像的高级特征，全连接层的目的就是用这些特征进行分类，类别基于训练集。比如<strong>图14</strong>所示的图像分类任务，有四种可能的类别。（注意，图14没有显示出所有的神经元节点）</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqpb6k5d5bj30qw08f74j.jpg" alt="图14:全连接层——每个节点都与相邻层的所有节点相连"></p>
<p>除了分类以外，加入全连接层也是学习特征之间非线性组合的有效办法。卷积层和池化层提取出来的特征很好，但是如果考虑这些特征之间的组合，就更好了。</p>
<p>全连接层的输出概率之和为1，这是由激励函数<code>Softmax</code>保证的。Softmax函数把任意实值的向量转变成元素取之0-1且和为1的向量。</p>
<h2 id="联合起来——反向传播训练"><a href="#联合起来——反向传播训练" class="headerlink" title="联合起来——反向传播训练"></a>联合起来——反向传播训练</h2><p>综上，卷积+池化是特征提取器，全连接层是分类器。</p>
<p>注意<strong>图15</strong>，因为输入图片是条船，所以目标概率对船是1，其他类别是0.</p>
<ul>
<li>输入图像 = 船</li>
<li>目标向量 = [0, 0, 1 ,0]</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqpb71ou4nj30zk0ciwf8.jpg" alt="图15:训练卷积神经网络"></p>
<p>卷积网络的训练过程可以概括如下：</p>
<ul>
<li><strong>Step 1:</strong> 用随机数初始化所有的滤波器和参数/权重</li>
<li><p><strong>Step 2:</strong> 网络将训练图片作为输入，执行前向步骤（卷积，ReLU，池化以及全连接层的前向传播）并计算每个类别的对应输出概率。</p>
</li>
<li><p>假设船图的输出概率是<code>[0.2, 0.4, 0.1, 0.3]</code></p>
</li>
<li><p>因为第一个训练样本的权重都是随机的，所以这个输出概率也跟随机的差不多</p>
</li>
<li><p><strong>Step 3:</strong> 计算输出层的总误差（4类别之和）</p>
</li>
<li><p>$总误差 = \sum \frac{1}{2} (目标概率 - 输出概率)^2 *$</p>
</li>
<li><p><strong>Step 4:</strong> 反向传播算法计算误差相对于所有权重的梯度，并用<em>梯度下降法</em>更新所有的滤波器/权重和参数的值，以使输出误差最小化。</p>
</li>
<li><p>权重的调整程度与其对总误差的贡献成正比。</p>
</li>
<li>当同一图像再次被输入，这次的输出概率可能是<code>[0.1, 0.1, 0.7, 0.1]</code>，与目标<code>[0, 0, 1, 0]</code>更接近了。</li>
<li>这说明我们的神经网络已经学习着分类特定图片了，学习的方式是调整权重/滤波器以降低输出误差。</li>
<li>如滤波器个数、滤波器尺寸、网络架构这些参数，是在Step 1之前就已经固定的，且不会在训练过程中改变——只有滤波矩阵和神经元突触权重会更新。</li>
</ul>
<p>以上步骤<em>训练</em>了卷积网络——本质上就是优化所有的权重和参数，使其能够正确地分类训练集里的图片。</p>
<p>当一个新的（前所未见的）的图片输入至卷积网络，网络会执行前向传播步骤并输出每个类别的概率（对于新图像，输出概率用的也是训练过的权重值）。如果我们的训练集足够大，网络就有望正确分类新图片，获得良好的泛化(generalization)能力。</p>
<p><strong>注意 1:</strong> 以上步骤已被极大简化，且数学细节均以忽略，这是为了让训练过程更直观。</p>
<p><strong>注意 2:</strong> 上例中，我们用了两组卷积+池化层，其实这些操作可以在一个卷积网络内重复无数次。如今有些表现出众的卷积网络，都有数以十计的卷积+池化层！并且，不是每个卷积层后面都要跟个池化层。由<strong>图16</strong>可见，我们可以有连续多组卷积+ReLU层，后面再加一个池化层。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqpb8h2zyjj30xo0gcac0.jpg" alt="图16"></p>
<h2 id="可视化卷积神经网络"><a href="#可视化卷积神经网络" class="headerlink" title="可视化卷积神经网络"></a>可视化卷积神经网络</h2><p>一般来说，卷积层越多，能学会的特征也就越复杂。比如在图像分类中，一个卷积神经网络的第一层学会了探测像素中的边缘，然后第二层用这些边缘再去探测简单的形状，其他层再用形状去探测高级特征，比如脸型，如<strong>图17</strong>所示——这些特征是<a href="http://web.eecs.umich.edu/~honglak/icml09-ConvolutionalDeepBeliefNetworks.pdf" target="_blank" rel="noopener">Convolutional Deep Belief Network</a>学得的。这里只是一个简单的例子，实际上卷积滤波器可能会探测出一些没有意义的特征。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqpb8o6b5xj30dg0e60t4.jpg" alt="图17:Convolutional Deep Belief Network学习的特征"></p>
<hr>
<p>Adam Harley做了一个非常惊艳的卷积神经网络可视化，这个网络是用MNIST手写数字数据库训练而来的。我强烈推荐大家<a href="http://scs.ryerson.ca/~aharley/vis/conv/flat.html" target="_blank" rel="noopener">玩一玩</a>，以便更深地理解卷积神经网络的细节。</p>
<p>如下我们将看到网络是如何识别输入数字”8”的。注意，<strong>图18</strong>没有把ReLU过程单独显示出来。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqpb9eoz7oj30zk0k5ac4.jpg" alt="图18:可视化卷积神经网络"></p>
<p>输入图像有1024个像素（32x32图片），第一个卷积层(Convolution Layer 1)有六个不同的5x5滤波器(Stride = 1)。由图可见，六个不同的滤波器产生了深度为6的特征映射。</p>
<p>Convolutional Layer 1 后面跟着Pooling Layer 1, 对六个特征映射分别进行2x2的最大池化（Stride = 2）。你可以在动态网页中的每个像素上活动鼠标指针，观察其在前一个卷积层里对应的4x4网格（如<strong>图19</strong>）。不难发现，每个4x4网格里的最亮的像素（对应最大值）构成了池化层。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqpb9x585wj30zk08iq48.jpg" alt="图19：可视化池化操作"></p>
<p>之后我们有三个全连接(FC)层：</p>
<ul>
<li><strong>FC 1:</strong> 120神经元</li>
<li><strong>FC 2:</strong> 100神经元</li>
<li><strong>FC 3:</strong> 10神经元，对应10个数字——也即输出层</li>
</ul>
<p>在<strong>图20</strong>，输出层10个节点中的每一个，都与第二个全连接层的100个节点相连（所以叫“全连接”）。</p>
<p>注意输出层里的唯一的亮点对应着<code>8</code>——这说明网络正确的识别了手写数字（越亮的节点代表越高的概率，比如这里8就拥有最高的概率）。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqpbab640ej30zk07d0sw.jpg" alt="图20：可视化全连接层"></p>
<p>该可视化的3D版可见于<a href="http://scs.ryerson.ca/~aharley/vis/conv/" target="_blank" rel="noopener">这里</a> 。</p>
<hr>
<h2 id="其他卷积网络架构"><a href="#其他卷积网络架构" class="headerlink" title="其他卷积网络架构"></a>其他卷积网络架构</h2><p>卷积神经网络始自1990年代起，我们已经认识了最早的LeNet，其他一些很有影响力的架构列举如下：</p>
<ul>
<li><p>1990s至2012：从90年代到2010年代早期，卷积神经网络都处于孵化阶段。随着数据量增大和计算能力提高，卷积神经网络能搞定的问题也越来越有意思了。</p>
</li>
<li><p>AlexNet(2012)：2012年，Alex Krizhevsky发布了<a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="noopener">AlexNet</a> ，是LeNet的更深、更宽版本，并且大比分赢得了当年的ImageNet大规模图像识别挑战赛(ILSVRC)。这是一次非常重要的大突破，现在普及的卷积神经网络应用都要感谢这一壮举。</p>
</li>
<li><p>ZF Net(2013)：2013年的ILSVRC赢家是Matthew Zeiler和Rob Fergus的卷积网络，被称作<a href="http://arxiv.org/abs/1311.2901" target="_blank" rel="noopener">ZF Net</a> ，这是调整过架构超参数的AlexNet改进型。</p>
</li>
<li><p>GoogleNet(2014)：2014的ILSVRC胜者是来自Google的<a href="http://arxiv.org/abs/1409.4842" target="_blank" rel="noopener">Szegedy et al.</a> 。其主要贡献是研发了<em>Inception Module</em>，它大幅减少了网络中的参数数量（四百万，相比AlexNet的六千万）。</p>
</li>
<li><p>VGGNet(2014)：当年的ILSVRC亚军是<a href="http://www.robots.ox.ac.uk/~vgg/research/very_deep/" target="_blank" rel="noopener">VGGNet</a> ，突出贡献是展示了网络的深度（层次数量）是良好表现的关键因素。</p>
</li>
<li><p>ResNet(2015)： Kaiming He研发的<a href="http://arxiv.org/abs/1512.03385" target="_blank" rel="noopener">Residual Network</a> 是2015年的ILSVRC冠军，也代表了卷积神经网络的最高水平，同时还是实践的默认选择（2016年5月）。</p>
</li>
<li><p>DenseNet（2016年8月）： 由Gao Huang发表，<a href="http://arxiv.org/abs/1608.06993" target="_blank" rel="noopener">Densely Connected Convolutional Network</a> 的每一层都直接与其他各层前向连接。DenseNet已经在五个高难度的物体识别基础集上，显式出非凡的进步。</p>
</li>
</ul>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这里有一些关于卷积神经网络的博客。</p>
<ul>
<li><a href="http://pancakeawesome.ink/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84.html">CNN卷积神经网络的模型结构</a></li>
<li><a href="http://pancakeawesome.ink/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95.html">CNN卷积神经网络的前向传播算法</a></li>
<li><a href="http://pancakeawesome.ink/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95.html">CNN卷积神经网络的反向传播算法</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> CNN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CTC算法小结]]></title>
      <url>/CTC%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  最近在做OCR相关的项目，看RCNN的时候碰到了CTC转录层，对其算法不适很了解，便整理了一下有关于CTC loss的一些定义和推导。由于个人水平有限，如果文章有错误，还恳请各位指出，万分感谢~ </p>
<h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h2><p>  在传统的语音识别的模型中，我们对语音模型进行训练之前，往往都要将文本与语音进行严格的对齐操作。这样就有两点不太好：</p>
<ol>
<li>严格对齐要花费人力、时间。</li>
<li>严格对齐之后，模型预测出的label只是局部分类的结果，而无法给出整个序列的输出结果，往往要对预测出的label做一些后处理才可以得到我们最终想要的结果。</li>
</ol>
<p>  虽然现在已经有了一些比较成熟的开源对齐工具供大家使用，但是随着deep learning越来越火，有人就会想，能不能让我们的网络自己去学习对齐方式呢？因此CTC（Connectionist temporal classification）就应运而生啦。</p>
<p>  想一想，为什么CTC就不需要去对齐语音和文本呢？因为CTC它允许我们的神经网络在任意一个时间段预测label，只有一个要求：就是输出的序列顺序只要是正确的就ok啦~这样我们就不在需要让文本和语音严格对齐了，而且CTC输出的是整个序列标签，因此也不需要我们再去做一些后处理操作。</p>
<p>  对一段音频使用CTC和使用文本对齐的例子如下图所示： </p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqoqiza1mfj30kn07ddg8.jpg" alt=""></p>
<h2 id="keypoints"><a href="#keypoints" class="headerlink" title="keypoints"></a>keypoints</h2><h3 id="2-1符号的表示"><a href="#2-1符号的表示" class="headerlink" title="2.1符号的表示"></a>2.1符号的表示</h3><p>  接下来，我们要对一些符号的定义进行介绍。由于水平有限，看这部分定义介绍的时候绕在里面很久，可能有些理解有误，还恳请各位大大及时指出~</p>
<ol>
<li><p>$y^t_k $：代表输出序列在第t步的输出为k的概率。举个简单的例子：当输出的序列为（a-ab-）时，$y^3_a$  代表了在第3步输出的字母为a的概率；</p>
</li>
<li><p>$p(\pi \mid x)$：代表了给定输入x，输出路径为 $\pi $的概率；</p>
</li>
</ol>
<p>由于假设在每一个时间步输出的label的概率都是相互独立的，那么 $p(\pi \mid x)$ 用公式来表示为 $p(\pi \mid x) =\prod_{t=1}^T (y^t_k) $，可以理解为每一个时间步输出路径 $\pi$ 的相应label的概率的乘积。</p>
<ol>
<li>$\mathscr{F}$：代表一种多对一的映射，将输出路径 $\pi$ 映射到 标签序列$l $的一种变换</li>
</ol>
<p>举个简单的例子 $\mathscr{F}(a-ab-) = \mathscr{F}(-aa–abb)=aab $（其中-代表了空格）</p>
<ol>
<li>$p(l \mid x) $：代表给定输入x，输出为序列 $l $的概率。</li>
</ol>
<p>因此输出的序列为 $l$ 的概率可以表示为所有输出的路径 $\pi$ 映射后的序列为$l$ 的概率之和，用公式表示为 $p(l \mid x) = \sum_{\pi\in{\mathscr{F}^{-1}(l)}}p(\pi \mid x)$</p>
<h3 id="2-2-空格的作用"><a href="#2-2-空格的作用" class="headerlink" title="2.2 空格的作用"></a>2.2 空格的作用</h3><p>  在最开始的CTC设定中是没有空格的，$\mathscr{F} $只是简单的移除了连续的相同字母。但是这样会产生两个问题：</p>
<ol>
<li>无法预测出连续两个相同的字母的单词了，比如说hello这个单词，在CTC中会删除掉连续相同的字母，因此CTC最后预测出的label应该是helo；</li>
<li>无法预测出一句完整的话，而只能预测单个的单词。因为缺乏空格，CTC无法表示出单词与单词之间停顿的部分，因此只能预测出单个单词，或者将一句话中的单词全部连接起来了；</li>
</ol>
<p>因此，空格在CTC中的作用还是十分重要的。</p>
<h2 id="3-前向传播与反向传播"><a href="#3-前向传播与反向传播" class="headerlink" title="3. 前向传播与反向传播"></a>3. 前向传播与反向传播</h2><h3 id="3-1前向传播"><a href="#3-1前向传播" class="headerlink" title="3.1前向传播"></a>3.1前向传播</h3><p>  在对符号做了一些定义之后，我们接下来看看CTC的前向传播的过程。我们前向传播就是要去计算 $p(l \mid x)$。由于一个序列 $l$ 通常可以有多条路径经过映射后得到，而随着序列 $l$ 长度的增加，相对应的路径的数目是成指数增加的，因此我们需要一种高效的算法来计算它。</p>
<p>  有一种类似于HMM的前向传播的算法可以帮助我们来解决这个问题。它的key就是那些与序列 lll 对应的路径概率都可以通过迭代来计算得出。</p>
<p>  在进行计算之前，我们需要对序列 $l$ 做一些预处理，在序列 $l$ 的开头与结尾分别加上空格，并且在字母与字母之间都添加上空格。如果原来序列 lll 的长度为U，那么预处理之后，序列 $l{‘} $的长度为2U+1 。</p>
<p>  对于一个特定的序列 $l$ ，我们定义前向变量 $\alpha(t,u)$ 为输出所有长度为 $t$ ，且经过 $\mathscr{F}$ 映射之后为序列 $l$ 的路径的概率之和，用公式表达如下所示：<br>$\alpha(t,u)=\sum_{\pi\in V(t,u)}\prod_{i=1}^ty_{\pi_i}^i$<br>其中，$V(t,u)={π∈A′t:F(π)=l1:u/2,πt=l′u}V(t,u) = {\pi\in A{‘}^t:\mathscr{F}(\pi)=l_{1:u/2},\pi_t=l{‘}_u}$ 代表了所有满足经过$\mathscr{F}$ 映射之后为序列 $l$ ，长度为t的路径集合，且在第t时间步的输出为$l{‘}_u$。</p>
<p>  所有正确路径的开头必须是空格或者label $l_1$，因此存在着初始化的约束条件： </p>
<p>$\alpha(1,1) = y_b^1$<br>$\alpha(1,2) = y_{l_1}^1$<br>$\alpha(1,u) = 0, \forall u &gt; 2$<br>也就是当路径长度为1时，它只可能对应到空格或者序列 $l$ 的第一个label，不可能对应到序列 $l$ 第一个之后的label中。</p>
<p>  因此，$p(l \mid x)$ 可以由前向变量来表示，即为 </p>
<p>$p(l \mid x) = \alpha(T,U{‘})+ \alpha(T,U{‘}{-1})$<br>其中$\alpha(T,U{‘})$可以理解为所有路径长度为T，经过 $\mathscr{F} $映射之后为序列 $l $,且第T时刻的输出的label为：$l{‘}_U $或者 $l{‘}_{U-1}$。也就是路径的最后一个是否包括了空格。</p>
<p>  怎么去理解它呢？我们不妨先看看它的递归图 </p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqoqnoh76rj309f05yt8s.jpg" alt=""><br>上图中，白色的点表示一个label，黑色的点表示空格，纵向每一列表示的是路径的长度T（或者时刻T？），箭头代表了路径下一个时刻可以输出到哪个label去。如果在时刻 1 的 label 为空格，那么路径在下一时刻只有两个选择，第一个还是输出空格，第二个就是输出序列 $l$ 中对应的空格的下一个label：C；如果在时刻2的 label 为 C，那么在时刻3，它可以有三种选择：第一种就是输出还是 C，第二种是输出为空格，第三种是直接输出A。</p>
<p>  从上图可以看出长度为T的输出路径映射到序列$l：cat$， 可以由第T步为label：T的所有路径和第T步为空格的所有路径的概率之和来表示（注意：并不是所有以空格或者T结束的路径都是对的，这里路径是有限制的，不要忘了初始条件的限制哦）。</p>
<p>  现在我们要来引出它的递推公式啦，具体公式如下所示： </p>
<p>$\alpha(t,u)=y_{l{‘}_u}^t\sum_{i=f(u)}^u\alpha(t-1,i)$<br>其中 </p>
<p>$$<br>f(u)=<br>\begin{cases}<br>u-1,  &amp; \text{if $l{‘}_u=blank$ or $l{‘}_{u-2}=l{‘}_u$} \\<br>u-2, &amp; \text{otherwise}<br>\end{cases}<br>$$<br>  如何理解这个递推公式呢，很简单，我们可以看上面递推图，就以时刻T为空格的前向变量为例，由于我们之前讲过了如果当前时刻的输出为空格，下一时刻路径输出只有两种可能性，而如果我们当前时刻是空格，上一时刻的输出从图中可以看出也是由两种可能性，一种是在T-1时刻输出为空格，另外一种是在T-1时刻输出为T。因此我们只要计算出T-1时刻输出为空格的所有正确路径的概率之和以及在T-1时刻输出为T的所有路径的概率之和，再乘上T时刻输出为空格的概率 $y_{l{‘}_u}^T$，就可以得到前向变量$\alpha(t,u)$ 啦。时刻T为label：T的前向变量的求法和空格的类似，只是它由三种可能情况求和再乘上 $y_{l{‘}_u}^T$ 得到的。</p>
<h3 id="3-2反向传播"><a href="#3-2反向传播" class="headerlink" title="3.2反向传播"></a>3.2反向传播</h3><p>  与前向传播类似，我们首先定义一个反向变量 $\beta(t,u)$，它的含义是从t+1时刻开始，在前向变量 $\alpha(t,u)$ 上添加路径$\pi{‘}$，使得最后通过 $\mathscr{F}$ 映射之后为序列 $l$ 的概率之和，用公式表示为： </p>
<p>$\beta(t,u)=\sum_{\pi \in W(t,u)}\prod_{i=1}^{T-t}y_{\pi_i}^{t+i}$<br>其中$W(t,u)={\pi \in A’^{T-t}:\mathscr{F}(\pi’+\pi)=l ,\forall\pi’\in V(t,u)}$</p>
<p>  按照前向传播的图举例说明：假设我们在T-2时刻路径输出为label：A，那么此时的反向变量的求法就是在T-2时刻开始，所有能到达T时刻输出为空格或者label：T的“剩余”路径 π′π′\pi’ 的概率之和。</p>
<p>反向传播也有相对应的初始化条件： </p>
<p>$\beta(T,U’)=\beta(T,U’-1)=1$<br>$\beta(T,u’)=0,\forall u’&lt;U’-1$<br>它的递推公式如下所示 </p>
<p>$\beta(t,u)=\sum_{i=u}^{g(u)}\beta(t+1,i)y_{l’_i}^{t+1}$<br>其中 </p>
<p>$$<br>g(u)=<br>\begin{cases}<br>u-1,  &amp; \text{if $l{‘}_u=blank$ or $l{‘}_{u-2}=l{‘}_u$} \\<br>u-2, &amp; \text{otherwise}<br>\end{cases}<br>$$</p>
<h3 id="3-3对数运算"><a href="#3-3对数运算" class="headerlink" title="3.3对数运算"></a>3.3对数运算</h3><p>  不论是在计算前向变量还是反向变量时，都涉及到了大量的概率的乘积。由于这些乘积都是小于1的，在大量的小数相乘时，最后得到的结果往往都会趋向于0，更严重的是产生underflow。因此在计算时对其做了取对数的处理，这样乘法就会转化为加法了，不仅避免了underflow，还简化了计算。但是，原来的加法计算就不是太方便了。不过这里有一个数学的trick： </p>
<p>$ln(a+b)=lna+ln(1+e^{lnb-lna})$</p>
<h2 id="4-损失函数"><a href="#4-损失函数" class="headerlink" title="4.损失函数"></a>4.损失函数</h2><p>  CTC的损失函数定义如下所示 </p>
<p>$L(S)=-ln\prod_{(x,z)\in S}p(z|x)=-\sum_{(x,z)\in S}ln p(z|x)$<br>其中 $p(z|x) $代表给定输入x，输出序列$z$ 的概率，S为训练集。损失函数可以解释为：给定样本后输出正确label的概率的乘积（这里个人不理解为啥要做乘积运算，求和的话不应该好解释一点么？可能是因为要取对数运算，求和可能不太方便，所以是做乘积运算），再取负对数就是损失函数了。取负号之后我们通过最小化损失函数，就可以使输出正确的label的概率达到最大了。</p>
<p>  由于上述定义的损失函数是可微的，因此我们可以求出它对每一个权重的导数，然后就可以使用什么梯度下降、Adam之类的算法来进行优化求解啦~</p>
<p>  下面我们就要把上一节定义的前向变量与反向变量用到我们的损失函数中去，让序列 $l=z$，定义一个新的集合 $X(t,u)={\pi\in A’^T:\mathscr{F}(\pi)=z,\pi_t=z’_u} $， $X(t,u) $代表了在时刻t经过label：$l’_u$ 的所有路径的集合，这样由之前对前向变量与反向变量的定义，它俩的乘积就可以写成： </p>
<p>$\alpha(t,u)\beta(t,u)=\sum_{\pi\in X(t,u)}\prod_{t=1}^Ty_{\pi_t}^t$<br>而 $p(\pi \mid x) =\prod_{t=1}^T (y^t_k) $，因此进一步转化可以得到 </p>
<p>$\alpha(t,u)\beta(t,u)=\sum_{\pi\in X(t,u)}p(\pi|x)$<br>因此，对于任意的时刻t，我们给定输入x，输出序列 $z$ 的概率可以表示成 </p>
<p>$p(z \mid x)=\sum_{u=1}^{|z’|}\alpha(t,u)\beta(t,u)$<br>也就是在任意一个时刻分开，前向变量与反向变量的乘积为在该时刻经过label：$l’_u$ 的所有概率之和，然后再遍历了序列 $l’ $的每一个label，因此就得到了所有输出为序列$l’ $的概率之和。</p>
<p>  损失函数就可以进一步转化为 </p>
<p>$L(x,z)=-ln\sum_{u=1}^{|z’|}\alpha(t,u)\beta(t,u)$</p>
<h3 id="4-1损失函数梯度计算"><a href="#4-1损失函数梯度计算" class="headerlink" title="4.1损失函数梯度计算"></a>4.1损失函数梯度计算</h3><p>  损失函数关于网络输出 $y_k^t $的偏导数为： </p>
<p>${\partial L(x,z)\over\partial y_k^t}=-{\partial lnp(x|z)\over\partial y_k^t}=-{1\over p(x|z)}{\partial p(x|z)\over\partial y_k^t}$<br>而 $p(z \mid x)=\sum_{u=1}^{|z’|}\alpha(t,u)\beta(t,u)=\sum_{\pi\in X(t,u)}\prod_{t=1}^Ty_{\pi_t}^t$，我们记label：k出现在序列 $z’$ 的所有路径的集合为$B(z,k)={u:z’_u=k}$，因此可以得出 </p>
<p>${\partial\alpha(t,u)\beta(t,u)\over\partial y_k^t}=<br>\begin{cases}<br>{\alpha(t,u)\beta(t,u)\over y_k^t},  &amp; \text{if k occurs in z’} \\<br>0, &amp; \text{otherwise}<br>\end{cases}  $</p>
<p>因此损失函数关于输出的偏导数可以写为 </p>
<p>${\partial L(x,z)\over\partial y_k^t }=-{1\over p(x|z)}{\partial p(x|z)\over\partial y_k^t}=-{1\over p(x|z)y_k^t }\sum_{u\in B(z,k)}\alpha(t,u)\beta(t,u)$<br>最后，我们可以通过链式法则，得到损失函数对未经过sofmax层的网络输出的 $a_k^t $的偏导数： </p>
<p>${\partial L(x,z)\over\partial a_k^t }= -\sum_{k’}{\partial L(x,z)\over\partial y_{k’}^t}{\partial y_{k’}^t \over\partial a_{k’}^t}$<br>又有  </p>
<p>$y_k^t={e^{a_k^t}\over\sum_{k’}e^{a_k^t}}$<br>因此可以得到损失函数对未经过sofmax层的网络输出的 $a_k^t $的偏导数： </p>
<p>${\partial L(x,z)\over\partial a_k^t }=y_k^t-{1\over p(x|z)}\sum_{u\in B(z,k)}\alpha(t,u)\beta(t,u)$</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5.参考文献"></a>5.参考文献</h3><p>1.<a href="https://www.cs.toronto.edu/~graves/preprint.pdf" target="_blank" rel="noopener">《Supervised Sequence Labelling with Recurrent Neural Networks》 chapter7</a> </p>
<p>2.<a href="http://blog.csdn.net/xmdxcsj/article/details/51763886" target="_blank" rel="noopener">   http://blog.csdn.net/xmdxcsj/article/details/51763886</a></p>
]]></content>
      
        <categories>
            
            <category> OCR </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OCR </tag>
            
            <tag> 目标检测， 论文笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[目标检测技术演进：RCNN、Fast RCNN、Faster RCNN]]></title>
      <url>/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B:RCNN%E3%80%81Fast%20RCNN%E3%80%81Faster%20RCNN.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="基于深度学习的目标检测技术演进：RCNN、Fast-RCNN、Faster-RCNN"><a href="#基于深度学习的目标检测技术演进：RCNN、Fast-RCNN、Faster-RCNN" class="headerlink" title="基于深度学习的目标检测技术演进：RCNN、Fast RCNN、Faster RCNN"></a>基于深度学习的目标检测技术演进：RCNN、Fast RCNN、Faster RCNN</h3><p>object detection我的理解，就是在给定的图片中精确找到物体所在位置，并标注出物体的类别。object detection要解决的问题就是物体在哪里，是什么这整个流程的问题。然而，这个问题可不是那么容易解决的，物体的尺寸变化范围很大，摆放物体的角度，姿态不定，而且可以出现在图片的任何地方，更何况物体还可以是多个类别。</p>
<p>object detection技术的演进：<br>RCNN-&gt;SppNET-&gt;Fast-RCNN-&gt;Faster-RCNN</p>
<p><strong>从图像识别的任务说起</strong><br>这里有一个图像任务：<br>既要把图中的物体识别出来，又要用方框框出它的位置。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqmuuf41t7j30mt0aidih.jpg" alt=""></p>
<p>上面的任务用专业的说法就是：图像识别+定位<br>图像识别（classification）：<br>输入：图片<br>输出：物体的类别<br>评估方法：准确率</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqmvsjox1wj30aj0473yd.jpg" alt=""></p>
<p>定位（localization）：<br>输入：图片<br>输出：方框在图片中的位置（x,y,w,h）<br>评估方法：检测评价函数 intersection-over-union ( IOU ) </p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqmuv6cqp7j30bk0650so.jpg" alt=""></p>
<p>卷积神经网络CNN已经帮我们完成了图像识别（判定是猫还是狗）的任务了，我们只需要添加一些额外的功能来完成定位任务即可。</p>
<p>定位的问题的解决思路有哪些？<br><strong>思路一：看做回归问题</strong><br>看做回归问题，我们需要预测出（x,y,w,h）四个参数的值，从而得出方框的位置。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqmuvw8a6fj30qb0bp3z0.jpg" alt=""></p>
<p>步骤1:<br>　　•    先解决简单问题， 搭一个识别图像的神经网络<br>　　•    在AlexNet VGG GoogleLenet上fine-tuning一下</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqmuw4wdq0j30qc08ldg5.jpg" alt=""></p>
<p>步骤2:<br>　　•    在上述神经网络的尾部展开（也就说CNN前面保持不变，我们对CNN的结尾处作出改进：加了两个头：“分类头”和“回归头”）<br>　　•    成为classification + regression模式</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqmuwbapr8j30p109nt98.jpg" alt=""><br>步骤3:<br>　　•    Regression那个部分用欧氏距离损失<br>　　•    使用SGD训练</p>
<p>步骤4:<br>　　•    预测阶段把2个头部拼上<br>　　•    完成不同的功能</p>
<p>这里需要进行两次fine-tuning<br>第一次在ALexNet上做，第二次将头部改成regression head，前面不变，做一次fine-tuning</p>
<p>Regression的部分加在哪？</p>
<p>有两种处理方法：<br>　　•    加在最后一个卷积层后面（如VGG）<br>　　•    加在最后一个全连接层后面（如R-CNN）</p>
<p>regression太难做了，应想方设法转换为classification问题。<br>regression的训练参数收敛的时间要长得多，所以上面的网络采取了用classification的网络来计算出网络共同部分的连接权值。</p>
<p><strong>思路二：取图像窗口</strong><br>　　•    还是刚才的classification + regression思路<br>　　•    咱们取不同的大小的“框”<br>　　•    让框出现在不同的位置，得出这个框的判定得分<br>　　•    取得分最高的那个框</p>
<p>左上角的黑框：得分0.5<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqmuwgqi8aj30m40a4jrl.jpg" alt=""><br>右上角的黑框：得分0.75</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqmuwpd8j2j30m709kdg2.jpg" alt=""></p>
<p>左下角的黑框：得分0.6<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqmuwwpe5lj30ly09fwep.jpg" alt=""><br>右下角的黑框：得分0.8</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqmux3dcmfj30lt09kmxe.jpg" alt=""></p>
<p>根据得分的高低，我们选择了右下角的黑框作为目标位置的预测。<br>注：有的时候也会选择得分最高的两个框，然后取两框的交集作为最终的位置预测。</p>
<p>疑惑：框要取多大？<br>取不同的框，依次从左上角扫到右下角。非常粗暴啊。</p>
<p>总结一下思路：<br>对一张图片，用各种大小的框（遍历整张图片）将图片截取出来，输入到CNN，然后CNN会输出这个框的得分（classification）以及这个框图片对应的x,y,h,w（regression）。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqmuxu3rpxj30qk07jaap.jpg" alt=""></p>
<p>这方法实在太耗时间了，做个优化。<br>原来网络是这样的：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqmuxzvrpij30io09ddg0.jpg" alt=""></p>
<p>优化成这样：把全连接层改为卷积层，这样可以提提速。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqmuycjm12j30k007imxh.jpg" alt=""></p>
<p><strong>物体检测（Object Detection）</strong><br>当图像有很多物体怎么办的？难度可是一下暴增啊。</p>
<p>那任务就变成了：多物体识别+定位多个物体<br>那把这个任务看做分类问题？<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqmuyjj8u6j30qk07jaal.jpg" alt=""></p>
<p>看成分类问题有何不妥？<br>　　•    你需要找很多位置， 给很多个不同大小的框<br>　　•    你还需要对框内的图像分类<br>　　•    当然， 如果你的GPU很强大， 恩， 那加油做吧…</p>
<p>看做classification， 有没有办法优化下？我可不想试那么多框那么多位置啊！<br>有人想到一个好方法：<br>找出可能含有物体的框（也就是候选框，比如选1000个候选框），这些框之间是可以互相重叠互相包含的，这样我们就可以避免暴力枚举的所有框了。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqmuz2dxrlj30jw063glz.jpg" alt=""></p>
<p>大牛们发明好多选定候选框的方法，比如EdgeBoxes和Selective Search。<br>以下是各种选定候选框的方法的性能对比。 </p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqmuza8hvzj30qd09m0ti.jpg" alt=""></p>
<p>有一个很大的疑惑，提取候选框用到的算法“选择性搜索”到底怎么选出这些候选框的呢？那个就得好好看看它的论文了，这里就不介绍了。</p>
<h2 id="R-CNN横空出世"><a href="#R-CNN横空出世" class="headerlink" title="R-CNN横空出世"></a><strong>R-CNN横空出世</strong></h2><p>基于以上的思路，RCNN的出现了。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqmuzfm0qlj30i20cewf3.jpg" alt=""></p>
<h3 id="步骤一：训练（或者下载）一个分类模型（比如AlexNet）"><a href="#步骤一：训练（或者下载）一个分类模型（比如AlexNet）" class="headerlink" title="步骤一：训练（或者下载）一个分类模型（比如AlexNet）"></a>步骤一：训练（或者下载）一个分类模型（比如AlexNet）</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqmuzl7b64j30q608dq38.jpg" alt=""></p>
<h3 id="步骤二：对该模型做fine-tuning"><a href="#步骤二：对该模型做fine-tuning" class="headerlink" title="步骤二：对该模型做fine-tuning"></a>步骤二：对该模型做fine-tuning</h3><p>　　•    将分类数从1000改为20<br>　　•    去掉最后一个全连接层</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqmuzqn486j30pl07xq3b.jpg" alt=""></p>
<h3 id="步骤三：特征提取"><a href="#步骤三：特征提取" class="headerlink" title="步骤三：特征提取"></a>步骤三：特征提取</h3><p>　　•    提取图像的所有候选框（选择性搜索）<br>　　•    对于每一个区域：修正区域大小以适合CNN的输入，做一次前向运算，将第五个池化层的输出（就是对候选框提取到的特征）存到硬盘</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqmv053309j30ql07zjru.jpg" alt=""></p>
<h3 id="步骤四：训练一个SVM分类器（二分类）来判断这个候选框里物体的类别"><a href="#步骤四：训练一个SVM分类器（二分类）来判断这个候选框里物体的类别" class="headerlink" title="步骤四：训练一个SVM分类器（二分类）来判断这个候选框里物体的类别"></a>步骤四：训练一个SVM分类器（二分类）来判断这个候选框里物体的类别</h3><p>每个类别对应一个SVM，判断是不是属于这个类别，是就是positive，反之nagative<br>比如下图，就是狗分类的SVM</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqmv0fodgmj30qk0b3q3j.jpg" alt=""></p>
<h3 id="步骤五：使用回归器精细修正候选框位置：对于每一个类，训练一个线性回归模型去判定这个框是否框得完美。"><a href="#步骤五：使用回归器精细修正候选框位置：对于每一个类，训练一个线性回归模型去判定这个框是否框得完美。" class="headerlink" title="步骤五：使用回归器精细修正候选框位置：对于每一个类，训练一个线性回归模型去判定这个框是否框得完美。"></a>步骤五：使用回归器精细修正候选框位置：对于每一个类，训练一个线性回归模型去判定这个框是否框得完美。</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqmv0o6jbhj30k8077dg5.jpg" alt=""></p>
<p>RCNN的进化中SPP Net的思想对其贡献很大，这里也简单介绍一下SPP Net。</p>
<h2 id="SPP-Net"><a href="#SPP-Net" class="headerlink" title="SPP Net"></a><strong>SPP Net</strong></h2><p>SPP：Spatial Pyramid Pooling（空间金字塔池化）<br>它的特点有两个:</p>
<h3 id="1-结合空间金字塔方法实现CNNs的对尺度输入。"><a href="#1-结合空间金字塔方法实现CNNs的对尺度输入。" class="headerlink" title="1.结合空间金字塔方法实现CNNs的对尺度输入。"></a>1.结合空间金字塔方法实现CNNs的对尺度输入。</h3><p>一般CNN后接全连接层或者分类器，他们都需要固定的输入尺寸，因此不得不对输入数据进行crop或者warp，这些预处理会造成数据的丢失或几何的失真。SPP Net的第一个贡献就是将金字塔思想加入到CNN，实现了数据的多尺度输入。</p>
<p>如下图所示，在卷积层和全连接层之间加入了SPP layer。此时网络的输入可以是任意尺度的，在SPP layer中每一个pooling的filter会根据输入调整大小，而SPP的输出尺度始终是固定的。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqmv0vx1wtj30al075t8u.jpg" alt=""></p>
<h3 id="2-只对原图提取一次卷积特征"><a href="#2-只对原图提取一次卷积特征" class="headerlink" title="2.只对原图提取一次卷积特征"></a>2.只对原图提取一次卷积特征</h3><p>在R-CNN中，每个候选框先resize到统一大小，然后分别作为CNN的输入，这样是很低效的。<br>所以SPP Net根据这个缺点做了优化：只对原图进行一次卷积得到整张图的feature map，然后找到每个候选框zaifeature map上的映射patch，将此patch作为每个候选框的卷积特征输入到SPP layer和之后的层。节省了大量的计算时间，比R-CNN有一百倍左右的提速。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqmv14uw7aj30bn069dfx.jpg" alt=""></p>
<h2 id="Fast-R-CNN"><a href="#Fast-R-CNN" class="headerlink" title="Fast R-CNN"></a><strong>Fast R-CNN</strong></h2><p>SPP Net真是个好方法，R-CNN的进阶版Fast R-CNN就是在RCNN的基础上采纳了SPP Net方法，对RCNN作了改进，使得性能进一步提高。</p>
<p>R-CNN与Fast RCNN的区别有哪些呢？<br>先说RCNN的缺点：即使使用了selective search等预处理步骤来提取潜在的bounding box作为输入，但是RCNN仍会有严重的速度瓶颈，原因也很明显，就是计算机对所有region进行特征提取时会有重复计算，Fast-RCNN正是为了解决这个问题诞生的。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqmv1h6887j30in097jss.jpg" alt=""></p>
<p>大牛提出了一个可以看做单层sppnet的网络层，叫做ROI Pooling，这个网络层可以把不同大小的输入映射到一个固定尺度的特征向量，而我们知道，conv、pooling、relu等操作都不需要固定size的输入，因此，在原始图片上执行这些操作后，虽然输入图片size不同导致得到的feature map尺寸也不同，不能直接接到一个全连接层进行分类，但是可以加入这个神奇的ROI Pooling层，对每个region都提取一个固定维度的特征表示，再通过正常的softmax进行类型识别。另外，之前RCNN的处理流程是先提proposal，然后CNN提取特征，之后用SVM分类器，最后再做bbox regression，而在Fast-RCNN中，作者巧妙的把bbox regression放进了神经网络内部，与region分类和并成为了一个multi-task模型，实际实验也证明，这两个任务能够共享卷积特征，并相互促进。Fast-RCNN很重要的一个贡献是成功的让人们看到了Region Proposal+CNN这一框架实时检测的希望，原来多类检测真的可以在保证准确率的同时提升处理速度，也为后来的Faster-RCNN做下了铺垫。</p>
<p>画一画重点：<br>R-CNN有一些相当大的缺点（把这些缺点都改掉了，就成了Fast R-CNN）。<br>大缺点：由于每一个候选框都要独自经过CNN，这使得花费的时间非常多。<br>解决：共享卷积层，现在不是每一个候选框都当做输入进入CNN了，而是输入一张完整的图片，在第五个卷积层再得到每个候选框的特征</p>
<p>原来的方法：许多候选框（比如两千个）–&gt;CNN–&gt;得到每个候选框的特征–&gt;分类+回归<br>现在的方法：一张完整图片–&gt;CNN–&gt;得到每张候选框的特征–&gt;分类+回归</p>
<p>所以容易看见，Fast RCNN相对于RCNN的提速原因就在于：不过不像RCNN把每个候选区域给深度网络提特征，而是整张图提一次特征，再把候选框映射到conv5上，而SPP只需要计算一次特征，剩下的只需要在conv5层上操作就可以了。</p>
<p>在性能上提升也是相当明显的：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqmv1mhslyj30ja08074e.jpg" alt=""></p>
<h2 id="Faster-R-CNN"><a href="#Faster-R-CNN" class="headerlink" title="Faster R-CNN"></a><strong>Faster R-CNN</strong></h2><p>Fast R-CNN存在的问题：存在瓶颈：选择性搜索，找出所有的候选框，这个也非常耗时。那我们能不能找出一个更加高效的方法来求出这些候选框呢？<br>解决：加入一个提取边缘的神经网络，也就说找到候选框的工作也交给神经网络来做了。<br>做这样的任务的神经网络叫做Region Proposal Network(RPN)。</p>
<p>具体做法：<br>　　•    将RPN放在最后一个卷积层的后面<br>　　•    RPN直接训练得到候选区域</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqmv1syt7ij30cp0c2gls.jpg" alt=""></p>
<p>RPN简介：<br>　　•    在feature map上滑动窗口<br>　　•    建一个神经网络用于物体分类+框位置的回归<br>　　•    滑动窗口的位置提供了物体的大体位置信息<br>　　•    框的回归提供了框更精确的位置</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqmv1y77v9j30bp0aajrj.jpg" alt=""></p>
<p>一种网络，四个损失函数;<br>　　•    RPN calssification(anchor good.bad)<br>　　•    RPN regression(anchor-&gt;propoasal)<br>　　•    Fast R-CNN classification(over classes)<br>　　•    Fast R-CNN regression(proposal -&gt;box)</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqmv2578zoj30at09sdfu.jpg" alt=""></p>
<p>速度对比</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqmv2b1cyfj30jp06e0sx.jpg" alt=""></p>
<p>Faster R-CNN的主要贡献是设计了提取候选区域的网络RPN，代替了费时的选择性搜索，使得检测速度大幅提高。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><strong>最后总结一下各大算法的步骤：</strong><br>RCNN<br>　　1.    在图像中确定约1000-2000个候选框 (使用选择性搜索)<br>　　2.    每个候选框内图像块缩放至相同大小，并输入到CNN内进行特征提取<br>　　3.    对候选框中提取出的特征，使用分类器判别是否属于一个特定类<br>　　4.    对于属于某一特征的候选框，用回归器进一步调整其位置 </p>
<p>Fast RCNN<br>　　1.    在图像中确定约1000-2000个候选框 (使用选择性搜索)<br>　　2.    对整张图片输进CNN，得到feature map<br>　　3.    找到每个候选框在feature map上的映射patch，将此patch作为每个候选框的卷积特征输入到SPP layer和之后的层<br>　　4.    对候选框中提取出的特征，使用分类器判别是否属于一个特定类<br>　　5.    对于属于某一特征的候选框，用回归器进一步调整其位置 </p>
<p>Faster RCNN<br>　　1.    对整张图片输进CNN，得到feature map<br>　　2.    卷积特征输入到RPN，得到候选框的特征信息<br>　　3.    对候选框中提取出的特征，使用分类器判别是否属于一个特定类<br>　　4.    对于属于某一特征的候选框，用回归器进一步调整其位置</p>
<p>总的来说，从R-CNN, SPP-NET, Fast R-CNN, Faster R-CNN一路走来，基于深度学习目标检测的流程变得越来越精简，精度越来越高，速度也越来越快。可以说基于region proposal的R-CNN系列目标检测方法是当前目标检测技术领域最主要的一个分支。</p>
]]></content>
      
        <categories>
            
            <category> 目标检测 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 目标检测 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[论文笔记之RCNN]]></title>
      <url>/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E4%B9%8BRCNN.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Girshick, Ross, et al. “Rich feature hierarchies for accurate object detection and semantic segmentation.” Proceedings of the IEEE conference on computer vision and pattern recognition. 2014.</p>
</blockquote>
<p>Region CNN(RCNN)可以说是<strong>利用深度学习进行目标检测的开山之作</strong>。作者<a href="http://www.cs.berkeley.edu/~rbg/" target="_blank" rel="noopener">Ross Girshick</a> 多次在PASCAL VOC的目标检测竞赛中折桂，2010年更带领团队获得终身成就奖，如今供职于Facebook旗下的FAIR。 </p>
<p>这篇文章思路简洁，在DPM方法多年平台期后，效果提高显著。包括本文在内的一系列目标检测算法：<a href="https://github.com/rbgirshick/rcnn" target="_blank" rel="noopener">RCNN</a> , <a href="https://github.com/rbgirshick/fast-rcnn" target="_blank" rel="noopener">Fast RCNN</a> , <a href="https://github.com/ShaoqingRen/faster_rcnn" target="_blank" rel="noopener">Faster RCNN</a> 代表当下目标检测的前沿水平，<strong>在github都给出了基于Caffe的源码</strong>。</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>本文解决了目标检测中的两个关键问题。</p>
<h3 id="问题一：速度"><a href="#问题一：速度" class="headerlink" title="问题一：速度"></a>问题一：速度</h3><p>经典的目标检测算法使用滑动窗法依次判断所有可能的区域。本文则预先提取一系列较可能是物体的<strong>候选区域</strong>，之后仅在这些候选区域上提取特征，进行判断。</p>
<h3 id="问题二：训练集"><a href="#问题二：训练集" class="headerlink" title="问题二：训练集"></a>问题二：训练集</h3><p>经典的目标检测算法在区域中提取人工设定的特征（Haar，HOG）。本文则需要训练深度网络进行<strong>特征提取</strong>。可供使用的有两个数据库： </p>
<p>一个较大的<strong>识别库</strong>（ImageNet ILSVC 2012）：标定每张图片中物体的类别。一千万图像，1000类。 </p>
<p>一个较小的<strong>检测库</strong>（PASCAL VOC 2007）：标定每张图片中，物体的类别和位置。一万图像，20类。 </p>
<p>本文使用识别库进行预训练，而后用检测库调优参数。最后在检测库上评测。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>RCNN算法分为4个步骤 </p>
<ul>
<li><p>一张图像生成1K~2K个<strong>候选区域</strong></p>
</li>
<li><p>对每个候选区域，使用深度网络<strong>提取特征</strong></p>
</li>
<li><p>特征送入每一类的SVM <strong>分类器</strong>，判别是否属于该类 </p>
</li>
<li><p>使用回归器<strong>精细修正</strong>候选框位置<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqmuk2pczfj30k105pq3i.jpg" alt=""></p>
</li>
</ul>
<h2 id="候选区域生成"><a href="#候选区域生成" class="headerlink" title="候选区域生成"></a>候选区域生成</h2><p>使用了Selective Search[1]方法从一张图像生成约2000-3000个候选区域。基本思路如下： </p>
<ul>
<li><p>使用一种过分割手段，将图像分割成小区域 </p>
</li>
<li><p>查看现有小区域，合并<strong>可能性最高</strong>的两个区域。重复直到整张图像合并成一个区域位置 </p>
</li>
<li><p>输出所有曾经存在过的区域，所谓候选区域</p>
</li>
</ul>
<p>候选区域生成和后续步骤相对独立，实际可以使用任意算法进行。</p>
<h2 id="合并规则"><a href="#合并规则" class="headerlink" title="合并规则"></a>合并规则</h2><p>优先合并以下四种区域： </p>
<ul>
<li><p>颜色（颜色直方图）相近的 </p>
</li>
<li><p>纹理（梯度直方图）相近的 </p>
</li>
<li><p>合并后总面积小的 </p>
</li>
<li><p>合并后，总面积在其BBOX中所占比例大的</p>
</li>
</ul>
<p>第三条，保证合并操作的尺度较为均匀，避免一个大区域陆续“吃掉”其他小区域。</p>
<blockquote>
<p>例：设有区域a-b-c-d-e-f-g-h。较好的合并方式是：ab-cd-ef-gh -&gt; abcd-efgh -&gt; abcdefgh。 </p>
<p>  不好的合并方法是：ab-c-d-e-f-g-h -&gt;abcd-e-f-g-h -&gt;abcdef-gh -&gt; abcdefgh。</p>
</blockquote>
<p>第四条，保证合并后形状规则。</p>
<blockquote>
<p>例：左图适于合并，右图不适于合并。<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqmukvjts3j309e02xjr5.jpg" alt=""></p>
</blockquote>
<p>上述四条规则只涉及区域的颜色直方图、纹理直方图、面积和位置。合并后的区域特征可以直接由子区域特征计算而来，速度较快。</p>
<h2 id="多样化与后处理"><a href="#多样化与后处理" class="headerlink" title="多样化与后处理"></a>多样化与后处理</h2><p>为尽可能不遗漏候选区域，上述操作在多个颜色空间中同时进行（RGB,HSV,Lab等）。在一个颜色空间中，使用上述四条规则的不同组合进行合并。所有颜色空间与所有规则的全部结果，在去除重复后，都作为候选区域输出。</p>
<p>作者提供了Selective Search的<a href="http://koen.me/research/selectivesearch/" target="_blank" rel="noopener">源码</a> ，内含较多.p文件和.mex文件，难以细查具体实现。</p>
<h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>使用深度网络提取特征之前，首先把候选区域归一化成同一尺寸227×227。 </p>
<p>此处有一些细节可做变化：外扩的尺寸大小，形变时是否保持原比例，对框外区域直接截取还是补灰。会轻微影响性能。</p>
<h3 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a>预训练</h3><p><strong>网络结构</strong></p>
<p>基本借鉴Hinton 2012年在Image Net上的分类网络[2]，略作简化[3]。<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqmuljhzk7j30i5055mx0.jpg" alt=""></p>
<p>此网络提取的特征为4096维，之后送入一个4096-&gt;1000的全连接(fc)层进行分类。 </p>
<p>学习率0.01。</p>
<p><strong>训练数据</strong></p>
<p>使用ILVCR 2012的全部数据进行训练，输入一张图片，输出1000维的类别标号。</p>
<h3 id="调优训练"><a href="#调优训练" class="headerlink" title="调优训练"></a>调优训练</h3><p><strong>网络结构</strong></p>
<p>同样使用上述网络，最后一层换成4096-&gt;21的全连接网络。 </p>
<p>学习率0.001，每一个batch包含32个正样本（属于20类）和96个背景。</p>
<p><strong>训练数据</strong></p>
<p>使用PASCAL VOC 2007的训练集，输入一张图片，输出21维的类别标号，表示20类+背景。 </p>
<p>考察一个候选框和当前图像上所有标定框重叠面积最大的一个。如果重叠比例大于0.5，则认为此候选框为此标定的类别；否则认为此候选框为背景。</p>
<h2 id="类别判断"><a href="#类别判断" class="headerlink" title="类别判断"></a>类别判断</h2><p><strong>分类器</strong></p>
<p>对每一类目标，使用一个线性SVM二类分类器进行判别。输入为深度网络输出的4096维特征，输出是否属于此类。 </p>
<p>由于负样本很多，使用hard negative mining方法。<br><strong>正样本</strong></p>
<p>本类的真值标定框。<br><strong>负样本</strong></p>
<p>考察每一个候选框，如果和本类所有标定框的重叠都小于0.3，认定其为负样本</p>
<h2 id="位置精修"><a href="#位置精修" class="headerlink" title="位置精修"></a>位置精修</h2><p>目标检测问题的衡量标准是重叠面积：许多看似准确的检测结果，往往因为候选框不够准确，重叠面积很小。故需要一个位置精修步骤。<br><strong>回归器</strong></p>
<p>对每一类目标，使用一个线性脊回归器进行精修。正则项$\lambda=10000$。 </p>
<p>输入为深度网络pool5层的4096维特征，输出为xy方向的缩放和平移。<br><strong>训练样本</strong></p>
<p>判定为本类的候选框中，和真值重叠面积大于0.6的候选框。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>论文发表的2014年，DPM已经进入瓶颈期，即使使用复杂的特征和结构得到的提升也十分有限。本文将深度学习引入检测领域，一举将PASCAL VOC上的检测率<strong>从35.1%提升到53.7%</strong>。 </p>
<p>本文的前两个步骤（候选区域提取+特征提取）与待检测类别无关，可以在不同类之间共用。这两步在GPU上约需13秒。 </p>
<p>同时检测多类时，需要倍增的只有后两步骤（判别+精修），都是简单的线性运算，速度很快。这两步对于100K类别只需10秒。</p>
<p>以本论文为基础，后续的fast RCNN[4]（参看<a href="">这篇博客</a> ）和faster RCNN[5]（参看<a href="">这篇博客</a> ）在速度上有突飞猛进的发展，基本解决了PASCAL VOC上的目标检测问题。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><hr>
<ol>
<li>J. Uijlings, K. van de Sande, T. Gevers, and A. Smeulders. Selective search for object recognition. IJCV, 2013. </li>
<li>A. Krizhevsky, I. Sutskever, and G. Hinton. ImageNet classification with deep convolutional neural networks. In NIPS, 2012 </li>
<li>所有层都是串行的。relu层为in-place操作，偏左绘制。 </li>
<li>Girshick, Ross. “Fast r-cnn.” Proceedings of the IEEE International Conference on Computer Vision. 2015. </li>
<li>Ren, Shaoqing, et al. “Faster R-CNN: Towards real-time object detection with region proposal networks.” Advances in Neural Information Processing Systems. 2015. </li>
</ol>
]]></content>
      
        <categories>
            
            <category> 论文笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最优化方法总结]]></title>
      <url>/%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅对一些常见的优化方法进行直观介绍和简单的比较，各种优化方法的详细内容及公式只好去认真啃论文了，在此我就不赘述了。</p>
<h2 id="最全优化方法总结比较（SGD，Adagrad，Adadelta，Adam，Adamax，Nadam）"><a href="#最全优化方法总结比较（SGD，Adagrad，Adadelta，Adam，Adamax，Nadam）" class="headerlink" title="最全优化方法总结比较（SGD，Adagrad，Adadelta，Adam，Adamax，Nadam）"></a>最全优化方法总结比较（SGD，Adagrad，Adadelta，Adam，Adamax，Nadam）</h2><h3 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h3><p>此处的SGD指mini-batch gradient descent，关于batch gradient descent, stochastic gradient descent, 以及 mini-batch gradient descent的具体区别就不细说了。现在的SGD一般都指mini-batch gradient descent。</p>
<p>SGD就是每一次迭代计算mini-batch的梯度，然后对参数进行更新，是最常见的优化方法了。即： </p>
<p>$$<br>g_t=\nabla_{\theta_{t-1}}{f(\theta_{t-1})}<br>$$</p>
<p>$$<br>\Delta{\theta_t}=-\eta*g_t<br>$$</p>
<p>其中，$\eta$是学习率，$g_t$是梯度<br>SGD完全依赖于当前batch的梯度，所以$\eta$可理解为允许当前batch的梯度多大程度影响参数更新</p>
<p><strong>缺点</strong>：（正因为有这些缺点才让这么多大神发展出了后续的各种算法）</p>
<ul>
<li>选择合适的learning rate比较困难</li>
<li>对所有的参数更新使用同样的learning rate。对于稀疏数据或者特征，有时我们可能想更新快一些对于不经常出现的特征，对于常出现的特征更新慢一些，这时候SGD就不太能满足要求了</li>
<li>SGD容易收敛到局部最优，在某些情况下可能被困在鞍点【但是在合适的初始化和学习率设置下，鞍点的影响其实没这么大】</li>
</ul>
<h3 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h3><p>momentum是模拟物理里动量的概念，积累之前的动量来替代真正的梯度。公式如下： </p>
<p>$$<br>m_t=\mu*m_{t-1}+g_t<br>$$</p>
<p>$$<br>\Delta{\theta_t}=-\eta<em>m_t<br>$$<br>其中，$\mu$是动量因子<br><em>*特点：</em></em></p>
<ul>
<li>下降初期时，使用上一次参数更新，下降方向一致，乘上较大的$\mu$能够进行很好的加速</li>
<li>下降中后期时，在局部最小值来回震荡的时候，$gradient\to0$，$\mu$使得更新幅度增大，跳出陷阱</li>
<li>在梯度改变方向的时候，$\mu$能够减少更新</li>
</ul>
<p>总而言之，momentum项能够在相关方向加速SGD，抑制振荡，从而加快收敛</p>
<h3 id="Nesterov"><a href="#Nesterov" class="headerlink" title="Nesterov"></a>Nesterov</h3><p>nesterov项在梯度更新时做一个校正，避免前进太快，同时提高灵敏度。 </p>
<p> 将上一节中的公式展开可得： </p>
<p>$$<br>\Delta{\theta_t}=-\eta<em>\mu</em>m_{t-1}-\eta*g_t<br>$$<br> 可以看出，$m_{t-1}$并没有直接改变当前梯度$tg_t$，所以Nesterov的改进就是让之前的动量直接影响当前的动量。即： </p>
<p>$$<br>g_t=\nabla_{\theta_{t-1}}{f(\theta_{t-1}-\eta<em>\mu</em>m_{t-1})}<br>$$</p>
<p>$$<br>m_t=\mu*m_{t-1}+g_t<br>$$</p>
<p>$$<br>\Delta{\theta_t}=-\eta*m_t<br>$$<br> 所以，加上nesterov项后，梯度在大的跳跃后，进行计算对当前梯度进行校正。如下图：<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqmu2nxv27j30mm06gwem.jpg" alt=""></p>
<p>momentum首先计算一个梯度(短的蓝色向量)，然后在加速更新梯度的方向进行一个大的跳跃(长的蓝色向量)，nesterov项首先在之前加速的梯度方向进行一个大的跳跃(棕色向量)，计算梯度然后进行校正(绿色梯向量)</p>
<p>其实，momentum项和nesterov项都是为了使梯度更新更加灵活，对不同情况有针对性。但是，人工设置一些学习率总还是有些生硬，接下来介绍几种自适应学习率的方法</p>
<h3 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h3><p>Adagrad其实是对学习率进行了一个约束。即： </p>
<p>$$<br>n_t=n_{t-1}+g_t^2<br>$$</p>
<p>$$<br>\Delta{\theta_t}=-\frac{\eta}{\sqrt{n_t+\epsilon}}*g_t<br>$$</p>
<p>此处，对$g_t$从$1到t$进行一个递推形成一个约束项regularizer，$\frac{1}{\sqrt{\sum_{r=1}^t(g_r)^2+\epsilon}}$ ，$\epsilon$用来保证分母非0<br><strong>特点：</strong></p>
<ul>
<li>前期$g_t$较小的时候， regularizer较大，能够放大梯度</li>
<li>后期$g_t$较大的时候，regularizer较小，能够约束梯度</li>
<li>适合处理稀疏梯度</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>由公式可以看出，仍依赖于人工设置一个全局学习率</li>
<li>$\eta$设置过大的话，会使regularizer过于敏感，对梯度的调节太大</li>
<li>中后期，分母上梯度平方的累加将会越来越大，使$gradient\to0$，使得训练提前结束</li>
</ul>
<h3 id="Adadelta"><a href="#Adadelta" class="headerlink" title="Adadelta"></a>Adadelta</h3><p>Adadelta是对Adagrad的扩展，最初方案依然是对学习率进行自适应约束，但是进行了计算上的简化。 </p>
<p>Adagrad会累加之前所有的梯度平方，而Adadelta只累加固定大小的项，并且也不直接存储这些项，仅仅是近似计算对应的平均值。即： </p>
<p>$$<br>n_t=\nu<em>n_{t-1}+(1-\nu)</em>g_t^2<br>$$</p>
<p>$$<br>\Delta{\theta_t} = -\frac{\eta}{\sqrt{n_t+\epsilon}}*g_t<br>$$<br>在此处Adadelta其实还是依赖于全局学习率的，但是作者做了一定处理，经过近似牛顿迭代法之后： </p>
<p>$$<br>E|g^2|_t=\rho<em>E|g^2|_{t-1}+(1-\rho)</em>g_t^2<br>$$</p>
<p>$$<br>\Delta{x_t}=-\frac{\sqrt{\sum_{r=1}^{t-1}\Delta{x_r}}}{\sqrt{E|g^2|_t+\epsilon}}<br>$$</p>
<p>其中，$E$代表求期望。 </p>
<p>此时，可以看出Adadelta已经不用依赖于全局学习率了。<br><strong>特点：</strong></p>
<ul>
<li>训练初中期，加速效果不错，很快</li>
<li>训练后期，反复在局部最小值附近抖动</li>
</ul>
<h3 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h3><p>RMSprop可以算作Adadelta的一个特例：</p>
<p>当$rho=0.5$时，$E|g^2|_t=\rho<em>E|g^2|_{t-1}+(1-\rho)</em>g_t^2$就变为了求梯度平方和的平均数。 </p>
<p>如果再求根的话，就变成了RMS(均方根)： </p>
<p>$$<br>RMS|g|_t=\sqrt{E|g^2|_t+\epsilon}<br>$$</p>
<p>此时，这个RMS就可以作为学习率$\eta$的一个约束： </p>
<p>$$<br>\Delta{x_t}=-\frac{\eta}{RMS|g|_t}*g_t<br>$$</p>
<p><strong>特点：</strong></p>
<ul>
<li>其实RMSprop依然依赖于全局学习率</li>
<li>RMSprop算是Adagrad的一种发展，和Adadelta的变体，效果趋于二者之间</li>
<li>适合处理非平稳目标</li>
<li>对于RNN效果很好</li>
</ul>
<h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h3><p>Adam(Adaptive Moment Estimation)本质上是带有动量项的RMSprop，它利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率。Adam的优点主要在于经过偏置校正后，每一次迭代学习率都有个确定范围，使得参数比较平稳。公式如下： </p>
<p>$$<br>m_t=\mu<em>m_{t-1}+(1-\mu)</em>g_t<br>$$</p>
<p>$$<br>n_t=\nu<em>n_{t-1}+（1-\nu）</em>g_t^2<br>$$</p>
<p>$$<br>\hat{m_t}=\frac{m_t}{1-\mu^t}<br>$$</p>
<p>$$<br>\hat{n_t}=\frac{n_t}{1-\nu^t}<br>$$</p>
<p>$$<br>\Delta{\theta_t}=-\frac{\hat{m_t}}{\sqrt{\hat{n_t}}+\epsilon}*\eta<br>$$</p>
<p>其中，$m_t，n_t$分别是对梯度的一阶矩估计和二阶矩估计，可以看作对期望$E|g_t|$，$E|g_t^2|$的估计；$\hat{m_t}$，$\hat{n_t}$是对$m_t，n_t$的校正，这样可以近似为对期望的无偏估计。 </p>
<p>可以看出，直接对梯度的矩估计对内存没有额外的要求，而且可以根据梯度进行动态调整，而$\frac{\hat{m_t}}{\sqrt{\hat{n_t}}+\epsilon}$对学习率形成一个动态约束，而且有明确的范围。</p>
<p><strong>特点：</strong></p>
<ul>
<li>结合了Adagrad善于处理稀疏梯度和RMSprop善于处理非平稳目标的优点</li>
<li>对内存需求较小</li>
<li>为不同的参数计算不同的自适应学习率</li>
<li>也适用于大多非凸优化</li>
<li>适用于大数据集和高维空间</li>
</ul>
<h3 id="Adamax"><a href="#Adamax" class="headerlink" title="Adamax"></a>Adamax</h3><p>Adamax是Adam的一种变体，此方法对学习率的上限提供了一个更简单的范围。公式上的变化如下： </p>
<p>$$<br>n_t=max(\nu*n_{t-1},|g_t|)<br>$$</p>
<p>$$<br>\Delta{x}=-\frac{\hat{m_t}}{n_t+\epsilon}*\eta<br>$$</p>
<p>可以看出，Adamax学习率的边界范围更简单</p>
<h3 id="Nadam"><a href="#Nadam" class="headerlink" title="Nadam"></a>Nadam</h3><p>Nadam类似于带有Nesterov动量项的Adam。公式如下： </p>
<p>$$<br>\hat{g_t}=\frac{g_t}{1-\Pi_{i=1}^t\mu_i}<br>$$</p>
<p>$$<br>m_t=\mu_t<em>m_{t-1}+(1-\mu_t)</em>g_t<br>$$</p>
<p>$$<br>\hat{m_t}=\frac{m_t}{1-\Pi_{i=1}^{t+1}\mu_i}<br>$$</p>
<p>$$<br>n_t=\nu<em>n_{t-1}+（1-\nu）</em>g_t^2<br>$$</p>
<p>$$<br>\hat{n_t}=\frac{n_t}{1-\nu^t}<br>$$</p>
<p>$$<br>\bar{m_t}=(1-\mu_t)<em>\hat{g_t}+\mu_{t+1}</em>\hat{m_t}<br>$$</p>
<p>$$<br>\Delta{\theta_t}=-\eta*\frac{\bar{m_t}}{\sqrt{\hat{n_t}}+\epsilon}<br>$$</p>
<p>可以看出，Nadam对学习率有了更强的约束，同时对梯度的更新也有更直接的影响。一般而言，在想使用带动量的RMSprop，或者Adam的地方，大多可以使用Nadam取得更好的效果。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="经验之谈-经验之谈"><a href="#经验之谈-经验之谈" class="headerlink" title="经验之谈 # (#经验之谈)"></a>经验之谈 # (#经验之谈)</h3><ul>
<li>对于稀疏数据，尽量使用学习率可自适应的优化方法，不用手动调节，而且最好采用默认值</li>
<li>SGD通常训练时间更长，容易陷入鞍点，但是在好的初始化和学习率调度方案的情况下，结果更可靠</li>
<li>如果在意更快的收敛，并且需要训练较深较复杂的网络时，推荐使用学习率自适应的优化方法。</li>
<li>Adadelta，RMSprop，Adam是比较相近的算法，在相似的情况下表现差不多。</li>
<li>在想使用带动量的RMSprop，或者Adam的地方，大多可以使用Nadam取得更好的效果</li>
</ul>
<p>最后展示两张可厉害的图，一切尽在图中啊，上面的都没啥用了… …</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqmu8i60upg30h80dc4f6.gif" alt="损失平面等高线"></p>
<p>损失平面等高线</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqmu95nm33g30h80dcdu0.gif" alt="在鞍点处的比较"></p>
<h3 id="引用-引用"><a href="#引用-引用" class="headerlink" title="引用 # (#引用)"></a>引用 # (#引用)</h3><p>[1]<a href="http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf" target="_blank" rel="noopener">Adagrad</a> </p>
<p>[2]<a href="http://www.cs.toronto.edu/~tijmen/csc321/lecture_notes.shtml" target="_blank" rel="noopener">RMSprop[Lecture 6e]</a> </p>
<p>[3]<a href="http://arxiv.org/abs/1212.5701" target="_blank" rel="noopener">Adadelta</a> </p>
<p>[4]<a href="http://arxiv.org/abs/1412.6980v8" target="_blank" rel="noopener">Adam</a> </p>
<p>[5]<a href="http://cs229.stanford.edu/proj2015/054_report.pdf" target="_blank" rel="noopener">Nadam</a> </p>
<p>[6]<a href="http://www.cs.toronto.edu/~fritz/absps/momentum.pdf" target="_blank" rel="noopener">On the importance of initialization and momentum in deep learning</a> </p>
<p>[7]<a href="https://keras.io/optimizers/" target="_blank" rel="noopener">Keras</a> <a href="http://keras-cn.readthedocs.io/en/latest/" target="_blank" rel="noopener">中文文档</a> </p>
<p>[8]<a href="https://link.zhihu.com/?target=https://twitter.com/alecrad" target="_blank" rel="noopener">Alec Radford</a> (图) </p>
<p>[9]<a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a> </p>
<p>[10]<a href="http://www.jmlr.org/proceedings/papers/v49/lee16.pdf" target="_blank" rel="noopener">Gradient Descent Only Converges to Minimizers</a> </p>
<p>[11]<a href="http://www.nature.com/nature/journal/v521/n7553/abs/nature14539.html" target="_blank" rel="noopener">Deep Learning:Nature</a> </p>
]]></content>
      
        <categories>
            
            <category> 优化算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 优化算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LSTM模型小结]]></title>
      <url>/LSTM%E6%A8%A1%E5%9E%8B%E5%B0%8F%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="http://pancakeawesome.ink/RNN%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%BB%93.html">循环神经网络(RNN)模型与前向反向传播算法</a>中，我们总结了对RNN模型做了总结。由于RNN也有梯度消失的问题，因此很难处理长序列的数据，大牛们对RNN做了改进，得到了RNN的特例LSTM（Long Short-Term Memory），它可以避免常规RNN的梯度消失，因此在工业界得到了广泛的应用。下面我们就对LSTM模型做一个总结。</p>
<h2 id="LSTM模型小结"><a href="#LSTM模型小结" class="headerlink" title="LSTM模型小结"></a>LSTM模型小结</h2><h3 id="1-从RNN到LSTM"><a href="#1-从RNN到LSTM" class="headerlink" title="1. 从RNN到LSTM"></a>1. 从RNN到LSTM</h3><p>在RNN模型里，我们讲到了RNN具有如下的结构，每个序列索引位置t都有一个隐藏状态$h^{(t)}$。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqfyodn6eqj30hw0bkwew.jpg" alt=""></p>
<p>如果我们略去每层都有的$o^{(t)}, L^{(t)}, y^{(t)}$，则RNN的模型可以简化成如下图的形式：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqfyp7w4m2j30ld082dfw.jpg" alt=""></p>
<p>图中可以很清晰看出在隐藏状态$h^{(t)}$由$x^{(t)}$和$h^{(t-1)}$得到。得到$h^{(t)}$后一方面用于当前层的模型损失计算，另一方面用于计算下一层的$h^{(t+1)}$。</p>
<p>由于RNN梯度消失的问题，大牛们对于序列索引位置t的隐藏结构做了改进，可以说通过一些技巧让隐藏结构复杂了起来，来避免梯度消失的问题，这样的特殊RNN就是我们的LSTM。由于LSTM有很多的变种，这里我们以最常见的LSTM为例讲述。LSTM的结构如下图：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqfypi8975j30l0082mxc.jpg" alt=""></p>
<p>可以看到LSTM的结构要比RNN的复杂的多，真佩服牛人们怎么想出来这样的结构，然后这样居然就可以解决RNN梯度消失的问题？由于LSTM怎么可以解决梯度消失是一个比较难讲的问题，我也不是很熟悉，这里就不多说，重点回到LSTM的模型本身。</p>
<h3 id="2-LSTM模型结构剖析"><a href="#2-LSTM模型结构剖析" class="headerlink" title="2. LSTM模型结构剖析"></a>2. LSTM模型结构剖析</h3><p>上面我们给出了LSTM的模型结构，下面我们就一点点的剖析LSTM模型在每个序列索引位置t时刻的内部结构。</p>
<p>从上图中可以看出，在每个序列索引位置t时刻向前传播的除了和RNN一样的隐藏状态$h^{(t)}$，还多了另一个隐藏状态，如图中上面的长横线。这个隐藏状态我们一般称为细胞状态(Cell State)，记为$C^{(t)}$。如下图所示：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqfypqwauqj30aj06ewec.jpg" alt=""></p>
<p>除了细胞状态，LSTM图中还有了很多奇怪的结构，这些结构一般称之为门控结构(Gate)。LSTM在在每个序列索引位置t的门一般包括遗忘门，输入门和输出门三种。下面我们就来研究上图中LSTM的遗忘门，输入门和输出门以及细胞状态。</p>
<h4 id="2-1-LSTM之遗忘门"><a href="#2-1-LSTM之遗忘门" class="headerlink" title="2.1 LSTM之遗忘门"></a>2.1 LSTM之遗忘门</h4><p>遗忘门（forget gate）顾名思义，是控制是否遗忘的，在LSTM中即以一定的概率控制是否遗忘上一层的隐藏细胞状态。遗忘门子结构如下图所示：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqfypvknjkj30aj06g0sl.jpg" alt=""></p>
<p>图中输入的有上一序列的隐藏状态$h^{(t-1)}$和本序列数据$x^{(t)}$，通过一个激活函数，一般是sigmoid，得到遗忘门的输出$f^{(t)}$。由于sigmoid的输出$f^{(t)}$在[0,1]之间，因此这里的输出$f^{(t)}$代表了遗忘上一层隐藏细胞状态的概率。用数学表达式即为：<br>$$<br>f^{(t)} = \sigma(W_fh^{(t-1)} + U_fx^{(t)} + b_f)<br>$$<br>其中$W_f, U_f, b_f$为线性关系的系数和偏倚，和RNN中的类似。$\sigma$为sigmoid激活函数。</p>
<h4 id="2-2-LSTM之输入门"><a href="#2-2-LSTM之输入门" class="headerlink" title="2.2 LSTM之输入门"></a>2.2 LSTM之输入门</h4><p>输入门（input gate）负责处理当前序列位置的输入，它的子结构如下图：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqfypznv7mj30ax06edfp.jpg" alt=""></p>
<p>从图中可以看到输入门由两部分组成，第一部分使用了sigmoid激活函数，输出为$i^{(t)}$,第二部分使用了tanh激活函数，输出为$a^{(t)}$, 两者的结果后面会相乘再去更新细胞状态。用数学表达式即为：<br>$$<br>i^{(t)} = \sigma(W_ih^{(t-1)} + U_ix^{(t)} + b_i)<br>$$<br>$$<br>a^{(t)} =tanh(W_ah^{(t-1)} + U_ax^{(t)} + b_a)<br>$$<br>其中$W_i, U_i, b_i, W_a, U_a, b_a,$为线性关系的系数和偏倚，和RNN中的类似。$\sigma$为sigmoid激活函数。</p>
<h4 id="2-3-LSTM之细胞状态更新"><a href="#2-3-LSTM之细胞状态更新" class="headerlink" title="2.3 LSTM之细胞状态更新"></a>2.3 LSTM之细胞状态更新</h4><p>在研究LSTM输出门之前，我们要先看看LSTM之细胞状态。前面的遗忘门和输入门的结果都会作用于细胞状态$C^{(t)}$。我们来看看从细胞状态$C^{(t-1)}$如何得到$C^{(t)}$。如下图所示：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqfyqb4tzej30am06ct8l.jpg" alt=""></p>
<p>细胞状态$C^{(t)}$由两部分组成，第一部分是$C^{(t-1)}$和遗忘门输出$f^{(t)}$的乘积，第二部分是输入门的$i^{(t)}$和$a^{(t)}$的乘积，即：<br>$$<br>C^{(t)} = C^{(t-1)} \odot f^{(t)} + i^{(t)} \odot a^{(t)}<br>$$<br>其中，$\odot$为Hadamard积，在DNN中也用到过。</p>
<h4 id="2-4-LSTM之输出门"><a href="#2-4-LSTM之输出门" class="headerlink" title="2.4 LSTM之输出门"></a>2.4 LSTM之输出门</h4><p>有了新的隐藏细胞状态$C^{(t)}$，我们就可以来看输出门了，子结构如下：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqfyqkrzkxj30ao06q0sm.jpg" alt=""></p>
<p>从图中可以看出，隐藏状态$h^{(t)}$的更新由两部分组成，第一部分是$o^{(t)}$, 它由上一序列的隐藏状态$h^{(t-1)}$和本序列数据$x^{(t)}$，以及激活函数sigmoid得到，第二部分由隐藏状态$C^{(t)}$和tanh激活函数组成, 即：<br>$$<br>o^{(t)} = \sigma(W_oh^{(t-1)} + U_ox^{(t)} + b_o)<br>$$<br>$$<br>h^{(t)} = o^{(t)} \odot tanh(C^{(t)})<br>$$<br>通过本节的剖析，相信大家对于LSTM的模型结构已经有了解了。当然，有些LSTM的结构和上面的LSTM图稍有不同，但是原理是完全一样的。</p>
<h3 id="3-LSTM重要分析"><a href="#3-LSTM重要分析" class="headerlink" title="3. LSTM重要分析"></a>3. LSTM重要分析</h3><p>让我们首先看一下RNN的拓扑图：<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqo3905fv7j30k0083t97.jpg" alt="RNN拓扑结构"></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqfypi8975j30l0082mxc.jpg" alt=""></p>
<p>我们再来仔细观察这张图。<br>可以看到中间的 <strong>cell 里面有四个黄色小框</strong>，你如果理解了那个代表的含义一切就明白了，<strong>每一个小黄框代表一个前馈网络层</strong>，对，就是经典的神经网络的结构，<strong>num_units就是这个层的隐藏神经元个数</strong>，就这么简单。其中1、2、4的激活函数是 sigmoid，第三个的激活函数是 tanh。</p>
<p>另外几个需要注意的地方：<br>1、 <strong>cell 的状态是一个向量，是有多个值的</strong>。。。一开始没有理解这点的时候怎么都想不明白<br>2、 <strong>上一次的状态 h(t-1)是怎么和下一次的输入 x(t) 结合（concat）起来的</strong>，这也是很多资料没有明白讲的地方，也很简单，<strong>concat， 直白的说就是把二者直接拼起来</strong>，比如 x是28位的向量，h(t-1)是128位的，那么拼起来就是156位的向量，就是这么简单。。<br>3、 <strong>cell 的权重是共享的</strong>，这是什么意思呢？这是指这张图片上有三个绿色的大框，代表三个 cell 对吧，但是实际上，它<strong>只是代表了一个 cell 在不同时序时候的状态</strong>，所有的数据只会通过一个 cell，然后不断更新它的权重。<br>4、那么一层的 LSTM 的参数有多少个？根据第 3 点的说明，我们知道参数的数量是由 cell 的数量决定的，这里只有一个 cell，所以参数的数量就是这个 cell 里面用到的参数个数。假设 num_units 是128，输入是28位的，那么根据上面的第 2 点，可以得到，四个小黄框的参数一共有 （128+28）x（128 x 4），也就是156 x 512，可以看看 TensorFlow 的最简单的 LSTM 的案例，中间层的参数就是这样，不过还要加上输出的时候的激活函数的参数，假设是10个类的话，就是128*10的 W 参数和10个bias 参数<br>5、cell 最上面的一条线的状态即 s(t) 代表了长时记忆，而下面的 h(t)则代表了工作记忆或短时记忆。</p>
<p>我们来举个栗子🌰：<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqnv62ctdhj30k00e53yz.jpg" alt=""></p>
<p>将一个28*28的mnist数据集图片按行送入RNN,从而实现手写体数字识别。上图这里按行切了28行（一般按列来做切片,_H为128 是因为RNN单元有128个LSTM Cell,所以需要一次线性转换）,使用tensorflow也能取得还算是不错的效果。不过tensorflow的CTC模块可以更好的处理变长验证码的识别。</p>
<pre><code>
def _RNN(_X,batch_size, _W, _b,num_layers,_nsteps):
    # 1.将输入从[batchsize, nsteps, diminput]变成[nsteps, batchsize, diminput]
    _X = tf.transpose(_X, [1, 0, 2])
    # 2.再次转换成[nsteps*batchsize, diminput]
    _X = tf.reshape(_X, [-1, diminput])
    # 3.从输入层进入隐层：一个线性变换
    _H = tf.matmul(_X, _W[&#39;hidden&#39;]) + _b[&#39;hidden&#39;]
    # 4.使用这种RNN输入方式，tensorflow的rnn定义稍微简单点
    _Hsplit = tf.split(0, _nsteps, _H)
    # 5.LSTM的最终输出 (_O) and 状态 (_S)
    #    Both _O and _S consist of &#39;batchsize&#39; elements
    with tf.variable_scope(_name):
        lstm_cell = tf.nn.rnn_cell.BasicLSTMCell(dimhidden, forget_bias=1.0)
        lstm_cell = tf.nn.rnn_cell.MultiRNNCell([lstm_cell]*num_layers, state_is_tuple=True)
        state = lstm_cell.zero_state(batch_size,dtype=tf.float32)
        _LSTM_O, _LSTM_S = tf.nn.rnn(lstm_cell, _Hsplit, initial_state=state)
</code></pre><p>对照下图，这里的batchsize(5) 就是一个batch的大小，nsteps(28)就是rnn的time step ,diminput(28)就是单个rnn单元输入的数据维度。很显然 nsteps x  diminput(28 x 28) 就是单个mnist的数据维度。 上述代码的示意图：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqnv71pz2oj30fe09wdg5.jpg" alt=""></p>
<h3 id="4-LSTM前向传播算法"><a href="#4-LSTM前向传播算法" class="headerlink" title="4. LSTM前向传播算法"></a>4. LSTM前向传播算法</h3><p>现在我们来总结下LSTM前向传播算法。LSTM模型有两个隐藏状态$h^{(t)}, C^{(t)}$，模型参数几乎是RNN的4倍，因为现在多了$W_f, U_f, b_f, W_a, U_a, b_a, W_i, U_i, b_i, W_o, U_o, b_o$这些参数。</p>
<p>前向传播过程在每个序列索引位置的过程为：</p>
<p>1）更新遗忘门输出：<br>$$<br>f^{(t)} = \sigma(W_fh^{(t-1)} + U_fx^{(t)} + b_f)<br>$$<br>2）更新输入门两部分输出：<br>$$<br>i^{(t)} = \sigma(W_ih^{(t-1)} + U_ix^{(t)} + b_i)<br>$$<br>$$<br>a^{(t)} = tanh(W_ah^{(t-1)} + U_ax^{(t)} + b_a)<br>$$<br>3）更新细胞状态：<br>$$<br>C^{(t)} = C^{(t-1)} \odot f^{(t)} + i^{(t)} \odot a^{(t)}<br>$$<br>4）更新输出门输出：<br>$$<br>o^{(t)} = \sigma(W_oh^{(t-1)} + U_ox^{(t)} + b_o)<br>$$<br>$$<br>h^{(t)} = o^{(t)} \odot tanh(C^{(t)})<br>$$<br>5）更新当前序列索引预测输出：<br>$$<br>\hat{y}^{(t)} = \sigma(Vh^{(t)} + c)<br>$$</p>
<h3 id="5-LSTM反向传播算法推导关键点"><a href="#5-LSTM反向传播算法推导关键点" class="headerlink" title="5.  LSTM反向传播算法推导关键点"></a>5.  LSTM反向传播算法推导关键点</h3><p>有了LSTM前向传播算法，推导反向传播算法就很容易了， 思路和RNN的反向传播算法思路一致，也是通过梯度下降法迭代更新我们所有的参数，关键点在于计算所有参数基于损失函数的偏导数。</p>
<p>在RNN中，为了反向传播误差，我们通过隐藏状态$h^{(t)}$的梯度$\delta^{(t)}$一步步向前传播。在LSTM这里也类似。只不过我们这里有两个隐藏状态$h^{(t)}和C^{(t)}$。这里我们定义两个$\delta$，即：<br>$$<br>\delta_h^{(t)} = \frac{\partial L}{\partial h^{(t)}}<br>$$<br>$$<br>\delta_C^{(t)} = \frac{\partial L}{\partial C^{(t)}}<br>$$<br>反向传播时只使用了$\delta_C^{(t)}$,变量$\delta_h^{(t)}$仅为帮助我们在某一层计算用，并没有参与反向传播，这里要注意。如下图所示：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqfyqwijijj30kq0s0aao.jpg" alt=""></p>
<p>而在最后的序列索引位置$\tau$的$\delta_h^{(\tau)}$和 $\delta_C^{(\tau)}$ 为：<br>$$<br>\delta_h^{(\tau)} =\frac{\partial L}{\partial O^{(\tau)}} \frac{\partial O^{(\tau)}}{\partial h^{(\tau)}} = V^T(\hat{y}^{(\tau)} - y^{(\tau)})<br>$$<br>$$<br>\delta_C^{(\tau)} =\frac{\partial L}{\partial h^{(\tau)}} \frac{\partial h^{(\tau)}}{\partial C^{(\tau)}} = \delta_h^{(\tau)} \odot  o^{(\tau)} \odot (1 - tanh^2(C^{(\tau)}))<br>$$<br>接着我们由$\delta_C^{(t+1)}$反向推导$\delta_C^{(t)}$。</p>
<p>$\delta_h^{(t)}$的梯度由本层的输出梯度误差决定，即：<br>$$<br>  \delta_h^{(t)} =\frac{\partial L}{\partial h^{(t)}}  = V^T(\hat{y}^{(t)} - y^{(t)})<br>$$<br>而$\delta_C^{(t)}$的反向梯度误差由前一层$\delta_C^{(t+1)}$的梯度误差和本层的从$h^{(t)}$传回来的梯度误差两部分组成，即：<br>$$<br>\delta_C^{(t)} =\frac{\partial L}{\partial C^{(t+1)}} \frac{\partial  C^{(t+1)}}{\partial C^{(t)}} + \frac{\partial L}{\partial h^{(t)}}\frac{\partial h^{(t)}}{\partial C^{(t)}} = \delta_C^{(t+1)}\odot f^{(t+1)} + \delta_h^{(t)} \odot  o^{(t)} \odot (1 - tanh^2(C^{(t)}))<br>$$<br>有了$\delta_h^{(t)}$和$\delta_C^{(t)}$， 计算这一大堆参数的梯度就很容易了，这里只给出WfWfW_f的梯度计算过程，其他的$U_f, b_f, W_a, U_a, b_a, W_i, U_i, b_i, W_o, U_o, b_o，V, c$的梯度大家只要照搬就可以了。<br>$$<br>\frac{\partial L}{\partial W_f} =  \sum\limits_{t=1}^{\tau}\frac{\partial L}{\partial C^{(t)}} \frac{\partial C^{(t)}}{\partial f^{(t)}} \frac{\partial f^{(t)}}{\partial W_f} =\sum\limits_{t=1}^{\tau} \delta_C^{(t)} \odot C^{(t-1)} \odot f^{(t)}(1-f^{(t)}) (h^{(t-1)})^T<br>$$</p>
<h3 id="6-LSTM的正则化"><a href="#6-LSTM的正则化" class="headerlink" title="6. LSTM的正则化"></a>6. LSTM的正则化</h3><p>在rnn中使用dropout的方法和cnn不同，推荐大家去把<a href="https://arxiv.org/pdf/1409.2329.pdf" target="_blank" rel="noopener">recurrent neural network regularization</a>看一遍。<br>所谓dropout,就是指网络中每个单元在每次有数据流入时以一定的概率(keep prob)正常工作，否则输出0值。这是是一种有效的正则化方法，可以有效防止过拟合。<br>在rnn中进行dropout时，对于rnn的部分不进行dropout，也就是说从t-1时候的状态传递到t时刻进行计算时，这个中间不进行memory的dropout；仅在同一个t时刻中，<strong>多层cell之间</strong>传递信息的时候进行dropout，如下图所示:</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqo356xp74j308706amwy.jpg" alt=""></p>
<p>具体在代码实现中可以使用tensorflow的DropoutWrapper api:</p>
<blockquote>
<p>tf.contrib.rnn.DropoutWrapper<br>Defined in tensorflow/python/ops/rnn_cell_impl.py.</p>
</blockquote>
<pre><code>__init__(
    cell,
    input_keep_prob=1.0,
    output_keep_prob=1.0,
    state_keep_prob=1.0,
    variational_recurrent=False,
    input_size=None,
    dtype=None,
    seed=None,
    dropout_state_filter_visitor=None
)
</code></pre><p>上图中，t-2时刻的输入$x_{t−2}$首先传入第一层cell，这个过程有dropout，但是从t−2时刻的第一层cell传到t−1,t,t+1的第一层cell这个中间都不进行dropout。再从t+1时候的第一层cell向同一时刻内后续的cell传递时，这之间又有dropout了。</p>
<p>在使用<code>tf.nn.rnn_cell.DropoutWrapper</code>时，同样有一些参数，例如<code>input_keep_prob,output_keep_prob</code>等，分别控制输入和输出的dropout概率，很好理解。<br>可以从官方文档中看到，它有input_keep_prob和output_keep_prob，也就是说裹上这个DropoutWrapper之后，如果我希望是input传入这个cell时dropout掉一部分input信息的话，就设置input_keep_prob，那么传入到cell的就是部分input；如果我希望这个cell的output只部分作为下一层cell的input的话，就定义output_keep_prob。<br>备注：<strong>Dropout只能是层与层之间</strong>（输入层与LSTM1层、LSTM1层与LSTM2层）的Dropout；同一个层里面，T时刻与T+1时刻是不会Dropout的。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="7-LSTM小结"><a href="#7-LSTM小结" class="headerlink" title="7. LSTM小结"></a>7. LSTM小结</h3><p>LSTM虽然结构复杂，但是只要理顺了里面的各个部分和之间的关系，进而理解前向反向传播算法是不难的。当然实际应用中LSTM的难点不在前向反向传播算法，这些有算法库帮你搞定，模型结构和一大堆参数的调参才是让人头痛的问题。不过，理解LSTM模型结构仍然是高效使用的前提。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>1） <a href="http://neuralnetworksanddeeplearning.com/index.html" target="_blank" rel="noopener">Neural Networks and Deep Learning</a> by By Michael Nielsen</p>
<p>2） <a href="http://www.deeplearningbook.org/" target="_blank" rel="noopener">Deep Learning</a>, book by Ian Goodfellow, Yoshua Bengio, and Aaron Courville</p>
<p>3） <a href="http://ufldl.stanford.edu/tutorial/" target="_blank" rel="noopener">UFLDL Tutorial</a> </p>
<p>4）<a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding-LSTMs</a> </p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RNN循环神经网络小结]]></title>
      <url>/RNN%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面我们讲到了DNN，以及DNN的特例CNN的模型和前向反向传播算法，这些算法都是前向反馈的，模型的输出和模型本身没有关联关系。今天我们就讨论另一类输出和模型间有反馈的神经网络：循环神经网络(Recurrent Neural Networks ，以下简称RNN)，它广泛的用于自然语言处理中的语音识别，手写书别以及机器翻译等领域。</p>
<h2 id="RNN循环神经网络小结"><a href="#RNN循环神经网络小结" class="headerlink" title="RNN循环神经网络小结"></a>RNN循环神经网络小结</h2><h3 id="1-RNN概述"><a href="#1-RNN概述" class="headerlink" title="1. RNN概述"></a>1. RNN概述</h3><p>在前面讲到的DNN和CNN中，训练样本的输入和输出是比较的确定的。但是有一类问题DNN和CNN不好解决，就是训练样本输入是连续的序列,且序列的长短不一，比如基于时间的序列：一段段连续的语音，一段段连续的手写文字。这些序列比较长，且长度不一，比较难直接的拆分成一个个独立的样本来通过DNN/CNN进行训练。</p>
<p>而对于这类问题，RNN则比较的擅长。那么RNN是怎么做到的呢？RNN假设我们的样本是基于序列的。比如是从序列索引1到序列索引$\tau$的。对于这其中的任意序列索引号$t$,它对应的输入是对应的样本序列中的$x^{(t)}$。而模型在序列索引号t位置的隐藏状态$h^{(t)}$，则由$x^{(t)}$和在t-1位置的隐藏状态$h^{(t-1)}$共同决定。在任意序列索引号t，我们也有对应的模型预测输出$o^{(t)}$。通过预测输出$o^{(t)}$和训练序列真实输出$y^{(t)}$,以及损失函数$L^{(t)}$，我们就可以用DNN类似的方法来训练模型，接着用来预测测试序列中的一些位置的输出。</p>
<p>下面我们来看看RNN的模型。</p>
<h3 id="2-RNN模型"><a href="#2-RNN模型" class="headerlink" title="2. RNN模型"></a>2. RNN模型</h3><p>RNN模型有比较多的变种，这里介绍最主流的RNN模型结构如下：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqfydmgisyj30hw0bkwew.jpg" alt=""></p>
<p>上图中左边是RNN模型没有按时间展开的图，如果按时间序列展开，则是上图中的右边部分。我们重点观察右边部分的图。</p>
<p>这幅图描述了在序列索引号$t$附近RNN的模型。其中：</p>
<p>1）$x^{(t)}$代表在序列索引号$t$时训练样本的输入。同样的，$x^{(t-1)}$和$x^{(t+1)}$代表在序列索引号$t-1和t+1$时训练样本的输入。</p>
<p>2）$h^{(t)}$代表在序列索引号t时模型的隐藏状态。$h^{(t)}$由$x^{(t)}$和$h^{(t-1)}$共同决定。</p>
<p>3）$o^{(t)}$代表在序列索引号t时模型的输出。$o^{(t)}$只由模型当前的隐藏状态$h^{(t)}$决定。</p>
<p>4）$L^{(t)}$代表在序列索引号t时模型的损失函数。</p>
<p>5）$y^{(t)}$代表在序列索引号t时训练样本序列的真实输出。</p>
<p>6）$U,W,V$这三个矩阵是我们的模型的线性关系参数，它在整个RNN网络中是共享的，这点和DNN很不相同。 也正因为是共享了，它体现了RNN的模型的“循环反馈”的思想。　　</p>
<p>也许通过上面的图，你理解不是很清楚，那给你看一下RNN的拓扑图，你应该会理解更加透彻：<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fqo3ay32y3j30k00b5dgd.jpg" alt="普通MLP层拓扑结构"></p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqo3905fv7j30k0083t97.jpg" alt="RNN拓扑结构"></p>
<h3 id="3-RNN前向传播算法"><a href="#3-RNN前向传播算法" class="headerlink" title="3. RNN前向传播算法"></a>3. RNN前向传播算法</h3><p>有了上面的模型，RNN的前向传播算法就很容易得到了。</p>
<p>对于任意一个序列索引号t，我们隐藏状态$h^{(t)}$由$x^{(t)}$和$h^{(t-1)}$得到：<br>$$<br>h^{(t)} = \sigma(z^{(t)}) = \sigma(Ux^{(t)} + Wh^{(t-1)} +b )<br>$$<br>其中$\sigma$为RNN的激活函数，一般为$tanh, b$为线性关系的偏倚。</p>
<p>序列索引号t时模型的输出$o^{(t)}$的表达式比较简单：<br>$$<br>o^{(t)} = Vh^{(t)} +c<br>$$<br>在最终在序列索引号t时我们的预测输出为:<br>$$<br>\hat{y}^{(t)} = \sigma(o^{(t)})<br>$$<br>通常由于RNN是识别类的分类模型，所以上面这个激活函数一般是softmax。</p>
<p>通过损失函数$L^{(t)}$，比如对数似然损失函数，我们可以量化模型在当前位置的损失，即$\hat{y}^{(t)}$和$y^{(t)}$的差距。</p>
<h3 id="4-RNN反向传播算法推导"><a href="#4-RNN反向传播算法推导" class="headerlink" title="4. RNN反向传播算法推导"></a>4. RNN反向传播算法推导</h3><p>有了RNN前向传播算法的基础，就容易推导出RNN反向传播算法的流程了。RNN反向传播算法的思路和DNN是一样的，即通过梯度下降法一轮轮的迭代，得到合适的RNN模型参数$U,W,V,b,c$。由于我们是基于时间反向传播，所以RNN的反向传播有时也叫做BPTT(back-propagation through time)。当然这里的BPTT和DNN也有很大的不同点，即这里所有的$U,W,V,b,c$在序列的各个位置是共享的，反向传播时我们更新的是相同的参数。</p>
<p>为了简化描述，这里的损失函数我们为对数损失函数，输出的激活函数为softmax函数，隐藏层的激活函数为tanh函数。</p>
<p>对于RNN，由于我们在序列的每个位置都有损失函数，因此最终的损失LLL为：<br>$$<br>L = \sum\limits_{t=1}^{\tau}L^{(t)}<br>$$<br>其中$V,c,$的梯度计算是比较简单的：<br>$$<br>\frac{\partial L}{\partial c} = \sum\limits_{t=1}^{\tau}\frac{\partial L^{(t)}}{\partial c} = \sum\limits_{t=1}^{\tau}\frac{\partial L^{(t)}}{\partial o^{(t)}} \frac{\partial o^{(t)}}{\partial c} = \sum\limits_{t=1}^{\tau}\hat{y}^{(t)} - y^{(t)}<br>$$<br>$$<br>\frac{\partial L}{\partial V} =\sum\limits_{t=1}^{\tau}\frac{\partial L^{(t)}}{\partial V} = \sum\limits_{t=1}^{\tau}\frac{\partial L^{(t)}}{\partial o^{(t)}} \frac{\partial o^{(t)}}{\partial V} = \sum\limits_{t=1}^{\tau}(\hat{y}^{(t)} - y^{(t)}) (h^{(t)})^T<br>$$<br>但是$W,U,b$的梯度计算就比较的复杂了。从RNN的模型可以看出，在反向传播时，在在某一序列位置t的梯度损失由当前位置的输出对应的梯度损失和序列索引位置$t+1$时的梯度损失两部分共同决定。对于$W$在某一序列位置t的梯度损失需要反向传播一步步的计算。我们定义序列索引t位置的隐藏状态的梯度为：<br>$$<br>\delta^{(t)} = \frac{\partial L}{\partial h^{(t)}}<br>$$<br>这样我们可以像DNN一样从$\delta^{(t+1)} $递推$\delta^{(t)} $。<br>$$<br>\delta^{(t)} =\frac{\partial L}{\partial o^{(t)}} \frac{\partial o^{(t)}}{\partial h^{(t)}} + \frac{\partial L}{\partial h^{(t+1)}}\frac{\partial h^{(t+1)}}{\partial h^{(t)}} = V^T(\hat{y}^{(t)} - y^{(t)}) + W^T\delta^{(t+1)}diag(1-(h^{(t+1)})^2)<br>$$<br>对于$\delta^{(\tau)} $，由于它的后面没有其他的序列索引了，因此有：<br>$$<br>\delta^{(\tau)} =\frac{\partial L}{\partial o^{(\tau)}} \frac{\partial o^{(\tau)}}{\partial h^{(\tau)}} = V^T(\hat{y}^{(\tau)} - y^{(\tau)})<br>$$<br>有了$\delta^{(t)} $,计算$W,U,b$就容易了，这里给出$W,U,b$的梯度计算表达式：<br>$$<br>\frac{\partial L}{\partial W} =  \sum\limits_{t=1}^{\tau}\frac{\partial L}{\partial h^{(t)}} \frac{\partial h^{(t)}}{\partial W} = \sum\limits_{t=1}^{\tau}diag(1-(h^{(t)})^2)\delta^{(t)}(h^{(t-1)})^T<br>$$<br>$$<br>\frac{\partial L}{\partial b}= \sum\limits_{t=1}^{\tau}\frac{\partial L}{\partial h^{(t)}} \frac{\partial h^{(t)}}{\partial b} = \sum\limits_{t=1}^{\tau}diag(1-(h^{(t)})^2)\delta^{(t)}<br>$$<br>$$<br>\frac{\partial L}{\partial U} = \sum\limits_{t=1}^{\tau}\frac{\partial L}{\partial h^{(t)}} \frac{\partial h^{(t)}}{\partial U} = \sum\limits_{t=1}^{\tau}diag(1-(h^{(t)})^2)\delta^{(t)}(x^{(t)})^T<br>$$<br>除了梯度表达式不同，RNN的反向传播算法和DNN区别不大，因此这里就不再重复总结了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="5-RNN小结"><a href="#5-RNN小结" class="headerlink" title="5. RNN小结"></a>5. RNN小结</h3><p>上面总结了通用的RNN模型和前向反向传播算法。当然，有些RNN模型会有些不同，自然前向反向传播的公式会有些不一样，但是原理基本类似。</p>
<p>RNN虽然理论上可以很漂亮的解决序列数据的训练，但是它也像DNN一样有梯度消失时的问题，当序列很长的时候问题尤其严重。因此，上面的RNN模型一般不能直接用于应用领域。在语音识别，手写书别以及机器翻译等NLP领域实际应用比较广泛的是基于RNN模型的一个特例LSTM，下一篇我们就来讨论LSTM模型。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>1） <a href="http://neuralnetworksanddeeplearning.com/index.html" target="_blank" rel="noopener">Neural Networks and Deep Learning</a> by By Michael Nielsen</p>
<p>2） <a href="http://www.deeplearningbook.org/" target="_blank" rel="noopener">Deep Learning</a>, book by Ian Goodfellow, Yoshua Bengio, and Aaron Courville</p>
<p>3） <a href="http://ufldl.stanford.edu/tutorial/" target="_blank" rel="noopener">UFLDL Tutorial</a> </p>
<p>4）<a href="http://cs231n.github.io/convolutional-networks/" target="_blank" rel="noopener">CS231n Convolutional Neural Networks for Visual Recognition, Stanford</a> </p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[论文笔记之CRNN(Convolutional Recurrent Neural Network)]]></title>
      <url>/CRNN-Convolutional-Recurrent-Neural-Network-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="【论文信息】"><a href="#【论文信息】" class="headerlink" title="【论文信息】"></a>【论文信息】</h3><p>《Convolutional Recurrent Neural Network》2015</p>
<p>该论文全称《An End-to-End Trainable Neural Network for Image-based Sequence Recognition and Its Application to Scene Text Recognition》，提出的CRNN模型，是目前比较经典的文字识别模型，主要记录以下几方面：</p>
<ul>
<li>概述</li>
<li>网络结构</li>
<li>实验相关</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>本文提出CRNN模型，即将CNN与RNN网络结合，共同训练，在一定程度上实现end-to-end文字检测和识别。说一定程度是因为虽然输入图像不需要精确给出每个字符的位置信息，但实际上还是需要对原始的图像进行前期的裁切工作。</p>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>CRNN的网络结构包括三个组成部分：卷积层、循环层和转录层。如下图所示： </p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqffmslj6jj30jf0ly0ts.jpg" alt=""></p>
<p>卷积层从输入图像中得到一组feature maps，再以feature sequence的形式输出，来作为循环层的输入。其中所有输入图像归一化至同一高度（本文实验为32 pixels），每个feature map的第i栏串联为feature sequence的第i个vector，即第i帧，每个vector对应一个纤维，代表了局部特征的深度。</p>
<p>循环层中采用deep双向lstm模型，如下图所示。LSTM可以将误差差别反向传播到卷积层，从而实现在同一网络中对CNN和RNN的共同训练。并且RNN可以在任意长度的序列上进行学习，优于CNN模型的固定维度。Lstm解决了传统RNN梯度消失的问题，文章堆叠了两个双向lstm，效果更好。循环层的输出为预测的序列结果 $y=<y^1,y^2,...,y^t>$。<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqffnf630rj309w0a2weh.jpg" alt=""></y^1,y^2,...,y^t></p>
<p>转录层是将预测结果转换成label序列，即找到最高概率分布的label序列。此处的概率函数采用CTC算法。实际上，有两个模式的转录层，一个是lexicon-free没有词典的，一个是lexicon-based有词典的。没有词典的转录层直接输出概率最高的label sequence；有词典的转录层需要在词典中查找最像的一个候选文本，采用BK-tree（模糊匹配算法）找到编辑距离（Levenshtein距离）A小于一定数值（本文设定δ=3）的文本作为候选文本，再一一比较编辑距离B（此处的B与前面提到的A不同，A为根据序列与tree的根结点比较的结果而得到的一个范围，B为序列与候选文本的直接编辑距离）找到最后的label sequence。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="实验相关"><a href="#实验相关" class="headerlink" title="实验相关"></a>实验相关</h3><p>训练过程的输入为图像及每个图像对应的label序列，采用随机梯度下降（SGD）法训练目标函数。优化算法采用<a href="">adadelta</a>而不是传统的momentum。实验过程中，采用VGG-veryDeep框架的卷积层，由于text的形状一般为长方形，在第3和第4个max pooling层，采用1*2的window代替原来的正方形window。在第5和第6个卷积层后加入batch nomalization层，使训练加速。</p>
]]></content>
      
        <categories>
            
            <category> 论文笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 论文笔记 </tag>
            
            <tag> OCR </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CNN卷积神经网络的反向传播算法]]></title>
      <url>/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="http://pancakeawesome.ink/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84.html">CNN卷积神经网络的模型结构</a></li>
<li><a href="http://pancakeawesome.ink/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95.html">CNN卷积神经网络的前向传播算法</a></li>
<li><a href="http://pancakeawesome.ink/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95.html">CNN卷积神经网络的反向传播算法</a></li>
</ul>
<p>在<a href="http://pancakeawesome.ink/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95.html">卷积神经网络(CNN)前向传播算法</a> 中，我们对CNN的前向传播算法做了总结，基于CNN前向传播算法的基础，我们下面就对CNN的反向传播算法做一个总结。在阅读本文前，建议先研究DNN的反向传播算法：<a href="http://pancakeawesome.ink/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C(DNN)%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95(BP).html">深度神经网络（DNN）反向传播算法(BP)</a></p>
<h2 id="CNN卷积神经网络反向传播算法"><a href="#CNN卷积神经网络反向传播算法" class="headerlink" title="CNN卷积神经网络反向传播算法"></a>CNN卷积神经网络反向传播算法</h2><h3 id="1-回顾DNN的反向传播算法"><a href="#1-回顾DNN的反向传播算法" class="headerlink" title="1. 回顾DNN的反向传播算法"></a>1. 回顾DNN的反向传播算法</h3><p>我们首先回顾DNN的反向传播算法。在DNN中，我们是首先计算出输出层的$\delta^L$:<br>$$<br>\delta^L = \frac{\partial J(W,b)}{\partial z^L} = \frac{\partial J(W,b)}{\partial a^L}\odot \sigma^{‘}(z^L)<br>$$<br>利用数学归纳法，用$\delta^{l+1}$的值一步步的向前求出第l层的$\delta^l$，表达式为：<br>$$<br>\delta^{l} = \delta^{l+1}\frac{\partial z^{l+1}}{\partial z^{l}} = (W^{l+1})^T\delta^{l+1}\odot \sigma^{‘}(z^l)<br>$$<br>有了$\delta^l$的表达式，从而求出$W,b$的梯度表达式：<br>$$<br>\frac{\partial J(W,b,x,y)}{\partial b^l} = \frac{\partial J(W,b)}{\partial z^l} \frac{\partial z^l}{\partial b^l} = \delta^{l}<br>$$<br>有了$W,b$梯度表达式，就可以用梯度下降法来优化$W,b$,求出最终的所有$W,b$的值。</p>
<p>现在我们想把同样的思想用到CNN中，很明显，CNN有些不同的地方，不能直接去套用DNN的反向传播算法的公式。</p>
<h3 id="2-CNN的反向传播算法思想"><a href="#2-CNN的反向传播算法思想" class="headerlink" title="2. CNN的反向传播算法思想"></a>2. CNN的反向传播算法思想</h3><p>要套用DNN的反向传播算法到CNN，有几个问题需要解决：</p>
<p>1）池化层没有激活函数，这个问题倒比较好解决，我们可以令池化层的激活函数为$\sigma(z) = z$，即激活后就是自己本身。这样池化层激活函数的导数为1.</p>
<p>2）池化层在前向传播的时候，对输入进行了压缩，那么我们现在需要向前反向推导$\delta^{l-1}$，这个推导方法和DNN完全不同。</p>
<p>3) 卷积层是通过张量卷积，或者说若干个矩阵卷积求和而得的当前层的输出，这和DNN很不相同，DNN的全连接层是直接进行矩阵乘法得到当前层的输出。这样在卷积层反向传播的时候，上一层的$\delta^{l-1}$递推计算方法肯定有所不同。</p>
<p>4）对于卷积层，由于$W$使用的运算是卷积，那么从$\delta^l$推导出该层的所有卷积核的$W,b$的方式也不同。</p>
<p>从上面可以看出，问题1比较好解决，但是问题2,3,4就需要好好的动一番脑筋了，而问题2,3,4也是解决CNN反向传播算法的关键所在。另外大家要注意到的是，DNN中的$a_l,z_l$都只是一个向量，而我们CNN中的$a_l,z_l$都是一个张量，这个张量是三维的，即由若干个输入的子矩阵组成。</p>
<p>下面我们就针对问题2,3,4来一步步研究CNN的反向传播算法。</p>
<p>在研究过程中，需要注意的是，由于卷积层可以有多个卷积核，各个卷积核的处理方法是完全相同且独立的，为了简化算法公式的复杂度，我们下面提到卷积核都是卷积层中若干卷积核中的一个。</p>
<h3 id="3-已知池化层的-delta-l-，推导上一隐藏层的-delta-l-1"><a href="#3-已知池化层的-delta-l-，推导上一隐藏层的-delta-l-1" class="headerlink" title="3. 已知池化层的$\delta^l$，推导上一隐藏层的$\delta^{l-1} $"></a>3. 已知池化层的$\delta^l$，推导上一隐藏层的$\delta^{l-1} $</h3><p>我们首先解决上面的问题2，如果已知池化层的$\delta^l$，推导出上一隐藏层的$\delta^{l-1}$。</p>
<p>在前向传播算法时，池化层一般我们会用MAX或者Average对输入进行池化，池化的区域大小已知。现在我们反过来，要从缩小后的误差$\delta^l$，还原前一次较大区域对应的误差。</p>
<p>在反向传播时，我们首先会把$\delta^l$的所有子矩阵矩阵大小还原成池化之前的大小，然后如果是MAX，则把$\delta^l$的所有子矩阵的各个池化局域的值放在之前做前向传播算法得到最大值的位置。如果是Average，则把$\delta^l$的所有子矩阵的各个池化局域的值取平均后放在还原后的子矩阵位置。这个过程一般叫做upsample。</p>
<p>用一个例子可以很方便的表示：假设我们的池化区域大小是2x2。$\delta^l$的第k个子矩阵为:<br>$$<br>\delta_k^l = \left( \begin{array}{ccc} 2&amp; 8 \\ 4&amp; 6 \end{array} \right)<br>$$<br>由于池化区域为2x2，我们先讲$\delta_k^l$做还原，即变成：<br>$$<br> \left( \begin{array}{ccc} 0&amp;0&amp;0&amp;0 \\ 0&amp;2&amp; 8&amp;0 \\ 0&amp;4&amp;6&amp;0 \\ 0&amp;0&amp;0&amp;0 \end{array} \right)<br>$$<br> 如果是MAX，假设我们之前在前向传播时记录的最大值位置分别是左上，右下，右上，左下，则转换后的矩阵为：<br>$$<br> \left( \begin{array}{ccc} 2&amp;0&amp;0&amp;0 \\ 0&amp;0&amp; 0&amp;8 \\ 0&amp;4&amp;0&amp;0 \\ 0&amp;0&amp;6&amp;0 \end{array} \right)<br>$$<br>如果是Average，则进行平均：转换后的矩阵为：<br>$$<br> \left( \begin{array}{ccc} 0.5&amp;0.5&amp;2&amp;2 \\ 0.5&amp;0.5&amp;2&amp;2 \\ 1&amp;1&amp;1.5&amp;1.5 \\ 1&amp;1&amp;1.5&amp;1.5 \end{array} \right)<br>$$<br>这样我们就得到了上一层 $\frac{\partial J(W,b)}{\partial a_k^{l-1}}$ 的值，要得到$\delta_k^{l-1}$：<br>$$<br>\delta_k^{l-1} = \frac{\partial J(W,b)}{\partial a_k^{l-1}} \frac{\partial  a_k^{l-1}}{\partial z_k^{l-1}} = upsample(\delta_k^l) \odot \sigma^{‘}(z_k^{l-1})<br>$$<br>其中，upsample函数完成了池化误差矩阵放大与误差重新分配的逻辑。</p>
<p>我们概括下，对于张量$\delta^{l-1}$，我们有：<br>$$<br>\delta^{l-1} =  upsample(\delta^l) \odot \sigma^{‘}(z^{l-1})<br>$$</p>
<h3 id="4-已知卷积层的-delta-l-，推导上一隐藏层的-delta-l-1"><a href="#4-已知卷积层的-delta-l-，推导上一隐藏层的-delta-l-1" class="headerlink" title="4. 已知卷积层的$\delta^l$，推导上一隐藏层的$\delta^{l-1} $"></a>4. 已知卷积层的$\delta^l$，推导上一隐藏层的$\delta^{l-1} $</h3><p>对于卷积层的反向传播，我们首先回忆下卷积层的前向传播公式：<br>$$<br>  a^l= \sigma(z^l) = \sigma(a^{l-1}*W^l +b^l)<br>$$<br>其中$n_in$为上一隐藏层的输入子矩阵个数。</p>
<p>在DNN中，我们知道$\delta^{l-1}$和$\delta^{l}$的递推关系为：<br>$$<br>\delta^{l} = \frac{\partial J(W,b)}{\partial z^l} = \frac{\partial J(W,b)}{\partial z^{l+1}}\frac{\partial z^{l+1}}{\partial z^{l}} = \delta^{l+1}\frac{\partial z^{l+1}}{\partial z^{l}}<br>$$<br>因此要推导出$\delta^{l-1}$和$\delta^{l}$的递推关系，必须计算$\frac{\partial z^{l}}{\partial z^{l-1}}$的梯度表达式。</p>
<p>注意到$z^{l}$和$z^{l-1}$的关系为：<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fq8jhcsescj30ai01la9u.jpg" alt=""></p>
<p>因此我们有：<br>$$<br>\delta^{l-1} =  \delta^{l}\frac{\partial z^{l}}{\partial z^{l-1}} = \delta^{l}*rot180(W^{l}) \odot  \sigma^{‘}(z^{l-1})<br>$$</p>
<p>这里的式子其实和DNN的类似，区别在于对于含有卷积的式子求导时，卷积核被旋转了180度。即式子中的$rot180()$，翻转180度的意思是上下翻转一次，接着左右翻转一次。在DNN中这里只是矩阵的转置。那么为什么呢？由于这里都是张量，直接推演参数太多了。我们以一个简单的例子说明为啥这里求导后卷积核要翻转。</p>
<p>假设我们$l-1$层的输出$a^{l-1}$是一个3x3矩阵，第$l$层的卷积核$W^l$是一个2x2矩阵，采用1像素的步幅，则输出$z^{l}$是一个2x2的矩阵。我们简化$b^l$都是0,则有<br>$$<br>a^{l-1}*W^l = z^{l}<br>$$</p>
<p>我们列出$a,W,z$的矩阵表达式如下：</p>
<p>$$<br> \left( \begin{array}{ccc} a_{11}&amp;a_{12}&amp;a_{13} \\ a_{21}&amp;a_{22}&amp;a_{23}\\ a_{31}&amp;a_{32}&amp;a_{33} \end{array} \right)    *  \left( \begin{array}{ccc} w_{11}&amp;w_{12}\\ w_{21}&amp;w_{22} \end{array} \right) = \left( \begin{array}{ccc} z_{11}&amp;z_{12}\\ z_{21}&amp;z_{22} \end{array} \right)<br>$$<br>利用卷积的定义，很容易得出：<br>$$<br>z_{11} = a_{11}w_{11} + a_{12}w_{12} + a_{21}w_{21} +   a_{22}w_{22}<br>$$<br>$$<br>z_{12} = a_{12}w_{11} + a_{13}w_{12} + a_{22}w_{21} +   a_{23}w_{22}<br>$$<br>$$<br>z_{21} = a_{21}w_{11} + a_{22}w_{12} + a_{31}w_{21} +   a_{32}w_{22}<br>$$<br>$$<br>z_{22} = a_{22}w_{11} + a_{23}w_{12} + a_{32}w_{21} +   a_{33}w_{22}<br>$$<br>接着我们模拟反向求导：<br>$$<br>\nabla a^{l-1} = \frac{\partial J(W,b)}{\partial a^{l-1}} = \frac{\partial J(W,b)}{\partial z^{l}} \frac{\partial z^{l}}{\partial a^{l-1}} = \delta^{l} \frac{\partial z^{l}}{\partial a^{l-1}}<br>$$<br>从上式可以看出，对于$a^{l-1}$的梯度误差$\nabla a^{l-1}$，等于第$l$层的梯度误差乘以$\frac{\partial z^{l}}{\partial a^{l-1}}$，而$\frac{\partial z^{l}}{\partial a^{l-1}}$对应上面的例子中相关联的$w$的值。假设我们的$z$矩阵对应的反向传播误差是$\delta_{11}, \delta_{12}, \delta_{21}, \delta_{22}$组成的2x2矩阵，则利用上面梯度的式子和4个等式，我们可以分别写出$\nabla a^{l-1}$的9个标量的梯度。</p>
<p>比如对于$a_{11}$的梯度，由于在4个等式中$a_{11}$只和$z_{11}$有乘积关系，从而我们有：<br>$$<br> \nabla a_{11} = \delta_{11}w_{11}<br>$$<br>对于$a_{12}$的梯度，由于在4个等式中$a_{12}$和$z_{12}，z_{11}$有乘积关系，从而我们有：<br>$$<br> \nabla a_{12} = \delta_{11}w_{12} + \delta_{12}w_{11}<br>$$<br>同样的道理我们得到：<br>$$<br> \nabla a_{13} = \delta_{12}w_{12}<br> $$<br>$$<br>\nabla a_{21} = \delta_{11}w_{21} + \delta_{21}w_{11}<br>$$<br>$$<br>\nabla a_{22} = \delta_{11}w_{22} + \delta_{12}w_{21} + \delta_{21}w_{12} + \delta_{22}w_{11}<br>$$<br>$$<br> \nabla a_{23} = \delta_{12}w_{22} + \delta_{22}w_{12}<br> $$<br>$$<br> \nabla a_{31} = \delta_{21}w_{21}<br> $$<br>$$<br> \nabla a_{32} = \delta_{21}w_{22} + \delta_{22}w_{21}<br> $$<br>$$<br> \nabla a_{33} = \delta_{22}w_{22}<br>$$<br>这上面9个式子其实可以用一个矩阵卷积的形式表示，即：<br>$$<br> \left( \begin{array}{ccc} 0&amp;0&amp;0&amp;0 \\ 0&amp;\delta_{11}&amp; \delta_{12}&amp;0 \\ 0&amp;\delta_{21}&amp;\delta_{22}&amp;0 \\ 0&amp;0&amp;0&amp;0 \end{array} \right) * \left( \begin{array}{ccc} w_{22}&amp;w_{21}\\ w_{12}&amp;w_{11} \end{array} \right)  = \left( \begin{array}{ccc} \nabla a_{11}&amp;\nabla a_{12}&amp;\nabla a_{13} \\ \nabla a_{21}&amp;\nabla a_{22}&amp;\nabla a_{23}\\ \nabla a_{31}&amp;\nabla a_{32}&amp;\nabla a_{33} \end{array} \right)<br>$$<br> 为了符合梯度计算，我们在误差矩阵周围填充了一圈0，此时我们将卷积核翻转后和反向传播的梯度误差进行卷积，就得到了前一次的梯度误差。这个例子直观的介绍了为什么对含有卷积的式子求导时，卷积核要翻转180度的原因。</p>
<p>以上就是卷积层的误差反向传播过程。</p>
<h3 id="5-已知卷积层的-delta-l-，推导该层的-W-b-的梯度"><a href="#5-已知卷积层的-delta-l-，推导该层的-W-b-的梯度" class="headerlink" title="5. 已知卷积层的$\delta^l$，推导该层的$W,b$的梯度"></a>5. 已知卷积层的$\delta^l$，推导该层的$W,b$的梯度</h3><p>好了，我们现在已经可以递推出每一层的梯度误差$\delta^l$了，对于全连接层，可以按DNN的反向传播算法求该层$W,b$的梯度，而池化层并没有$W,b$,也不用求$W,b$的梯度。只有卷积层的$W,b$需要求出。</p>
<p>注意到卷积层$z$和$W,b$的关系为：<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fq8ju8b1xuj306k01rjr5.jpg" alt=""></p>
<p>因此我们有：<br>$$<br>\frac{\partial J(W,b)}{\partial W^{l}} = \frac{\partial J(W,b)}{\partial z^{l}}\frac{\partial z^{l}}{\partial W^{l}} =\delta^l*rot180(a^{l-1})<br>$$<br>由于我们有上一节的基础，大家应该清楚为什么这里求导后要旋转180度了。</p>
<p>而对于b,则稍微有些特殊，因为$\delta^l$是三维张量，而$b$只是一个向量，不能像DNN那样直接和$\delta^l$相等。通常的做法是将$\delta^l$的各个子矩阵的项分别求和，得到一个误差向量，即为bbb的梯度：<br>$$<br>\frac{\partial J(W,b)}{\partial b^{l}} = \sum\limits_{u,v}(\delta^l)_{u,v}<br>$$</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="6-CNN反向传播算法总结"><a href="#6-CNN反向传播算法总结" class="headerlink" title="6. CNN反向传播算法总结"></a>6. CNN反向传播算法总结</h3><p>现在我们总结下CNN的反向传播算法，以最基本的批量梯度下降法为例来描述反向传播算法。</p>
<p>输入：m个图片样本，CNN模型的层数L和所有隐藏层的类型，对于卷积层，要定义卷积核的大小K，卷积核子矩阵的维度F，填充大小P，步幅S。对于池化层，要定义池化区域大小k和池化标准（MAX或Average），对于全连接层，要定义全连接层的激活函数（输出层除外）和各层的神经元个数。梯度迭代参数迭代步长$\alpha$,最大迭代次数MAX与停止迭代阈值$\epsilon$</p>
<p>输出：CNN模型各隐藏层与输出层的$W,b$</p>
<p>1) 初始化各隐藏层与输出层的各$W,b$的值为一个随机值。</p>
<p>   2）for iter to 1 to MAX：</p>
<p>   2-1) for i =1 to m：</p>
<p>　　a) 将CNN输入$a^1$设置为$x_i$对应的张量</p>
<p>　　b) for $l$=2 to L-1，根据下面3种情况进行前向传播算法计算：</p>
<p>　　b-1) 如果当前是全连接层：则有$a^{i,l} = \sigma(z^{i,l}) = \sigma(W^la^{i,l-1} + b^{l})$</p>
<p>　　b-2) 如果当前是卷积层：则有$a^{i,l} = \sigma(z^{i,l}) = \sigma(W^l*a^{i,l-1} + b^{l})$</p>
<p>　　b-3) 如果当前是池化层：则有$a^{i,l}= pool(a^{i,l-1})$, 这里的pool指按照池化区域大小k和池化标准将输入张量缩小的过程。</p>
<p>　　c) 对于输出层第L层: $a^{i,L}= softmax(z^{i,L}) = softmax(W^{L}a^{i,L-1} +b^{L})$</p>
<p>　　c) 通过损失函数计算输出层的$\delta^{i,L}$</p>
<p>　　d) for $l$= L-1 to 2, 根据下面3种情况进行进行反向传播算法计算:</p>
<p>　　   d-1)  如果当前是全连接层：$\delta^{i,l} =  (W^{l+1})^T\delta^{i,l+1}\odot \sigma^{‘}(z^{i,l})$</p>
<p>　　   d-2) 如果当前是卷积层：$\delta^{i,l} = \delta^{i,l+1}*rot180(W^{l+1}) \odot  \sigma^{‘}(z^{i,l}) $</p>
<p>　　   d-3) 如果当前是池化层：$\delta^{i,l} =  upsample(\delta^{i,l+1}) \odot \sigma^{‘}(z^{i,l})$</p>
<p>2-2) for $l$ = 2 to L，根据下面2种情况更新第$l$层的$W^l,b^l$:</p>
<p>   2-2-1) 如果当前是全连接层：$W^l = W^l -\alpha \sum\limits_{i=1}^m \delta^{i,l}(a^{i, l-1})^T ，b^l = b^l -\alpha \sum\limits_{i=1}^m \delta^{i,l}$</p>
<p>　　2-2-2) 如果当前是卷积层，对于每一个卷积核有：$\delta^{i,l}*rot180(a^{i, l-1}) ， b^l = b^l -\alpha \sum\limits_{i=1}^m \sum\limits_{u,v}(\delta^{i,l})_{u,v}$</p>
<p>   2-3) 如果所有$W，b$的变化值都小于停止迭代阈值$\epsilon$，则跳出迭代循环到步骤3。</p>
<p>3） 输出各隐藏层与输出层的线性关系系数矩阵$W$和偏倚向量$b$。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>1） <a href="http://neuralnetworksanddeeplearning.com/index.html" target="_blank" rel="noopener">Neural Networks and Deep Learning</a> by By Michael Nielsen</p>
<p>2） <a href="http://www.deeplearningbook.org/" target="_blank" rel="noopener">Deep Learning</a>, book by Ian Goodfellow, Yoshua Bengio, and Aaron Courville</p>
<p>3） <a href="http://ufldl.stanford.edu/tutorial/" target="_blank" rel="noopener">UFLDL Tutorial</a> </p>
<p>4）<a href="http://cs231n.github.io/convolutional-networks/" target="_blank" rel="noopener">CS231n Convolutional Neural Networks for Visual Recognition, Stanford</a> </p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CNN卷积神经网络的前向传播算法]]></title>
      <url>/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="http://pancakeawesome.ink/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84.html">CNN卷积神经网络的模型结构</a></li>
<li><a href="http://pancakeawesome.ink/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95.html">CNN卷积神经网络的前向传播算法</a></li>
<li><a href="http://pancakeawesome.ink/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95.html">CNN卷积神经网络的反向传播算法</a></li>
</ul>
<p>在<a href="hhttp://pancakeawesome.ink/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84.html">卷积神经网络(CNN)模型结构</a> 中，我们对CNN的模型结构做了总结，这里我们就在CNN的模型基础上，看看CNN的前向传播算法是什么样子的。重点会和传统的DNN比较讨论。</p>
<h2 id="卷积神经网络-CNN-前向传播算法"><a href="#卷积神经网络-CNN-前向传播算法" class="headerlink" title="卷积神经网络(CNN)前向传播算法"></a>卷积神经网络(CNN)前向传播算法</h2><h3 id="1-回顾CNN的结构"><a href="#1-回顾CNN的结构" class="headerlink" title="1. 回顾CNN的结构"></a>1. 回顾CNN的结构</h3><p>在上一篇里，我们已经讲到了CNN的结构，包括输出层，若干的卷积层+ReLU激活函数，若干的池化层，DNN全连接层，以及最后的用Softmax激活函数的输出层。这里我们用一个彩色的汽车样本的图像识别再从感官上回顾下CNN的结构。图中的CONV即为卷积层，POOL即为池化层，而FC即为DNN全连接层，包括了我们上面最后的用Softmax激活函数的输出层。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fq8ipvatsvj30yv0gpwgq.jpg" alt=""></p>
<p>从上图可以看出，要理顺CNN的前向传播算法，重点是输入层的前向传播，卷积层的前向传播以及池化层的前向传播。而DNN全连接层和用Softmax激活函数的输出层的前向传播算法我们在讲DNN时已经讲到了。</p>
<h3 id="2-CNN输入层前向传播到卷积层"><a href="#2-CNN输入层前向传播到卷积层" class="headerlink" title="2. CNN输入层前向传播到卷积层"></a>2. CNN输入层前向传播到卷积层</h3><p>输入层的前向传播是CNN前向传播算法的第一步。一般输入层对应的都是卷积层，因此我们标题是输入层前向传播到卷积层。</p>
<p>我们这里还是以图像识别为例。</p>
<p>先考虑最简单的，样本都是二维的黑白图片。这样输入层$X$就是一个矩阵，矩阵的值等于图片的各个像素位置的值。这时和卷积层相连的卷积核$W$就也是矩阵。</p>
<p>如果样本都是有RGB的彩色图片，这样输入$X$就是3个矩阵，即分别对应R，G和B的矩阵，或者说是一个张量。这时和卷积层相连的卷积核$W$就也是张量，对应的最后一维的维度为3.即每个卷积核都是3个子矩阵组成。</p>
<p>同样的方法，对于3D的彩色图片之类的样本，我们的输入$X$可以是4维，5维的张量，那么对应的卷积核$W$也是个高维的张量。</p>
<p>不管维度多高，对于我们的输入，前向传播的过程可以表示为：<br>$$<br> a^2= \sigma(z^2) = \sigma(a^1*W^2 +b^2)<br>$$<br>其中，上标代表层数，星号代表卷积，而b代表我们的偏倚, $\sigma$为激活函数，这里一般都是ReLU。</p>
<p>和DNN的前向传播比较一下，其实形式非常的像，只是我们这儿是张量的卷积，而不是矩阵的乘法。同时由于$W$是张量，那么同样的位置，$W$参数的个数就比DNN多很多了。</p>
<p>为了简化我们的描述，本文后面如果没有特殊说明，我们都默认输入是3维的张量，即用RBG可以表示的彩色图片。</p>
<p>这里需要我们自己定义的CNN模型参数是：</p>
<p>1） 一般我们的卷积核不止一个，比如有K个，那么我们输入层的输出，或者说第二层卷积层的对应的输入就K个。</p>
<p>2） 卷积核中每个子矩阵的的大小，一般我们都用子矩阵为方阵的卷积核，比如FxF的子矩阵。</p>
<p>3） 填充padding（以下简称P），我们卷积的时候，为了可以更好的识别边缘，一般都会在输入矩阵在周围加上若干圈的0再进行卷积，加多少圈则P为多少。</p>
<p>4） 步幅stride（以下简称S），即在卷积过程中每次移动的像素距离大小。</p>
<p>这些参数我们在上一篇都有讲述。</p>
<h3 id="3-隐藏层前向传播到卷积层"><a href="#3-隐藏层前向传播到卷积层" class="headerlink" title="3. 隐藏层前向传播到卷积层"></a>3. 隐藏层前向传播到卷积层</h3><p>现在我们再来看普通隐藏层前向传播到卷积层时的前向传播算法。</p>
<p>假设隐藏层的输出是M个矩阵对应的三维张量，则输出到卷积层的卷积核也是M个子矩阵对应的三维张量。这时表达式和输入层的很像，也是<br>$$<br> a^l= \sigma(z^l) = \sigma(a^{l-1}*W^l +b^l)<br>$$<br>其中，上标代表层数，星号代表卷积，而b代表我们的偏倚, σσ\sigma为激活函数，这里一般都是ReLU。</p>
<p>也可以写成M个子矩阵子矩阵卷积后对应位置相加的形式，即：<br>$$<br> a^l= \sigma(z^l) = \sigma(\sum\limits_{k=1}^{M}z_k^l) = \sigma(\sum\limits_{k=1}^{M}a_k^{l-1}*W_k^l +b^l)<br>$$<br>和上一节唯一的区别仅仅在于，这里的输入是隐藏层来的，而不是我们输入的原始图片样本形成的矩阵。</p>
<p>需要我们定义的CNN模型参数也和上一节一样，这里我们需要定义卷积核的个数K，卷积核子矩阵的维度F，填充大小P以及步幅S。</p>
<h3 id="4-隐藏层前向传播到池化层"><a href="#4-隐藏层前向传播到池化层" class="headerlink" title="4. 隐藏层前向传播到池化层"></a>4. 隐藏层前向传播到池化层</h3><p>池化层的处理逻辑是比较简单的，我们的目的就是对输入的矩阵进行缩小概括。比如输入的若干矩阵是NxN维的，而我们的池化大小是kxk的区域，则输出的矩阵都是$\frac{N}{k} \times \frac{N}{k}$维的。</p>
<p>这里需要需要我们定义的CNN模型参数是：</p>
<p>1）池化区域的大小k</p>
<p>2）池化的标准，一般是MAX或者Average。</p>
<h3 id="5-隐藏层前向传播到全连接层"><a href="#5-隐藏层前向传播到全连接层" class="headerlink" title="5. 隐藏层前向传播到全连接层"></a>5. 隐藏层前向传播到全连接层</h3><p>由于全连接层就是普通的DNN模型结构，因此我们可以直接使用DNN的前向传播算法逻辑，即：<br>$$<br>a^l = \sigma(z^l) = \sigma(W^la^{l-1} + b^l)<br>$$<br>这里的激活函数一般是sigmoid或者tanh。</p>
<p>经过了若干全连接层之后，最后的一层为Softmax输出层。此时输出层和普通的全连接层唯一的区别是，激活函数是softmax函数。</p>
<p>这里需要需要我们定义的CNN模型参数是：</p>
<p>1）全连接层的激活函数</p>
<p>2）全连接层各层神经元的个数</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="6-CNN前向传播算法小结"><a href="#6-CNN前向传播算法小结" class="headerlink" title="6. CNN前向传播算法小结"></a>6. CNN前向传播算法小结</h3><p>有了上面的基础，我们现在总结下CNN的前向传播算法。</p>
<p>输入：1个图片样本，CNN模型的层数L和所有隐藏层的类型，对于卷积层，要定义卷积核的大小K，卷积核子矩阵的维度F，填充大小P，步幅S。对于池化层，要定义池化区域大小k和池化标准（MAX或Average），对于全连接层，要定义全连接层的激活函数（输出层除外）和各层的神经元个数。</p>
<p>输出：CNN模型的输出$a^L$</p>
<p>1) 根据输入层的填充大小P，填充原始图片的边缘，得到输入张量$a^1$。</p>
<p>2）初始化所有隐藏层的参数$W,b$</p>
<p>3）for $l$=2 to $L-1$:</p>
<p>　　a) 如果第$l$层是卷积层,则输出为<br>$$<br> a^l= ReLU(z^l) = ReLU(a^{l-1}*W^l +b^l)<br>$$<br>　　b) 如果第$l$层是池化层,则输出为$ a^l= pool(a^{l-1})$, 这里的pool指按照池化区域大小k和池化标准将输入张量缩小的过程。<br>　　c) 如果第$l$层是全连接层,则输出为<br>$$<br> a^l= \sigma(z^l) = \sigma(W^la^{l-1} +b^l)<br>$$<br>4)对于输出层第L层:<br>$$<br> a^L= softmax(z^L) = softmax(W^La^{L-1} +b^L)<br>$$<br>以上就是CNN前向传播算法的过程总结。有了CNN前向传播算法的基础，我们后面再来理解CNN的反向传播算法就简单多了。下一篇我们来讨论CNN的反向传播算法。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>1） <a href="http://neuralnetworksanddeeplearning.com/index.html" target="_blank" rel="noopener">Neural Networks and Deep Learning</a> by By Michael Nielsen</p>
<p>2） <a href="http://www.deeplearningbook.org/" target="_blank" rel="noopener">Deep Learning</a>, book by Ian Goodfellow, Yoshua Bengio, and Aaron Courville</p>
<p>3） <a href="http://ufldl.stanford.edu/tutorial/" target="_blank" rel="noopener">UFLDL Tutorial</a> </p>
<p>4）<a href="http://cs231n.github.io/convolutional-networks/" target="_blank" rel="noopener">CS231n Convolutional Neural Networks for Visual Recognition, Stanford</a> </p>
<h2 id="后记-1"><a href="#后记-1" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[论文笔记之Fully Convolutional Networks for Semantic Segmentation]]></title>
      <url>/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E4%B9%8BFully-Convolutional-Networks-for-Semantic-Segmentation.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="【论文信息】"><a href="#【论文信息】" class="headerlink" title="【论文信息】"></a>【论文信息】</h3><p>《Fully Convolutional Networks for Semantic Segmentation》<br>CVPR 2015 best paper<br>原文<a href="https://arxiv.org/abs/1411.4038" target="_blank" rel="noopener">链接</a><br>概览&amp;主要贡献<br>这篇论文是2015cvpr的best paper，可以说是在cnn上做图像语义分割的开山之作。<br>提出了一种end-to-end的做semantic segmentation的方法，简称FCN。<br>如下图所示，直接拿segmentation 的 ground truth作为监督信息，训练一个端到端的网络，让网络做pixelwise的prediction，直接预测label map。</p>
<p>(自己类比思想:faster rcnn中的rbn-&gt;(fc-&gt;region proposal) label map-&gt; fast-rcnn for fine tuning)</p>
<h3 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h3><p>语义就是指物体的类别，即属于同一类别的物体都算作一类</p>
<p>比如图像中的3个人算作一类，5辆汽车算作一类等，它们都属于同一类别，即“人类”、“汽车”</p>
<p>一般规定要进行分割的n个类别的物体（即我们重点关注的一些物体），剩余物体属于背景类别。所以一共有n+1个类别</p>
<p>语义分割就是对“每个像素点进行分类”，即每个像素点属于n+1个类别中的某一类。比如：Image中所有的人的像素点都属于“人”这个类别，所有的汽车的像素点都属于“汽车”这个类别。</p>
<p>在这里需要区别的两种分割任务：<br>semantic segmentation - 只标记语义。下图中。<br>instance segmentation - 标记实例和语义。下图右。<br>本文研究第一种：语义分割<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fq66qm9r5fj30p805xabd.jpg" alt=""></p>
<h2 id="【方法简介】"><a href="#【方法简介】" class="headerlink" title="【方法简介】"></a>【方法简介】</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>将vgg，alexnet或者GoogLeNet等训练好的网络的最后几层全连接层改成全卷积层，再做反卷积，得到一个与输入大小一样的map，在这张map上做pixelwise classification。拿segmentation 的 ground truth作为监督信息，进行训练。<br>如图所示：<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fq53vawh0tj30dl08tt93.jpg" alt=""></p>
<p>主要思路是把CNN改为FCN，输入一幅图像后直接在输出端得到dense prediction，也就是每个像素所属的class，从而得到一个end-to-end的方法来实现image  semantic segmentation。    </p>
<p>我们已经有一个CNN模型，首先要把CNN的全连接层看成是卷积层，卷积模板大小就是输入的特征map的大小，也就是说把全连接网络看成是对整张输入map做卷积，全连接层分别有4096个6<em>6的卷积核，4096个1</em>1的卷积核，1000个1<em>1的卷积核，如下图：<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fq53vpzavxj30ln0c9dgt.jpg" alt=""><br>接下来就要对这1000个1</em>1的输出，做upsampling，得到1000个原图大小（如32*32）的输出，这些输出合并后，得到上图所示的heatmap。</p>
<h4 id="主要就是以下几个内容："><a href="#主要就是以下几个内容：" class="headerlink" title="主要就是以下几个内容："></a>主要就是以下几个内容：</h4><p>1.拿vgg或者其他现有的训练好的模型进行fine-tune<br>2.将最后2层的全连接层全部改成卷积核为1<em>1 全卷积层，channel数为对应总共的类别数+1（背景）<br>3.对最后一层1</em>1的全卷积层的输出进行deconvolution，输出与原图大小一样的map，便于对每个peixl 进行classification。deconvolution时使用<a href="https://blog.csdn.net/u011771047/article/details/72872742" target="_blank" rel="noopener">双线性插值</a>来初始化“转置卷积核”，学习率为0<br>4.增加了skip Architecture，增加前面pool层的信息进去，论文实验分别对1个pool，2个pool，3个pool进行实验，分别对应fcn-32s,fcn-16s,fcn-8s,实验证明加入3个pool效果最好。称为fcn-8s 8指的是568/70=8</p>
<blockquote>
<p>线性插值法利用原图像中两个点计算像素值进行插值，双线性插值法利用原图像中四个点计算目标像素值进行插值</p>
</blockquote>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fq53ycl3mlj30tv07hgma.jpg" alt=""></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fq6rwk265ij30u50ckdi4.jpg" alt=""><br>如图所示<br>1）原始图像是$500*500$，为了使最后的输出为能够得到一个更大的feature图，便于deconvolution，因此人为的在原图上加了padding=100，（这样的做法略显粗糙，以后 改变stride+hole算法可以解决）</p>
<p>2.）pool5之前就是纯粹的vgg网络</p>
<p>3）pool5之后将原来的两个4096的全连接层，改成$1<em>1$的卷积核生成的$16</em>16*4096$的map，channel数量为4096</p>
<p>4）对于最后一个$16<em>16</em>4096$的在用一个$1<em>1$的卷积核去卷积，channel=21 得到$16</em>16*21$的map，称为coarse score map1</p>
<p>5）coarse score map1进行反卷积（bilinear插值上采样）得到$34<em>34</em>21$的map</p>
<p>6）同时pool4层也通过$1<em>1$的卷积变成$x4</em>x4<em>21$的map再通过crop变成$34</em>34*21$的map，称为coarse score map2</p>
<p>7）将第5步和第六步的map对应叠加，再进行反卷积（bilinear插值上采样）得到$70<em>70</em>21$的map<br>8）同理对pool3进行操作得到$70<em>70</em>21$的map与第七步的叠加，再进行反卷积（bilinear插值上采样）得到$568<em>568</em>21$的map</p>
<p>9）最后对$568<em>568</em>21$的map进行crop，变成$500<em>500$的图片，然后进行peixl classification ，总共$500</em>500$个像素，每个像素有21个值分别表示为对应类别的概率，取至最大的概率对应的类别作为这个像素的类别即可</p>
<h2 id="【细节记录】"><a href="#【细节记录】" class="headerlink" title="【细节记录】"></a>【细节记录】</h2><h3 id="dense-prediction"><a href="#dense-prediction" class="headerlink" title="dense prediction"></a>dense prediction</h3><p>这里通过upsampling得到dense prediction，作者研究过3种方案：</p>
<ul>
<li>shift-and-stitch：设原图与FCN所得输出图之间的降采样因子是f，那么对于原图的每个f<em>f的区域（不重叠），“shift the input x pixels to the right and y pixels down for every (x,y) ,0 &lt; x,y &lt; f.” 把这个f</em>f区域对应的output作为此时区域中心点像素对应的output，这样就对每个f*f的区域得到了$f^2$个output，也就是每个像素都能对应一个output，所以成为了dense prediction。</li>
<li>filter rarefaction：就是放大CNN网络中的subsampling层的filter的尺寸，得到新的filter：<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fq53xbeinvj30bn02d0sk.jpg" alt=""><br>其中s是subsampling的滑动步长，这个新filter的滑动步长要设为1，这样的话，subsampling就没有缩小图像尺寸，最后可以得到dense prediction。<br>以上两种方法作者都没有采用，主要是因为这两种方法都是trad-off的，原因是：<br>对于第二种方法， 下采样的功能被减弱，使得更细节的信息能被filter看到，但是receptive fileds会相对变小，可能会损失全局信息，且会对卷积层引入更多运算。<br>对于第一种方法，虽然receptive fileds没有变小，但是由于原图被划分成f*f的区域输入网络，使得filters无法感受更精细的信息。</li>
<li>重点方法:反卷积</li>
</ul>
<p>反卷积层-&gt;pixel wise-&gt;bp parameters-&gt;实现把conv的前传和反传过程对调一下即可</p>
<p>这里upsampling的操作可以看成是反卷积(deconvolutional)具体方法：<a href="https://blog.csdn.net/kekong0713/article/details/68941498" target="_blank" rel="noopener">反卷积详解</a></p>
<ul>
<li><p>卷积stride=1<br><img src="http://ww4.sinaimg.cn/large/8c2b2f6fjw1f99j2k89hlg209k0aq41i.gif" alt=""></p>
</li>
<li><p>卷积stride&gt;2</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/8c2b2f6fjw1f9aba7bh2ig20az0chwjq.gif" alt=""></p>
<blockquote>
<p>这里反卷积的操作用到了<a href="https://blog.csdn.net/u011771047/article/details/72872742" target="_blank" rel="noopener">双线性插值的</a>技巧。</p>
</blockquote>
<h3 id="fusion-prediction"><a href="#fusion-prediction" class="headerlink" title="fusion prediction"></a>fusion prediction</h3><p>以上是对CNN的结果做处理，得到了dense prediction，而作者在试验中发现，得到的分割结果比较粗糙，所以考虑加入更多前层的细节信息，也就是把倒数第几层的输出和最后的输出做一个fusion，实际上也就是加和：<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fq66mciuvqj30lg094gm9.jpg" alt=""><br>这样就得到第二行和第三行的结果，实验表明，这样的分割结果更细致更准确。在逐层fusion的过程中，做到第三行再往下，结果又会变差，所以作者做到这里就停了。可以看到如上三行的对应的结果：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fq53xsnvvoj30en067mxk.jpg" alt=""><br>问题&amp;解决办法</p>
<p>1.如何做pixelwise的prediction？</p>
<p>传统的网络是subsampling的，对应的输出尺寸会降低，要想做pixelwiseprediction，必须保证输出尺寸。<br>解决办法：<br>（1）对传统网络如AlexNet，VGG等的最后全连接层变成卷积层。<br>例如VGG16中第一个全连接层是25088x4096的，将之解释为512x7x7x4096的卷积核，则如果在一个更大的输入图像上进行卷积操作（上图的下半部分），原来输出4096维feature的节点处（上图的上半部分），就会输出一个coarsefeature map。<br>这样做的好处是，能够很好的利用已经训练好的supervisedpre-training的网络，不用像已有的方法那样，从头到尾训练，只需要fine-tuning即可，训练efficient。<br>（2）加In-network upsampling layer。<br>对中间得到的featuremap做bilinear上采样，就是反卷积层。实现把conv的前传和反传过程对调一下即可。</p>
<p>2.如何refine，得到更好的结果？</p>
<p>upsampling中步长是32，输入为3x500x500的时候，输出是544x544，边缘很不好，并且limit thescale of detail of the upsampling output。<br>解决办法：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fq53ycl3mlj30tv07hgma.jpg" alt=""></p>
<p>采用skiplayer的方法，在浅层处减小upsampling的步长，得到的finelayer 和 高层得到的coarselayer做融合，然后再upsampling得到输出。</p>
<p>这种做法兼顾local和global信息，即文中说的combiningwhat and where，取得了不错的效果提升。FCN-32s为59.4，FCN-16s提升到了62.4，FCN-8s提升到62.7。可以看出效果还是很明显的。</p>
<p>3.训练细节</p>
<p>用AlexNet，VGG16或者GoogleNet训练好的模型做初始化，在这个基础上做fine-tuning，全部都fine-tuning。<br>采用wholeimage做训练，不进行patchwise sampling。实验证明直接用全图已经很effectiveand efficient。<br>对classscore的卷积层做全零初始化。随机初始化在性能和收敛上没有优势。</p>
<p>【实验设计】</p>
<p>1，对比3种性能较好的几种CNN：AlexNet, VGG16, GoogLeNet进行实验，选择VGG16<br>2，对比FCN-32s-fixed, FCN-32s, FCN-16s, FCN-8s，证明最好的dense prediction组合是8s<br>3，FCN-8s和state-of-the-art对比是最优的，R-CNN, SDS.   FCN-16s<br>4，FCN-16s和现有的一些工作对比，是最优的<br>5，FCN-32s和FCN-16s在RGB-D和HHA的图像数据集上，优于state-of-the-art</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a>【总结】</h3><p>优点<br>1，训练一个end-to-end的FCN模型，利用卷积神经网络的很强的学习能力，得到较准确的结果，以前的基于CNN的方法都是要对输入或者输出做一些处理，才能得到最终结果。<br>2，直接使用现有的CNN网络，如AlexNet, VGG16, GoogLeNet，只需在末尾加上upsampling，参数的学习还是利用CNN本身的反向传播原理，”whole image training is effective and efficient.”<br>3，不限制输入图片的尺寸，不要求图片集中所有图片都是同样尺寸，只需在最后upsampling时按原图被subsampling的比例缩放回来，最后都会输出一张与原图大小一致的dense prediction map。</p>
<p>缺陷<br>根据论文的conclusion部分所示的实验输出sample如下图：<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fq53yovm8hj30e30cet9y.jpg" alt=""><br>可以直观地看出，本文方法和Groud truth相比，容易丢失较小的目标，比如第一幅图片中的汽车，和第二幅图片中的观众人群，如果要改进的话，这一点上应该是有一些提升空间的。<br>结果</p>
<p>当然是state-of-the-art的了。</p>
<p>感受一下：<br><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fq53yuai88j30dq0gh403.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 论文笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 论文笔记 </tag>
            
            <tag> 语义分割 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CNN卷积神经网络的模型结构]]></title>
      <url>/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="http://pancakeawesome.ink/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84.html">CNN卷积神经网络的模型结构</a></li>
<li><a href="http://pancakeawesome.ink/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95.html">CNN卷积神经网络的前向传播算法</a></li>
<li><a href="http://pancakeawesome.ink/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95.html">CNN卷积神经网络的反向传播算法</a></li>
</ul>
<p>在前面我们讲述了DNN的模型与前向反向传播算法。而在DNN大类中，卷积神经网络(Convolutional Neural Networks，以下简称CNN)是最为成功的DNN特例之一。CNN广泛的应用于图像识别，当然现在也应用于NLP等其他领域，本文我们就对CNN的模型结构做一个总结。</p>
<p>在学习CNN前，推荐大家先学习DNN的知识。如果不熟悉DNN而去直接学习CNN，难度会比较的大。这是我写的DNN的教程：</p>
<ul>
<li><a href="http://pancakeawesome.ink/深度神经网络(DNN)模型与前向传播算法(FP).html">深度神经网络和前向传播算法</a></li>
</ul>
<ul>
<li><a href="http://pancakeawesome.ink/深度神经网络(DNN)与反向传播算法(BP).html">深度神经网络和反向传播算法</a></li>
</ul>
<ul>
<li><a href="http://pancakeawesome.ink/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88DNN%EF%BC%89%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%92%8C%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9.html">深度神经网络的损失函数和激活函数</a></li>
<li><a href="http://pancakeawesome.ink/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96.html">深度神经网络的正则化</a><h2 id="卷积神经网络-CNN-模型结构"><a href="#卷积神经网络-CNN-模型结构" class="headerlink" title="卷积神经网络(CNN)模型结构"></a>卷积神经网络(CNN)模型结构</h2><h3 id="1-CNN的基本结构"><a href="#1-CNN的基本结构" class="headerlink" title="1. CNN的基本结构"></a>1. CNN的基本结构</h3></li>
</ul>
<p>首先我们来看看CNN的基本结构。一个常见的CNN例子如下图：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fq7xjsby8lj30ks04yjrk.jpg" alt=""></p>
<p>图中是一个图形识别的CNN模型。可以看出最左边的船的图像就是我们的输入层，计算机理解为输入若干个矩阵，这点和DNN基本相同。</p>
<p>接着是卷积层（Convolution Layer）,这个是CNN特有的，我们后面专门来讲。卷积层的激活函数使用的是ReLU。我们在DNN中介绍过ReLU的激活函数，它其实很简单，就是$ReLU(x) = max(0,x)$。在卷积层后面是池化层(Pooling layer)，这个也是CNN特有的，我们后面也会专门来讲。需要注意的是，池化层没有激活函数。</p>
<p>卷积层+池化层的组合可以在隐藏层出现很多次，上图中出现两次。而实际上这个次数是根据模型的需要而来的。当然我们也可以灵活使用使用卷积层+卷积层，或者卷积层+卷积层+池化层的组合，这些在构建模型的时候没有限制。但是最常见的CNN都是若干卷积层+池化层的组合，如上图中的CNN结构。</p>
<p>在若干卷积层+池化层后面是全连接层（Fully Connected Layer, 简称FC），全连接层其实就是我们前面讲的DNN结构，只是输出层使用了Softmax激活函数来做图像识别的分类，这点我们在DNN中也有讲述。</p>
<p>从上面CNN的模型描述可以看出，CNN相对于DNN，比较特殊的是卷积层和池化层，如果我们熟悉DNN，只要把卷积层和池化层的原理搞清楚了，那么搞清楚CNN就容易很多了。</p>
<h3 id="2-初识卷积"><a href="#2-初识卷积" class="headerlink" title="2. 初识卷积"></a>2. 初识卷积</h3><p>首先，我们去学习卷积层的模型原理，在学习卷积层的模型原理前，我们需要了解什么是卷积，以及CNN中的卷积是什么样子的。</p>
<p>大家学习数学时都有学过卷积的知识，微积分中卷积的表达式为：<br>$$<br>S(t) = \int x(t-a)w(a) da<br>$$<br>离散形式是：<br>$$<br>s(t) = \sum\limits_ax(t-a)w(a)<br>$$<br>这个式子如果用矩阵表示可以为：<br>$$<br>s(t)=(X*W)(t)<br>$$<br>其中星号表示卷积。</p>
<p>如果是二维的卷积，则表示式为：<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fq7xkyi03jj30er01tglf.jpg" alt=""><br>在CNN中，虽然我们也是说卷积，但是我们的卷积公式和严格意义数学中的定义稍有不同,比如对于二维的卷积，定义为：<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fq7xl9u8ctj30ey021jr7.jpg" alt=""><br>这个式子虽然从数学上讲不是严格意义上的卷积，但是大牛们都这么叫了，那么我们也跟着这么叫了。后面讲的CNN的卷积都是指的上面的最后一个式子。</p>
<p>其中，我们叫W为我们的卷积核，而X则为我们的输入。如果X是一个二维输入的矩阵，而W也是一个二维的矩阵。但是如果X是多维张量，那么W也是一个多维的张量。</p>
<h3 id="3-CNN中的卷积层"><a href="#3-CNN中的卷积层" class="headerlink" title="3. CNN中的卷积层"></a>3. CNN中的卷积层</h3><p>有了卷积的基本知识，我们现在来看看CNN中的卷积，假如是对图像卷积，回想我们的上一节的卷积公式，其实就是对输入的图像的不同局部的矩阵和卷积核矩阵各个位置的元素相乘，然后相加得到。</p>
<p>举个例子如下，图中的输入是一个二维的3x4的矩阵，而卷积核是一个2x2的矩阵。这里我们假设卷积是一次移动一个像素来卷积的，那么首先我们对输入的左上角2x2局部和卷积核卷积，即各个位置的元素相乘再相加，得到的输出矩阵S的$S_{00}$的元素，值为$aw+bx+ey+fz$。接着我们将输入的局部向右平移一个像素，现在是(b,c,f,g)四个元素构成的矩阵和卷积核来卷积，这样我们得到了输出矩阵S的S01S01S_{01}的元素，同样的方法，我们可以得到输出矩阵S的$S_{02}，S_{10}，S_{11}， S_{12}$的元素。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fq7xmynk8fj30fb0du0sz.jpg" alt=""></p>
<p> 最终我们得到卷积输出的矩阵为一个2x3的矩阵S。</p>
<p>再举一个动态的卷积过程的例子如下：</p>
<p>我们有下面这个绿色的5x5输入矩阵，卷积核是一个下面这个黄色的3x3的矩阵。卷积的步幅是一个像素。则卷积的过程如下面的动图。卷积的结果是一个3x3的矩阵。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fq7xnx5110j303j037dfo.jpg" alt=""></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fq7xo1nsbuj302201rmwx.jpg" alt=""></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fq7xol1fe5g307g05g0t3.gif" alt=""></p>
<p>上面举的例子都是二维的输入，卷积的过程比较简单，那么如果输入是多维的呢？比如在前面一组卷积层+池化层的输出是3个矩阵，这3个矩阵作为输入呢，那么我们怎么去卷积呢？又比如输入的是对应RGB的彩色图像，即是三个分布对应R，G和B的矩阵呢？</p>
<p> 在斯坦福大学的cs231n的课程上，有一个动态的例子，<a href="http://cs231n.github.io/assets/conv-demo/index.html" target="_blank" rel="noopener">链接在这</a> 。建议大家对照着例子中的动图看下面的讲解。</p>
<p>大家打开这个例子可以看到，这里面输入是3个7x7的矩阵。实际上原输入是3个5x5的矩阵。只是在原来的输入周围加上了1的padding，即将周围都填充一圈的0，变成了3个7x7的矩阵。</p>
<p>例子里面使用了两个卷积核，我们先关注于卷积核W0。和上面的例子相比，由于输入是3个7x7的矩阵，或者说是7x7x3的张量，则我们对应的卷积核W0也必须最后一维是3的张量，这里卷积核W0的单个子矩阵维度为3x3。那么卷积核W0实际上是一个3x3x3的张量。同时和上面的例子比，这里的步幅为2，也就是每次卷积后会移动2个像素的位置。</p>
<p>最终的卷积过程和上面的2维矩阵类似，上面是矩阵的卷积，即两个矩阵对应位置的元素相乘后相加。这里是张量的卷积，即两个张量的3个子矩阵卷积后，再把卷积的结果相加后再加上偏倚b。</p>
<p>7x7x3的张量和3x3x3的卷积核张量W0卷积的结果是一个3x3的矩阵。由于我们有两个卷积核W0和W1，因此最后卷积的结果是两个3x3的矩阵。或者说卷积的结果是一个3x3x2的张量。</p>
<p>仔细回味下卷积的过程，输入是7x7x3的张量，卷积核是两个3x3x3的张量。卷积步幅为2，最后得到了输出是3x3x2的张量。如果把上面的卷积过程用数学公式表达出来就是：<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fq7xpg9qvoj30dw02ajr7.jpg" alt=""><br>其中，$n_in$为输入矩阵的个数，或者是张量的最后一维的维数。$X_k$代表第k个输入矩阵。$W_k$代表卷积核的第k个子卷积核矩阵。$s(i,j)$即卷积核$W$对应的输出矩阵的对应位置元素的值。</p>
<p>通过上面的例子，相信大家对CNN的卷积层的卷积理论过程有了一定的了解。</p>
<p>这里有两篇别人写的博客，可以对照着看一下，<a href="http://www.360doc.com/content/16/0730/18/28378250_579606324.shtml" target="_blank" rel="noopener">CNN新手指南</a><br><a href="https://www.cnblogs.com/hellcat/p/7149348.html" target="_blank" rel="noopener">卷积神经网络的可视化与进一步理解</a></p>
<p>总之CNN可以说是深度学习最重要的部分，也是我们解决问题最重要的利器，请务必掌握！</p>
<p>对于卷积后的输出，一般会通过ReLU激活函数，将输出的张量中的小于0的位置对应的元素值都变为0。</p>
<h3 id="4-CNN中的池化层"><a href="#4-CNN中的池化层" class="headerlink" title="4. CNN中的池化层"></a>4. CNN中的池化层</h3><p>相比卷积层的复杂，池化层则要简单的多，所谓的池化，个人理解就是对输入张量的各个子矩阵进行压缩。假如是2x2的池化，那么就将子矩阵的每2x2个元素变成一个元素，如果是3x3的池化，那么就将子矩阵的每3x3个元素变成一个元素，这样输入矩阵的维度就变小了。</p>
<p>要想将输入子矩阵的每nxn个元素变成一个元素，那么需要一个池化标准。常见的池化标准有2个，MAX或者是Average。即取对应区域的最大值或者平均值作为池化后的元素值。</p>
<p>下面这个例子采用取最大值的池化方法。同时采用的是2x2的池化。步幅为2。</p>
<p>首先对红色2x2区域进行池化，由于此2x2区域的最大值为6.那么对应的池化输出位置的值为6，由于步幅为2，此时移动到绿色的位置去进行池化，输出的最大值为8.同样的方法，可以得到黄色区域和蓝色区域的输出值。最终，我们的输入4x4的矩阵在池化后变成了2x2的矩阵。进行了压缩。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fq7xpo3mkej30dq0bpglr.jpg" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="5-CNN模型结构小结"><a href="#5-CNN模型结构小结" class="headerlink" title="5. CNN模型结构小结"></a>5. CNN模型结构小结</h3><p>理解了CNN模型中的卷积层和池化层，就基本理解了CNN的基本原理，后面再去理解CNN模型的前向传播算法和反向传播算法就容易了。下一篇我们就来讨论CNN模型的前向传播算法。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>1） <a href="http://neuralnetworksanddeeplearning.com/index.html" target="_blank" rel="noopener">Neural Networks and Deep Learning</a> by By Michael Nielsen</p>
<p>2） <a href="http://www.deeplearningbook.org/" target="_blank" rel="noopener">Deep Learning</a>, book by Ian Goodfellow, Yoshua Bengio, and Aaron Courville</p>
<p>3） <a href="http://ufldl.stanford.edu/tutorial/" target="_blank" rel="noopener">UFLDL Tutorial</a></p>
<p>4）<a href="http://cs231n.github.io/convolutional-networks/" target="_blank" rel="noopener">CS231n Convolutional Neural Networks for Visual Recognition, Stanford</a> </p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DNN深度神经网络的正则化]]></title>
      <url>/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="http://pancakeawesome.ink/深度神经网络(DNN)模型与前向传播算法(FP).html">深度神经网络和前向传播算法</a></li>
</ul>
<ul>
<li><a href="http://pancakeawesome.ink/深度神经网络(DNN)与反向传播算法(BP).html">深度神经网络和反向传播算法</a></li>
</ul>
<ul>
<li><a href="http://pancakeawesome.ink/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88DNN%EF%BC%89%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%92%8C%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9.html">深度神经网络的损失函数和激活函数</a></li>
<li><a href="http://pancakeawesome.ink/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96.html">深度神经网络的正则化</a></li>
</ul>
<p>和普通的机器学习算法一样，DNN也会遇到过拟合的问题，需要考虑泛化，这里我们就对DNN的正则化方法做一个总结。</p>
<h2 id="深度神经网络（DNN）的正则化"><a href="#深度神经网络（DNN）的正则化" class="headerlink" title="深度神经网络（DNN）的正则化"></a>深度神经网络（DNN）的正则化</h2><h3 id="1-DNN的L1-amp-L2正则化"><a href="#1-DNN的L1-amp-L2正则化" class="headerlink" title="1. DNN的L1&amp;L2正则化"></a>1. DNN的L1&amp;L2正则化</h3><p>想到正则化，我们首先想到的就是L1正则化和L2正则化。L1正则化和L2正则化原理类似，这里重点讲述DNN的L2正则化。</p>
<p>而DNN的L2正则化通常的做法是只针对与线性系数矩阵$W$,而不针对偏倚系数$b$。利用我们之前的机器学习的知识，我们很容易可以写出DNN的L2正则化的损失函数。</p>
<p>假如我们的每个样本的损失函数是均方差损失函数,则所有的m个样本的损失函数为：<br>$$<br>J(W,b) = \frac{1}{2m}\sum\limits_{i=1}^{m}||a^L-y||_2^2<br>$$<br>则加上了L2正则化后的损失函数是：<br>$$<br>J(W,b) = \frac{1}{2m}\sum\limits_{i=1}^{m}||a^L-y||_2^2 + \frac{\lambda}{2m}\sum\limits_{l=2}^L||w||_2^2<br>$$<br>其中,$\lambda$即我们的正则化超参数，实际使用时需要调参。而$w$为所有权重矩阵$W$的所有列向量。</p>
<p>如果使用上式的损失函数，进行反向传播算法时，流程和没有正则化的反向传播算法完全一样，区别仅仅在于进行梯度下降法时，$W$的更新公式。</p>
<p>回想我们在<a href="http://pancakeawesome.ink/深度神经网络(DNN)与反向传播算法(BP).html">深度神经网络和反向传播算法</a>中，$W$的梯度下降更新公式为：<br>$$<br>W^l = W^l -\alpha \sum\limits_{i=1}^m \delta^{i,l}(a^{x, l-1})^T<br>$$<br>则加入L2正则化以后，迭代更新公式变成：<br>$$<br>W^l = W^l -\alpha \sum\limits_{i=1}^m \delta^{i,l}(a^{i, l-1})^T -\alpha \lambda W^l<br>$$<br>注意到上式中的梯度计算中$\frac{1}{m}$我忽略了，因为$\alpha$是常数，而除以$m$也是常数，所以等同于用了新常数$\alpha$来代替$\frac{\alpha}{m}$。进而简化表达式，但是不影响损失算法。</p>
<p>类似的L2正则化方法可以用于交叉熵损失函数或者其他的DNN损失函数，这里就不累述了。</p>
<h3 id="2-DNN通过集成学习的思路正则化"><a href="#2-DNN通过集成学习的思路正则化" class="headerlink" title="2. DNN通过集成学习的思路正则化"></a>2. DNN通过集成学习的思路正则化</h3><p>除了常见的L1&amp;L2正则化，DNN还可以通过集成学习的思路正则化。在<a href="">集成学习原理</a> 中，我们讲到集成学习有Boosting和Bagging两种思路。而DNN可以用Bagging的思路来正则化。常用的机器学习Bagging算法中，随机森林是最流行的。它 通过随机采样构建若干个相互独立的弱决策树学习器，最后采用加权平均法或者投票法决定集成的输出。在DNN中，我们一样使用Bagging的思路。不过和随机森林不同的是，我们这里不是若干个决策树，而是若干个DNN的网络。</p>
<p>首先我们要对原始的m个训练样本进行有放回随机采样，构建N组m个样本的数据集，然后分别用这N组数据集去训练我们的DNN。即采用我们的前向传播算法和反向传播算法得到N个DNN模型的$W,b$参数组合，最后对N个DNN模型的输出用加权平均法或者投票法决定最终输出。</p>
<p>不过用集成学习Bagging的方法有一个问题，就是我们的DNN模型本来就比较复杂，参数很多。现在又变成了N个DNN模型，这样参数又增加了N倍，从而导致训练这样的网络要花更加多的时间和空间。因此一般N的个数不能太多，比如5-10个就可以了。</p>
<h3 id="3-DNN通过dropout-正则化"><a href="#3-DNN通过dropout-正则化" class="headerlink" title="3. DNN通过dropout 正则化"></a>3. DNN通过dropout 正则化</h3><p>这里我们再讲一种和Bagging类似但是又不同的正则化方法：Dropout。</p>
<p>所谓的Dropout指的是在用前向传播算法和反向传播算法训练DNN模型时，一批数据迭代时，随机的从全连接DNN网络中去掉一部分隐藏层的神经元。</p>
<p>比如我们本来的DNN模型对应的结构是这样的：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fpcd7fgp80j308w09e749.jpg" alt=""></p>
<p>在对训练集中的一批数据进行训练时，我们随机去掉一部分隐藏层的神经元，并用去掉隐藏层的神经元的网络来拟合我们的一批训练数据。如下图，去掉了一半的隐藏层神经元：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fpcd860nrsj309709ijrc.jpg" alt=""></p>
<p>然后用这个去掉隐藏层的神经元的网络来进行一轮迭代，更新所有的$W,b$。这就是所谓的dropout。</p>
<p>当然，dropout并不意味着这些神经元永远的消失了。在下一批数据迭代前，我们会把DNN模型恢复成最初的全连接模型，然后再用随机的方法去掉部分隐藏层的神经元，接着去迭代更新$W,b$。当然，这次用随机的方法去掉部分隐藏层后的残缺DNN网络和上次的残缺DNN网络并不相同。</p>
<p>总结下dropout的方法： 每轮梯度下降迭代时，它需要将训练数据分成若干批，然后分批进行迭代，每批数据迭代时，需要将原始的DNN模型随机去掉部分隐藏层的神经元，用残缺的DNN模型来迭代更新$W,b$。每批数据迭代更新完毕后，要将残缺的DNN模型恢复成原始的DNN模型。</p>
<p>从上面的描述可以看出dropout和Bagging的正则化思路还是很不相同的。dropout模型中的$W,b$是一套，共享的。所有的残缺DNN迭代时，更新的是同一组$W,b$；而Bagging正则化时每个DNN模型有自己独有的一套$W,b$参数，相互之间是独立的。当然他们每次使用基于原始数据集得到的分批的数据集来训练模型，这点是类似的。</p>
<p>使用基于dropout的正则化比基于bagging的正则化简单，这显而易见，当然天下没有免费的午餐，由于dropout会将原始数据分批迭代，因此原始数据集最好较大，否则模型可能会欠拟合。</p>
<h3 id="4-DNN通过增强数据集正则化"><a href="#4-DNN通过增强数据集正则化" class="headerlink" title="4. DNN通过增强数据集正则化"></a>4. DNN通过增强数据集正则化</h3><p>增强模型泛化能力最好的办法是有更多更多的训练数据，但是在实际应用中，更多的训练数据往往很难得到。有时候我们不得不去自己想办法能无中生有，来增加训练数据集，进而得到让模型泛化能力更强的目的。</p>
<p>对于我们传统的机器学习分类回归方法，增强数据集还是很难的。你无中生有出一组特征输入，却很难知道对应的特征输出是什么。但是对于DNN擅长的领域，比如图像识别，语音识别等则是有办法的。以图像识别领域为例，对于原始的数据集中的图像，我们可以将原始图像稍微的平移或者旋转一点点，则得到了一个新的图像。虽然这是一个新的图像，即样本的特征是新的，但是我们知道对应的特征输出和之前未平移旋转的图像是一样的。</p>
<p>举个例子，下面这个图像，我们的特征输出是5。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fpcd92gawaj30ev0b5mwy.jpg" alt=""></p>
<p>我们将原始的图像旋转15度，得到了一副新的图像如下：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fpcd9c63alj30eu0b63yb.jpg" alt=""></p>
<p>我们现在得到了一个新的训练样本，输入特征和之前的训练样本不同，但是特征输出是一样的，我们可以确定这是5.</p>
<p>用类似的思路，我们可以对原始的数据集进行增强，进而得到增强DNN模型的泛化能力的目的。</p>
<h3 id="5-其他DNN正则化方法"><a href="#5-其他DNN正则化方法" class="headerlink" title="5. 其他DNN正则化方法"></a>5. 其他DNN正则化方法</h3><p>DNN的正则化的方法是很多的，还是持续的研究中。在<a href="http://www.deeplearningbook.org/" target="_blank" rel="noopener">Deep Learning</a>这本书中，正则化是洋洋洒洒的一大章。里面提到的其他正则化方法有：Noise Robustness， Adversarial Training，Early Stopping等。如果大家对这些正则化方法感兴趣，可以去阅读<a href="http://www.deeplearningbook.org/" target="_blank" rel="noopener">Deep Learning</a>这本书中的第七章。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>1） <a href="http://neuralnetworksanddeeplearning.com/index.html" target="_blank" rel="noopener">Neural Networks and Deep Learning</a> by By Michael Nielsen</p>
<p>2） <a href="http://www.deeplearningbook.org/" target="_blank" rel="noopener">Deep Learning</a>, book by Ian Goodfellow, Yoshua Bengio, and Aaron Courville</p>
<p>3） <a href="http://ufldl.stanford.edu/tutorial/" target="_blank" rel="noopener">UFLDL Tutorial</a></p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DNN深度神经网络的损失函数和激活函数]]></title>
      <url>/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%92%8C%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="http://pancakeawesome.ink/深度神经网络(DNN)模型与前向传播算法(FP).html">深度神经网络和前向传播算法</a></li>
</ul>
<ul>
<li><a href="http://pancakeawesome.ink/深度神经网络(DNN)与反向传播算法(BP).html">深度神经网络和反向传播算法</a></li>
</ul>
<ul>
<li><a href="http://pancakeawesome.ink/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88DNN%EF%BC%89%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%92%8C%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9.html">深度神经网络的损失函数和激活函数</a></li>
<li><a href="http://pancakeawesome.ink/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96.html">深度神经网络的正则化</a></li>
</ul>
<p>在<a href="http://pancakeawesome.ink/深度神经网络(DNN)与反向传播算法(BP).html">深度神经网络（DNN）反向传播算法(BP)</a> 中，我们对DNN的前向反向传播算法的使用做了总结。里面使用的损失函数是均方差，而激活函数是Sigmoid。实际上DNN可以使用的损失函数和激活函数不少。这些损失函数和激活函数如何选择呢？下面我们就对DNN损失函数和激活函数的选择做一个总结。</p>
<h2 id="深度神经网络（DNN）损失函数和激活函数的选择"><a href="#深度神经网络（DNN）损失函数和激活函数的选择" class="headerlink" title="深度神经网络（DNN）损失函数和激活函数的选择"></a>深度神经网络（DNN）损失函数和激活函数的选择</h2><h3 id="1-均方差损失函数-Sigmoid激活函数的问题"><a href="#1-均方差损失函数-Sigmoid激活函数的问题" class="headerlink" title="1. 均方差损失函数+Sigmoid激活函数的问题"></a>1. 均方差损失函数+Sigmoid激活函数的问题</h3><p>在讲反向传播算法时，我们用均方差损失函数和Sigmoid激活函数做了实例，首先我们就来看看均方差+Sigmoid的组合有什么问题。</p>
<p>首先我们回顾下Sigmoid激活函数的表达式为：<br>$$<br>\sigma(z) = \frac{1}{1+e^{-z}}<br>$$<br>$\sigma(z)$的函数图像如下：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fp5906d8ijj30ci08cjrj.jpg" alt=""></p>
<p>从图上可以看出，对于Sigmoid，当$z$的取值越来越大后，函数曲线变得越来越平缓，意味着此时的导数$\sigma ^{‘}(z)$也越来越小。同样的，当$z$的取值越来越小时，也有这个问题。仅仅在$z$取值为0附近时，导数$\sigma ^{‘}(z)$的取值较大。</p>
<p>在上篇讲的均方差+Sigmoid的反向传播算法中，每一层向前递推都要乘以$\sigma ^{‘}(z)$,得到梯度变化值。Sigmoid的这个曲线意味着在大多数时候，我们的梯度变化值很小，导致我们的$W,b$更新到极值的速度较慢，也就是我们的算法收敛速度较慢。那么有什么什么办法可以改进呢？</p>
<h3 id="2-使用交叉熵损失函数-Sigmoid激活函数改进DNN算法收敛速度"><a href="#2-使用交叉熵损失函数-Sigmoid激活函数改进DNN算法收敛速度" class="headerlink" title="2. 使用交叉熵损失函数+Sigmoid激活函数改进DNN算法收敛速度"></a>2. 使用交叉熵损失函数+Sigmoid激活函数改进DNN算法收敛速度</h3><p>上一节我们讲到Sigmoid的函数特性导致反向传播算法收敛速度慢的问题，那么如何改进呢？换掉Sigmoid？这当然是一种选择。另一种常见的选择是用交叉熵损失函数来代替均方差损失函数。</p>
<p>我们来看看每个样本的交叉熵损失函数的形式：<br>$$<br>J(W,b,a,y) = -y \bullet lna- (1-y) \bullet ln(1 -a)<br>$$<br>其中，$\bullet$为向量内积。这个形式其实很熟悉，在<a href="http://pancakeawesome.ink/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93.html">逻辑回归原理小结</a> 中其实我们就用到了类似的形式，只是当时我们是用最大似然估计推导出来的，而这个损失函数的学名叫交叉熵。</p>
<p>使用了交叉熵损失函数，就能解决Sigmoid函数导数变化大多数时候反向传播算法慢的问题吗？我们来看看当使用交叉熵时，我们输出层$\delta^L$的梯度情况。</p>
<p>$$<br> \begin{align} \delta^L  &amp; = \frac{\partial J(W,b,a^L,y)}{\partial z^L} \\&amp; = -y\frac{1}{a^L}(a^L)(1-a^L) + (1-y) \frac{1}{1-a^L}(a^L)(1-a^L) \\&amp; = -y(1-a^L) + (1-y)a^L \\&amp; = a^L-y \end{align}<br>$$<br>可见此时我们的$\delta^l$梯度表达式里面已经没有了$\sigma ^{‘}(z)$，作为一个特例，回顾一下我们上一节均方差损失函数时在$\delta^L$梯度，<br>$$<br>\frac{\partial J(W,b,x,y)}{\partial z^L} = (a^L-y) \odot \sigma^{‘}(z)<br>$$<br>对比两者在第L层的$\delta^L$梯度表达式，就可以看出，使用交叉熵，得到的的$\delta^l$梯度表达式没有了$\sigma^{‘}(z)$，梯度为预测值和真实值的差距，这样求得的$W^l,b^l$的地图也不包含$\sigma^{‘}(z)$，因此避免了反向传播收敛速度慢的问题。</p>
<p>通常情况下，如果我们使用了sigmoid激活函数，交叉熵损失函数肯定比均方差损失函数好用。</p>
<h3 id="3-使用对数似然损失函数和softmax激活函数进行DNN分类输出"><a href="#3-使用对数似然损失函数和softmax激活函数进行DNN分类输出" class="headerlink" title="3. 使用对数似然损失函数和softmax激活函数进行DNN分类输出"></a>3. 使用对数似然损失函数和softmax激活函数进行DNN分类输出</h3><p>在前面我们讲的所有DNN相关知识中，我们都假设输出是连续可导的值。但是如果是分类问题，那么输出是一个个的类别，那我们怎么用DNN来解决这个问题呢？</p>
<p>比如假设我们有一个三个类别的分类问题，这样我们的DNN输出层应该有三个神经元，假设第一个神经元对应类别一，第二个对应类别二，第三个对应类别三，这样我们期望的输出应该是(1,0,0)，（0,1,0）和(0,0,1)这三种。即样本真实类别对应的神经元输出应该无限接近或者等于1，而非改样本真实输出对应的神经元的输出应该无限接近或者等于0。或者说，我们希望输出层的神经元对应的输出是若干个概率值，这若干个概率值即我们DNN模型对于输入值对于各类别的输出预测，同时为满足概率模型，这若干个概率值之和应该等于1。</p>
<p>DNN分类模型要求是输出层神经元输出的值在0到1之间，同时所有输出值之和为1。很明显，现有的普通DNN是无法满足这个要求的。但是我们只需要对现有的全连接DNN稍作改良，即可用于解决分类问题。在现有的DNN模型中，我们可以将输出层第i个神经元的激活函数定义为如下形式：<br>$$<br>a_i^L = \frac{e^{z_i^L}}{\sum\limits_{j=1}^{n_L}e^{z_j^L}}<br>$$<br>其中，$n_L$是输出层第L层的神经元个数，或者说我们的分类问题的类别数。</p>
<p>很容易看出，所有的$a_i^L$都是在(0,1) 之间的数字，而$\sum\limits_{j=1}^{n_L}e^{z_j^L}$作为归一化因子保证了所有的$a_i^L$之和为1。</p>
<p>这个方法很简洁漂亮，仅仅只需要将输出层的激活函数从Sigmoid之类的函数转变为上式的激活函数即可。上式这个激活函数就是我们的softmax激活函数。它在分类问题中有广泛的应用。将DNN用于分类问题，在输出层用softmax激活函数也是最常见的了。</p>
<p>下面这个例子清晰的描述了softmax激活函数在前向传播算法时的使用。假设我们的输出层为三个神经元，而未激活的输出为3,1和-3，我们求出各自的指数表达式为：20,2.7和0.05，我们的归一化因子即为22.75，这样我们就求出了三个类别的概率输出分布为0.88，0.12和0。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fp592w2tf8j30ev08bgmo.jpg" alt=""></p>
<p>从上面可以看出，将softmax用于前向传播算法是也很简单的。那么在反向传播算法时还简单吗？反向传播的梯度好计算吗？答案是Yes！</p>
<p>对于用于分类的softmax激活函数，对应的损失函数一般都是用对数似然函数，即：<br>$$<br>J(W,b,a^L,y) = - \sum\limits_ky_klna_k^L<br>$$<br>其中$y_k$的取值为0或者1，如果某一训练样本的输出为第i类。则$y_i=1$,其余的$j \neq i$都有$y_j=0$。由于每个样本只属于一个类别，所以这个对数似然函数可以简化为：<br>$$<br>J(W,b,a^L,y) = -lna_i^L<br>$$<br>其中$i$即为训练样本真实的类别序号。</p>
<p>可见损失函数只和真实类别对应的输出有关，这样假设真实类别是第i类，则其他不属于第i类序号对应的神经元的梯度导数直接为0。对于真实类别第i类，它的$W_i^L$对应的梯度计算为：<br>$$<br> \begin{align} \frac{\partial J(W,b,a^L,y)}{\partial W_i^L}&amp; = \frac{\partial J(W,b,a^L,y)}{\partial a_i^L}\frac{\partial a_i^L}{\partial z_i^L}\frac{\partial z_i^L}{\partial w_i^L} \\&amp; = -\frac{1}{a_i^L}\frac{(e^{z_i^L})\sum\limits_{j=1}^{n_L}e^{z_j^L}-e^{z_i^L}e^{z_i^L}}{(\sum\limits_{j=1}^{n_L}e^{z_j^L)^2}} a_i^{L-1} \\&amp; = -\frac{1}{a_i^L} (\frac{e^{z_i^L}}{\sum\limits_{j=1}^{n_L}e^{z_j^L}}-\frac{e^{z_i^L}}{\sum\limits_{j=1}^{n_L}e^{z_j^L}}\frac{e^{z_i^L}}{\sum\limits_{j=1}^{n_L}e^{z_j^L}}) a_i^{L-1} \\&amp; = -\frac{1}{a_i^L} a_i^L(1- a_i^L) a_i^{L-1} \\&amp; = (a_i^L -1)  a_i^{L-1} \end{align}<br>$$<br>同样的可以得到$b_i^L$的梯度表达式为：<br>$$<br>\frac{\partial J(W,b,a^L,y)}{\partial b_i^L} = a_i^L -1<br>$$<br>可见，梯度计算也很简洁，也没有第一节说的训练速度慢的问题。举个例子，假如我们对于第2类的训练样本，通过前向算法计算的未激活输出为（1,5,3），则我们得到softmax激活后的概率输出为：(0.015,0.866,0.117)。由于我们的类别是第二类，则反向传播的梯度应该为：(0.015,0.866-1,0.117)。是不是很简单呢？</p>
<p>当softmax输出层的反向传播计算完以后，后面的普通DNN层的反向传播计算和之前讲的普通DNN没有区别。　</p>
<h3 id="4-梯度爆炸梯度消失与ReLU激活函数"><a href="#4-梯度爆炸梯度消失与ReLU激活函数" class="headerlink" title="4. 梯度爆炸梯度消失与ReLU激活函数"></a>4. 梯度爆炸梯度消失与ReLU激活函数</h3><p>学习DNN，大家一定听说过梯度爆炸和梯度消失两个词。尤其是梯度消失，是限制DNN与深度学习的一个关键障碍，目前也没有完全攻克。</p>
<p>什么是梯度爆炸和梯度消失呢？从理论上说都可以写一篇论文出来。不过简单理解，就是在反向传播的算法过程中，由于我们使用了是矩阵求导的链式法则，有一大串连乘，如果连乘的数字在每层都是小于1的，则梯度越往前乘越小，导致梯度消失，而如果连乘的数字在每层都是大于1的，则梯度越往前乘越大，导致梯度爆炸。</p>
<p>比如我们在前一篇反向传播算法里面讲到了$\delta$的计算，可以表示为：<br>$$<br>\delta^l =\frac{\partial J(W,b,x,y)}{\partial z^l} = \frac{\partial J(W,b,x,y)}{\partial z^L}\frac{\partial z^L}{\partial z^{L-1}}\frac{\partial z^{L-1}}{\partial z^{L-2}}…\frac{\partial z^{l+1}}{\partial z^{l}}<br>$$<br>如果不巧我们的样本导致每一层$\frac{\partial z^{l+1}}{\partial z^{l}}$的都小于1，则随着反向传播算法的进行，我们的$\delta^l$会随着层数越来越小，甚至接近越0，导致梯度几乎消失，进而导致前面的隐藏层的$W,b$参数随着迭代的进行，几乎没有大的改变，更谈不上收敛了。这个问题目前没有完美的解决办法。</p>
<p>而对于梯度爆炸，则一般可以通过调整我们DNN模型中的初始化参数得以解决。</p>
<p>对于无法完美解决的梯度消失问题，目前有很多研究，一个可能部分解决梯度消失问题的办法是使用ReLU（Rectified Linear Unit）激活函数，ReLU在卷积神经网络CNN中得到了广泛的应用，在CNN中梯度消失似乎不再是问题。那么它是什么样子呢？其实很简单，比我们前面提到的所有激活函数都简单，表达式为：<br>$$<br>\sigma(z) = max(0,z)<br>$$<br>也就是说大于等于0则不变，小于0则激活后为0。就这么一玩意就可以解决梯度消失？至少部分是的。具体的原因现在其实也没有从理论上得以证明。这里我也就不多说了。</p>
<h3 id="5-DNN其他激活函数"><a href="#5-DNN其他激活函数" class="headerlink" title="5. DNN其他激活函数"></a>5. DNN其他激活函数</h3><p>除了上面提到了激活函数，DNN常用的激活函数还有：</p>
<p>1） tanh：这个是sigmoid的变种，表达式为：<br>$$<br>tanh(z) = \frac{e^z-e^{-z}}{e^z+e^{-z}}<br>$$<br>tanh激活函数和sigmoid激活函数的关系为：<br>$$<br>tanh(z) = 2sigmoid(2z)-1<br>$$<br>tanh和sigmoid对比主要的特点是它的输出落在了[-1,1],这样输出可以进行标准化。同时tanh的曲线在较大时变得平坦的幅度没有sigmoid那么大，这样求梯度变化值有一些优势。当然，要说tanh一定比sigmoid好倒不一定，还是要具体问题具体分析。</p>
<p>2） softplus：这个其实就是sigmoid函数的原函数，表达式为：<br>$$<br>softplus(z) = log(1+e^z)<br>$$<br>它的导数就是sigmoid函数。softplus的函数图像和ReLU有些类似。它出现的比ReLU早，可以视为ReLU的鼻祖。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fp5955e2okj30et0b93yj.jpg" alt=""></p>
<p>3）PReLU：从名字就可以看出它是ReLU的变种，特点是如果未激活值小于0，不是简单粗暴的直接变为0，而是进行一定幅度的缩小。如下图。当然，由于ReLU的成功，有很多的跟风者，有其他各种变种ReLU，这里就不多提了。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fp595qupc0j30ey09b3yy.jpg" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="DNN损失函数和激活函数小结"><a href="#DNN损失函数和激活函数小结" class="headerlink" title="DNN损失函数和激活函数小结"></a>DNN损失函数和激活函数小结</h3><p>上面我们对DNN损失函数和激活函数做了详细的讨论，重要的点有：1）如果使用sigmoid激活函数，则交叉熵损失函数一般肯定比均方差损失函数好。2）如果是DNN用于分类，则一般在输出层使用softmax激活函数和对数似然损失函数。3）ReLU激活函数对梯度消失问题有一定程度的解决，尤其是在CNN模型中。</p>
<p>下一篇我们讨论下DNN模型的正则化问题。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>1） <a href="http://neuralnetworksanddeeplearning.com/index.html" target="_blank" rel="noopener">Neural Networks and Deep Learning</a> by By Michael Nielsen</p>
<p>2） <a href="http://www.deeplearningbook.org/" target="_blank" rel="noopener">Deep Learning</a>, book by Ian Goodfellow, Yoshua Bengio, and Aaron Courville</p>
<p>3） <a href="http://ufldl.stanford.edu/tutorial/" target="_blank" rel="noopener">UFLDL Tutorial</a></p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DNN深度神经网络和反向传播算法]]></title>
      <url>/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C(DNN)%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95(BP).html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="http://pancakeawesome.ink/深度神经网络(DNN)模型与前向传播算法(FP).html">深度神经网络和前向传播算法</a></li>
</ul>
<ul>
<li><a href="http://pancakeawesome.ink/深度神经网络(DNN)与反向传播算法(BP).html">深度神经网络和反向传播算法</a></li>
</ul>
<ul>
<li><a href="http://pancakeawesome.ink/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88DNN%EF%BC%89%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%92%8C%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9.html">深度神经网络的损失函数和激活函数</a></li>
<li><a href="http://pancakeawesome.ink/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96.html">深度神经网络的正则化</a></li>
</ul>
<p>在<a href="http://pancakeawesome.ink/深度神经网络(DNN)模型与前向传播算法(FP).html">深度神经网络（DNN）模型与前向传播算法</a>中，我们对DNN的模型和前向传播算法做了总结，这里我们更进一步，对DNN的反向传播算法（Back Propagation，BP）做一个总结。</p>
<h2 id="深度神经网络（DNN）反向传播算法-BP"><a href="#深度神经网络（DNN）反向传播算法-BP" class="headerlink" title="深度神经网络（DNN）反向传播算法(BP)"></a>深度神经网络（DNN）反向传播算法(BP)</h2><h3 id="1-DNN反向传播算法要解决的问题"><a href="#1-DNN反向传播算法要解决的问题" class="headerlink" title="1. DNN反向传播算法要解决的问题"></a>1. DNN反向传播算法要解决的问题</h3><p>在了解DNN的反向传播算法前，我们先要知道DNN反向传播算法要解决的问题，也就是说，什么时候我们需要这个反向传播算法？　</p>
<p>回到我们监督学习的一般问题，假设我们有m个训练样本：${(x_1,y_1), (x_2,y_2), …, (x_m,y_m)}$,其中$x$为输入向量，特征维度为$n_{in}$,而$y$为输出向量，特征维度为$n_{out}$。我们需要利用这m个样本训练出一个模型，当有一个新的测试样本$(x_{test},?)$来到时, 我们可以预测$y_{test}$向量的输出。　</p>
<p>如果我们采用DNN的模型，即我们使输入层有$n_{in}$个神经元，而输出层有$n_{out}$个神经元。再加上一些含有若干神经元的隐藏层。此时我们需要找到合适的所有隐藏层和输出层对应的线性系数矩阵$W$,偏倚向量$b$,让所有的训练样本输入计算出的输出尽可能的等于或很接近样本输出。怎么找到合适的参数呢？</p>
<p>如果大家对传统的机器学习的算法优化过程熟悉的话，这里就很容易联想到我们可以用一个合适的损失函数来度量训练样本的输出损失，接着对这个损失函数进行优化求最小化的极值，对应的一系列线性系数矩阵$W$,偏倚向量$b$即为我们的最终结果。在DNN中，损失函数优化极值求解的过程最常见的一般是通过梯度下降法来一步步迭代完成的，当然也可以是其他的迭代方法比如牛顿法与拟牛顿法。如果大家对梯度下降法不熟悉，建议先阅读我之前写的<a href="http://pancakeawesome.ink/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%EF%BC%88Gradient-Descent%EF%BC%89%E5%B0%8F%E7%BB%93.html">梯度下降（Gradient Descent）小结</a> 。</p>
<p>对DNN的损失函数用梯度下降法进行迭代优化求极小值的过程即为我们的反向传播算法。</p>
<h3 id="2-DNN反向传播算法的基本思路"><a href="#2-DNN反向传播算法的基本思路" class="headerlink" title="2. DNN反向传播算法的基本思路"></a>2. DNN反向传播算法的基本思路</h3><p>在进行DNN反向传播算法前，我们需要选择一个损失函数，来度量训练样本计算出的输出和真实的训练样本输出之间的损失。你也许会问：训练样本计算出的输出是怎么得来的？这 个输出是随机选择一系列$W,b$,用我们上一节的前向传播算法计算出来的。即通过一系列的计算：$a^l = \sigma(z^l) = \sigma(W^la^{l-1} + b^l)$。计算到输出层第$L$层对应的$a^L$即为前向传播算法计算出来的输出。</p>
<p>回到损失函数，DNN可选择的损失函数有不少，为了专注算法，这里我们使用最常见的均方差来度量损失。即对于每个样本，我们期望最小化下式：<br>$$<br>J(W,b,x,y) = \frac{1}{2}||a^L-y||_2^2<br>$$<br>其中，$a^L$和$y$为特征维度为$n_{out}$的向量,而$||S||_2$为S的L2范数。</p>
<p>损失函数有了，现在我们开始用梯度下降法迭代求解每一层的$W,b$。</p>
<p>首先是输出层第$L$层。注意到输出层的$W,b$满足下式：<br>$$<br>a^L = \sigma(z^L) = \sigma(W^La^{L-1} + b^L)<br>$$<br>这样对于输出层的参数，我们的损失函数变为：<br>$$<br>J(W,b,x,y) = \frac{1}{2}||a^L-y||_2^2 =  \frac{1}{2}|| \sigma(W^La^{L-1} + b^L)-y||_2^2<br>$$<br>这样求解$W,b$的梯度就简单了：<br>$$<br>\frac{\partial J(W,b,x,y)}{\partial W^L} = \frac{\partial J(W,b,x,y)}{\partial z^L}\frac{\partial z^L}{\partial W^L} =(a^L-y) \odot \sigma^{‘}(z^L)(a^{L-1})^T<br>$$<br>$$<br>\frac{\partial J(W,b,x,y)}{\partial b^L} = \frac{\partial J(W,b,x,y)}{\partial z^L}\frac{\partial z^L}{\partial b^L} =(a^L-y)\odot \sigma^{‘}(z^L)<br>$$<br>注意上式中有一个符号$\odot$,它代表Hadamard积，对于两个维度相同的向量$A（a_1,a_2,…a_n）^T$和$B（b_1,b_2,…b_n）^T$,则$A \odot B = (a_1b_1, a_2b_2,…a_nb_n)^T$。</p>
<p>我们注意到在求解输出层的$W,b$的时候，有公共的部分$\frac{\partial J(W,b,x,y)}{\partial z^L}$，因此我们可以把公共的部分即对$z^L$先算出来，记为：<br>$$<br>\delta^L = \frac{\partial J(W,b,x,y)}{\partial z^L} = (a^L-y)\odot \sigma^{‘}(z^L)<br>$$<br>现在我们终于把输出层的梯度算出来了，那么如何计算上一层$L-1$层的梯度，上上层$L-2$层的梯度呢？这里我们需要使用函数求导的<a href="https://baike.baidu.com/item/%E9%93%BE%E5%BC%8F%E6%B3%95%E5%88%99/3314017?fr=aladdin" target="_blank" rel="noopener">链式法则</a>，一步步的递推，注意到对于第$l$层的未激活输出$z^l$，它的梯度可以表示为:<br>$$<br>\delta^l =\frac{\partial J(W,b,x,y)}{\partial z^l} = \frac{\partial J(W,b,x,y)}{\partial z^L}\frac{\partial z^L}{\partial z^{L-1}}\frac{\partial z^{L-1}}{\partial z^{L-2}}…\frac{\partial z^{l+1}}{\partial z^{l}}<br>$$<br>如果我们可以依次计算出第$l$层的$\delta^l$,则该层的$W^l,b^l$很容易计算？为什么呢？注意到根据前向传播算法，我们有：<br>$$<br>z^l= W^la^{l-1} + b^l<br>$$<br>所以根据上式我们可以很方便的计算出第l层的$W^l,b^l$的梯度如下：<br>$$<br>\frac{\partial J(W,b,x,y)}{\partial W^l} = \frac{\partial J(W,b,x,y)}{\partial z^l} \frac{\partial z^l}{\partial W^l} = \delta^{l}(a^{l-1})^T<br>$$<br>$$<br>\frac{\partial J(W,b,x,y)}{\partial b^l} = \frac{\partial J(W,b,x,y)}{\partial z^l} \frac{\partial z^l}{\partial b^l} = \delta^{l}<br>$$<br>那么现在问题的关键就是要求出$\delta^{l}$了。这里我们用数学归纳法，第$L$层的$\delta^{L}$上面我们已经求出， 假设第$l+1$层的$\delta^{l+1}$已经求出来了，那么我们如何求出第$l$层的$\delta^{l}$呢？我们注意到：<br>$$<br>\delta^{l} = \frac{\partial J(W,b,x,y)}{\partial z^l} = \frac{\partial J(W,b,x,y)}{\partial z^{l+1}}\frac{\partial z^{l+1}}{\partial z^{l}} = \delta^{l+1}\frac{\partial z^{l+1}}{\partial z^{l}}<br>$$<br>可见，用归纳法递推$\delta^{l+1}$和$\delta^{l}$的关键在于求解$\frac{\partial z^{l+1}}{\partial z^{l}}$。</p>
<p>而$z^{l+1}$和$z^{l}$的关系其实很容易找出：<br>$$<br>z^{l+1}= W^{l+1}a^{l} + b^{l+1} = W^{l+1}\sigma(z^l) + b^{l+1}<br>$$<br>这样很容易求出：<br>$$<br>\frac{\partial z^{l+1}}{\partial z^{l}} = (W^{l+1})^T\odot \underbrace{(\sigma^{‘}(z^l),..,\sigma^{‘}(z^l))}_{n_{l+1}}<br>$$<br>将上式带入上面$\delta^{l+1}$和$\delta^{l}$关系式我们得到：<br>$$<br>\delta^{l} = \delta^{l+1}\frac{\partial z^{l+1}}{\partial z^{l}} = (W^{l+1})^T\delta^{l+1}\odot \sigma^{‘}(z^l)<br>$$<br>现在我们得到了$\delta^{l}$的递推关系式，只要求出了某一层的$\delta^{l}$，求解$W^l,b^l$的对应梯度就很简单的。</p>
<h3 id="3-DNN反向传播算法过程"><a href="#3-DNN反向传播算法过程" class="headerlink" title="3. DNN反向传播算法过程"></a>3. DNN反向传播算法过程</h3><p>现在我们总结下DNN反向传播算法的过程。由于梯度下降法有批量（Batch），小批量(mini-Batch)，随机三个变种，为了简化描述，这里我们以最基本的批量梯度下降法为例来描述反向传播算法。实际上在业界使用最多的是mini-Batch的梯度下降法。不过区别仅仅在于迭代时训练样本的选择而已。</p>
<p>输入: 总层数L，以及各隐藏层与输出层的神经元个数，激活函数，损失函数，迭代步长$\alpha$,最大迭代次数MAX与停止迭代阈值$\epsilon$，输入的m个训练样本${(x_1,y_1), (x_2,y_2), …, (x_m,y_m)}$</p>
<p>输出：各隐藏层与输出层的线性关系系数矩阵$W$和偏倚向量$b$</p>
<p>1) 初始化各隐藏层与输出层的线性关系系数矩阵$W$和偏倚向量$b$的值为一个随机值。</p>
<p>2）for iter to 1 to MAX：</p>
<p>2-1) for i =1 to m：</p>
<p>　　a) 将DNN输入$a^1$设置为$x_i$</p>
<p>　　b) for $l$=2 to L，进行前向传播算法计算$a^{i,l} = \sigma(z^{i,l}) = \sigma(W^la^{i,l-1} + b^l)$</p>
<p>　　c) 通过损失函数计算输出层的$\delta^{i,L}$</p>
<p>　　d) for $l$= L to 2, 进行反向传播算法计算$\delta^{i,l} =  (W^{l+1})^T\delta^{i,l+1}\odot \sigma^{‘}(z^{i,l})$</p>
<p>2-2) for $l$ = 2 to L，更新第$l$层的$W^l,b^l$:<br>$$<br>W^l = W^l -\alpha \sum\limits_{i=1}^m \delta^{i,l}(a^{i, l-1})^T<br>$$<br>$$<br>b^l = b^l -\alpha \sum\limits_{i=1}^m \delta^{i,l}<br>$$<br>2-3) 如果所有$W，b$的变化值都小于停止迭代阈值$\epsilon$，则跳出迭代循环到步骤3。</p>
<p>3） 输出各隐藏层与输出层的线性关系系数矩阵$W$和偏倚向量$b$。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="DNN反向传播算法小结"><a href="#DNN反向传播算法小结" class="headerlink" title="DNN反向传播算法小结"></a>DNN反向传播算法小结</h3><p>有了DNN反向传播算法，我们就可以很方便的用DNN的模型去解决第一节里面提到了各种监督学习的分类回归问题。当然DNN的参数众多，矩阵运算量也很大，直接使用会有各种各样的问题。有哪些问题以及如何尝试解决这些问题并优化DNN模型与算法，我们在下一篇讲。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>1） <a href="http://neuralnetworksanddeeplearning.com/index.html" target="_blank" rel="noopener">Neural Networks and Deep Learning</a> by By Michael Nielsen</p>
<p>2） <a href="http://www.deeplearningbook.org/" target="_blank" rel="noopener">Deep Learning</a>, book by Ian Goodfellow, Yoshua Bengio, and Aaron Courville</p>
<p>3） <a href="http://ufldl.stanford.edu/tutorial/" target="_blank" rel="noopener">UFLDL Tutorial</a> <a href="http://ufldl.stanford.edu/tutorial/supervised/MultiLayerNeuralNetworks/" target="_blank" rel="noopener">
</a> </p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DNN深度神经网络和前向传播算法]]></title>
      <url>/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C(DNN)%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95(FP).html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="http://pancakeawesome.ink/深度神经网络(DNN)模型与前向传播算法(FP).html">DNN深度神经网络和前向传播算法</a></li>
</ul>
<ul>
<li><a href="http://pancakeawesome.ink/深度神经网络(DNN)与反向传播算法(BP).html">深度神经网络和反向传播算法</a></li>
</ul>
<ul>
<li><a href="http://pancakeawesome.ink/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88DNN%EF%BC%89%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%92%8C%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9.html">深度神经网络的损失函数和激活函数</a></li>
<li><a href="http://pancakeawesome.ink/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96.html">深度神经网络的正则化</a></li>
</ul>
<p>深度神经网络可以说是深度学习的基础，把DNN学好，对后面的学习很有帮助。<br>深度神经网络（Deep Neural Networks， 以下简称DNN）是深度学习的基础，而要理解DNN，首先我们要理解DNN模型，下面我们就对DNN的模型与前向传播算法做一个总结。</p>
<h2 id="深度神经网络（DNN）模型与前向传播算法"><a href="#深度神经网络（DNN）模型与前向传播算法" class="headerlink" title="深度神经网络（DNN）模型与前向传播算法"></a>深度神经网络（DNN）模型与前向传播算法</h2><h3 id="1-从感知机到神经网络"><a href="#1-从感知机到神经网络" class="headerlink" title="1. 从感知机到神经网络"></a>1. 从感知机到神经网络</h3><p>在<a href="http://pancakeawesome.ink/%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93.html">感知机原理小结</a> 中，我们介绍过感知机的模型，它是一个有若干输入和一个输出的模型，如下图:</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fp362gkr5qj307x03za9u.jpg" alt=""></p>
<p>输出和输入之间学习到一个线性关系，得到中间输出结果：<br>$$<br>z=\sum\limits_{i=1}^mw_ix_i + b<br>$$<br>接着是一个神经元激活函数:<br>$$<br>sign(z)= \begin{cases} -1&amp; {z&lt;0}\\ 1&amp; {z\geq 0} \end{cases}<br>$$<br>从而得到我们想要的输出结果1或者-1。</p>
<p>这个模型只能用于二元分类，且无法学习比较复杂的非线性模型，因此在工业界无法使用。</p>
<p>而神经网络则在感知机的模型上做了扩展，总结下主要有三点：</p>
<p>1）加入了隐藏层，隐藏层可以有多层，增强模型的表达能力，如下图实例，当然增加了这么多隐藏层模型的复杂度也增加了好多。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fp362x6u04j30fs068748.jpg" alt=""></p>
<p>2）输出层的神经元也可以不止一个输出，可以有多个输出，这样模型可以灵活的应用于分类回归，以及其他的机器学习领域比如降维和聚类等。多个神经元输出的输出层对应的一个实例如下图，输出层现在有4个神经元了。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fp3638heh7j30a007wq34.jpg" alt=""> </p>
<p>3） 对激活函数做扩展，感知机的激活函数是$sign(z)$,虽然简单但是处理能力有限，因此神经网络中一般使用的其他的激活函数，比如我们在逻辑回归里面使用过的Sigmoid函数，即：<br>$$<br>f(z)=\frac{1}{1+e^{-z}}<br>$$<br>还有后来出现的tanx, softmax,和ReLU等。通过使用不同的激活函数，神经网络的表达能力进一步增强。对于各种常用的激活函数，我们在后面再专门讲。</p>
<h3 id="2-DNN的基本结构"><a href="#2-DNN的基本结构" class="headerlink" title="2. DNN的基本结构"></a>2. DNN的基本结构</h3><p>上一节我们了解了神经网络基于感知机的扩展，而DNN可以理解为有很多隐藏层的神经网络。这个很多其实也没有什么度量标准, 多层神经网络和深度神经网络DNN其实也是指的一个东西，当然，DNN有时也叫做多层感知机（Multi-Layer perceptron,MLP）, 名字实在是多。后面我们讲到的神经网络都默认为DNN。</p>
<p>从DNN按不同层的位置划分，DNN内部的神经网络层可以分为三类，输入层，隐藏层和输出层,如下图示例，一般来说第一层是输入层，最后一层是输出层，而中间的层数都是隐藏层。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fp363kxfogj30fv08sgn4.jpg" alt=""></p>
<p>层与层之间是全连接的，也就是说，第i层的任意一个神经元一定与第i+1层的任意一个神经元相连。虽然DNN看起来很复杂，但是从小的局部模型来说，还是和感知机一样，即一个线性关系$z=\sum\limits w_ix_i + b$加上一个激活函数$\sigma(z)$。</p>
<p>由于DNN层数多，则我们的线性关系系数$w$和偏倚$b$的数量也就是很多了。具体的参数在DNN是如何定义的呢？</p>
<p>首先我们来看看线性关系系数$w$的定义。以下图一个三层的DNN为例，第二层的第4个神经元到第三层的第2个神经元的线性系数定义为$w_{24}^3$。上标3代表线性系数$w$所在的层数，而下标对应的是输出的第三层索引2和输入的第二层索引4。你也许会问，为什么不是$w_{42}^3$, 而是$w_{24}^3$呢？这主要是为了便于模型用于矩阵表示运算，如果是$w_{42}^3$而每次进行矩阵运算是$w^Tx+b$，需要进行转置。将输出的索引放在前面的话，则线性运算不用转置,即直接为$wx+b$。总结下，第$l-1$层的第k个神经元到第$l$层的第j个神经元的线性系数定义为$w_{jk}^l$。注意，输入层是没有$w$参数的。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fp363snmf2j30g206vweo.jpg" alt=""> </p>
<p> 再来看看偏倚$b$的定义。还是以这个三层的DNN为例，第二层的第三个神经元对应的偏倚定义为$b_3^{2}$。其中，上标2代表所在的层数，下标3代表偏倚所在的神经元的索引。同样的道理，第三个的第一个神经元的偏倚应该表示为$b_1^{3}$。同样的，输入层是没有偏倚参数$b$的。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fp363ydx64j309b07k0sn.jpg" alt=""></p>
<h3 id="3-DNN前向传播算法数学原理"><a href="#3-DNN前向传播算法数学原理" class="headerlink" title="3. DNN前向传播算法数学原理"></a>3. DNN前向传播算法数学原理</h3><p>在上一节，我们已经介绍了DNN各层线性关系系数$w$,偏倚$b$的定义。假设我们选择的激活函数是$\sigma(z)$，隐藏层和输出层的输出值为$a$，则对于下图的三层DNN,利用和感知机一样的思路，我们可以利用上一层的输出计算下一层的输出，也就是所谓的DNN前向传播算法。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fp36462j3jj30fq0c4aah.jpg" alt=""></p>
<p>对于第二层的的输出$a_1^2,a_2^2,a_3^2$，我们有：<br>$$<br>a_1^2=\sigma(z_1^2) = \sigma(w_{11}^2x_1 + w_{12}^2x_2 + w_{13}^2x_3 + b_1^{2})<br>$$<br>$$<br>a_2^2=\sigma(z_2^2) = \sigma(w_{21}^2x_1 + w_{22}^2x_2 + w_{23}^2x_3 + b_2^{2})<br>$$<br>$$<br>a_3^2=\sigma(z_3^2) = \sigma(w_{31}^2x_1 + w_{32}^2x_2 + w_{33}^2x_3 + b_3^{2})<br>$$<br>对于第三层的的输出$a_1^3$，我们有：<br>$$<br>a_1^3=\sigma(z_1^3) = \sigma(w_{11}^3a_1^2 + w_{12}^3a_2^2 + w_{13}^3a_3^2 + b_1^{3})<br>$$<br>将上面的例子一般化，假设第$l-1$层共有m个神经元，则对于第$l$层的第j个神经元的输出$a_j^l$，我们有：<br>$$<br>a_j^l = \sigma(z_j^l) = \sigma(\sum\limits_{k=1}^mw_{jk}^la_k^{l-1} + b_j^l)<br>$$<br>其中，如果$l=2$,则对于的$a_k^1$即为输入层的$x_k$。</p>
<p>从上面可以看出，使用代数法一个个的表示输出比较复杂，而如果使用矩阵法则比较的简洁。假设第$l-1$层共有m个神经元，而第$l$层共有n个神经元，则第$l$层的线性系数$w$组成了一个$n \times m$的矩阵$W^l$, 第$l$层的偏倚$b$组成了一个$n \times 1$的向量$b^l$ , 第$l-1$层的的输出$a$组成了一个$m \times 1$的向量$a^{l-1}$，第$l$层的的未激活前线性输出$z$组成了一个$n \times 1$的向量$z^{l}$, 第$l$层的的输出$a$组成了一个$n \times 1$的向量$a^{l}$。则用矩阵法表示，第l层的输出为：<br>$$<br>a^l = \sigma(z^l) = \sigma(W^la^{l-1} + b^l)<br>$$<br>这个表示方法简洁漂亮，后面我们的讨论都会基于上面的这个矩阵法表示来。</p>
<h3 id="4-DNN前向传播算法"><a href="#4-DNN前向传播算法" class="headerlink" title="4. DNN前向传播算法"></a>4. DNN前向传播算法</h3><p>有了上一节的数学推导，DNN的前向传播算法也就不难了。所谓的DNN的前向传播算法也就是利用我们的若干个权重系数矩阵$W$,偏倚向量$b$来和输入值向量$x$进行一系列线性运算和激活运算，从输入层开始，一层层的向后计算，一直到运算到输出层，得到输出结果为值。</p>
<p>输入: 总层数L，所有隐藏层和输出层对应的矩阵$W$,偏倚向量$b$，输入值向量$x$</p>
<p>输出：输出层的输出$a^L$</p>
<p>1） 初始化$a^1 = x $</p>
<p>2)  forl = 2 to L, 计算：<br>$$<br>a^l = \sigma(z^l) = \sigma(W^la^{l-1} + b^l)<br>$$<br>最后的结果即为输出$a^L$。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="DNN前向传播算法小结"><a href="#DNN前向传播算法小结" class="headerlink" title="DNN前向传播算法小结"></a>DNN前向传播算法小结</h3><p>单独看DNN前向传播算法，似乎没有什么大用处，而且这一大堆的矩阵$W$,偏倚向量$b$对应的参数怎么获得呢？怎么得到最优的矩阵$W$,偏倚向量$b$呢？这个我们在讲DNN的反向传播算法时再讲。而理解反向传播算法的前提就是理解DNN的模型与前向传播算法。这也是我们这一篇先讲的原因。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>1） <a href="http://neuralnetworksanddeeplearning.com/index.html" target="_blank" rel="noopener">Neural Networks and Deep Learning</a> by By Michael Nielsen</p>
<p>2） <a href="http://www.deeplearningbook.org/" target="_blank" rel="noopener">Deep Learning</a>, book by Ian Goodfellow, Yoshua Bengio, and Aaron Courville</p>
<p>3） <a href="http://ufldl.stanford.edu/tutorial/" target="_blank" rel="noopener">UFLDL Tutorial</a> <a href="http://ufldl.stanford.edu/tutorial/supervised/MultiLayerNeuralNetworks/" target="_blank" rel="noopener">
</a> </p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[主成分分析（PCA）和白化（whitening）原理总结]]></title>
      <url>/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%EF%BC%88PCA%EF%BC%89%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>主成分分析（Principal components analysis，以下简称PCA）是最重要的降维方法之一。在数据压缩消除冗余和数据噪音消除等领域都有广泛的应用。一般我们提到降维最容易想到的算法就是PCA，下面我们就对PCA的原理做一个总结。</p>
<h2 id="主成分分析（PCA）原理总结"><a href="#主成分分析（PCA）原理总结" class="headerlink" title="主成分分析（PCA）原理总结"></a>主成分分析（PCA）原理总结</h2><h3 id="1-PCA的思想"><a href="#1-PCA的思想" class="headerlink" title="1. PCA的思想"></a>1. PCA的思想</h3><p>PCA顾名思义，就是找出数据里最主要的方面，用数据里最主要的方面来代替原始数据。具体的，假如我们的数据集是n维的，共有m个数据$(x^{(1)},x^{(2)},…,x^{(m)})$。我们希望将这m个数据的维度从n维降到n’维，希望这m个n’维的数据集尽可能的代表原始数据集。我们知道数据从n维降到n’维肯定会有损失，但是我们希望损失尽可能的小。那么如何让这n’维的数据尽可能表示原来的数据呢？</p>
<p>我们先看看最简单的情况，也就是n=2，n’=1,也就是将数据从二维降维到一维。数据如下图。我们希望找到某一个维度方向，它可以代表这两个维度的数据。图中列了两个向量方向，$u_1和u_2$，那么哪个向量可以更好的代表原始数据集呢？从直观上也可以看出，$u_1比u_2$好。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fotp9srn5zj30er0b33yh.jpg" alt=""></p>
<p>为什么$u_1比u_2$好呢？可以有两种解释，第一种解释是样本点到这个直线的距离足够近，第二种解释是样本点在这个直线上的投影能尽可能的分开。</p>
<p>假如我们把n’从1维推广到任意维，则我们的希望降维的标准为：样本点到这个超平面的距离足够近,或者说样本点在这个超平面上的投影能尽可能的分开。</p>
<p>基于上面的两种标准，我们可以得到PCA的两种等价推导。</p>
<h3 id="2-PCA的推导-基于小于投影距离"><a href="#2-PCA的推导-基于小于投影距离" class="headerlink" title="2. PCA的推导:基于小于投影距离"></a>2. PCA的推导:基于小于投影距离</h3><p>我们首先看第一种解释的推导，即样本点到这个超平面的距离足够近。</p>
<p>假设m个n维数据($(x^{(1)}, x^{(2)},…,x^{(m)})$都已经进行了标准化，即$\sum\limits_{i=1}^{m}x^{(i)}=0$。经过投影变换后得到的新坐标系为${w_1,w_2,…,w_n}$,其中$w$是标准正交基，即$||w||_2=1, w_i^Tw_j=0$。</p>
<p>如果我们将数据从n维降到n’维，即丢弃新坐标系中的部分坐标，则新的坐标系为${w_1,w_2,…,w_{n’}}$,样本点$x^{(i)}$在n’维坐标系中的投影为：$z^{(i)} = (z_1^{(i)}, z_2^{(i)},…,z_{n’}^{(i)})$.其中，$z_j^{(i)} = w_j^Tx^{(i)}$是$x^{(i)}$在低维坐标系里第j维的坐标。</p>
<p>如果我们用$z^{(i)}$来恢复原始数据$x^{(i)}$,则得到的恢复数据$\overline{x}^{(i)} = \sum\limits_{j=1}^{n’}z_j^{(i)}w_j = Wz^{(i)}$,其中，W为标准正交基组成的矩阵。</p>
<p>现在我们考虑整个样本集，我们希望所有的样本到这个超平面的距离足够近，即最小化下式：<br>$$<br>\sum\limits_{i=1}^{m}||\overline{x}^{(i)} - x^{(i)}||_2^2<br>$$<br>将这个式子进行整理，可以得到:<br>$$<br> \begin{align} \sum\limits_{i=1}^{m}||\overline{x}^{(i)} - x^{(i)}||_2^2 &amp; = \sum\limits_{i=1}^{m}|| Wz^{(i)} - x^{(i)}||_2^2 \\&amp; = \sum\limits_{i=1}^{m}(Wz^{(i)})^T(Wz^{(i)}) - 2\sum\limits_{i=1}^{m}(Wz^{(i)})^Tx^{(i)} + \sum\limits_{i=1}^{m} x^{(i)T}x^{(i)} \\&amp; = \sum\limits_{i=1}^{m}z^{(i)T}z^{(i)} - 2\sum\limits_{i=1}^{m}z^{(i)T}W^Tx^{(i)} +\sum\limits_{i=1}^{m} x^{(i)T}x^{(i)} \\&amp; = \sum\limits_{i=1}^{m}z^{(i)T}z^{(i)} - 2\sum\limits_{i=1}^{m}z^{(i)T}z^{(i)}+\sum\limits_{i=1}^{m} x^{(i)T}x^{(i)}  \\&amp; = - \sum\limits_{i=1}^{m}z^{(i)T}z^{(i)} + \sum\limits_{i=1}^{m} x^{(i)T}x^{(i)}  \\&amp; =   -tr( W^T（\sum\limits_{i=1}^{m}x^{(i)}x^{(i)T})W)  + \sum\limits_{i=1}^{m} x^{(i)T}x^{(i)} \\&amp; =  -tr( W^TXX^TW)  + \sum\limits_{i=1}^{m} x^{(i)T}x^{(i)}  \end{align}<br>$$<br>其中第（1）步用到了$\overline{x}^{(i)}=Wz^{(i)}$ ,第二步用到了平方和展开，第（3）步用到了矩阵转置公式$(AB)^T =B^TA^T$和$W^TW=I$,第（4）步用到了$z^{(i)}=W^Tx^{(i)}$，第（5）步合并同类项，第（6）步用到了$z^{(i)}=W^Tx^{(i)}$和矩阵的迹,第7步将代数和表达为矩阵形式。</p>
<p>注意到$\sum\limits_{i=1}^{m}x^{(i)}x^{(i)T}$是数据集的协方差矩阵，W的每一个向量$w_j$是标准正交基。而$\sum\limits_{i=1}^{m} x^{(i)T}x^{(i)}$是一个常量。最小化上式等价于：<br>$$<br>\underbrace{arg\;min}_{W}\;-tr( W^TXX^TW) \;\;s.t. W^TW=I<br>$$<br>这个最小化不难，直接观察也可以发现最小值对应的W由协方差矩阵$XX^T$最大的n’个特征值对应的特征向量组成。当然用数学推导也很容易。利用拉格朗日函数可以得到<br>$$<br>J(W) = -tr( W^TXX^TW) + \lambda(W^TW-I)<br>$$<br>对W求导有$-XX^TW+\lambda W=0$, 整理下即为：<br>$$<br>XX^TW=\lambda W<br>$$<br>这样可以更清楚的看出，W为$XX^T$的n’个特征向量组成的矩阵，而$\lambda$为$XX^T$的特征值。当我们将数据集从n维降到n’维时，需要找到最大的n’个特征值对应的特征向量。这n’个特征向量组成的矩阵W即为我们需要的矩阵。对于原始数据集，我们只需要用$z^{(i)}=W^Tx^{(i)}$,就可以把原始数据集降维到最小投影距离的n’维数据集。</p>
<p>如果你熟悉谱聚类的优化过程，就会发现和PCA的非常类似，只不过谱聚类是求前k个最小的特征值对应的特征向量，而PCA是求前k个最大的特征值对应的特征向量。　　</p>
<h3 id="3-PCA的推导-基于最大投影方差"><a href="#3-PCA的推导-基于最大投影方差" class="headerlink" title="3. PCA的推导:基于最大投影方差"></a>3. PCA的推导:基于最大投影方差</h3><p>现在我们再来看看基于最大投影方差的推导。</p>
<p>假设m个n维数据$(x^{(1)}, x^{(2)},…,x^{(m)})$都已经进行了标准化，即$\sum\limits_{i=1}^{m}x^{(i)}=0$。经过投影变换后得到的新坐标系${w_1,w_2,…,w_n}$,其中$w$是标准正交基，即$||w||_2=1, w_i^Tw_j=0$。</p>
<p>如果我们将数据从n维降到n’维，即丢弃新坐标系中的部分坐标，则新的坐标系为${w_1,w_2,…,w_{n’}}$,样本点$x^{(i)}$在n’维坐标系中的投影为：$z^{(i)} = (z_1^{(i)}, z_2^{(i)},…,z_{n’}^{(i)})$.其中，$z_j^{(i)} = w_j^Tx^{(i)}是x(i)x(i)x^{(i)}$在低维坐标系里第j维的坐标。</p>
<p>对于任意一个样本$x^{(i)}$，在新的坐标系中的投影为$W^Tx^{(i)}$,在新坐标系中的投影方差为$x^{(i)T}W^Tx^{(i)}W$，要使所有的样本的投影方差和最大，也就是最大化$\sum\limits_{i=1}^{m}x^{(i)T}W^Tx^{(i)}W$,即：<br>$$<br>\underbrace{arg\;max}_{W}\;tr( W^TXX^TW) \;\;s.t. W^TW=I<br>$$<br>观察第二节的基于最小投影距离的优化目标，可以发现完全一样，只是一个是加负号的最小化，一个是最大化。</p>
<p>利用拉格朗日函数可以得到<br>$$<br>J(W) = tr( W^TXX^TW) + \lambda(W^TW-I)<br>$$<br>对W求导有$XX^TW+\lambda W=0$, 整理下即为：<br>$$<br>XX^TW=（-\lambda）W<br>$$<br>和上面一样可以看出，W为$XX^T$的n’个特征向量组成的矩阵，而$-\lambda$为$XX^T$的特征值。当我们将数据集从n维降到n’维时，需要找到最大的n’个特征值对应的特征向量。这n’个特征向量组成的矩阵W即为我们需要的矩阵。对于原始数据集，我们只需要用$z^{(i)}=W^Tx^{(i)}$,就可以把原始数据集降维到最小投影距离的n’维数据集。</p>
<h3 id="4-PCA算法流程"><a href="#4-PCA算法流程" class="headerlink" title="4. PCA算法流程"></a>4. PCA算法流程</h3><p>从上面两节我们可以看出，求样本$x^{(i)}$的n’维的主成分其实就是求样本集的协方差矩阵$XX^T$的前n’个特征值对应特征向量矩阵W，然后对于每个样本$x^{(i)}$,做如下变换$z^{(i)}=W^Tx^{(i)}$，即达到降维的PCA目的。</p>
<p>下面我们看看具体的算法流程。</p>
<p>输入：n维样本集$D=(x^{(1)}, x^{(2)},…,x^{(m)})$，要降维到的维数n’.</p>
<p>输出：降维后的样本集$D’$</p>
<p>1) 对所有的样本进行中心化： $x^{(i)} = x^{(i)} - \frac{1}{m}\sum\limits_{j=1}^{m} x^{(j)}$</p>
<p>2) 计算样本的协方差矩阵$XX^T$</p>
<p>3) 对矩阵$XX^T$进行特征值分解</p>
<p>4）取出最大的n’个特征值对应的特征向量$(w_1,w_2,…,w_{n’})$, 将所有的特征向量标准化后，组成特征向量矩阵W。</p>
<p>5）对样本集中的每一个样本$x^{(i)}$,转化为新的样本$z^{(i)}=W^Tx^{(i)}$</p>
<p>6) 得到输出样本集$D’ =(z^{(1)}, z^{(2)},…,z^{(m)})$</p>
<p>有时候，我们不指定降维后的n’的值，而是换种方式，指定一个降维到的主成分比重阈值t。这个阈值t在（0,1]之间。假如我们的n个特征值为$\lambda_1 \geq \lambda_2 \geq … \geq \lambda_n$,则n’可以通过下式得到:<br>$$<br>\frac{\sum\limits_{i=1}^{n’}\lambda_i}{\sum\limits_{i=1}^{n}\lambda_i} \geq t<br>$$</p>
<h3 id="5-PCA实例"><a href="#5-PCA实例" class="headerlink" title="5. PCA实例"></a>5. PCA实例</h3><p>下面举一个简单的栗子🌰，说明PCA的过程。</p>
<p>假设我们的数据集有10个二维数据(2.5,2.4), (0.5,0.7), (2.2,2.9), (1.9,2.2), (3.1,3.0), (2.3, 2.7), (2, 1.6), (1, 1.1), (1.5, 1.6), (1.1, 0.9)，需要用PCA降到1维特征。</p>
<p>首先我们对样本中心化，这里样本的均值为(1.81, 1.91),所有的样本减去这个均值后，即中心化后的数据集为(0.69, 0.49), (-1.31, -1.21), (0.39, 0.99), (0.09, 0.29), (1.29, 1.09), (0.49, 0.79), (0.19, -0.31), (-0.81, -0.81), (-0.31, -0.31), (-0.71, -1.01)。</p>
<p>现在我们开始求样本的协方差矩阵，由于我们是二维的，则协方差矩阵为：</p>
<p>$$<br>\mathbf{XX^T} = \left( \begin{array}{ccc} cov(x_1,x_1) &amp; cov(x_1,x_2)\\   cov(x_2,x_1) &amp; cov(x_2,x_2) \end{array} \right)<br>$$<br>对于我们的数据，求出协方差矩阵为：<br>$$<br>\mathbf{XX^T} = \left( \begin{array}{ccc} 0.616555556 &amp; 0.615444444\\    0.615444444 &amp; 0.716555556 \end{array} \right)<br>$$<br>求出特征值为（0.490833989， 1.28402771），对应的特征向量分别为：$(0.735178656, 0.677873399)^T\;\; (-0.677873399, -0.735178656)^T$,由于最大的k=1个特征值为1.28402771，对于的k=1个特征向量为$(-0.677873399, -0.735178656)^T$. 则我们的$W=(-0.677873399, -0.735178656)^T$</p>
<p>我们对所有的数据集进行投影$z^{(i)}=W^Tx^{(i)}$，得到PCA降维后的10个一维数据集为：(-0.827970186， 1.77758033， -0.992197494， -0.274210416， -1.67580142， -0.912949103， 0.0991094375， 1.14457216, 0.438046137， 1.22382056)</p>
<h3 id="6-核主成分分析KPCA介绍"><a href="#6-核主成分分析KPCA介绍" class="headerlink" title="6. 核主成分分析KPCA介绍"></a>6. 核主成分分析KPCA介绍</h3><p>在上面的PCA算法中，我们假设存在一个线性的超平面，可以让我们对数据进行投影。但是有些时候，数据不是线性的，不能直接进行PCA降维。这里就需要用到和支持向量机一样的核函数的思想，先把数据集从n维映射到线性可分的高维N&gt;n,然后再从N维降维到一个低维度n’, 这里的维度之间满足n’&lt;n&lt;N。</p>
<p>使用了核函数的主成分分析一般称之为核主成分分析(Kernelized PCA, 以下简称KPCA。假设高维空间的数据是由n维空间的数据通过映射$\phi$产生。</p>
<p>则对于n维空间的特征分解：<br>$$<br> \sum\limits_{i=1}^{m}x^{(i)}x^{(i)T}W=\lambda W<br>$$<br>映射为：<br>$$<br> \sum\limits_{i=1}^{m}\phi(x^{(i)})\phi(x^{(i)})^TW=\lambda W<br>$$<br>通过在高维空间进行协方差矩阵的特征值分解，然后用和PCA一样的方法进行降维。一般来说，映射$\phi$不用显式的计算，而是在需要计算的时候通过核函数完成。由于KPCA需要核函数的运算，因此它的计算量要比PCA大很多。</p>
<h3 id="7-白化whitening"><a href="#7-白化whitening" class="headerlink" title="7. 白化whitening"></a>7. <strong>白化whitening</strong></h3><h4 id="一、相关理论"><a href="#一、相关理论" class="headerlink" title="一、相关理论"></a><strong>一、相关理论</strong></h4><p>白化这个词，可能在深度学习领域比较常遇到，挺起来就是高大上的名词，然而其实白化是一个比PCA稍微高级一点的算法而已，所以如果熟悉PCA，那么其实会发现这是一个非常简单的算法。</p>
<p>白化的目的是去除输入数据的冗余信息。假设训练数据是图像，由于图像中相邻像素之间具有很强的相关性，所以用于训练时输入是冗余的；白化的目的就是降低输入的冗余性。</p>
<p>输入数据集X，经过白化处理后，新的数据X’满足两个性质：</p>
<p>(1)特征之间相关性较低；</p>
<p>(2)所有特征具有相同的方差。</p>
<p>其实我们之前学的PCA算法中，可能PCA给我们的印象是一般用于降维操作。然而其实PCA如果不降维，而是仅仅使用PCA求出特征向量，然后把数据X映射到新的特征空间，这样的一个映射过程，其实就是满足了我们白化的第一个性质：除去特征之间的相关性。因此白化算法的实现过程，第一步操作就是PCA，求出新特征空间中X的新坐标，然后再对新的坐标进行方差归一化操作。</p>
<h4 id="二、算法概述"><a href="#二、算法概述" class="headerlink" title="二、算法概述"></a><strong>二、算法概述</strong></h4><p>白化分为PCA白化、ZCA白化，下面主要讲解算法实现。这部分主要是学了UFLDL的深度学习《白化》教程：<a href="http://ufldl.stanford.edu/wiki/index.php/%E7%99%BD%E5%8C%96" target="_blank" rel="noopener">http://ufldl.stanford.edu/wiki/index.php/%E7%99%BD%E5%8C%96</a> 。自己的一点概括总结，算法实现步骤如下：</p>
<h5 id="1、首先是PCA预处理"><a href="#1、首先是PCA预处理" class="headerlink" title="1、首先是PCA预处理"></a><strong>1、首先是PCA预处理</strong></h5><p><img src="http://img.blog.csdn.net/20160312120157759" alt="">     <img src="http://img.blog.csdn.net/20160312120205309" alt=""></p>
<p>上面图片，左图表示原始数据X，然后我们通过协方差矩阵可以求得特征向量u1、u2，然后把每个数据点，投影到这两个新的特征向量，得到进行坐标如下：</p>
<p><img src="http://img.blog.csdn.net/20160312120214088" alt=""> </p>
<p>这就是所谓的pca处理。</p>
<h5 id="2、PCA白化"><a href="#2、PCA白化" class="headerlink" title="2、PCA白化"></a><strong>2、PCA白化</strong></h5><p>所谓的pca白化是指对上面的pca的新坐标X’,每一维的特征做一个标准差归一化处理。因为从上面我们看到在新的坐标空间中，(x1,x2)两个坐标轴方向的数据明显标准差不同，因此我们接着要对新的每一维坐标做一个标注差归一化处理：</p>
<p><img src="http://img.blog.csdn.net/20160312121312585" alt=""></p>
<p>当然你也可以采用下面的公式：</p>
<p><img src="http://img.blog.csdn.net/20160312121413148" alt=""></p>
<p>X’为经过PCA处理的新PCA坐标空间,然后λi就是第i维特征对应的特征值（前面pca得到的特征值），ε是为了避免除数为0。</p>
<p><img src="http://img.blog.csdn.net/20160312121102984" alt=""></p>
<h5 id="3、ZCA白化"><a href="#3、ZCA白化" class="headerlink" title="3、ZCA白化"></a><strong>3、ZCA白化</strong></h5><p>ZCA白虎是在PCA白化的基础上，又进行处理的一个操作。具体的实现是把上面PCA白化的结果，又变换到原来坐标系下的坐标：</p>
<p><img src="http://img.blog.csdn.net/20160312121828206" alt=""></p>
<p>给人的感觉就像是在PCA空间做了处理完后，然后又把它变换到原始的数据空间。</p>
<p><img src="http://img.blog.csdn.net/20160312121921531" alt=""></p>
<p>具体源码实现如下：</p>
<pre><code>def zca_whitening(inputs):
    sigma = np.dot(inputs, inputs.T)/inputs.shape[1] #inputs是经过归一化处理的，所以这边就相当于计算协方差矩阵
    U,S,V = np.linalg.svd(sigma) #奇异分解
    epsilon = 0.1                #白化的时候，防止除数为0
    ZCAMatrix = np.dot(np.dot(U, np.diag(1.0/np.sqrt(np.diag(S) + epsilon))), U.T)                     #计算zca白化矩阵
    return np.dot(ZCAMatrix, inputs)   #白化变换
</code></pre><h3 id="8-PCA算法总结"><a href="#8-PCA算法总结" class="headerlink" title="8. PCA算法总结"></a>8. PCA算法总结</h3><p>这里对PCA算法做一个总结。作为一个非监督学习的降维方法，它只需要特征值分解，就可以对数据进行压缩，去噪。因此在实际场景应用很广泛。为了克服PCA的一些缺点，出现了很多PCA的变种，比如第六节的为解决非线性降维的KPCA，还有解决内存限制的增量PCA方法Incremental PCA，以及解决稀疏数据降维的PCA方法Sparse PCA等。</p>
<p>PCA算法的主要优点有：</p>
<p>1）仅仅需要以方差衡量信息量，不受数据集以外的因素影响。　</p>
<p>2）各主成分之间正交，可消除原始数据成分间的相互影响的因素。</p>
<p>3）计算方法简单，主要运算是特征值分解，易于实现。</p>
<p>PCA算法的主要缺点有：</p>
<p>1）主成分各个特征维度的含义具有一定的模糊性，不如原始样本特征的解释性强。</p>
<p>2）方差小的非主成分也可能含有对样本差异的重要信息，因降维丢弃可能对后续数据处理有影响。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[K-Means聚类算法]]></title>
      <url>/K-Means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>K-Means算法是无监督的聚类算法，它实现起来比较简单，聚类效果也不错，因此应用很广泛。K-Means算法有大量的变体，本文就从最传统的K-Means算法讲起，在其基础上讲述K-Means的优化变体方法。包括初始化优化K-Means++, 距离计算优化elkan K-Means算法和大数据情况下的优化Mini Batch K-Means算法。</p>
<h2 id="K-Means聚类算法原理"><a href="#K-Means聚类算法原理" class="headerlink" title="K-Means聚类算法原理"></a>K-Means聚类算法原理</h2><h3 id="1-K-Means原理初探"><a href="#1-K-Means原理初探" class="headerlink" title="1. K-Means原理初探"></a>1. K-Means原理初探</h3><p>K-Means算法的思想很简单，对于给定的样本集，按照样本之间的距离大小，将样本集划分为K个簇。让簇内的点尽量紧密的连在一起，而让簇间的距离尽量的大。</p>
<p>如果用数据表达式表示，假设簇划分为$(C_1,C_2,…C_k)$，则我们的目标是最小化平方误差E：<br>$$<br> E = \sum\limits_{i=1}^k\sum\limits_{x \in C_i} ||x-\mu_i||_2^2<br>$$<br>其中$\mu_i$是簇$C_i$的均值向量，有时也称为质心，表达式为：<br>$$<br>\mu_i = \frac{1}{|C_i|}\sum\limits_{x \in C_i}x<br>$$<br>如果我们想直接求上式的最小值并不容易，这是一个NP难的问题，因此只能采用启发式的迭代方法。</p>
<p>K-Means采用的启发式方式很简单，用下面一组图就可以形象的描述。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fot0rxyp38j30el0a2gly.jpg" alt=""></p>
<p>上图a表达了初始的数据集，假设k=2。在图b中，我们随机选择了两个k类所对应的类别质心，即图中的红色质心和蓝色质心，然后分别求样本中所有点到这两个质心的距离，并标记每个样本的类别为和该样本距离最小的质心的类别，如图c所示，经过计算样本和红色质心和蓝色质心的距离，我们得到了所有样本点的第一轮迭代后的类别。此时我们对我们当前标记为红色和蓝色的点分别求其新的质心，如图4所示，新的红色质心和蓝色质心的位置已经发生了变动。图e和图f重复了我们在图c和图d的过程，即将所有点的类别标记为距离最近的质心的类别并求新的质心。最终我们得到的两个类别如图f。</p>
<p>当然在实际K-Mean算法中，我们一般会多次运行图c和图d，才能达到最终的比较优的类别。</p>
<h3 id="2-传统K-Means算法流程"><a href="#2-传统K-Means算法流程" class="headerlink" title="2. 传统K-Means算法流程"></a>2. 传统K-Means算法流程</h3><p>在上一节我们对K-Means的原理做了初步的探讨，这里我们对K-Means的算法做一个总结。</p>
<p>首先我们看看K-Means算法的一些要点。</p>
<p>1）对于K-Means算法，首先要注意的是k值的选择，一般来说，我们会根据对数据的先验经验选择一个合适的k值，如果没有什么先验知识，则可以通过交叉验证选择一个合适的k值。</p>
<p>2）在确定了k的个数后，我们需要选择k个初始化的质心，就像上图b中的随机质心。由于我们是启发式方法，k个初始化的质心的位置选择对最后的聚类结果和运行时间都有很大的影响，因此需要选择合适的k个质心，最好这些质心不能太近。</p>
<p>好了，现在我们来总结下传统的K-Means算法流程。　</p>
<p>输入是样本集$D={x_1,x_2,…x_m}$,聚类的簇树k,最大迭代次数N</p>
<p>输出是簇划分$C={C_1,C_2,…C_k}$</p>
<p>1) 从数据集D中随机选择k个样本作为初始的k个质心向量： ${\mu_1,\mu_2,…,\mu_k}$</p>
<p>2）对于n=1,2,…,N</p>
<p>　　a) 将簇划分C初始化为$C_t = \varnothing \;\; t =1,2…k$</p>
<p>　　b) 对于i=1,2…m,计算样本xixix_i和各个质心向量$\mu_j(j=1,2,…k)$的距离：$d_{ij} = ||x_i - \mu_j||_2^2$，将$x_i$标记最小的为$d_{ij}$所对应的类别$\lambda_i$。此时更新$C_{\lambda_i} = C_{\lambda_i} \cup {x_i}$</p>
<p>　　c) 对于j=1,2,…,k,对$C_j$中所有的样本点重新计算新的质心$\mu_j = \frac{1}{|C_j|}\sum\limits_{x \in C_j}x$</p>
<p>　　e) 如果所有的k个质心向量都没有发生变化，则转到步骤3）</p>
<p>3） 输出簇划分$C={C_1,C_2,…C_k}$</p>
<h3 id="3-K-Means初始化优化K-Means"><a href="#3-K-Means初始化优化K-Means" class="headerlink" title="3. K-Means初始化优化K-Means++"></a>3. K-Means初始化优化K-Means++</h3><p>在上节我们提到，k个初始化的质心的位置选择对最后的聚类结果和运行时间都有很大的影响，因此需要选择合适的k个质心。如果仅仅是完全随机的选择，有可能导致算法收敛很慢。K-Means++算法就是对K-Means随机初始化质心的方法的优化。</p>
<p>K-Means++的对于初始化质心的优化策略也很简单，如下：</p>
<p> a)  从输入的数据点集合中随机选择一个点作为第一个聚类中心$\mu_1$<br>b) 对于数据集中的每一个点$x_i$，计算它与已选择的聚类中心中最近聚类中心的距离$D(x) = arg\;min \sum\limits_{r=1}^{k_{selected}}||x_i- \mu_r||_2^2$<br>c) 选择一个新的数据点作为新的聚类中心，选择的原则是：$D(x)$较大的点，被选取作为聚类中心的概率较大<br>d) 重复b和c直到选择出k个聚类质心<br>e) 利用这k个质心来作为初始化质心去运行标准的K-Means算法</p>
<h3 id="4-K-Means距离计算优化elkan-K-Means"><a href="#4-K-Means距离计算优化elkan-K-Means" class="headerlink" title="4. K-Means距离计算优化elkan K-Means"></a>4. K-Means距离计算优化elkan K-Means</h3><p>在传统的K-Means算法中，我们在每轮迭代时，要计算所有的样本点到所有的质心的距离，这样会比较的耗时。那么，对于距离的计算有没有能够简化的地方呢？elkan K-Means算法就是从这块入手加以改进。它的目标是减少不必要的距离的计算。那么哪些距离不需要计算呢？</p>
<p>elkan K-Means利用了两边之和大于等于第三边,以及两边之差小于第三边的三角形性质，来减少距离的计算。</p>
<p>第一种规律是对于一个样本点$x$和两个质心$\mu_{j_1}, \mu_{j_2}$。如果我们预先计算出了这两个质心之间的距离$D(j_1,j_2)$，则如果计算发现$2D(x,j_1) \leq D(j_1,j_2)$,我们立即就可以知道$D(x,j_1) \leq D(x, j_2)$。此时我们不需要再计算$D(x, j_2)$,也就是说省了一步距离计算。</p>
<p>第二种规律是对于一个样本点$x$和两个质心$\mu_{j_1}, \mu_{j_2}$。我们可以得到$D(x,j_2) \geq max{0, D(x,j_1) - D(j_1,j_2)}$。这个从三角形的性质也很容易得到。</p>
<p>利用上边的两个规律，elkan K-Means比起传统的K-Means迭代速度有很大的提高。但是如果我们的样本的特征是稀疏的，有缺失值的话，这个方法就不使用了，此时某些距离无法计算，则不能使用该算法。</p>
<h3 id="5-大样本优化Mini-Batch-K-Means"><a href="#5-大样本优化Mini-Batch-K-Means" class="headerlink" title="5. 大样本优化Mini Batch K-Means"></a>5. 大样本优化Mini Batch K-Means</h3><p>在统的K-Means算法中，要计算所有的样本点到所有的质心的距离。如果样本量非常大，比如达到10万以上，特征有100以上，此时用传统的K-Means算法非常的耗时，就算加上elkan K-Means优化也依旧。在大数据时代，这样的场景越来越多。此时Mini Batch K-Means应运而生。</p>
<p>顾名思义，Mini Batch，也就是用样本集中的一部分的样本来做传统的K-Means，这样可以避免样本量太大时的计算难题，算法收敛速度大大加快。当然此时的代价就是我们的聚类的精确度也会有一些降低。一般来说这个降低的幅度在可以接受的范围之内。</p>
<p>在Mini Batch K-Means中，我们会选择一个合适的批样本大小batch size，我们仅仅用batch size个样本来做K-Means聚类。那么这batch size个样本怎么来的？一般是通过无放回的随机采样得到的。</p>
<p>为了增加算法的准确性，我们一般会多跑几次Mini Batch K-Means算法，用得到不同的随机采样集来得到聚类簇，选择其中最优的聚类簇。</p>
<h3 id="6-K-Means与KNN"><a href="#6-K-Means与KNN" class="headerlink" title="6. K-Means与KNN"></a>6. K-Means与KNN</h3><p>初学者很容易把K-Means和KNN搞混，两者其实差别还是很大的。</p>
<p>K-Means是无监督学习的聚类算法，没有样本输出；而KNN是监督学习的分类算法，有对应的类别输出。KNN基本不需要训练，对测试集里面的点，只需要找到在训练集中最近的k个点，用这最近的k个点的类别来决定测试点的类别。而K-Means则有明显的训练过程，找到k个类别的最佳质心，从而决定样本的簇类别。</p>
<p>当然，两者也有一些相似点，两个算法都包含一个过程，即找出和某一个点最近的点。两者都利用了最近邻(nearest neighbors)的思想。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="K-Means小结"><a href="#K-Means小结" class="headerlink" title="K-Means小结"></a>K-Means小结</h3><p>K-Means是个简单实用的聚类算法，这里对K-Means的优缺点做一个总结。</p>
<p>K-Means的主要优点有：</p>
<p>1）原理比较简单，实现也是很容易，收敛速度快。</p>
<p>2）聚类效果较优。</p>
<p>3）算法的可解释度比较强。</p>
<p>4）主要需要调参的参数仅仅是簇数k。</p>
<p>K-Means的主要缺点有：</p>
<p>1）K值的选取不好把握</p>
<p>2）对于不是凸的数据集比较难收敛</p>
<p>3）如果各隐含类别的数据不平衡，比如各隐含类别的数据量严重失衡，或者各隐含类别的方差不同，则聚类效果不佳。</p>
<p>4） 采用迭代方法，得到的结果只是局部最优。</p>
<p>5） 对噪音和异常点比较的敏感。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[支持向量机原理(五)线性支持回归]]></title>
      <url>/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%8E%9F%E7%90%86-%E4%BA%94-%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%9B%9E%E5%BD%92.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://pancakeawesome.ink/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%8E%9F%E7%90%86-%E4%B8%80-%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html">支持向量机原理(一) 线性支持向量机</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-二-线性支持向量机的软间隔最大化模型.html">支持向量机原理(二) 线性支持向量机的软间隔最大化模型</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-三-线性不可分支持向量机与核函数.html">支持向量机原理(三)线性不可分支持向量机与核函数</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-四-SMO算法原理.html">支持向量机原理(四)SMO算法原理</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-五-线性支持回归.html">支持向量机原理(五)线性支持回归</a></p>
<p>在前四篇里面我们讲到了SVM的线性分类和非线性分类，以及在分类时用到的算法。这些都关注与SVM的分类问题。实际上SVM也可以用于回归模型，本篇就对如何将SVM用于回归模型做一个总结。重点关注SVM分类和SVM回归的相同点与不同点。</p>
<h2 id="支持向量机原理-五-线性支持回归"><a href="#支持向量机原理-五-线性支持回归" class="headerlink" title="支持向量机原理(五)线性支持回归"></a>支持向量机原理(五)线性支持回归</h2><h3 id="1-SVM回归模型的损失函数度量"><a href="#1-SVM回归模型的损失函数度量" class="headerlink" title="1. SVM回归模型的损失函数度量"></a>1. SVM回归模型的损失函数度量</h3><p>回顾下我们前面SVM分类模型中，我们的目标函数是让$\frac{1}{2}||w||_2^2$最小，同时让各个训练集中的点尽量远离自己类别一边的的支持向量，即$y_i(w \bullet \phi(x_i )+ b) \geq 1$。如果是加入一个松弛变量$\xi_i \geq 0$,则目标函数是$\frac{1}{2}||w||_2^2 +C\sum\limits_{i=1}^{m}\xi_i$,对应的约束条件变成：$y_i(w \bullet \phi(x_i ) + b )  \geq 1 - \xi_i $</p>
<p>但是我们现在是回归模型，优化目标函数可以继续和SVM分类模型保持一致为$\frac{1}{2}||w||_2^2$，但是约束条件呢？不可能是让各个训练集中的点尽量远离自己类别一边的的支持向量，因为我们是回归模型，没有类别。对于回归模型，我们的目标是让训练集中的每个点$(x_i,y_i)$,尽量拟合到一个线性模型$y_i ~= w \bullet \phi(x_i ) +b$ 。对于一般的回归模型，我们是用均方差作为损失函数,但是SVM不是这样定义损失函数的。</p>
<p>SVM需要我们定义一个常量$\epsilon &gt; 0$ ,对于某一个点$(x_i,y_i)$，如果$|y_i - w \bullet \phi(x_i ) -b| \leq \epsilon$，则完全没有损失，如果$|y_i - w \bullet \phi(x_i ) -b| &gt; \epsilon$,则对应的损失为$|y_i - w \bullet \phi(x_i ) -b| - \epsilon$，这个均方差损失函数不同，如果是均方差，那么只要$y_i - w \bullet \phi(x_i ) -b \neq 0$，那么就会有损失。</p>
<p>如下图所示，在蓝色条带里面的点都是没有损失的，但是外面的点的是有损失的，损失大小为红色线的长度。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1forrzhjkgzj309h09fjr9.jpg" alt=""></p>
<p>总结下，我们的SVM回归模型的损失函数度量为：<br>$$<br> err(x_i,y_i) =  \begin{cases} 0 &amp; {|y_i - w \bullet \phi(x_i ) -b| \leq \epsilon}\\ |y_i - w \bullet \phi(x_i ) +b| - \epsilon &amp; {|y_i - w \bullet \phi(x_i ) -b| &gt; \epsilon} \end{cases}<br>$$</p>
<h3 id="2-SVM回归模型的目标函数的原始形式"><a href="#2-SVM回归模型的目标函数的原始形式" class="headerlink" title="2. SVM回归模型的目标函数的原始形式"></a>2. SVM回归模型的目标函数的原始形式</h3><p>上一节我们已经得到了我们的损失函数的度量，现在可以可以定义我们的目标函数如下：<br>$$<br>min\;\; \frac{1}{2}||w||_2^2  \;\; s.t \;\; |y_i - w \bullet \phi(x_i ) -b| \leq \epsilon (i =1,2,…m)<br>$$<br>和SVM分类模型相似，回归模型也可以对每个样本$(x_i,y_i)$加入松弛变量$\xi_i \geq 0$, 但是由于我们这里用的是绝对值，实际上是两个不等式，也就是说两边都需要松弛变量，我们定义为$\xi_i^{\lor}, \xi_i^{\land}$, 则我们SVM回归模型的损失函数度量在加入松弛变量之后变为：<br>$$<br>min\;\; \frac{1}{2}||w||_2^2 + C\sum\limits_{i=1}^{m}(\xi_i^{\lor}+ \xi_i^{\land})<br>$$<br>$$<br>s.t. \;\;\; -\epsilon - \xi_i^{\lor} \leq y_i - w \bullet \phi(x_i ) -b \leq \epsilon + \xi_i^{\land}<br>$$<br>$$<br>\xi_i^{\lor} \geq 0, \;\; \xi_i^{\land} \geq 0 \;(i = 1,2,…, m)<br>$$<br>依然和SVM分类模型相似，我们可以用拉格朗日函数将目标优化函数变成无约束的形式，也就是拉格朗日函数的原始形式如下：<br>$$<br>L(w,b,\alpha^{\lor}, \alpha^{\land}, \xi_i^{\lor}, \xi_i^{\land}, \mu^{\lor}, \mu^{\land}) = \frac{1}{2}||w||_2^2 + C\sum\limits_{i=1}^{m}(\xi_i^{\lor}+ \xi_i^{\land}) + \sum\limits_{i=1}^{m}\alpha^{\lor}(-\epsilon - \xi_i^{\lor} -y_i + w \bullet \phi(x_i) + b) +<br>$$<br>$$<br>\sum\limits_{i=1}^{m}\alpha^{\land}(y_i - w \bullet \phi(x_i ) - b -\epsilon - \xi_i^{\land}) - \sum\limits_{i=1}^{m}\mu^{\lor}\xi_i^{\lor} - \sum\limits_{i=1}^{m}\mu^{\land}\xi_i^{\land}<br>$$<br>其中 $\mu^{\lor} \geq 0, \mu^{\land} \geq 0, \alpha_i^{\lor} \geq 0, \alpha_i^{\land} \geq 0$,均为拉格朗日系数。</p>
<h3 id="3-SVM回归模型的目标函数的对偶形式"><a href="#3-SVM回归模型的目标函数的对偶形式" class="headerlink" title="3. SVM回归模型的目标函数的对偶形式"></a>3. SVM回归模型的目标函数的对偶形式</h3><p>上一节我们讲到了SVM回归模型的目标函数的原始形式,我们的目标是<br>$$<br>\underbrace{min}_{w,b,\xi_i^{\lor}, \xi_i^{\land}}\; \;\;\;\;\;\;\;\;\underbrace{max}_{\mu^{\lor} \geq 0, \mu^{\land} \geq 0, \alpha_i^{\lor} \geq 0, \alpha_i^{\land} \geq 0}\;L(w,b,\alpha^{\lor}, \alpha^{\land}, \xi_i^{\lor}, \xi_i^{\land}, \mu^{\lor}, \mu^{\land})<br>$$<br>和SVM分类模型一样，这个优化目标也满足KKT条件，也就是说，我们可以通过拉格朗日对偶将我们的优化问题转化为等价的对偶问题来求解如下：<br>$$<br>\underbrace{max}_{\mu^{\lor} \geq 0, \mu^{\land} \geq 0, \alpha_i^{\lor} \geq 0, \alpha_i^{\land} \geq 0}\; \;\;\;\;\;\;\;\;\underbrace{min}_{w,b,\xi_i^{\lor}, \xi_i^{\land}}\;L(w,b,\alpha^{\lor}, \alpha^{\land}, \xi_i^{\lor}, \xi_i^{\land}, \mu^{\lor}, \mu^{\land})<br>$$<br>我们可以先求优化函数对于$w,b,\xi_i^{\lor}, \xi_i^{\land}$的极小值, 接着再求拉格朗日乘子$\alpha^{\lor}, \alpha^{\land}, \mu^{\lor}, \mu^{\land}$的极大值。</p>
<p>首先我们来求优化函数对于$w,b,\xi_i^{\lor}, \xi_i^{\land}$的极小值，这个可以通过求偏导数求得：<br>$$<br>\frac{\partial L}{\partial w} = 0 \;\Rightarrow w = \sum\limits_{i=1}^{m}(\alpha_i^{\land} - \alpha_i^{\lor})\phi(x_i)<br>$$<br>$$<br>\frac{\partial L}{\partial b} = 0 \;\Rightarrow  \sum\limits_{i=1}^{m}(\alpha_i^{\land} - \alpha_i^{\lor}) = 0<br>$$<br>$$<br>\frac{\partial L}{\partial \xi_i^{\lor}} = 0 \;\Rightarrow C-\alpha^{\lor}-\mu^{\lor} = 0<br>$$<br>$$<br>\frac{\partial L}{\partial \xi_i^{\land}} = 0 \;\Rightarrow C-\alpha^{\land}-\mu^{\land} = 0<br>$$<br>好了，我们可以把上面4个式子带入$L(w,b,\alpha^{\lor}, \alpha^{\land}, \xi_i^{\lor}, \xi_i^{\land}, \mu^{\lor}, \mu^{\land}) $去消去$w,b,\xi_i^{\lor}, \xi_i^{\land}$了。</p>
<p>看似很复杂，其实消除过程和系列第一篇第二篇文章类似，由于式子实在是冗长，这里我就不写出推导过程了，最终得到的对偶形式为：<br>$$<br> \underbrace{ max }_{\alpha^{\lor}, \alpha^{\land}}\; -\sum\limits_{i=1}^{m}(\epsilon-y_i)\alpha_i^{\land}+ (\epsilon+y_i)\alpha_i^{\lor}) - \frac{1}{2}\sum\limits_{i=1,j=1}^{m}(\alpha_i^{\land} - \alpha_i^{\lor})(\alpha_j^{\land} - \alpha_j^{\lor})K_{ij}<br>$$<br>$$<br> s.t. \; \sum\limits_{i=1}^{m}(\alpha_i^{\land} - \alpha_i^{\lor}) = 0<br>$$<br>$$<br> 0 &lt; \alpha_i^{\lor} &lt; C \; (i =1,2,…m)<br>$$<br>$$<br> 0 &lt; \alpha_i^{\land} &lt; C \; (i =1,2,…m)<br>$$<br> 对目标函数取负号，求最小值可以得到和SVM分类模型类似的求极小值的目标函数如下：<br>$$<br> \underbrace{ min}_{\alpha^{\lor}, \alpha^{\land}}\; \frac{1}{2}\sum\limits_{i=1,j=1}^{m}(\alpha_i^{\land} - \alpha_i^{\lor})(\alpha_j^{\land} - \alpha_j^{\lor})K_{ij} + \sum\limits_{i=1}^{m}(\epsilon-y_i)\alpha_i^{\land}+ (\epsilon+y_i)\alpha_i^{\lor}<br>$$<br>$$<br> s.t. \; \sum\limits_{i=1}^{m}(\alpha_i^{\land} - \alpha_i^{\lor}) = 0<br>$$<br>$$<br> 0 &lt; \alpha_i^{\lor} &lt; C \; (i =1,2,…m)<br>$$<br>$$<br> 0 &lt; \alpha_i^{\land} &lt; C \; (i =1,2,…m)<br>$$<br>对于这个目标函数，我们依然可以用第四篇讲到的SMO算法来求出对应的$\alpha^{\lor}, \alpha^{\land}$，进而求出我们的回归模型系数$w, b$。</p>
<h3 id="4-SVM回归模型系数的稀疏性"><a href="#4-SVM回归模型系数的稀疏性" class="headerlink" title="4. SVM回归模型系数的稀疏性"></a>4. SVM回归模型系数的稀疏性</h3><p>在SVM分类模型中，我们的KKT条件的对偶互补条件为： <img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fors6ab9naj307d00v742.jpg" alt="">，而在回归模型中，我们的对偶互补条件类似如下：<br>$$<br>\alpha_i^{\lor}(\epsilon + \xi_i^{\lor} + y_i - w \bullet \phi(x_i ) - b ) = 0<br>α∧i(ϵ+ξ∧i−yi+w∙ϕ(xi)+b)=0αi∧(ϵ+ξi∧−yi+w∙ϕ(xi)+b)=0<br>\alpha_i^{\land}(\epsilon + \xi_i^{\land} - y_i + w \bullet \phi(x_i ) + b ) = 0<br>$$<br>根据松弛变量定义条件，如果$y_i - w \bullet \phi(x_i ) -b| &lt; \epsilon$，我们有$\xi_i^{\lor} = 0, \xi_i^{\land}= 0$，此时$\epsilon + \xi_i^{\lor} + y_i - w \bullet \phi(x_i ) - b \neq 0, \epsilon + \xi_i^{\land} - y_i + w \bullet \phi(x_i ) + b \neq 0$这样要满足对偶互补条件，只有$\alpha_i^{\lor} = 0, \alpha_i^{\land} = 0$。</p>
<p>我们定义样本系数系数<br>$$<br>\beta_i =\alpha_i^{\land}-\alpha_i^{\lor}<br>$$<br>根据上面$w$的计算式$w = \sum\limits_{i=1}^{m}(\alpha_i^{\land} - \alpha_i^{\lor})\phi(x_i) $，我们发现此时$\beta_i = 0$,也就是说$w$不受这些在误差范围内的点的影响。对于在边界上或者在边界外的点，$\alpha_i^{\lor} \neq 0, \alpha_i^{\land} \neq 0，此时βi≠0βi≠0\beta_i \neq 0$。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="SVM-算法小结"><a href="#SVM-算法小结" class="headerlink" title="SVM 算法小结"></a>SVM 算法小结</h3><p>这个系列终于写完了，这里按惯例SVM 算法做一个总结。SVM算法是一个很优秀的算法，在集成学习和神经网络之类的算法没有表现出优越性能前，SVM基本占据了分类模型的统治地位。目前则是在大数据时代的大样本背景下,SVM由于其在大样本时超级大的计算量，热度有所下降，但是仍然是一个常用的机器学习算法。</p>
<p>SVM算法的主要优点有：</p>
<p>1) 解决高维特征的分类问题和回归问题很有效,在特征维度大于样本数时依然有很好的效果。</p>
<p>2) 仅仅使用一部分支持向量来做超平面的决策，无需依赖全部数据。</p>
<p>3) 有大量的核函数可以使用，从而可以很灵活的来解决各种非线性的分类回归问题。</p>
<p>4)样本量不是海量数据的时候，分类准确率高，泛化能力强。</p>
<p>SVM算法的主要缺点有：</p>
<p>1) 如果特征维度远远大于样本数，则SVM表现一般。</p>
<p>2) SVM在样本量非常大，核函数映射维度非常高时，计算量过大，不太适合使用。</p>
<p>3）非线性问题的核函数的选择没有通用标准，难以选择一个合适的核函数。</p>
<p>4）SVM对缺失数据敏感。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[支持向量机原理(四)SMO算法原理]]></title>
      <url>/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%8E%9F%E7%90%86-%E5%9B%9B-SMO%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://pancakeawesome.ink/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%8E%9F%E7%90%86-%E4%B8%80-%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html">支持向量机原理(一) 线性支持向量机</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-二-线性支持向量机的软间隔最大化模型.html">支持向量机原理(二) 线性支持向量机的软间隔最大化模型</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-三-线性不可分支持向量机与核函数.html">支持向量机原理(三)线性不可分支持向量机与核函数</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-四-SMO算法原理.html">支持向量机原理(四)SMO算法原理</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-五-线性支持回归.html">支持向量机原理(五)线性支持回归</a></p>
<p>　　在SVM的前三篇里，我们优化的目标函数最终都是一个关于$\alpha$向量的函数。而怎么极小化这个函数，求出对应的$\alpha$向量，进而求出分离超平面我们没有讲。本篇就对优化这个关于$\alpha$向量的函数的SMO算法做一个总结。</p>
<h2 id="支持向量机原理-四-SMO算法原理"><a href="#支持向量机原理-四-SMO算法原理" class="headerlink" title="支持向量机原理(四)SMO算法原理"></a>支持向量机原理(四)SMO算法原理</h2><h3 id="1-回顾SVM优化目标函数"><a href="#1-回顾SVM优化目标函数" class="headerlink" title="1. 回顾SVM优化目标函数"></a>1. 回顾SVM优化目标函数</h3><p>我们首先回顾下我们的优化目标函数：<br>$$<br> \underbrace{ min }_{\alpha}  \frac{1}{2}\sum\limits_{i=1,j=1}^{m}\alpha_i\alpha_jy_iy_jK(x_i,x_j) - \sum\limits_{i=1}^{m}\alpha_i<br>$$</p>
<p>$$<br> s.t. \; \sum\limits_{i=1}^{m}\alpha_iy_i = 0<br>$$</p>
<p>$$<br>0 \leq \alpha_i \leq C<br>$$<br>我们的解要满足的KKT条件的对偶互补条件为：<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1forp7ae6lej308101p742.jpg" alt=""><br>根据这个KKT条件的对偶互补条件，我们有：<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1foro11f8j6j30pc01e0sl.jpg" alt=""><br> 由于<img src="https://ws1.sinaimg.cn/large/006tKfTcgy1foro1qglmqj305f01q0si.jpg" alt="">我们令<img src="https://ws2.sinaimg.cn/large/006tKfTcgy1foro241li2j30b001k0sj.jpg" alt="">，则有：<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1foro2b40gtj307q04hweb.jpg" alt=""></p>
<h1 id="2-SMO算法的基本思想"><a href="#2-SMO算法的基本思想" class="headerlink" title="2. SMO算法的基本思想"></a>2. SMO算法的基本思想</h1><p>上面这个优化式子比较复杂，里面有m个变量组成的向量$\alpha$需要在目标函数极小化的时候求出。直接优化时很难的。SMO算法则采用了一种启发式的方法。它每次只优化两个变量，将其他的变量都视为常数。由于$\sum\limits_{i=1}^{m}\alpha_iy_i = 0$.假如将$\alpha_3, \alpha_4, …, \alpha_m$　固定，那么$\alpha_1, \alpha_2$之间的关系也确定了。这样SMO算法将一个复杂的优化算法转化为一个比较简单的两变量优化问题。</p>
<p>为了后面表示方便，我们定义$K_{ij} = \phi(x_i) \bullet \phi(x_j)$</p>
<p>由于$\alpha_3, \alpha_4, …, \alpha_m$都成了常量，所有的常量我们都从目标函数去除，这样我们上一节的目标优化函数变成下式：<br>$$<br>\;\underbrace{ min }_{\alpha_1, \alpha_1} \frac{1}{2}K_{11}\alpha_1^2 + \frac{1}{2}K_{22}\alpha_2^2 +y_1y_2K_{12}\alpha_1 \alpha_2 -(\alpha_1 + \alpha_2) +y_1\alpha_1\sum\limits_{i=3}^{m}y_i\alpha_iK_{i1} + y_2\alpha_2\sum\limits_{i=3}^{m}y_i\alpha_iK_{i2}<br>$$</p>
<p>$$<br>s.t. \;\;\alpha_1y_1 +  \alpha_2y_2 = -\sum\limits_{i=3}^{m}y_i\alpha_i = \varsigma<br>$$</p>
<p>$$<br>0 \leq \alpha_i \leq C \;\; i =1,2<br>$$</p>
<h1 id="3-SMO算法目标函数的优化"><a href="#3-SMO算法目标函数的优化" class="headerlink" title="3. SMO算法目标函数的优化"></a>3. SMO算法目标函数的优化</h1><p>为了求解上面含有这两个变量的目标优化问题，我们首先分析约束条件，所有的$\alpha_1, \alpha_2$都要满足约束条件，然后在约束条件下求最小。</p>
<p>根据上面的约束条件$\alpha_1y_1 +  \alpha_2y_2  = \varsigma\;\;0 \leq \alpha_i \leq C \;\; i =1,2，$又由于$y_1,y_2$均只能取值1或者-1, 这样$\alpha_1, \alpha_2$在[0,C]和[0,C]形成的盒子里面，并且两者的关系直线的斜率只能为1或者-1，也就是说$\alpha_1, \alpha_2$的关系直线平行于[0,C]和[0,C]形成的盒子的对角线，如下图所示：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fornyq39a0j30ev06bweg.jpg" alt=""></p>
<p> 由于$\alpha_1, \alpha_2$的关系被限制在盒子里的一条线段上，所以两变量的优化问题实际上仅仅是一个变量的优化问题。不妨我们假设最终是$\alpha_2$的优化问题。由于我们采用的是启发式的迭代法，假设我们上一轮迭代得到的解是$\alpha_1^{old}, \alpha_2^{old}$，假设沿着约束方向$\alpha_2$未经剪辑的解是$\alpha_2^{new,unc}$.本轮迭代完成后的解为$\alpha_1^{new}, \alpha_2^{new}$</p>
<p>由于$\alpha_2^{new}$必须满足上图中的线段约束。假设L和H分别是上图中$\alpha_2^{new}$所在的线段的边界。那么很显然我们有：<br>$$<br>L \leq \alpha_2^{new} \leq H<br>$$<br>而对于L和H，我们也有限制条件如果是上面左图中的情况，则<br>$$<br>L = max(0, \alpha_2^{old}-\alpha_1^{old}) \;\;\;H = min(C, C+\alpha_2^{old}-\alpha_1^{old})<br>$$<br>如果是上面右图中的情况，我们有：<br>$$<br>L = max(0, \alpha_2^{old}+\alpha_1^{old}-C) \;\;\; H = min(C, \alpha_2^{old}+\alpha_1^{old})<br>$$<br> 也就是说，假如我们通过求导得到的$\alpha_2^{new,unc}$，则最终的$\alpha_2^{new}$应该为：<br>$$<br>\alpha_2^{new}= \begin{cases} H&amp; {L \leq \alpha_2^{new,unc} &gt; H}\\ \alpha_2^{new,unc}&amp; {L \leq \alpha_2^{new,unc} \leq H}\\ L&amp; {\alpha_2^{new,unc} &lt; L} \end{cases}<br>$$<br>那么如何求出$\alpha_2^{new,unc}$呢？很简单，我们只需要将目标函数对$\alpha_2$求偏导数即可。</p>
<p>首先我们整理下我们的目标函数。</p>
<p>为了简化叙述，我们令<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fornz5u6p7j30bt02e3yb.jpg" alt=""><br>其中$g(x)$就是我们在第一节里面的提到的<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fornzbmr4rj30c702qa9v.jpg" alt=""><br>我们令<br>$$<br>v_i = \sum\limits_{i=3}^{m}y_j\alpha_jK(x_i,x_j) = g(x_i) -  \sum\limits_{i=1}^{2}y_j\alpha_jK(x_i,x_j) -b<br>$$<br>这样我们的优化目标函数进一步简化为：<br>$$<br>W(\alpha_1,\alpha_2) = \frac{1}{2}K_{11}\alpha_1^2 + \frac{1}{2}K_{22}\alpha_2^2 +y_1y_2K_{12}\alpha_1 \alpha_2 -(\alpha_1 + \alpha_2) +y_1\alpha_1v_1 +  y_2\alpha_2v_2<br>$$<br>由于$\alpha_1y_1 +  \alpha_2y_2 =  \varsigma$ ，并且$y_i^2 = 1$，可以得到$\alpha_1用 \alpha_2$表达的式子为：<br>$$<br>\alpha_1 = y_1(\varsigma  - \alpha_2y_2)<br>$$<br>将上式带入我们的目标优化函数，就可以消除$\alpha_1$,得到仅仅包含$\alpha_2$的式子。<br>$$<br>W(\alpha_2) = \frac{1}{2}K_{11}(\varsigma  - \alpha_2y_2)^2 + \frac{1}{2}K_{22}\alpha_2^2 +y_2K_{12}(\varsigma - \alpha_2y_2) \alpha_2 -(\alpha_1 + \alpha_2) +(\varsigma  - \alpha_2y_2)v_1 +  y_2\alpha_2v_2<br>$$<br>忙了半天，我们终于可以开始求$\alpha_2^{new,unc}$了，现在我们开始通过求偏导数来得到$\alpha_2^{new,unc}$。<br>$$<br>\frac{\partial W}{\partial \alpha_2} = K_{11}\alpha_2 +  K_{22}\alpha_2 -2K_{12}\alpha_2 -  K_{11}\varsigma y_2 + K_{12}\varsigma y_2 +y_1y_2 -1 -v_1y_2 +y_2v_2 = 0<br>$$<br>整理上式有：<br>$$<br>(K_{11} +K_{22}-2K_{12})\alpha_2 = y_2(y_2-y_1 + \varsigma  K_{11} - \varsigma  K_{12} + v_1 - v_2)<br>$$<br>$$<br> = y_2(y_2-y_1 + \varsigma  K_{11} - \varsigma  K_{12} + (g(x_1) -  \sum\limits_{j=1}^{2}y_j\alpha_jK_{1j} -b ) -(g(x_2) -  \sum\limits_{j=1}^{2}y_j\alpha_jK_{2j} -b))<br>$$<br>将$ \varsigma  = \alpha_1y_1 +  \alpha_2y_2 $带入上式，我们有：<br>$$<br>(K_{11} +K_{22}-2K_{12})\alpha_2^{new,unc} = y_2((K_{11} +K_{22}-2K_{12})\alpha_2^{old}y_2 +y_2-y_1 +g(x_1) - g(x_2))<br>$$<br>$$<br>\;\;\;\; = (K_{11} +K_{22}-2K_{12}) \alpha_2^{old} + y2(E_1-E_2)<br>$$<br>我们终于得到了$\alpha_2^{new,unc}$的表达式：<br>$$<br>\alpha_2^{new,unc} = \alpha_2^{old} + \frac{y2(E_1-E_2)}{K_{11} +K_{22}-2K_{12})}<br>$$<br>利用上面讲到的$\alpha_2^{new,unc}$和$\alpha_2^{new}$的关系式，我们就可以得到我们新的$\alpha_2^{new}$了。利用$\alpha_2^{new}$和$\alpha_1^{new}$的线性关系，我们也可以得到新的$\alpha_1^{new}$。</p>
<h1 id="4-SMO算法两个变量的选择"><a href="#4-SMO算法两个变量的选择" class="headerlink" title="4. SMO算法两个变量的选择"></a>4. SMO算法两个变量的选择</h1><p>SMO算法需要选择合适的两个变量做迭代，其余的变量做常量来进行优化，那么怎么选择这两个变量呢？</p>
<h2 id="4-1-第一个变量的选择"><a href="#4-1-第一个变量的选择" class="headerlink" title="4.1 第一个变量的选择"></a>4.1 第一个变量的选择</h2><p>SMO算法称选择第一个变量为外层循环，这个变量需要选择在训练集中违反KKT条件最严重的样本点。对于每个样本点，要满足的KKT条件我们在第一节已经讲到了：<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1foro4bncwvj30il01nq2r.jpg" alt=""><br>一般来说，我们首先选择违反<img src="https://ws1.sinaimg.cn/large/006tKfTcgy1foro4magrqj305i00zq2p.jpg" alt=""> 这个条件的点。如果这些支持向量都满足KKT条件，再选择违反<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1foro4v0b61j305e00rq2p.jpg" alt="">和 <img src="https://ws2.sinaimg.cn/large/006tKfTcgy1foro564fbgj305g00st8h.jpg" alt="">的点。</p>
<h2 id="4-2-第二个变量的选择"><a href="#4-2-第二个变量的选择" class="headerlink" title="4.2 第二个变量的选择"></a>4.2 第二个变量的选择</h2><p> SMO算法称选择第二一个变量为内层循环，假设我们在外层循环已经找到了$\alpha_1$, 第二个变量$\alpha_2$的选择标准是让$|E1-E2|$有足够大的变化。由于$\alpha_1$定了的时候,$E_1$也确定了，所以要想$|E1-E2|$最大，只需要在$E_1$为正时，选择最小的$E_i$作为$E_2$， 在$E_1$为负时，选择最大的$E_i$作为$E_2$，可以将所有的$E_i$保存下来加快迭代。</p>
<p>如果内存循环找到的点不能让目标函数有足够的下降， 可以采用遍历支持向量点来做$\alpha_2$,直到目标函数有足够的下降， 如果所有的支持向量做$\alpha_2$都不能让目标函数有足够的下降，可以跳出循环，重新选择$\alpha_1$</p>
<h2 id="4-3-计算阈值b和差值-E-i"><a href="#4-3-计算阈值b和差值-E-i" class="headerlink" title="4.3 计算阈值b和差值$E_i$"></a>4.3 计算阈值b和差值$E_i$</h2><p>在每次完成两个变量的优化之后，需要重新计算阈值b。当$\leq \alpha_{1}^{new} \leq C$时，我们有<br>$$<br>y_1 - \sum\limits_{i=1}^{m}\alpha_iy_iK_{i1} -b_1 = 0<br>$$<br>于是新的$b_1^{new}$为：<br>$$<br>b_1^{new} = y_1 - \sum\limits_{i=3}^{m}\alpha_iy_iK_{i1} - \alpha_{1}^{new}y_1K_{11} - \alpha_{2}^{new}y_2K_{21}<br>$$<br>计算出$E_1$为：<br>$$<br>E_1 = g(x_1) - y_1 = \sum\limits_{i=3}^{m}\alpha_iy_iK_{i1} + \alpha_{1}^{old}y_1K_{11} + \alpha_{2}^{old}y_2K_{21} + b^{old} -y_1<br>$$<br>可以看到上两式都有$y_1 - \sum\limits_{i=3}^{m}\alpha_iy_iK_{i1}$，因此可以将$b_1^{new}$用$E_1$表示为：<br>$$<br>b_1^{new} = -E_1 -y_1K_{11}(\alpha_{1}^{new} - \alpha_{1}^{old}) -y_2K_{21}(\alpha_{2}^{new} - \alpha_{2}^{old}) + b^{old}<br>$$<br>同样的，如果$ \leq \alpha_{2}^{new} \leq C$, 那么有：<br>$$<br>b_2^{new} = -E_2 -y_1K_{12}(\alpha_{1}^{new} - \alpha_{1}^{old}) -y_2K_{22}(\alpha_{2}^{new} - \alpha_{2}^{old}) + b^{old}<br>$$<br>最终的$b^{new}$为：<br>$$<br>b^{new} = \frac{b_1^{new} + b_2^{new}}{2}<br>$$<br>得到了$b^{new}$我们需要更新$E_i$:<br>$$<br>E_i = \sum\limits_{S}y_j\alpha_jK(x_i,x_j) + b^{new} -y_i<br>$$<br>其中，S是所有支持向量$x_j$的集合。</p>
<p>好了，SMO算法基本讲完了，我们来归纳下SMO算法。</p>
<h1 id="5-SMO算法总结"><a href="#5-SMO算法总结" class="headerlink" title="5. SMO算法总结"></a>5. SMO算法总结</h1><p>输入是m个样本${(x_1,y_1), (x_2,y_2), …, (x_m,y_m),}$,其中x为n维特征向量。y为二元输出，值为1，或者-1.精度e。</p>
<p>输出是近似解$\alpha$</p>
<p>1)取初值$\alpha^{0} = 0, k =0$</p>
<p>2)按照4.1节的方法选择$\alpha_1^k$,接着按照4.2节的方法选择$\alpha_2^k$，求出新的$\alpha_2^{new,unc}$。<br>$$<br>\alpha_2^{new,unc} = \alpha_2^{k} + \frac{y_2(E_1-E_2)}{K_{11} +K_{22}-2K_{12})}<br>$$<br>3)按照下式求出$\alpha_2^{k+1}$</p>
<p>$$<br>\alpha_2^{k+1}= \begin{cases} H&amp; {L \leq \alpha_2^{new,unc} &gt; H}\\ \alpha_2^{new,unc}&amp; {L \leq \alpha_2^{new,unc} \leq H}\\ L&amp; {\alpha_2^{new,unc} &lt; L} \end{cases}<br>$$<br>4)利用$\alpha_2^{k+1}和αk+11α1k+1\alpha_1^{k+1}$的关系求出$\alpha_1^{k+1}$</p>
<p>5)按照4.3节的方法计算$b^{k+1}$和$E_i$</p>
<p>6）在精度e范围内检查是否满足如下的终止条件：<br>$$<br>\sum\limits_{i=1}^{m}\alpha_iy_i = 0<br>0 \leq \alpha_i \leq C, i =1,2…m<br>$$<br>$$<br>\alpha_{i}^{k+1} = 0 \Rightarrow y_ig(x_i) \geq 1<br>$$<br>$$<br> 0 &lt;\alpha_{i}^{k+1} &lt; C  \Rightarrow y_ig(x_i)  = 1<br> $$<br> $$<br>\alpha_{i}^{k+1}= C \Rightarrow y_ig(x_i)  \leq 1<br>$$<br>7)如果满足则结束，返回$\alpha^{k+1}$,否则转到步骤2）。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>SMO算法终于写完了，这块在以前学的时候是非常痛苦的，不过弄明白就豁然开朗了。希望大家也是一样。写完这一篇， SVM系列就只剩下支持向量回归了，胜利在望！</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[支持向量机原理(三)线性不可分支持向量机与核函数]]></title>
      <url>/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%8E%9F%E7%90%86-%E4%B8%89-%E7%BA%BF%E6%80%A7%E4%B8%8D%E5%8F%AF%E5%88%86%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E4%B8%8E%E6%A0%B8%E5%87%BD%E6%95%B0.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://pancakeawesome.ink/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%8E%9F%E7%90%86-%E4%B8%80-%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html">支持向量机原理(一) 线性支持向量机</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-二-线性支持向量机的软间隔最大化模型.html">支持向量机原理(二) 线性支持向量机的软间隔最大化模型</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-三-线性不可分支持向量机与核函数.html">支持向量机原理(三)线性不可分支持向量机与核函数</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-四-SMO算法原理.html">支持向量机原理(四)SMO算法原理</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-五-线性支持回归.html">支持向量机原理(五)线性支持回归</a></p>
<p>在前面两篇我们讲到了线性可分SVM的硬间隔最大化和软间隔最大化的算法，它们对线性可分的数据有很好的处理，但是对完全线性不可分的数据没有办法。本文我们就来探讨SVM如何处理线性不可分的数据，重点讲述核函数在SVM中处理线性不可分数据的作用。</p>
<h2 id="支持向量机原理-三-线性不可分支持向量机与核函数"><a href="#支持向量机原理-三-线性不可分支持向量机与核函数" class="headerlink" title="支持向量机原理(三)线性不可分支持向量机与核函数"></a>支持向量机原理(三)线性不可分支持向量机与核函数</h2><h3 id="1-回顾多项式回归"><a href="#1-回顾多项式回归" class="headerlink" title="1. 回顾多项式回归"></a>1. 回顾多项式回归</h3><p>在<a href="http://pancakeawesome.ink/线性回归原理小结.html">线性回归原理小结</a> 中，我们讲到了如何将多项式回归转化为线性回归。</p>
<p>比如一个只有两个特征的p次方多项式回归的模型：<br>$$<br>h_\theta(x_1, x_2) = \theta_0 + \theta_{1}x_1 + \theta_{2}x_{2} + \theta_{3}x_1^{2} + \theta_{4}x_2^{2} + \theta_{5}x_{1}x_2<br>$$<br>我们令$x_0 = 1, x_1 = x_1, x_2 = x_2, x_3 =x_1^{2}, x_4 = x_2^{2}, x_5 =  x_{1}x_2$ ,这样我们就得到了下式：<br>$$<br>h_\theta(x_1, x_2) = \theta_0 + \theta_{1}x_1 + \theta_{2}x_{2} + \theta_{3}x_3 + \theta_{4}x_4 + \theta_{5}x_5<br>$$<br>可以发现，我们又重新回到了线性回归，这是一个五元线性回归，可以用线性回归的方法来完成算法。对于每个二元样本特征$(x_1,x_2)$,我们得到一个五元样本特征$(1, x_1, x_2, x_{1}^2, x_{2}^2, x_{1}x_2)$，通过这个改进的五元样本特征，我们重新把不是线性回归的函数变回线性回归。</p>
<p>也就是说，对于二维的不是线性的数据，我们将其映射到了五维以后，就变成了线性的数据。</p>
<p>这给了我们启发，也就是说对于在低维线性不可分的数据，在映射到了高维以后，就变成线性可分的了。这个思想我们同样可以运用到SVM的线性不可分数据上。也就是说，对于SVM线性不可分的低维特征数据，我们可以将其映射到高维，就能线性可分，此时就可以运用前两篇的线性可分SVM的算法思想了。</p>
<h3 id="2-核函数的引入"><a href="#2-核函数的引入" class="headerlink" title="2. 核函数的引入"></a>2. 核函数的引入</h3><p>上一节我们讲到线性不可分的低维特征数据，我们可以将其映射到高维，就能线性可分。现在我们将它运用到我们的SVM的算法上。回顾线性可分SVM的优化目标函数：<br>$$<br> \underbrace{ min }_{\alpha}  \frac{1}{2}\sum\limits_{i=1,j=1}^{m}\alpha_i\alpha_jy_iy_jx_i \bullet x_j - \sum\limits_{i=1}^{m}\alpha_i<br> $$</p>
<p>$$<br> s.t. \; \sum\limits_{i=1}^{m}\alpha_iy_i = 0<br>$$</p>
<p>$$<br>0 \leq \alpha_i \leq C<br>$$<br>注意到上式低维特征仅仅以内积$x_i \bullet x_j$ 的形式出现，如果我们定义一个低维特征空间到高维特征空间的映射$\phi$（比如上一节2维到5维的映射），将所有特征映射到一个更高的维度，让数据线性可分，我们就可以继续按前两篇的方法来优化目标函数，求出分离超平面和分类决策函数了。也就是说现在的SVM的优化目标函数变成：<br>$$<br> \underbrace{ min }_{\alpha}  \frac{1}{2}\sum\limits_{i=1,j=1}^{m}\alpha_i\alpha_jy_iy_j\phi(x_i) \bullet \phi(x_j) - \sum\limits_{i=1}^{m}\alpha_i<br>$$</p>
<p>$$<br> s.t. \; \sum\limits_{i=1}^{m}\alpha_iy_i = 0<br> $$</p>
<p>$$<br>0 \leq \alpha_i \leq C<br>$$<br>可以看到，和线性可分SVM的优化目标函数的区别仅仅是将内积$x_i \bullet x_j$ 替换为$\phi(x_i) \bullet \phi(x_j)$。</p>
<p>看起来似乎这样我们就已经完美解决了线性不可分SVM的问题了，但是事实是不是这样呢？我们看看，假如是一个2维特征的数据，我们可以将其映射到5维来做特征的内积，如果原始空间是三维，可以映射到到19维空间，似乎还可以处理。但是如果我们的低维特征是100个维度，1000个维度呢？那么我们要将其映射到超级高的维度来计算特征的内积。这时候映射成的高维维度是爆炸性增长的，这个计算量实在是太大了，而且如果遇到无穷维的情况，就根本无从计算了。</p>
<p>怎么办？似乎我们刚提出了一种好的解决线性不可分的办法，接着就把自己否决了。</p>
<p>好吧，核函数该隆重出场了！</p>
<p>假设$\phi$是一个从低维的输入空间$\chi$（欧式空间的子集或者离散集合）到高维的希尔伯特空间的$\mathcal{H}$映射。那么如果存在函数$K(x,z)$，对于任意$x, z \in \chi$，都有：<br>$$<br>K(x, z) = \phi(x_i) \bullet \phi(x_j)<br>$$<br>那么我们就称$K(x, z)$为核函数。</p>
<p> 从上面的式子乍一看还是不明白核函数怎么帮我们解决线性不可分的问题的。仔细观察上式可以发现，$K(x, z)$的计算是在低维特征空间来计算的，它避免了在刚才我们提到了在高维维度空间计算内积的恐怖计算量。也就是说，我们可以好好享受在高维特征空间线性可分的红利，却避免了高维特征空间恐怖的内积计算量。</p>
<p>至此，我们总结下线性不可分时核函数的引入过程：</p>
<p>我们遇到线性不可分的样例时，常用做法是把样例特征映射到高维空间中去(如上一节的多项式回归）但是遇到线性不可分的样例，一律映射到高维空间，那么这个维度大小是会高到令人恐怖的。此时，核函数就体现出它的价值了，核函数的价值在于它虽然也是将特征进行从低维到高维的转换，但核函数好在它在低维上进行计算，而将实质上的分类效果（利用了内积）表现在了高维上，这样避免了直接在高维空间中的复杂计算，真正解决了SVM线性不可分的问题。</p>
<h3 id="3-核函数的介绍"><a href="#3-核函数的介绍" class="headerlink" title="3. 核函数的介绍"></a>3. 核函数的介绍</h3><p>事实上，核函数的研究非常的早，要比SVM出现早得多，当然，将它引入SVM中是最近二十多年的事情。对于从低维到高维的映射，核函数不止一个。那么什么样的函数才可以当做核函数呢？这是一个有些复杂的数学问题。这里不多介绍。由于一般我们说的核函数都是正定核函数，这里我们直说明正定核函数的充分必要条件。一个函数要想成为正定核函数，必须满足他里面任何点的集合形成的Gram矩阵是半正定的。也就是说,对于任意的$mx_i \in \chi ， i=1,2,3…m , K(x_i,x_j)$对应的Gram矩阵$K = \bigg[ K(x_i, x_j )\bigg]  $是半正定矩阵，则$K(x,z)$是正定核函数。　</p>
<p>从上面的定理看，它要求任意的集合都满足Gram矩阵半正定，所以自己去找一个核函数还是很难的，怎么办呢？还好牛人们已经帮我们找到了很多的核函数，而常用的核函数也仅仅只有那么几个。下面我们来看看常见的核函数, 选择这几个核函数介绍是因为scikit-learn中默认可选的就是下面几个核函数。</p>
<h4 id="3-1-线性核函数"><a href="#3-1-线性核函数" class="headerlink" title="3.1 线性核函数"></a>3.1 线性核函数</h4><p>线性核函数（Linear Kernel）其实就是我们前两篇的线性可分SVM，表达式为：<br>$$<br>K(x, z) = x \bullet z<br>$$<br>也就是说，线性可分SVM我们可以和线性不可分SVM归为一类，区别仅仅在于线性可分SVM用的是线性核函数。</p>
<h4 id="3-2-多项式核函数"><a href="#3-2-多项式核函数" class="headerlink" title="3.2 多项式核函数"></a>3.2 多项式核函数</h4><p>多项式核函数（Polynomial Kernel）是线性不可分SVM常用的核函数之一，表达式为：<br>$$<br>K(x, z) = （\gamma x \bullet z  + r)^d<br>$$<br>其中，$\gamma, r, d$都需要自己调参定义。</p>
<h4 id="3-3-高斯核函数"><a href="#3-3-高斯核函数" class="headerlink" title="3.3 高斯核函数"></a>3.3 高斯核函数</h4><p>高斯核函数（Gaussian Kernel），在SVM中也称为径向基核函数（Radial Basis Function,RBF），它是非线性分类SVM最主流的核函数。libsvm默认的核函数就是它。表达式为：<br>$$<br>K(x, z) = exp(-\gamma||x-z||^2)<br>$$<br>其中，$\gamma$大于0，需要自己调参定义。</p>
<h4 id="3-4-Sigmoid核函数"><a href="#3-4-Sigmoid核函数" class="headerlink" title="3.4 Sigmoid核函数"></a>3.4 <strong>Sigmoid核函数</strong></h4><p>Sigmoid核函数（Sigmoid Kernel）也是线性不可分SVM常用的核函数之一，表达式为：<br>$$<br>K(x, z) = tanh（\gamma x \bullet z  + r)<br>$$<br>其中，$\gamma, r$都需要自己调参定义。</p>
<h3 id="4-分类SVM的算法小结"><a href="#4-分类SVM的算法小结" class="headerlink" title="4. 分类SVM的算法小结"></a>4. 分类SVM的算法小结</h3><p>引入了核函数后，我们的SVM算法才算是比较完整了。现在我们对分类SVM的算法过程做一个总结。不再区别是否线性可分。</p>
<p>输入是m个样本${(x_1,y_1), (x_2,y_2), …, (x_m,y_m),}$,其中x为n维特征向量。y为二元输出，值为1，或者-1.</p>
<p>输出是分离超平面的参数<img src="https://ws2.sinaimg.cn/large/006tKfTcgy1forml06sakj301o00qa9t.jpg" alt="">和分类决策函数。</p>
<p>算法过程如下：</p>
<p>1）选择适当的核函数K(x,z)K(x,z)K(x,z)和一个惩罚系数C&gt;0C&gt;0C&gt;0, 构造约束优化问题<br>$$<br> \underbrace{ min }_{\alpha}  \frac{1}{2}\sum\limits_{i=1,j=1}^{m}\alpha_i\alpha_jy_iy_jK(x_i,x_j) - \sum\limits_{i=1}^{m}\alpha_i<br>$$</p>
<p>$$<br>s.t. \; \sum\limits_{i=1}^{m}\alpha_iy_i = 0<br>$$</p>
<p>$$<br>0 \leq \alpha_i \leq C<br>$$<br>2）用SMO算法求出上式最小时对应的<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1formnd9eplj300n00o0sh.jpg" alt="">向量的值<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1formnd9eplj300n00o0sh.jpg" alt="">向量.</p>
<p>3) 得到<img src="https://ws3.sinaimg.cn/large/006tKfTcgy1formnly77kj304o01i0si.jpg" alt="">，此处可以不直接显式的计算<img src="https://ws2.sinaimg.cn/large/006tKfTcgy1formnrye29j300m00s0sh.jpg" alt="">。</p>
<p>4) 找出所有的S个支持向量,即满足$\alpha_s &lt; C$对应的样本$(x_s,y_s)$，通过 $y_s(\sum\limits_{i=1}^{S}\alpha_iy_iK(x_i,x_s)+b) = 1$，计算出每个支持向量$(x_s, y_s)$对应的<img src="https://ws2.sinaimg.cn/large/006tKfTcgy1formpg2odhj300q00w3y9.jpg" alt="">,计算出这些<img src="https://ws3.sinaimg.cn/large/006tKfTcgy1formqvl0o6j306k01l742.jpg" alt="">. 所有的$b_s^{*}$对应的平均值即为最终的<img src="https://ws3.sinaimg.cn/large/006tKfTcgy1formr5x3xkj303901pjr5.jpg" alt=""></p>
<p> 这样最终的分类超平面为：<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1formrdfwvlj306b01n742.jpg" alt=""> ，最终的分类决策函数为：<img src="https://ws3.sinaimg.cn/large/006tKfTcgy1formrjel6aj308v01yt8i.jpg" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>至此，我们的分类SVM算是总结完毕，唯一的漏网之鱼是SMO算法，这个算法关系到，我们如何求出优化函数极小化时候的<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1formnd9eplj300n00o0sh.jpg" alt="">，进而求出$w,b$,我们将在下一篇讨论这个问题。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[支持向量机原理(二) 线性支持向量机的软间隔最大化模型]]></title>
      <url>/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%8E%9F%E7%90%86-%E4%BA%8C-%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%9A%84%E8%BD%AF%E9%97%B4%E9%9A%94%E6%9C%80%E5%A4%A7%E5%8C%96%E6%A8%A1%E5%9E%8B.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://pancakeawesome.ink/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%8E%9F%E7%90%86-%E4%B8%80-%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html">支持向量机原理(一) 线性支持向量机</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-二-线性支持向量机的软间隔最大化模型.html">支持向量机原理(二) 线性支持向量机的软间隔最大化模型</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-三-线性不可分支持向量机与核函数.html">支持向量机原理(三)线性不可分支持向量机与核函数</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-四-SMO算法原理.html">支持向量机原理(四)SMO算法原理</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-五-线性支持回归.html">支持向量机原理(五)线性支持回归</a></p>
<p>在<a href="http://pancakeawesome.ink/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%8E%9F%E7%90%86-%E4%B8%80-%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html">支持向量机原理(一) 线性支持向量机</a> 中，我们对线性可分SVM的模型和损失函数优化做了总结。最后我们提到了有时候不能线性可分的原因是线性数据集里面多了少量的异常点，由于这些异常点导致了数据集不能线性可分，本篇就对线性支持向量机如何处理这些异常点的原理方法做一个总结。</p>
<h2 id="支持向量机原理-二-线性支持向量机的软间隔最大化模型"><a href="#支持向量机原理-二-线性支持向量机的软间隔最大化模型" class="headerlink" title="支持向量机原理(二) 线性支持向量机的软间隔最大化模型"></a>支持向量机原理(二) 线性支持向量机的软间隔最大化模型</h2><h3 id="1-线性分类SVM面临的问题"><a href="#1-线性分类SVM面临的问题" class="headerlink" title="1. 线性分类SVM面临的问题"></a>1. 线性分类SVM面临的问题</h3><p>有时候本来数据的确是可分的，也就是说可以用 线性分类SVM的学习方法来求解，但是却因为混入了异常点，导致不能线性可分，比如下图，本来数据是可以按下面的实线来做超平面分离的，可以由于一个橙色和一个蓝色的异常点导致我们没法按照上一篇<a href="http://pancakeawesome.ink/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%8E%9F%E7%90%86-%E4%B8%80-%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html">线性支持向量机</a> 中的方法来分类。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1forjkcaw3mj30ej0bu3yl.jpg" alt=""></p>
<p>另外一种情况没有这么糟糕到不可分，但是会严重影响我们模型的泛化预测效果，比如下图，本来如果我们不考虑异常点，SVM的超平面应该是下图中的红色线所示，但是由于有一个蓝色的异常点，导致我们学习到的超平面是下图中的粗虚线所示，这样会严重影响我们的分类模型预测效果。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1forjlg0wf6j30g80fxmxj.jpg" alt=""></p>
<p>如何解决这些问题呢？SVM引入了软间隔最大化的方法来解决。</p>
<h3 id="2-线性分类SVM的软间隔最大化"><a href="#2-线性分类SVM的软间隔最大化" class="headerlink" title="2. 线性分类SVM的软间隔最大化"></a>2. 线性分类SVM的软间隔最大化</h3><p>所谓的软间隔，是相对于硬间隔说的，我们可以认为上一篇线性分类SVM的学习方法属于硬间隔最大化。</p>
<p>回顾下硬间隔最大化的条件：<br>$$<br>min\;\; \frac{1}{2}||w||_2^2  \;\; s.t \;\; y_i(w^Tx_i + b)  \geq 1 (i =1,2,…m)<br>$$<br>接着我们再看如何可以软间隔最大化呢？</p>
<p>SVM对训练集里面的每个样本$(x_i,y_i)$引入了一个松弛变量$\xi_i \geq 0$,使函数间隔加上松弛变量大于等于1，也就是说：<br>$$<br>y_i(w\bullet x_i +b) \geq 1- \xi_i<br>$$<br>对比硬间隔最大化，可以看到我们对样本到超平面的函数距离的要求放松了，之前是一定要大于等于1，现在只需要加上一个大于等于0的松弛变量能大于等于1就可以了。当然，松弛变量不能白加，这是有成本的，每一个松弛变量$\xi_i$, 对应了一个代价$\xi_i$，这个就得到了我们的软间隔最大化的SVM学习条件如下：<br>$$<br>min\;\; \frac{1}{2}||w||_2^2 +C\sum\limits_{i=1}^{m}\xi_i<br>$$</p>
<p>$$<br> s.t.  \;\; y_i(w^Tx_i + b)  \geq 1 - \xi_i \;\;(i =1,2,…m)<br>$$</p>
<p>$$<br>\xi_i \geq 0 \;\;(i =1,2,…m)<br>$$<br>这里,$C&gt;0$为惩罚参数，可以理解为我们一般回归和分类问题正则化时候的参数。$C$越大，对误分类的惩罚越大，$C$越小，对误分类的惩罚越小。</p>
<p>也就是说，我们希望$\frac{1}{2}||w||_2^2$尽量小，误分类的点尽可能的少。C是协调两者关系的正则化惩罚系数。在实际应用中，需要调参来选择。</p>
<p>这个目标函数的优化和上一篇的线性可分SVM的优化方式类似，我们下面就来看看怎么对线性分类SVM的软间隔最大化来进行学习优化。</p>
<h3 id="3-线性分类SVM的软间隔最大化目标函数的优化"><a href="#3-线性分类SVM的软间隔最大化目标函数的优化" class="headerlink" title="3. 线性分类SVM的软间隔最大化目标函数的优化"></a>3. 线性分类SVM的软间隔最大化目标函数的优化</h3><p>和线性可分SVM的优化方式类似，我们首先将软间隔最大化的约束问题用拉格朗日函数转化为无约束问题如下：<br>$$<br>L(w,b,\xi,\alpha,\mu) = \frac{1}{2}||w||_2^2 +C\sum\limits_{i=1}^{m}\xi_i - \sum\limits_{i=1}^{m}\alpha_i[y_i(w^Tx_i + b) - 1 + \xi_i] - \sum\limits_{i=1}^{m}\mu_i\xi_i<br>$$<br>其中 $\mu_i \geq 0, \alpha_i \geq 0$,均为拉格朗日系数。</p>
<p>也就是说，我们现在要优化的目标函数是：<br>$$<br>\underbrace{min}_{w,b,\xi}\; \underbrace{max}_{\alpha_i \geq 0, \mu_i \geq 0,} L(w,b,\alpha, \xi,\mu)<br>$$<br>这个优化目标也满足KKT条件，也就是说，我们可以通过拉格朗日对偶将我们的优化问题转化为等价的对偶问题来求解如下：<br>$$<br>\underbrace{max}_{\alpha_i \geq 0, \mu_i \geq 0,} \; \underbrace{min}_{w,b,\xi}\; L(w,b,\alpha, \xi,\mu)<br>$$<br>我们可以先求优化函数对于$w, b, \xi$ 的极小值, 接着再求拉格朗日乘子$\alpha$和 $\mu$的极大值。</p>
<p>首先我们来求优化函数对于$w, b, \xi$ 的极小值，这个可以通过求偏导数求得：<br>$$<br>\frac{\partial L}{\partial w} = 0 \;\Rightarrow w = \sum\limits_{i=1}^{m}\alpha_iy_ix_i<br>\frac{\partial L}{\partial b} = 0 \;\Rightarrow \sum\limits_{i=1}^{m}\alpha_iy_i = 0<br>\frac{\partial L}{\partial \xi} = 0 \;\Rightarrow C- \alpha_i - \mu_i = 0<br>$$<br>好了，我们可以利用上面的三个式子去消除$w$和$b$了。<br>$$<br> \begin{align} L(w,b,\xi,\alpha,\mu) &amp; = \frac{1}{2}||w||_2^2 +C\sum\limits_{i=1}^{m}\xi_i - \sum\limits_{i=1}^{m}\alpha_i[y_i(w^Tx_i + b) - 1 + \xi_i] - \sum\limits_{i=1}^{m}\mu_i\xi_i 　\\&amp;= \frac{1}{2}||w||_2^2 - \sum\limits_{i=1}^{m}\alpha_i[y_i(w^Tx_i + b) - 1 + \xi_i] + \sum\limits_{i=1}^{m}\alpha_i\xi_i \\&amp; = \frac{1}{2}||w||_2^2 - \sum\limits_{i=1}^{m}\alpha_i[y_i(w^Tx_i + b) - 1] \\&amp; = \frac{1}{2}w^Tw-\sum\limits_{i=1}^{m}\alpha_iy_iw^Tx_i - \sum\limits_{i=1}^{m}\alpha_iy_ib + \sum\limits_{i=1}^{m}\alpha_i \\&amp; = \frac{1}{2}w^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i -\sum\limits_{i=1}^{m}\alpha_iy_iw^Tx_i - \sum\limits_{i=1}^{m}\alpha_iy_ib + \sum\limits_{i=1}^{m}\alpha_i \\&amp; = \frac{1}{2}w^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i - w^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i - \sum\limits_{i=1}^{m}\alpha_iy_ib + \sum\limits_{i=1}^{m}\alpha_i \\&amp; = - \frac{1}{2}w^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i - \sum\limits_{i=1}^{m}\alpha_iy_ib + \sum\limits_{i=1}^{m}\alpha_i \\&amp; = - \frac{1}{2}w^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i - b\sum\limits_{i=1}^{m}\alpha_iy_i + \sum\limits_{i=1}^{m}\alpha_i \\&amp; = -\frac{1}{2}(\sum\limits_{i=1}^{m}\alpha_iy_ix_i)^T(\sum\limits_{i=1}^{m}\alpha_iy_ix_i) - b\sum\limits_{i=1}^{m}\alpha_iy_i + \sum\limits_{i=1}^{m}\alpha_i \\&amp; = -\frac{1}{2}\sum\limits_{i=1}^{m}\alpha_iy_ix_i^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i - b\sum\limits_{i=1}^{m}\alpha_iy_i + \sum\limits_{i=1}^{m}\alpha_i \\&amp; = -\frac{1}{2}\sum\limits_{i=1}^{m}\alpha_iy_ix_i^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i + \sum\limits_{i=1}^{m}\alpha_i \\&amp; = -\frac{1}{2}\sum\limits_{i=1,j=1}^{m}\alpha_iy_ix_i^T\alpha_jy_jx_j + \sum\limits_{i=1}^{m}\alpha_i \\&amp; = \sum\limits_{i=1}^{m}\alpha_i - \frac{1}{2}\sum\limits_{i=1,j=1}^{m}\alpha_i\alpha_jy_iy_jx_i^Tx_j \end{align}<br>$$<br>其中，(1)式到(2)式用到了$C- \alpha_i - \mu_i = 0$, (2)式到(3)式合并了同类项，(3)式到(4)式用到了范数的定义$||w||_2^2 =w^Tw$, (4)式到(5)式用到了上面的$w = \sum\limits_{i=1}^{m}\alpha_iy_ix_i$， (5)式到(6)式把和样本无关的$w^T$提前，(6)式到(7)式合并了同类项，(7)式到(8)式把和样本无关的$b$提前，(8)式到(9)式继续用到$w = \sum\limits_{i=1}^{m}\alpha_iy_ix_i$，（9）式到(10)式用到了向量的转置。由于常量的转置是其本身，所有只有向量$x_i$被转置，（10）式到(11)式用到了上面的$\sum\limits_{i=1}^{m}\alpha_iy_i = 0$，（11）式到(12)式使用了$(a+b+c+…)(a+b+c+…)=aa+ab+ac+ba+bb+bc+…$的乘法运算法则，（12）式到(13)式仅仅是位置的调整。</p>
<p>仔细观察可以发现，这个式子和我们上一篇线性可分SVM的一样。唯一不一样的是约束条件。现在我们看看我们的优化目标的数学形式：<br>$$<br> \underbrace{ max }_{\alpha} \sum\limits_{i=1}^{m}\alpha_i - \frac{1}{2}\sum\limits_{i=1,j=1}^{m}\alpha_i\alpha_jy_iy_jx_i^Tx_j<br> $$</p>
<p> $$<br> s.t. \; \sum\limits_{i=1}^{m}\alpha_iy_i = 0<br> $$</p>
<p>$$<br> C- \alpha_i - \mu_i = 0<br>$$</p>
<p>$$<br> \alpha_i \geq 0 \;(i =1,2,…,m)<br>$$</p>
<p>$$<br> \mu_i \geq 0 \;(i =1,2,…,m)<br>$$<br>对于$ C- \alpha_i - \mu_i = 0 ， \alpha_i \geq 0 ，\mu_i \geq 0 $这3个式子，我们可以消去$\mu_i$，只留下$\alpha_i$，也就是说$ \leq \alpha_i \leq C$。 同时将优化目标函数变号，求极小值，如下：<br>$$<br> \underbrace{ min }_{\alpha}  \frac{1}{2}\sum\limits_{i=1,j=1}^{m}\alpha_i\alpha_jy_iy_jx_i^Tx_j - \sum\limits_{i=1}^{m}\alpha_i<br>$$</p>
<p>$$<br> s.t. \; \sum\limits_{i=1}^{m}\alpha_iy_i = 0<br>$$</p>
<p>$$<br>0 \leq \alpha_i \leq C<br>$$<br>这就是软间隔最大化时的线性可分SVM的优化目标形式，和上一篇的硬间隔最大化的线性可分SVM相比，我们仅仅是多了一个约束条件$\leq \alpha_i \leq C$。我们依然可以通过SMO算法来求上式极小化时对应的$\alpha$向量就可以求出$w和b$了。</p>
<h3 id="4-软间隔最大化时的支持向量"><a href="#4-软间隔最大化时的支持向量" class="headerlink" title="4. 软间隔最大化时的支持向量"></a>4. 软间隔最大化时的支持向量</h3><p>在硬间隔最大化时，支持向量比较简单，就是满足$y_i(w^Tx_i + b) -1 =0$就可以了。根据KKT条件中的对偶互补条件<img src="https://ws2.sinaimg.cn/large/006tKfTcgy1forjvc6hjdj306g00rwe9.jpg" alt="">，如果<img src="https://ws1.sinaimg.cn/large/006tKfTcgy1forjvn1o2gj301q00s741.jpg" alt="">则有$y_i(w^Tx_i + b) =1$ 即点在支持向量上，否则如果<img src="https://ws2.sinaimg.cn/large/006tKfTcgy1forjw5maoxj301o00u741.jpg" alt="">则有$y_i(w^Tx_i + b) \geq 1$，即样本在支持向量上或者已经被正确分类。</p>
<p>在软间隔最大化时，则稍微复杂一些，因为我们对每个样本$(x_i,y_i$)引入了松弛变量$\xi_i$。我们从下图来研究软间隔最大化时支持向量的情况，第i个点到对应类别支持向量的距离为$\frac{\xi_i}{||w||_2}$。根据软间隔最大化时KKT条件中的对偶互补条件<img src="https://ws3.sinaimg.cn/large/006tKfTcgy1forjx2x8nxj307e00v742.jpg" alt="">我们有：</p>
<p>a) 如果$\alpha = 0$,那么$y_i(w^Tx_i + b) - 1 \geq 0$,即样本在支持向量上或者已经被正确分类。如图中所有远离支持向量的点。</p>
<p>b) 如果$\alpha &lt; C$,那么$\xi_i = 0 ,\;\; y_i(w^Tx_i + b) - 1 =  0$,即点在支持向量上。如图中在虚线支持向量上的点。</p>
<p>c) 如果$\alpha = C$，说明这是一个可能比较异常的点，需要检查此时$\xi_i$</p>
<p>　　i)如果$\leq \xi_i \leq 1$,那么点被正确分类，但是却在超平面和自己类别的支持向量之间。如图中的样本2和4.</p>
<p>　　ii)如果$\xi_i =1$,那么点在分离超平面上，无法被正确分类。</p>
<p>　　iii)如果$\xi_i &gt; 1$,那么点在超平面的另一侧，也就是说，这个点不能被正常分类。如图中的样本1和3.</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1forjmpwxvkj30eh09xt98.jpg" alt=""></p>
<h3 id="5-软间隔最大化的线性可分SVM的算法过程"><a href="#5-软间隔最大化的线性可分SVM的算法过程" class="headerlink" title="5. 软间隔最大化的线性可分SVM的算法过程"></a>5. 软间隔最大化的线性可分SVM的算法过程</h3><p>这里我们对软间隔最大化时的线性可分SVM的算法过程做一个总结。</p>
<p>输入是线性可分的m个样本${(x_1,y_1), (x_2,y_2), …, (x_m,y_m),}$,其中x为n维特征向量。y为二元输出，值为1，或者-1.</p>
<p>输出是分离超平面的参数<img src="https://ws2.sinaimg.cn/large/006tKfTcgy1forjxs0tjrj301q00kdfl.jpg" alt="">和分类决策函数。</p>
<p>算法过程如下：</p>
<p>1）选择一个惩罚系数$C&gt;0$, 构造约束优化问题<br>$$<br> \underbrace{ min }_{\alpha}  \frac{1}{2}\sum\limits_{i=1,j=1}^{m}\alpha_i\alpha_jy_iy_jx_i^Tx_j - \sum\limits_{i=1}^{m}\alpha_i<br>$$</p>
<p> $$<br> s.t. \; \sum\limits_{i=1}^{m}\alpha_iy_i = 0<br>$$</p>
<p>$$<br>0 \leq \alpha_i \leq C<br>$$<br>2）用SMO算法求出上式最小时对应的$\alpha$向量的值<img src="https://ws1.sinaimg.cn/large/006tKfTcgy1forjydovgtj300o00m0sh.jpg" alt="">向量.</p>
<p>3) 计算<img src="https://ws3.sinaimg.cn/large/006tKfTcgy1forjyrrpg3j303v01jq2p.jpg" alt=""></p>
<p>4) 找出所有的S个支持向量,即满足$\alpha_s &lt; C$对应的样本$(x_s,y_s)$，通过 $y_s(\sum\limits_{i=1}^{S}\alpha_iy_ix_i^Tx_s+b) = 1$，计算出每个支持向量$(x_x, y_s)$对应的<img src="https://ws3.sinaimg.cn/large/006tKfTcgy1forjzbkpthj300o00r3y9.jpg" alt="">,计算出这些<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fork0oei4rj305i01g0si.jpg" alt="">. 所有的<img src="https://ws3.sinaimg.cn/large/006tKfTcgy1forjzbkpthj300o00r3y9.jpg" alt="">对应的平均值即为最终的<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fork0wadsij303401ojr5.jpg" alt=""></p>
<p>这样最终的分类超平面为：<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fork17volaj3040013gld.jpg" alt="">，最终的分类决策函数为：<img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fork1grqwsj30680143ya.jpg" alt=""></p>
<h3 id="6-合页损失函数"><a href="#6-合页损失函数" class="headerlink" title="6. 合页损失函数"></a>6. 合页损失函数</h3><p>线性支持向量机还有另外一种解释如下：<br>$$<br> \underbrace{ min}_{w, b}[1-y_i(w \bullet x + b)]_{+} + \lambda ||w||_2^2<br>$$<br>其中$L(y(w \bullet x + b)) = [1-y_i(w \bullet x + b)]_{+}$称为合页损失函数(hinge loss function)，下标+表示为：<br>$$<br> [z]_{+}= \begin{cases} z &amp; {z &gt;0}\\ 0&amp; {z\leq 0} \end{cases}<br>$$<br>也就是说，如果点被正确分类，且函数间隔大于1，损失是0，否则损失是$1-y(w \bullet x + b)$,如下图中的绿线。我们在下图还可以看出其他各种模型损失和函数间隔的关系：对于0-1损失函数，如果正确分类，损失是0，误分类损失1， 如下图黑线，可见0-1损失函数是不可导的。对于感知机模型，感知机的损失函数是$[-y_i(w \bullet x + b)]_{+}$，这样当样本被正确分类时，损失是0，误分类时，损失是$-y_i(w \bullet x + b)$，如下图紫线。对于逻辑回归之类和最大熵模型对应的对数损失，损失函数是$log[1+exp(-y(w \bullet x + b))]$, 如下图红线所示。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1forjnfwcntj30es0b2q30.jpg" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>线性可分SVM通过软间隔最大化，可以解决线性数据集带有异常点时的分类处理，但是现实生活中的确有很多数据不是线性可分的，这些线性不可分的数据也不是去掉异常点就能处理这么简单。那么SVM怎么能处理中这样的情况呢？我们在下一篇就来讨论线性不可分SVM和核函数的原理。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[支持向量机原理(一) 线性支持向量机]]></title>
      <url>/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%8E%9F%E7%90%86-%E4%B8%80-%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://pancakeawesome.ink/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%8E%9F%E7%90%86-%E4%B8%80-%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html">支持向量机原理(一) 线性支持向量机</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-二-线性支持向量机的软间隔最大化模型.html">支持向量机原理(二) 线性支持向量机的软间隔最大化模型</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-三-线性不可分支持向量机与核函数.html">支持向量机原理(三)线性不可分支持向量机与核函数</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-四-SMO算法原理.html">支持向量机原理(四)SMO算法原理</a> </p>
<p><a href="http://pancakeawesome.ink/支持向量机原理-五-线性支持回归.html">支持向量机原理(五)线性支持回归</a> </p>
<p>支持向量机(Support Vecor Machine,以下简称SVM)虽然诞生只有短短的二十多年，但是自一诞生便由于它良好的分类性能席卷了机器学习领域，并牢牢压制了神经网络领域好多年。如果不考虑集成学习的算法，不考虑特定的训练数据集，在分类算法中的表现SVM说是排第一估计是没有什么异议的。</p>
<p>SVM是一个二元分类算法，线性分类和非线性分类都支持。经过演进，现在也可以支持多元分类，同时经过扩展，也能应用于回归问题。本系列文章就对SVM的原理做一个总结。本篇的重点是SVM用于线性分类时模型和损失函数优化的一个总结。</p>
<h2 id="支持向量机原理-一-线性支持向量机"><a href="#支持向量机原理-一-线性支持向量机" class="headerlink" title="支持向量机原理(一) 线性支持向量机"></a>支持向量机原理(一) 线性支持向量机</h2><h3 id="1-回顾感知机模型"><a href="#1-回顾感知机模型" class="headerlink" title="1. 回顾感知机模型"></a>1. 回顾感知机模型</h3><p>在<a href="http://pancakeawesome.ink/%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93.html">感知机原理小结</a> 中，我们讲到了感知机的分类原理，感知机的模型就是尝试找到一条直线，能够把二元数据隔离开。放到三维空间或者更高维的空间，感知机的模型就是尝试找到一个超平面，能够把所有的二元类别隔离开。对于这个分离的超平面，我们定义为$w^Tx + b = 0$，如下图。在超平面$w^Tx + b = 0$上方的我们定义为$y=1$,在超平面$w^Tx + b = 0$下方的我们定义为$y=-1$。可以看出满足这个条件的超平面并不止一个。那么我们可能会尝试思考，这么多的可以分类的超平面，哪个是最好的呢？或者说哪个是泛化能力最强的呢?</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1foo9605bd0j30e20a6q34.jpg" alt=""></p>
<p>接着我们看感知机模型的损失函数优化，它的思想是让所有误分类的点(定义为M)到超平面的距离和最小，即最小化下式：<br>$$<br>\sum\limits_{x_i \in M}- y^{(i)}(w^Tx^{(i)} +b)\big / ||w||_2<br>$$</p>
<p>当w和b成比例的增加，比如,当分子的w和b扩大N倍时，分母的L2范数也会扩大N倍。也就是说，分子和分母有固定的倍数关系。那么我们可以固定分子或者分母为1，然后求另一个即分子自己或者分母的倒数的最小化作为损失函数，这样可以简化我们的损失函数。在感知机模型中，我们采用的是保留分子，固定分母$||w||_2 = 1$,即最终感知机模型的损失函数为：<br>$$<br>\sum\limits_{x_i \in M}- y^{(i)}(w^Tx^{(i)} +b)<br>$$<br>如果我们不是固定分母，改为固定分子，作为分类模型有没有改进呢？</p>
<p>这些问题在我们引入SVM后会详细解释。</p>
<h3 id="2-函数间隔与几何间隔"><a href="#2-函数间隔与几何间隔" class="headerlink" title="2. 函数间隔与几何间隔"></a>2. 函数间隔与几何间隔</h3><p>在正式介绍SVM的模型和损失函数之前，我们还需要先了解下函数间隔和几何间隔的知识。</p>
<p>在分离超平面固定为$w^Tx + b = 0$的时候，$w^Tx + b |$表示点x到超平面的距离。通过观察$w^Tx + b$ 和y是否同号，我们判断分类是否正确，这些知识我们在感知机模型里都有讲到。这里我们引入函数间隔的概念，定义函数间隔$\gamma^{‘}$为：<br>$$<br>\gamma^{‘} = y(w^Tx + b)<br>$$<br>可以看到，它就是感知机模型里面的误分类点到超平面距离的分子。对于训练集中m个样本点对应的m个函数间隔的最小值，就是整个训练集的函数间隔。</p>
<p>函数间隔并不能正常反应点到超平面的距离，在感知机模型里我们也提到，当分子成比例的增长时，分母也是成倍增长。为了统一度量，我们需要对法向量$w$加上约束条件，这样我们就得到了几何间隔$\gamma$,定义为：<br>$$<br>\gamma = \frac{y(w^Tx + b)}{||w||_2} =  \frac{\gamma^{‘}}{||w||_2}<br>$$<br>几何间隔才是点到超平面的真正距离，感知机模型里用到的距离就是几何距离。</p>
<h3 id="3-支持向量"><a href="#3-支持向量" class="headerlink" title="3. 支持向量"></a>3. 支持向量</h3><p>在感知机模型中，我们可以找到多个可以分类的超平面将数据分开，并且优化时希望所有的点都离超平面远。但是实际上离超平面很远的点已经被正确分类，我们让它离超平面更远并没有意义。反而我们最关心是那些离超平面很近的点，这些点很容易被误分类。如果我们可以让离超平面比较近的点尽可能的远离超平面，那么我们的分类效果会好有一些。SVM的思想起源正起于此。</p>
<p>如下图所示，分离超平面为$w^Tx + b = 0$，如果所有的样本不光可以被超平面分开，还和超平面保持一定的函数距离（下图函数距离为1），那么这样的分类超平面是比感知机的分类超平面优的。可以证明，这样的超平面只有一个。和超平面平行的保持一定的函数距离的这两个超平面对应的向量，我们定义为支持向量，如下图虚线所示。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1foo96qfx44j30ep0anglz.jpg" alt=""></p>
<p> 支持向量到超平面的距离为$1/||w||_2$,两个支持向量之间的距离为$2/||w||_2$。</p>
<h3 id="4-SVM模型目标函数与优化"><a href="#4-SVM模型目标函数与优化" class="headerlink" title="4. SVM模型目标函数与优化"></a>4. SVM模型目标函数与优化</h3><p>SVM的模型是让所有点到超平面的距离大于一定的距离，也就是所有的分类点要在各自类别的支持向量两边。用数学式子表示为：<br>$$<br>max \;\; \gamma = \frac{y(w^Tx + b)}{||w||_2}  \;\; s.t \;\; y_i(w^Tx_i + b) = \gamma^{‘(i)} \geq \gamma^{‘} (i =1,2,…m)<br>$$<br>一般我们都取函数间隔$\gamma^{‘}$为1，这样我们的优化函数定义为：<br>$$<br>max \;\; \frac{1}{||w||_2}  \;\; s.t \;\; y_i(w^Tx_i + b)  \geq 1 (i =1,2,…m)<br>$$<br>也就是说，我们要在约束条件$y_i(w^Tx_i + b)  \geq 1 (i =1,2,…m)$下，最大化$\frac{1}{||w||_2}$。可以看出，这个感知机的优化方式不同，感知机是固定分母优化分子，而SVM是固定分子优化分母，同时加上了支持向量的限制。</p>
<p>由于$\frac{1}{||w||_2}$的最大化等同于$\frac{1}{2}||w||_2^2$的最小化。这样SVM的优化函数等价于：<br>$$<br>min \;\; \frac{1}{2}||w||_2^2  \;\; s.t \;\; y_i(w^Tx_i + b)  \geq 1 (i =1,2,…m)<br>$$<br>由于目标函数$\frac{1}{2}||w||_2^2$是凸函数，同时约束条件不等式是仿射的，根据凸优化理论，我们可以通过拉格朗日函数将我们的优化目标转化为无约束的优化函数，关于拉格朗日乘法优化算法的问题可以看这篇文章<a href="http://pancakeawesome.ink/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95%EF%BC%88Lagrange-Multiplier-%E5%92%8CKKT%E6%9D%A1%E4%BB%B6.html">传送门</a>。<a href="">最大熵模型原理小结</a> 中讲到了目标函数的优化方法一样。具体的，优化函数转化为：<br>$$<br>\sum\limits_{i=1}^{m}\alpha_i[y_i(w^Tx_i + b) - 1] \; 满足\alpha_i \geq 0<br>$$<br>由于引入了朗格朗日乘子，我们的优化目标变成：<br>$$<br>\underbrace{min}_{w,b}\; \underbrace{max}_{\alpha_i \geq 0} L(w,b,\alpha)<br>$$<br>和最大熵模型一样的，我们的这个优化函数满足KKT条件，也就是说，我们可以通过拉格朗日对偶将我们的优化问题转化为等价的对偶问题来求解。如果对凸优化和拉格朗日对偶不熟悉，建议阅读鲍德的《凸优化》。</p>
<p>也就是说，现在我们要求的是：<br>$$<br>\underbrace{max}_{\alpha_i \geq 0} \;\underbrace{min}_{w,b}\;  L(w,b,\alpha)<br>$$<br>从上式中，我们可以先求优化函数对于$w和b$的极小值。接着再求拉格朗日乘子$\alpha$的极大值。</p>
<p>首先我们来求$w和b$的极小值，即$\underbrace{min}_{w,b}\;  L(w,b,\alpha)$。这个极值我们可以通过对$w和b$分别求偏导数得到：<br>$$<br>\frac{\partial L}{\partial b} = 0 \;\Rightarrow \sum\limits_{i=1}^{m}\alpha_iy_i = 0<br>$$<br> 从上两式子可以看出，我们已经求得了$w和\alpha$的关系，只要我们后面接着能够求出优化函数极大化对应的$\alpha$，就可以求出我们的$w$了，至于b，由于上两式已经没有b，所以最后的b可以有多个。</p>
<p>好了，既然我们已经求出$w和\alpha$的关系，就可以带入优化函数$L(w,b,\alpha)$消去$w$了。我们定义:<br>$$<br>\psi(\alpha) = \underbrace{min}_{w,b}\;  L(w,b,\alpha)<br>$$<br>现在我们来看将$w$替换为$\alpha$的表达式以后的优化函数$\psi(\alpha)$的表达式：</p>
<p> $$<br> \begin{align} \psi(\alpha) &amp; =  \frac{1}{2}||w||_2^2 - \sum\limits_{i=1}^{m}\alpha_i[y_i(w^Tx_i + b) - 1] \\&amp; = \frac{1}{2}w^Tw-\sum\limits_{i=1}^{m}\alpha_iy_iw^Tx_i - \sum\limits_{i=1}^{m}\alpha_iy_ib + \sum\limits_{i=1}^{m}\alpha_i \\&amp; = \frac{1}{2}w^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i -\sum\limits_{i=1}^{m}\alpha_iy_iw^Tx_i - \sum\limits_{i=1}^{m}\alpha_iy_ib + \sum\limits_{i=1}^{m}\alpha_i \\&amp; = \frac{1}{2}w^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i - w^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i - \sum\limits_{i=1}^{m}\alpha_iy_ib + \sum\limits_{i=1}^{m}\alpha_i  \\&amp; = - \frac{1}{2}w^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i - \sum\limits_{i=1}^{m}\alpha_iy_ib + \sum\limits_{i=1}^{m}\alpha_i  \\&amp; = - \frac{1}{2}w^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i - b\sum\limits_{i=1}^{m}\alpha_iy_i + \sum\limits_{i=1}^{m}\alpha_i \\&amp; = -\frac{1}{2}(\sum\limits_{i=1}^{m}\alpha_iy_ix_i)^T(\sum\limits_{i=1}^{m}\alpha_iy_ix_i) - b\sum\limits_{i=1}^{m}\alpha_iy_i + \sum\limits_{i=1}^{m}\alpha_i  \\&amp; = -\frac{1}{2}\sum\limits_{i=1}^{m}\alpha_iy_ix_i^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i - b\sum\limits_{i=1}^{m}\alpha_iy_i + \sum\limits_{i=1}^{m}\alpha_i \\&amp; = -\frac{1}{2}\sum\limits_{i=1}^{m}\alpha_iy_ix_i^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i + \sum\limits_{i=1}^{m}\alpha_i \\&amp; = -\frac{1}{2}\sum\limits_{i=1,j=1}^{m}\alpha_iy_ix_i^T\alpha_jy_jx_j + \sum\limits_{i=1}^{m}\alpha_i \\&amp; = \sum\limits_{i=1}^{m}\alpha_i  - \frac{1}{2}\sum\limits_{i=1,j=1}^{m}\alpha_i\alpha_jy_iy_jx_i^Tx_j  \end{align}<br>$$<br>其中，(1)式到(2)式用到了范数的定义$||w||_2^2 =w^Tw$, (2)式到(3)式用到了上面的$w = \sum\limits_{i=1}^{m}\alpha_iy_ix_i$， (3)式到(4)式把和样本无关的$w^T$提前，(4)式到(5)式合并了同类项，(5)式到(6)式把和样本无关的$b$提前，(6)式到(7)式继续用到$w = \sum\limits_{i=1}^{m}\alpha_iy_ix_i$，（7）式到(8)式用到了向量的转置。由于常量的转置是其本身，所有只有向量$x_i$被转置，（8）式到(9)式用到了上面的$\sum\limits_{i=1}^{m}\alpha_iy_i = 0$，（9）式到(10)式使用了$(a+b+c+…)(a+b+c+…)=aa+ab+ac+ba+bb+bc+…$的乘法运算法则，（10）式到(11)式仅仅是位置的调整。</p>
<p>从上面可以看出，通过对$w,b$极小化以后，我们的优化函数$\psi(\alpha)$仅仅只有$\alpha$向量做参数。只要我们能够极大化$\psi(\alpha)$，就可以求出此时对应的$\alpha$，进而求出$w,b$.</p>
<p>对$\psi(\alpha)$求极大化的数学表达式如下:<br>$$<br> \underbrace{max}_{\alpha} -\frac{1}{2}\sum\limits_{i=1}^{m}\sum\limits_{j=1}^{m}$\alpha_i\alpha_jy_iy_j(x_i \bullet x_j) + \sum\limits_{i=1}^{m} \alpha_i<br> $$</p>
<p>$$<br>s.t. \; \sum\limits_{i=1}^{m}\alpha_iy_i = 0<br>$$</p>
<p>$$<br> \alpha_i \geq 0  \; i=1,2,…m<br>$$<br>可以去掉负号，即为等价的极小化问题如下：<br>$$<br>\underbrace{min}_{\alpha} \frac{1}{2}\sum\limits_{i=1}^{m}\sum\limits_{j=1}^{m}\alpha_i\alpha_jy_iy_j(x_i \bullet x_j) -  \sum\limits_{i=1}^{m} \alpha_i<br>$$</p>
<p>$$<br>s.t. \; \sum\limits_{i=1}^{m}\alpha_iy_i = 0<br>$$</p>
<p>$$<br> \alpha_i \geq 0  \; i=1,2,…m<br>$$<br> 只要我们可以求出上式极小化时对应的$\alpha$向量就可以求出w和b了。具体怎么极小化上式得到对应的$\alpha$，一般需要用到SMO算法，这个算法比较复杂，我们后面会专门来讲。在这里，我们假设通过SMO算法，我们得到了对应的$\alpha$的值$\alpha^{*}$。</p>
<p>那么我们根据$w = \sum\limits_{i=1}^{m}\alpha_iy_ix_i$，可以求出对应的$w$的值<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1forfr9etejj306f02cwe9.jpg" alt=""><br>求b则稍微麻烦一点。注意到，对于任意支持向量$(x_x, y_s)$，都有</p>
<p>$$<br>y_s(w^Tx_s+b) = y_s(\sum\limits_{i=1}^{S}\alpha_iy_ix_i^Tx_s+b) = 1<br>$$<br>假设我们有S个支持向量，则对应我们求出S个<img src="https://ws3.sinaimg.cn/large/006tKfTcgy1forg9kg5ekj300l00s0sh.jpg" alt="">,理论上这些<img src="https://ws3.sinaimg.cn/large/006tKfTcgy1forg9kg5ekj300l00s0sh.jpg" alt="">都可以作为最终的结果， 但是我们一般采用一种更健壮的办法，即求出所有支持向量所对应的<img src="https://ws3.sinaimg.cn/large/006tKfTcgy1forgacjnllj300l00r3y9.jpg" alt="">，然后将其平均值作为最后的结果。</p>
<p>怎么得到支持向量呢？根据KKT条件中的对偶互补条件$\alpha_{i}^{*}(y_i(w^Tx_i + b) - 1) = 0$，如果$\alpha_i&gt;0$则有$y_i(w^Tx_i + b) =1$ 即点在支持向量上，否则如果$\alpha_i=0$则有$y_i(w^Tx_i + b) \geq 1$，即样本在支持向量上或者已经被正确分类。</p>
<h3 id="5-线性可分SVM的算法过程"><a href="#5-线性可分SVM的算法过程" class="headerlink" title="5. 线性可分SVM的算法过程"></a>5. 线性可分SVM的算法过程</h3><p>这里我们对线性可分SVM的算法过程做一个总结。</p>
<p>输入是线性可分的m个样本${(x_1,y_1), (x_2,y_2), …, (x_m,y_m),}$,其中x为n维特征向量。y为二元输出，值为1，或者-1.</p>
<p>输出是分离超平面的参数<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1forgb0sjhmj301o00oa9t.jpg" alt="">和分类决策函数。</p>
<p>算法过程如下：</p>
<p>1）构造约束优化问题<br>$$<br>\underbrace{min}_{\alpha} \frac{1}{2}\sum\limits_{i=1}^{m}\sum\limits_{j=1}^{m}\alpha_i\alpha_jy_iy_j(x_i \bullet x_j) -  \sum\limits_{i=1}^{m} \alpha_i<br>s.t. \; \sum\limits_{i=1}^{m}\alpha_iy_i = 0<br> \alpha_i \geq 0  \; i=1,2,…m<br>$$<br>2）用SMO算法求出上式最小时对应的$\alpha$向量的值$\alpha^{*}$向量.</p>
<p>3）计算出<img src="https://ws1.sinaimg.cn/large/006tKfTcgy1forjigtez9j304101jq2p.jpg" alt=""></p>
<p>4) 找出所有的S个支持向量,即满足$\alpha_s &gt; 0对应的样本(x_s,y_s)$，通过 $y_s(\sum\limits_{i=1}^{S}\alpha_iy_ix_i^Tx_s+b) = 1$，计算出每个支持向量$(x_x, y_s)$对应的<img src="https://ws3.sinaimg.cn/large/006tKfTcgy1forignoltxj300n00s3y9.jpg" alt="">,计算出这些<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1forih85h1ij305k01m0si.jpg" alt="">. 所有的<img src="https://ws1.sinaimg.cn/large/006tKfTcgy1forihgijw3j300k00w0sh.jpg" alt="">对应的平均值即为最终的<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1foriho23knj303701ljr5.jpg" alt=""></p>
<p> 这样最终的分类超平面为：<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1forihwybdtj304000wdfl.jpg" alt="">，最终的分类决策函数为：<img src="https://ws1.sinaimg.cn/large/006tKfTcgy1forii2lcckj306c00z0si.jpg" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>线性可分SVM的学习方法对于非线性的数据集是没有办法使用的， 有时候不能线性可分的原因是线性数据集里面多了少量的异常点，由于这些异常点导致了数据集不能线性可分， 那么怎么可以处理这些异常点使数据集依然可以用线性可分的思想呢？ 我们在下一节的线性SVM的软间隔最大化里继续讲。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[感知机原理小结]]></title>
      <url>/%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="感知机原理小结"><a href="#感知机原理小结" class="headerlink" title="感知机原理小结"></a>感知机原理小结</h2><p>感知机可以说是最古老的分类方法之一了，在1957年就已经提出。今天看来它的分类模型在大多数时候泛化能力不强，但是它的原理却值得好好研究。因为研究透了感知机模型，学习支持向量机的话会降低不少难度。同时如果研究透了感知机模型，再学习神经网络，深度学习，也是一个很好的起点。这里对感知机的原理做一个小结。</p>
<h3 id="1-感知机模型"><a href="#1-感知机模型" class="headerlink" title="1. 感知机模型"></a>1. 感知机模型</h3><p>感知机的思想很简单，比如我们在一个平台上有很多的男孩女孩，感知机的模型就是尝试找到一条直线，能够把所有的男孩和女孩隔离开。放到三维空间或者更高维的空间，感知机的模型就是尝试找到一个超平面，能够把所有的二元类别隔离开。当然你会问，如果我们找不到这么一条直线的话怎么办？找不到的话那就意味着类别线性不可分，也就意味着感知机模型不适合你的数据的分类。使用感知机一个最大的前提，就是数据是线性可分的。这严重限制了感知机的使用场景。它的分类竞争对手在面对不可分的情况时，比如支持向量机可以通过核技巧来让数据在高维可分，神经网络可以通过激活函数和增加隐藏层来让数据可分。</p>
<p>用数学的语言来说，如果我们有m个样本，每个样本对应于n维特征和一个二元类别输出，如下：<br>$$<br>(x_1^{(0)}, x_2^{(0)}, …x_n^{(0)}, y_0), (x_1^{(1)}, x_2^{(1)}, …x_n^{(1)},y_1), … (x_1^{(m)}, x_2^{(m)}, …x_n^{(m)}, y_m)<br>$$<br>我们的目标是找到这样一个超平面，即：<br>$$<br>\theta_0 + \theta_{1}x_1 + … + \theta_{n}x_{n} = 0<br>$$<br>让其中一种类别的样本都满足$\theta_0 + \theta_{1}x_1 + … + \theta_{n}x_{n} &gt; 0$ ，让另一种类别的样本都满足$\theta_0 + \theta_{1}x_1 + … + \theta_{n}x_{n} &lt; 0$ ，从而得到线性可分。如果数据线性可分，这样的超平面一般都不是唯一的，也就是说感知机模型可以有多个解。</p>
<p>为了简化这个超平面的写法，我们增加一个特征$x_0 = 1$  ，这样超平面为$\sum\limits_{i=0}^{n}\theta_{i}x_{i} = 0$。进一步用向量来表示为： $\theta \bullet x = 0$,其中$\theta$ 为(n+1)x1的向量，x为(n+1)x1的向量, $\bullet$ 为内积，后面我们都用向量来表示超平面。</p>
<p>   而感知机的模型可以定义为：$y = sign(z)$ 其中：<br>$$<br>sign(z)= \begin{cases} -1&amp; {z&lt;0}\\ 1&amp; {z\geq 0} \end{cases}<br>$$<br>$z = \theta \bullet x$。</p>
<h3 id="2-感知机模型损失函数"><a href="#2-感知机模型损失函数" class="headerlink" title="2. 感知机模型损失函数"></a>2. 感知机模型损失函数</h3><p>为了后面便于定义损失函数，我们将满足$\theta \bullet x &gt; 0$的样本类别输出值取为1，满足$\theta \bullet x &lt; 0$的样本类别输出值取为-1，  这样取y的值有一个好处，就是方便定义损失函数。因为正确分类的样本满足$y\theta \bullet x &gt; 0$，而错误分类的样本满足 $y\theta \bullet x &lt; 0$。我们损失函数的优化目标，就是期望使误分类的所有样本，到超平面的距离之和最小。</p>
<p>由于$y\theta \bullet x &lt; 0$，所以对于每一个误分类的样本i  ，到超平面的距离是<br>$$<br>\theta \bullet x^{(i)}\big / ||\theta||_2,<br>$$<br>其中$||\theta||_2$为L2范数。</p>
<p>我们假设所有误分类的点的集合为M，则所有误分类的样本到超平面的距离之和为：<br>$$<br>\sum\limits_{x_i \in M}y^{(i)}\theta \bullet x^{(i)}\big / ||\theta||_2,<br>$$<br>这样我们就得到了初步的感知机模型的损失函数。</p>
<p>我们研究可以发现，分子和分母都含有$\theta$,当分子的$\theta$扩大N倍时，分母的L2范数也会扩大N倍。也就是说，分子和分母有固定的倍数关系。那么我们可以固定分子或者分母为1，然后求另一个即分子自己或者分母的倒数的最小化作为损失函数，这样可以简化我们的损失函数。在感知机模型中，我们采用的是保留分子，即最终感知机模型的损失函数简化为：<br>$$<br>J(\theta) = - \sum\limits_{x_i \in M}y^{(i)}\theta \bullet x^{(i)}<br>$$<br>题外话，如果大家了解过支持向量机，就发现支持向量机采用的是固定分子为1，然后求$1/ ||\theta||_2$的最小化。采用不同的损失函数主要与它的后面的优化算法有关系。</p>
<h3 id="3-感知机模型损失函数的优化方法"><a href="#3-感知机模型损失函数的优化方法" class="headerlink" title="3. 感知机模型损失函数的优化方法"></a>3. 感知机模型损失函数的优化方法</h3><p>上一节我们讲到了感知机的损失函数：$J(\theta) = - \sum\limits_{x_i \in M}y^{(i)}\theta \bullet x^{(i)}$，其中M是所有误分类的点的集合。这是一个凸函数，可以用梯度下降法或者拟牛顿法来解决，常用的是梯度下降法。</p>
<p>但是用普通的基于所有样本的梯度和的均值的批量梯度下降法（BGD）是行不通的，原因在于我们的损失函数里面有限定，只有误分类的M集合里面的样本才能参与损失函数的优化。所以我们不能用最普通的批量梯度下降,只能采用随机梯度下降（SGD）或者小批量梯度下降（MBGD）。如果对这几种梯度下降法的区别不了解，可以参考我的另一篇文章<a href="http://pancakeawesome.ink/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%EF%BC%88Gradient-Descent%EF%BC%89%E5%B0%8F%E7%BB%93.html">梯度下降（Gradient Descent）小结</a> </p>
<p>感知机模型选择的是采用随机梯度下降，这意味着我们每次仅仅需要使用一个误分类的点来更新梯度。</p>
<p>损失函数基于$\theta$向量的的偏导数为：<br>$$<br>\frac{\partial}{\partial \theta}J(\theta) = - \sum\limits_{x_i \in M}y^{(i)}x^{(i)}<br>$$<br>$\theta$的梯度下降迭代公式应该为：<br>$$<br>\theta = \theta  + \alpha\sum\limits_{x_i \in M}y^{(i)}x^{(i)}<br>$$<br>由于我们采用随机梯度下降，所以每次仅仅采用一个误分类的样本来计算梯度，假设采用第i个样本来更新梯度，则简化后的$\theta$向量的梯度下降迭代公式为：<br>$$<br>\theta = \theta  + \alpha y^{(i)}x^{(i)}<br>$$<br>其中$\alpha$为步长，$y^{(i)}$为样本输出1或者-1，$x^{(i)}$为(n+1)x1的向量。 </p>
<h3 id="3-感知机模型的算法"><a href="#3-感知机模型的算法" class="headerlink" title="3. 感知机模型的算法"></a>3. 感知机模型的算法</h3><p>前两节我们谈到了感知机模型，对应的损失函数和优化方法。这里我们就对感知机模型基于随机梯度下降来求$\theta$向量的算法做一个总结。</p>
<p>算法的输入为m个样本，每个样本对应于n维特征和一个二元类别输出1或者-1，如下：<br>$$<br>(x_1^{(0)}, x_2^{(0)}, …x_n^{(0)}, y_0), (x_1^{(1)}, x_2^{(1)}, …x_n^{(1)},y_1), … (x_1^{(m)}, x_2^{(m)}, …x_n^{(m)}, y_m)<br>$$<br>输出为分离超平面的模型系数$\theta$向量</p>
<p>算法的执行步骤如下：</p>
<p>1) 定义所有$x_0$为1。选择$\theta$向量的初值和 步长$\alpha$的初值。可以将$\theta$向量置为0向量，步长设置为1。要注意的是，由于感知机的解不唯一，使用的这两个初值会影响$\theta$向量的最终迭代结果。</p>
<p>2) 在训练集里面选择一个误分类的点$(x_1^{(i)}, x_2^{(i)}, …x_n^{(i)}, y_i)$, 用向量表示即$(x^{(i)}, y^{(i)})$，这个点应该满足：$y^{(i)}\theta \bullet x^{(i)} &lt; 0$</p>
<p>3) 对$\theta$向量进行一次随机梯度下降的迭代：$\theta = \theta  + \alpha y^{(i)}x^{(i)} $</p>
<p>4）检查训练集里是否还有误分类的点，如果没有，算法结束，此时的$\theta$向量即为最终结果。如果有，继续第2步。</p>
<h3 id="4-感知机模型的算法对偶形式"><a href="#4-感知机模型的算法对偶形式" class="headerlink" title="4. 感知机模型的算法对偶形式"></a>4. 感知机模型的算法对偶形式</h3><p>上一节的感知机模型的算法形式我们一般称为感知机模型的算法原始形式。对偶形式是对算法执行速度的优化。具体是怎么优化的呢？</p>
<p>通过上一节感知机模型的算法原始形式$\theta = \theta  + \alpha y^{(i)}x^{(i)}$可以看出，我们每次梯度的迭代都是选择的一个样本来更新$\theta$向量。最终经过若干次的迭代得到最终的结果。对于从来都没有误分类过的样本，他被选择参与$\theta$迭代的次数是0，对于被多次误分类而更新的样本j，它参与$\theta$迭代的次数我们设置为$m_j$。如果令$\theta$向量初始值为0向量， 这样我们的$\theta$向量的表达式可以写为：<br>$$<br>\theta = \alpha \sum\limits_{j=1}^{m}m_jy^{(j)}x^{(j)}<br>$$<br>其中$m_j$为样本$(x^{(j)}, y^{(j)})$在随机梯度下降到当前的这一步之前因误分类而更新的次数。</p>
<p>每一个样本$(x^{(j)}, y^{(j)})$的$m_j$的初始值为0，每当此样本在某一次梯度下降迭代中因误分类而更新时，$m_j$的值加1。</p>
<p>由于步长$\alpha$为常量，我们令$\beta_j = \alpha m_j$,这样$\theta$向量的表达式为:<br>$$<br>\theta = \sum\limits_{j=1}^{m}\beta_j y^{(j)}x^{(j)}<br>$$<br>在每一步判断误分类条件的地方，我们用 $y^{(i)}\theta \bullet x^{(i)} &lt; 0$ 的变种 $y^{(i)}\sum\limits_{j=1}^{m}\beta_j y^{(j)}x^{(j)}\bullet x^{(i)} &lt; 0$ 来判断误分类。注意到这个判断误分类的形式里面是计算两个样本$x^{(i)}和x^{(j)}$的内积，而且这个内积计算的结果在下面的迭代次数中可以重用。如果我们事先用矩阵运算计算出所有的样本之间的内积，那么在算法运行时， 仅仅一次的矩阵内积运算比多次的循环计算省时。 计算量最大的判断误分类这儿就省下了很多的时间，，这也是对偶形式的感知机模型比原始形式优的原因。</p>
<p>样本的内积矩阵称为Gram矩阵，它是一个对称矩阵，记为 $G = [x^{(i)} \bullet x^{(j)} ]$</p>
<p>这里给出感知机模型的算法对偶形式的内容。</p>
<p>算法的输入为m个样本，每个样本对应于n维特征和一个二元类别输出1或者-1，如下：<br>$$<br>(x_1^{(0)}, x_2^{(0)}, …x_n^{(0)}, y_0), (x_1^{(1)}, x_2^{(1)}, …x_n^{(1)},y_1), … (x_1^{(m)}, x_2^{(m)}, …x_n^{(m)}, y_m)<br>$$<br>输出为分离超平面的模型系数$\theta$向量</p>
<p>算法的执行步骤如下：</p>
<p>1) 定义所有$x_0$为1，步长$\alpha$初值，设置$\beta$的初值0。可以将$\alpha$设置为1。要注意的是，由于感知机的解不唯一，使用的步长初值会影响$\theta$向量的最终迭代结果。</p>
<p>2) 计算所有样本内积形成的Gram矩阵G。</p>
<p>2) 在训练集里面选择一个误分类的点$(x^{(i)}, y^{(i)})$，这个点应该满足：$y^{(i)}\sum\limits_{j=1}^{m}\beta_j y^{(j)}x^{(j)}\bullet x^{(i)} &lt; 0$，  在检查是否满足时可以通过查询Gram矩阵的$g_{ij}$ 的值来快速计算是否小于0。</p>
<p>3) 对$\beta$向量的第i个分量进行一次更新：$\beta_i= \beta_i+ \alpha $</p>
<p>4）检查训练集里是否还有误分类的点，如果没有，算法结束，此时的$\theta$向量最终结果为下式。如果有，继续第2步。<br>$$<br>\theta = \sum\limits_{j=1}^{m}\beta_j y^{(j)}x^{(j)}<br>$$<br>其中$\beta_j$  为$\beta$向量的第j个分量。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>感知机算法是一个简单易懂的算法，自己编程实现也不太难。前面提到它是很多算法的鼻祖，比如支持向量机算法，神经网络与深度学习。因此虽然它现在已经不是一个在实践中广泛运用的算法，还是值得好好的去研究一下。感知机算法对偶形式为什么在实际运用中比原始形式快，也值得好好去体会。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[精确率与召回率，RoC曲线与PR曲线]]></title>
      <url>/%E7%B2%BE%E7%A1%AE%E7%8E%87%E4%B8%8E%E5%8F%AC%E5%9B%9E%E7%8E%87%EF%BC%8CRoC%E6%9B%B2%E7%BA%BF%E4%B8%8EPR%E6%9B%B2%E7%BA%BF.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在机器学习的算法评估中，尤其是分类算法评估中，我们经常听到精确率(precision)与召回率(recall)，RoC曲线与PR曲线这些概念，那这些概念到底有什么用处呢？</p>
<h2 id="精确率与召回率，RoC曲线与PR曲线"><a href="#精确率与召回率，RoC曲线与PR曲线" class="headerlink" title="精确率与召回率，RoC曲线与PR曲线"></a>精确率与召回率，RoC曲线与PR曲线</h2><p>首先，我们需要搞清楚几个拗口的概念：</p>
<h3 id="1-TP-FP-TN-FN"><a href="#1-TP-FP-TN-FN" class="headerlink" title="1. TP, FP, TN, FN"></a>1. TP, FP, TN, FN</h3><p>1.True Positives,TP：预测为正样本，实际也为正样本的特征数<br>2.False Positives,FP：预测为正样本，实际为负样本的特征数<br>3.True Negatives,TN：预测为负样本，实际也为负样本的特征数<br>4.False Negatives,FN：预测为负样本，实际为正样本的特征数</p>
<p>听起来还是很费劲，不过我们用一张图就很容易理解了。图如下所示，里面绿色的半圆就是TP(True Positives), 红色的半圆就是FP(False Positives), 左边的灰色长方形（不包括绿色半圆），就是FN（False Negatives）。右边的 浅灰色长方形（不包括红色半圆），就是TN(True Negatives)。这个绿色和红色组成的圆内代表我们分类得到模型结果认为是正值的样本。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1folr0nx47uj30dj0b5wfe.jpg" alt=""></p>
<h3 id="2-精确率-precision-召回率-Recall-与特异性-specificity"><a href="#2-精确率-precision-召回率-Recall-与特异性-specificity" class="headerlink" title="2. 精确率(precision),召回率(Recall)与特异性(specificity)"></a>2. 精确率(precision),召回率(Recall)与特异性(specificity)</h3><p>精确率（Precision）的定义在上图可以看出，是绿色半圆除以红色绿色组成的圆。严格的数学定义如下：<br>$$<br>P = \frac{TP}{TP + FP }<br>$$<br>召回率(Recall)的定义也在图上能看出，是绿色半圆除以左边的长方形。严格的数学定义如下：<br>$$<br>R = \frac{TP}{TP + FN }<br>$$<br>特异性(specificity)的定义图上没有直接写明，这里给出，是红色半圆除以右边的长方形。严格的数学定义如下：<br>$$<br>S = \frac{FP}{FP + TN }<br>$$<br>有时也用一个F1值来综合评估精确率和召回率，它是精确率和召回率的调和均值。当精确率和召回率都高时,F1值也会高。严格的数学定义如下：<br>$$<br>\frac{2}{F_1} = \frac{1}{P} + \frac{1}{R}<br>$$<br>有时候我们对精确率和召回率并不是一视同仁，比如有时候我们更加重视精确率。我们用一个参数$\beta$来度量两者之间的关系。如果$\beta&gt;1$, 召回率有更大影响，如果$\beta&lt;1$,精确率有更大影响。自然，当$\beta=1$的时候，精确率和召回率影响力相同，和F1形式一样。含有度量参数$\beta$的F1我们记为$F_\beta$, 严格的数学定义如下：<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fp26nunyjrj305t01z742.jpg" alt=""><br>我们熟悉了精确率， 召回率和特异性，后面的RoC曲线和PR曲线就好了解了。</p>
<h3 id="3-RoC曲线和PR曲线"><a href="#3-RoC曲线和PR曲线" class="headerlink" title="3. RoC曲线和PR曲线"></a>3. RoC曲线和PR曲线</h3><p>有了上面精确率， 召回率和特异性的基础，理解RoC曲线和PR曲线就小菜一碟了。</p>
<p>以召回率为y轴，以特异性为x轴，我们就直接得到了RoC曲线。从召回率和特异性的定义可以理解，召回率越高，特异性越小，我们的模型和算法就越高效。也就是画出来的RoC曲线越靠近左上越好。如下图左图所示。从几何的角度讲，RoC曲线下方的面积越大越大，则模型越优。所以有时候我们用RoC曲线下的面积，即AUC（Area Under Curve）值来作为算法和模型好坏的标准。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1folr0wvsgej30et07bdfw.jpg" alt=""></p>
<p>以精确率为y轴，以召回率为x轴，我们就得到了PR曲线。仍然从精确率和召回率的定义可以理解，精确率越高，召回率越高，我们的模型和算法就越高效。也就是画出来的PR曲线越靠近右上越好。如上图右图所示。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>使用RoC曲线和PR曲线，我们就能很方便的评估我们的模型的分类能力的优劣了。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[逻辑回归原理小结]]></title>
      <url>/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://pancakeawesome.ink/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93.html">线性回归原理小结</a></p>
<p>逻辑回归是一个分类算法，它可以处理二元分类以及多元分类。虽然它名字里面有“回归”两个字，却不是一个回归算法。那为什么有“回归”这个误导性的词呢？后面我们会说道逻辑回归的假设函数是sigmoid函数，逻辑回归又被称为sigmoid回归，本文对逻辑回归原理做一个总结。</p>
<h2 id="逻辑回归原理小结"><a href="#逻辑回归原理小结" class="headerlink" title="逻辑回归原理小结"></a>逻辑回归原理小结</h2><h3 id="1-从线性回归到逻辑回归"><a href="#1-从线性回归到逻辑回归" class="headerlink" title="1. 从线性回归到逻辑回归"></a>1. 从线性回归到逻辑回归</h3><p>我们知道，线性回归的模型是求出输出特征向量Y和输入样本矩阵X之间的线性关系系数$\theta$，满足$\mathbf{Y = X\theta}$。此时我们的Y是连续的，所以是回归模型。如果我们想要Y是离散的话，怎么办呢？一个可以想到的办法是，我们对于这个Y再做一次函数转换，变为$g(Y)$。如果我们令$g(Y)$的值在某个实数区间的时候是类别A，在另一个实数区间的时候是类别B，以此类推，就得到了一个分类模型。如果结果的类别只有两种，那么就是一个二元分类模型了。逻辑回归的出发点就是从这来的。下面我们开始引入二元逻辑回归。</p>
<h3 id="2-二元逻辑回归的模型"><a href="#2-二元逻辑回归的模型" class="headerlink" title="2. 二元逻辑回归的模型"></a>2. 二元逻辑回归的模型</h3><p>上一节我们提到对线性回归的结果做一个在函数g上的转换，可以变化为逻辑回归。这个函数g在逻辑回归中我们一般取为sigmoid函数，形式如下：<br>$$<br>\frac{1}{1+e^{-z}}<br>$$<br>它有一个非常好的性质，即当z趋于正无穷时，$g(z)$趋于1，而当z趋于负无穷时，$g(z)$趋于0，这非常适合于我们的分类概率模型。另外，它还有一个很好的导数性质：<br>$$<br>g^{‘}(z) = g(z)(1-g(z))<br>$$<br>这个通过函数对$g(z)$求导很容易得到，后面我们会用到这个式子。</p>
<p>如果我们令$g(z)$中的z为：${z = x\theta}$，这样就得到了二元逻辑回归模型的一般形式：<br>$$<br>h_{\theta}(x) = \frac{1}{1+e^{-x\theta}}<br>$$<br>其中x为样本输入，$h_{\theta}(x)$为模型输出，可以理解为某一分类的概率大小。而$\theta$为分类模型的要求出的模型参数。对于模型输出$h_{\theta}(x)$，我们让它和我们的二元样本输出y（假设为0和1）有这样的对应关系，如果$h_{\theta}(x) &gt;0.5 $，即$\theta &gt; 0$, 则y为1。如果$h_{\theta}(x) &lt; 0.5$，即$\theta &lt; 0$, 则y为0。y=0.5是临界情况，此时$\theta = 0$为， 从逻辑回归模型本身无法确定分类。</p>
<p>$h_{\theta}(x)$的值越小，而分类为0的的概率越高，反之，值越大的话分类为1的的概率越高。如果靠近临界点，则分类准确率会下降。</p>
<p>此处我们也可以将模型写成矩阵模式：<br>$$<br>h_{\theta}(X) = \frac{1}{1+e^{-X\theta}}<br>$$<br>其中$h_{\theta}(X)$为模型输出，为 mx1的维度。X为样本特征矩阵，为mxn的维度。$\theta$为分类的模型系数，为nx1的向量。</p>
<p>理解了二元分类回归的模型，接着我们就要看模型的损失函数了，我们的目标是极小化损失函数来得到对应的模型系数$\theta$。</p>
<h3 id="3-二元逻辑回归的损失函数"><a href="#3-二元逻辑回归的损失函数" class="headerlink" title="3. 二元逻辑回归的损失函数"></a>3. 二元逻辑回归的损失函数</h3><p>回顾下线性回归的损失函数，由于线性回归是连续的，所以可以使用模型误差的的平方和来定义损失函数。但是逻辑回归不是连续的，自然线性回归损失函数定义的经验就用不上了，而且逻辑回归对应的平方差的损失函数并不是凸函数，我们不能进行凸优化，找到全局最优值。不过我们可以使用最大似然法，通过训练集来拟合参数，来推导出我们的损失函数。</p>
<p>我们可以找到这种损失函数的定义，<br>$$<br>cost(h_{\theta}(x), y) = -log(P(y=1|x;\theta)),<br>$$</p>
<p>$$<br>cost(h_{\theta}(x), y) = -log(1-P(y=0|x;\theta))<br>$$</p>
<p>总结一下，可以用I指示函数将上述两个式子写成一个。<br>$$<br>cost(h_{\theta}(x), y) = -log(I(y=i)P(y=i|x;\theta))<br>$$</p>
<p>其中cost函数是损失函数。我们观察到，这个cost函数很符合分类对损失函数的要求。</p>
<p>对于上面的cost函数的选择，我们有两种解释，分别从信息论和概率论的角度出发：<br>信息理论视角：在“真实”分布p和估计分布q之间的交叉熵定义如下：</p>
<p>$\displaystyle H(p,q)=-\sum_xp(x) logq(x)$<br>因此，Softmax分类器所做的就是最小化在估计分类概率（就是上面的$e^{f_{y_i}}/\sum_je^{f_j}）$和“真实”分布之间的交叉熵，在这个解释中，“真实”分布就是所有概率密度都分布在正确的类别上（比如：p=[0,…1,…,0]中在y_i的位置就有一个单独的1）。还有，既然交叉熵可以写成熵和相对熵（Kullback-Leibler divergence）$H(p,q)=H(p)+D_{KL}(p||q)$，并且delta函数p的熵是0，那么就能等价的看做是对两个分布之间的相对熵做最小化操作。换句话说，交叉熵损失函数“想要”预测分布的所有概率密度都在正确分类上。</p>
<p>译者注：Kullback-Leibler差异（Kullback-Leibler Divergence）也叫做相对熵（Relative Entropy），它衡量的是相同事件空间里的两个概率分布的差异情况。</p>
<p>概率论解释：先看下面的公式：</p>
<p>$P(y_i|x_i,W)=\frac{e^{f_{y_i}}}{\sum_je^{f_j}}$<br>可以解释为是给定图像数据$x_i$，以W为参数，分配给正确分类标签$y_i$的归一化概率。为了理解这点，请回忆一下Softmax分类器将输出向量f中的评分值解释为没有归一化的对数概率。那么以这些数值做指数函数的幂就得到了没有归一化的概率，而除法操作则对数据进行了归一化处理，使得这些概率的和为1。从概率论的角度来理解，我们就是在最小化正确分类的负对数概率，这可以看做是在进行最大似然估计（MLE）。该解释的另一个好处是，损失函数中的正则化部分R(W)可以被看做是权重矩阵W的高斯先验，这里进行的是最大后验估计（MAP）而不是最大似然估计。提及这些解释只是为了让读者形成直观的印象，具体细节就超过本课程范围了。</p>
<p>我们知道，按照第二节二元逻辑回归的定义，假设我们的样本输出是0或者1两类。那么我们有：<br>$$<br>P(y=1|x,\theta ) = h_{\theta}(x)<br>$$</p>
<p>$$<br>P(y=0|x,\theta ) = 1- h_{\theta}(x)<br>$$<br> 把这两个式子写成一个式子，就是：<br>$$<br>P(y|x,\theta ) = h_{\theta}(x)^y(1-h_{\theta}(x))^{1-y}<br>$$<br>其中y的取值只能是0或者1。</p>
<p>用矩阵法表示，即为：<br>$$<br>P(Y|X,\theta ) = h_{\theta}(X)^Y(1-h_{\theta}(X))^{1-Y}<br>$$</p>
<p>得到了y的概率分布函数表达式，我们就可以用似然函数最大化来求解我们需要的模型系数$\theta$。</p>
<p>为了方便求解，这里我们用对数似然函数最大化，对数似然函数取反即为我们的损失函数$J(\theta)$。其中：</p>
<p>似然函数的代数表达式为：<br>$$<br>L(\theta) = P(Y|X;\theta)=\prod\limits_{i=1}^{m}P(y^{(i)}|x^{(i)};\theta)=\prod\limits_{i=1}^{m}(h_{\theta}(x^{(i)}))^{y^{(i)}}(1-h_{\theta}(x^{(i)}))^{1-y^{(i)}}<br>$$<br>其中m为样本的个数。</p>
<p>根据上面我们对cost函数的推导，对似然函数对数化取反的表达式，即损失函数表达式为：<br>$$<br>J(\theta) = -lnL(\theta) = -\sum\limits_{i=1}^{m}(y^{(i)}log(h_{\theta}(x^{(i)}))+ (1-y^{(i)})log(1-h_{\theta}(x^{(i)})))<br>$$<br> 损失函数用矩阵法表达更加简洁：<br>$$<br>J(\theta) = -Y\bullet logh_{\theta}(X) - (1-Y)\bullet log(1-h_{\theta}(X))<br>$$<br>其中$\bullet$为阿达姆乘积，在octave和matlab中用<code>.*</code>表示，代表矩阵中每个元素相乘。</p>
<h3 id="4-二元逻辑回归的损失函数的优化方法"><a href="#4-二元逻辑回归的损失函数的优化方法" class="headerlink" title="4. 二元逻辑回归的损失函数的优化方法"></a>4. 二元逻辑回归的损失函数的优化方法</h3><p>对于二元逻辑回归的损失函数极小化，有比较多的方法，最常见的有梯度下降法，坐标轴下降法，等牛顿法等。这里推导出梯度下降法中$\theta$每次迭代的公式。由于代数法推导比较的繁琐，我习惯于用矩阵法来做损失函数的优化过程，这里给出矩阵法推导二元逻辑回归梯度的过程。</p>
<p>对于$J(\theta) = -Y\bullet logh_{\theta}(X) - (1-Y)\bullet log(1-h_{\theta}(X))$，我们用$J(\theta)$对$\theta$向量求导可得：<br>$$<br>\frac{\partial}{\partial\theta}J(\theta) = -Y \bullet X^T\frac{1}{h_{\theta}(X)}h_{\theta}(X)(1-h_{\theta}(X)) + (1-Y)\bullet X^T\frac{1}{1-h_{\theta}(X)}h_{\theta}(X)(1-h_{\theta}(X))<br>$$<br>这一步我们用到了矩阵求导的链式法则，和下面三个矩阵求导公式：<br>$$<br>\frac{\partial}{\partial X}logX = 1/X<br>$$<br>$g(z)’=g(z)(1−g(z)) ,(g(z)$为sigmoid函数)。<br>$$<br>\frac{\partial}{\partial\theta}X\theta = X^T<br>$$<br>对于刚才的求导公式我们进行化简可得：<br>$$<br>\frac{\partial}{\partial\theta}J(\theta) = X^T(h_{\theta}(X) - Y )<br>$$<br>从而在梯度下降法中每一步向量$\theta$的迭代公式如下：<br>$$<br>\theta = \theta - \alpha X^T(h_{\theta}(X) - Y )<br>$$<br>其中，$\alpha$为梯度下降法的步长。</p>
<p>实践中，我们一般不用操心优化方法，大部分机器学习库都内置了各种逻辑回归的优化方法，不过了解至少一种优化方法还是有必要的。</p>
<h3 id="5-二元逻辑回归的正则化"><a href="#5-二元逻辑回归的正则化" class="headerlink" title="5. 二元逻辑回归的正则化"></a>5. 二元逻辑回归的正则化</h3><p>逻辑回归也会面临过拟合问题，所以我们也要考虑正则化。常见的有L1正则化和L2正则化。</p>
<p>逻辑回归的L1正则化的损失函数表达式如下，相比普通的逻辑回归损失函数，增加了L1的范数做作为惩罚，超参数αα\alpha作为惩罚系数，调节惩罚项的大小。</p>
<p>二元逻辑回归的L1正则化损失函数表达式如下：<br>$$<br>J(\theta) = -Y\bullet logh_{\theta}(X) - (1-Y)\bullet log(1-h_{\theta}(X)) + \frac{1}{2}\alpha||\theta||_1<br>$$<br>其中$||\theta||_1$为$\theta$的L1范数。</p>
<p>逻辑回归的L1正则化损失函数的优化方法常用的有坐标轴下降法和最小角回归法。</p>
<p>二元逻辑回归的L2正则化损失函数表达式如下：<br>$$<br>J(\theta) = -Y\bullet logh_{\theta}(X) - (1-Y)\bullet log(1-h_{\theta}(X)) + \frac{1}{2m}\alpha||\theta||_2^2<br>$$<br>其中$||\theta||_2$为$\theta$的L2范数。</p>
<p>逻辑回归的L2正则化损失函数的优化方法和普通的逻辑回归类似。</p>
<h3 id="6-二元逻辑回归的推广：多元逻辑回归"><a href="#6-二元逻辑回归的推广：多元逻辑回归" class="headerlink" title="6. 二元逻辑回归的推广：多元逻辑回归"></a>6. 二元逻辑回归的推广：多元逻辑回归</h3><p>前面几节我们的逻辑回归的模型和损失函数都局限于二元逻辑回归，实际上二元逻辑回归的模型和损失函数很容易推广到多元逻辑回归。比如总是认为某种类型为正值，其余为0值，这种方法为最常用的one-vs-reset，简称OvR.</p>
<p>另一种多元逻辑回归的方法是Many-vs-Many(MvM)，它会选择一部分类别的样本和另一部分类别的样本来做逻辑回归二分类。最常用的是One-Vs-One（OvO）。OvO是MvM的特例。每次我们选择两类样本来做二元逻辑回归。</p>
<p>这里只介绍多元逻辑回归的softmax回归的一种特例推导：</p>
<p>首先回顾下二元逻辑回归。<br>$$<br>P(y=1|x,\theta ) = h_{\theta}(x) =  \frac{1}{1+e^{-x\theta}} = \frac{e^{x\theta}}{1+e^{x\theta}}<br>$$</p>
<p>$$<br>P(y=0|x,\theta ) = 1- h_{\theta}(x) = \frac{1}{1+e^{x\theta}}<br>$$<br>其中y只能取到0和1。则有：<br>$$<br>ln\frac{P(y=1|x,\theta )}{P(y=0|x,\theta)} = x\theta<br>$$<br>如果我们要推广到多元逻辑回归，则模型要稍微做下扩展。</p>
<p>我们假设是K元分类模型,即样本输出y的取值为1，2，。。。，K。</p>
<p>根据二元逻辑回归的经验，我们有：<br>$$<br>\frac{P(y=1|x,\theta )}{P(y=K|x,\theta)} = x\theta_1<br>$$</p>
<p>$$<br>\frac{P(y=2|x,\theta )}{P(y=K|x,\theta)} = x\theta_2<br>$$<br>…<br>$$<br>ln\frac{P(y=K-1|x,\theta )}{P(y=K|x,\theta)} = x\theta_{K-1}<br>$$<br>上面有K-1个方程。</p>
<p>加上概率之和为1的方程如下：<br>$$<br>\sum\limits_{i=1}^{K}P(y=i|x,\theta ) = 1<br>$$<br>从而得到K个方程，里面有K个逻辑回归的概率分布。</p>
<p>解出这个K元一次方程组，得到K元逻辑回归的概率分布如下：<br>$$<br>P(y=k|x,\theta ) =  e^{x\theta_k} \bigg/ 1+\sum\limits_{t=1}^{K-1}e^{x\theta_t}　 k = 1,2,…K-1<br>$$</p>
<p>$$<br>P(y=K|x,\theta ) =  1 \bigg/ 1+\sum\limits_{t=1}^{K-1}e^{x\theta_t}<br>$$<br>多元逻辑回归的损失函数推导以及优化方法和二元逻辑回归类似，这里就不累述。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><a href="http://pancakeawesome.ink/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93.html">线性回归原理小结</a>。</p>
<p>逻辑回归尤其是二元逻辑回归是非常常见的模型，训练速度很快，虽然使用起来没有支持向量机（SVM）那么占主流，但是解决普通的分类问题是足够了，训练速度也比起SVM要快不少。<strong>如果你要理解机器学习分类算法，那么第一个应该学习的分类算法个人觉得应该是逻辑回归。理解了逻辑回归，其他的分类算法再学习起来应该没有那么难了。</strong></p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[线性回归原理小结]]></title>
      <url>/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://pancakeawesome.ink/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93.html">逻辑回归原理小结</a></p>
<p>线性回归可以说是机器学习中最基本的问题类型了，这里就对线性回归的原理和算法做一个小结。</p>
<h2 id="线性回归原理小结"><a href="#线性回归原理小结" class="headerlink" title="线性回归原理小结"></a>线性回归原理小结</h2><h3 id="1-线性回归的模型函数和损失函数"><a href="#1-线性回归的模型函数和损失函数" class="headerlink" title="1. 线性回归的模型函数和损失函数"></a>1. 线性回归的模型函数和损失函数</h3><p>线性回归遇到的问题一般是这样的。我们有m个样本，每个样本对应于n维特征和一个结果输出，如下：<br>$$<br>(x_1^{(0)}, x_2^{(0)}, …x_n^{(0)}, y_0), (x_1^{(1)}, x_2^{(1)}, …x_n^{(1)},y_1), … (x_1^{(m)}, x_2^{(m)}, …x_n^{(m)}, y_n)<br>$$<br>我们的问题是，对于一个新的$(x_1^{(x)}, x_2^{(x)}, …x_n^{(x)}$ , 他所对应的yxyxy_x是多少呢？ 如果这个问题里面的y是连续的，则是一个回归问题，否则是一个分类问题。</p>
<p>对于n维特征的样本数据，如果我们决定使用线性回归，那么对应的模型是这样的：</p>
<p>$h_\theta(x_1, x_2, …x_n) = \theta_0 + \theta_{1}x_1 + … + \theta_{n}x_{n}$, 其中$\theta_i $ (i = 0,1,2… n)为模型参数，$x_i  $(i = 0,1,2… n)为每个样本的n个特征值。这个表示可以简化，我们增加一个特征$x_0 = 1$  ，这样$h_\theta(x_0, x_1, …x_n) = \sum\limits_{i=0}^{n}\theta_{i}x_{i}$。</p>
<p>进一步用矩阵形式表达更加简洁如下：<br>$$<br>h_\mathbf{\theta}(\mathbf{X}) = \mathbf{X\theta}<br>$$<br>其中， 假设函数$h_\mathbf{\theta}(\mathbf{X})$为mx1的向量,$\mathbf{\theta}$为nx1的向量，里面有n个代数法的模型参数。$\mathbf{X}$为mxn维的矩阵。m代表样本的个数，n代表样本的特征数。</p>
<p>得到了模型，我们需要求出需要的损失函数，一般线性回归我们用均方误差作为损失函数。损失函数的代数法表示如下：<br>$$<br>J(\theta_0, \theta_1…, \theta_n) = \frac{1}{2m}\sum\limits_{i=0}^{m}(h_\theta(x_0, x_1, …x_n) - y_i)^2<br>$$<br><em>ps:1/m系数是为了平均损失函数，1/2是为了方便求导损失函数的计算。</em><br>进一步用矩阵形式表达损失函数：<br>$$<br>J(\mathbf\theta) = \frac{1}{m}(\mathbf{X\theta} - \mathbf{Y})^T(\mathbf{X\theta} - \mathbf{Y})<br>$$<br><em>ps:矩阵表达没有1/2是矩阵求导不需要方便乘上1/2计算。</em><br>由于矩阵法表达比较的简洁，后面我们将统一采用矩阵方式表达模型函数和损失函数。</p>
<h3 id="2-线性回归的算法"><a href="#2-线性回归的算法" class="headerlink" title="2. 线性回归的算法"></a>2. 线性回归的算法</h3><p>对于线性回归的损失函数$J(\mathbf\theta) = \frac{1}{2}(\mathbf{X\theta} - \mathbf{Y})^T(\mathbf{X\theta} - \mathbf{Y})$，我们常用的有两种方法来求损失函数最小化时候的$\mathbf{\theta}$参数：一种是<strong><a href="http://pancakeawesome.ink/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%EF%BC%88Gradient-Descent%EF%BC%89%E5%B0%8F%E7%BB%93.html">梯度下降法</a> </strong>，一种是<strong><a href="http://pancakeawesome.ink/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E5%B0%8F%E7%BB%93.html">最小二乘法</a> </strong>。由于已经在其它篇中单独介绍了梯度下降法和最小二乘法，可以点链接到对应的文章链接去阅读。</p>
<p>如果采用梯度下降法，则$\mathbf{\theta}$的迭代公式是这样的：<br>$$<br>\mathbf\theta= \mathbf\theta - \alpha\frac{1}{m}\mathbf{X}^T(\mathbf{X\theta} - \mathbf{Y})<br>$$<br>通过若干次迭代后，我们可以得到最终的$\mathbf{\theta}$的结果</p>
<p>如果采用最小二乘法，则$\mathbf{\theta}$的结果公式如下：<br>$$<br>\mathbf{\theta} = \frac{1}{m}(\mathbf{X^{T}X})^{-1}\mathbf{X^{T}Y}<br>$$</p>
<p>当然线性回归，还有其他的常用算法，比如牛顿法和拟牛顿法，这里不详细描述。</p>
<h3 id="3-线性回归的推广：多项式回归"><a href="#3-线性回归的推广：多项式回归" class="headerlink" title="3. 线性回归的推广：多项式回归"></a>3. 线性回归的推广：多项式回归</h3><p>回到我们开始的线性模型，$h_\theta(x_1, x_2, …x_n) = \theta_0 + \theta_{1}x_1 + … + \theta_{n}x_{n}$, 如果这里不仅仅是x的一次方，比如增加二次方，那么模型就变成了多项式回归。这里写一个只有两个特征的p次方多项式回归的模型：<br>$$<br>h_\theta(x_1, x_2) = \theta_0 + \theta_{1}x_1 + \theta_{2}x_{2} + \theta_{3}x_1^{2} + \theta_{4}x_2^{2} + \theta_{5}x_{1}x_2<br>$$<br>我们令$x_0 = 1, x_1 = x_1, x_2 = x_2, x_3 =x_1^{2}, x_4 = x_2^{2}, x_5 =  x_{1}x_2$ ,这样我们就得到了下式：<br>$$<br>h_\theta(x_1, x_2) = \theta_0 + \theta_{1}x_1 + \theta_{2}x_{2} + \theta_{3}x_3 + \theta_{4}x_4 + \theta_{5}x_5<br>$$<br>可以发现，我们又重新回到了线性回归，这是一个五元线性回归，可以用线性回归的方法来完成算法。对于每个二元样本特征$(x_1,x_2)$,我们得到一个五元样本特征$(1, x_1, x_2, x_{1}^2, x_{2}^2, x_{1}x_2)$，通过这个改进的五元样本特征，我们重新把不是线性回归的函数变回线性回归。</p>
<p>多项式回归常常用来拟合训练集数据，从而减少训练数据的损失。但是过多的特征有可能会导致假设函数过拟合。</p>
<h3 id="4-线性回归的推广：广义线性回归"><a href="#4-线性回归的推广：广义线性回归" class="headerlink" title="4. 线性回归的推广：广义线性回归"></a>4. 线性回归的推广：广义线性回归</h3><p>在上一节的线性回归的推广中，我们对样本特征端做了推广，这里我们对于特征y做推广。比如我们的输出$\mathbf{Y}$不满足和$\mathbf{X}$的线性关系，但是$\mathbf{Y}$ 和XX\mathbf{X}满足线性关系，模型函数如下：<br>$$<br>\mathbf{Y} = \mathbf{X\theta}<br>$$<br>这样对与每个样本的输入y，我们用 lny去对应， 从而仍然可以用线性回归的算法去处理这个问题。我们把 Iny一般化，假设这个函数是单调可微函数g(.)g(.)\mathbf{g}(.),则一般化的广义线性回归形式是：<br>$$<br>\mathbf{g}(\mathbf{Y}) = \mathbf{X\theta} 或者 \mathbf{Y} = \mathbf{g^{-1}}(\mathbf{X\theta})<br>$$<br>这个函数$\mathbf{g}(.)$我们通常称为联系函数。</p>
<h3 id="5-线性回归的正则化"><a href="#5-线性回归的正则化" class="headerlink" title="5. 线性回归的正则化"></a>5. 线性回归的正则化</h3><p>为了防止模型的过拟合，我们在建立线性模型的时候经常需要加入正则化项。一般有L1正则化和L2正则化。</p>
<p>线性回归的L1正则化通常称为Lasso回归，它和一般线性回归的区别是在损失函数上增加了一个L1正则化的项，L1正则化的项有一个常数系数$alpha$来调节损失函数的均方差项和正则化项的权重，具体Lasso回归的损失函数表达式如下：　　<br>$$<br>J(\mathbf\theta) = \frac{1}{2n}(\mathbf{X\theta} - \mathbf{Y})^T(\mathbf{X\theta} - \mathbf{Y}) + \alpha\frac{1}{m}||\theta||_1<br>$$<br>其中n为样本个数，$\alpha$为常数系数，需要进行调优。$||\theta||_1$为L1范数。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fofwspfbxmj30mi0ditae.jpg" alt=""></p>
<p> Lasso回归可以使得一些特征的系数变小，甚至还是一些绝对值较小的系数直接变为0。增强模型的泛化能力。</p>
<p> Lasso回归的求解办法一般有坐标轴下降法（coordinate descent）和最小角回归法（ Least Angle Regression），由于它们比较复杂，在我的这篇文章单独讲述： <a href="">线程回归的正则化-Lasso回归小结</a> </p>
<p>线性回归的L2正则化通常称为Ridge回归，它和一般线性回归的区别是在损失函数上增加了一个L2正则化的项，和Lasso回归的区别是Ridge回归的正则化项是L2范数，而Lasso回归的正则化项是L1范数。具体Ridge回归的损失函数表达式如下：<br>$$<br>J(\mathbf\theta) = \frac{1}{2}(\mathbf{X\theta} - \mathbf{Y})^T(\mathbf{X\theta} - \mathbf{Y}) + \frac{1}{2m}\alpha||\theta||_2^2<br>$$<br>其中$\alpha$为常数系数，需要进行调优。$||\theta||_2$为L2范数。</p>
<p>Ridge回归在不抛弃任何一个特征的情况下，缩小了回归系数，使得模型相对而言比较的稳定，但和Lasso回归比，这会使得模型的特征留的特别多，模型解释性差。</p>
<p>Ridge回归的求解比较简单，一般用最小二乘法。这里给出用最小二乘法的矩阵推导形式，和普通线性回归类似。</p>
<p>令$J(\mathbf\theta)$的导数为0，得到下式：<br>$$<br>\mathbf{X^T(X\theta - Y) + \alpha\theta} = 0<br>$$<br>整理即可得到最后的$\theta$的结果：<br>$$<br>\mathbf{\theta = (X^TX + \alpha E)^{-1}X^TY}<br>$$<br>其中E为单位矩阵。</p>
<p>除了上面这两种常见的线性回归正则化，还有一些其他的线性回归正则化算法，区别主要就在于正则化项的不同，和损失函数的优化方式不同，这里就不累述了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><a href="http://pancakeawesome.ink/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93.html">逻辑回归原理小结</a></p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[交叉验证(Cross Validation)原理小结]]></title>
      <url>/%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81-Cross-Validation-%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="交叉验证-Cross-Validation-原理小结"><a href="#交叉验证-Cross-Validation-原理小结" class="headerlink" title="交叉验证(Cross Validation)原理小结"></a>交叉验证(Cross Validation)原理小结</h2><p>交叉验证是在机器学习建立模型和验证模型参数时常用的办法。交叉验证，顾名思义，就是重复的使用数据，把得到的样本数据进行切分，组合为不同的训练集和测试集，用训练集来训练模型，用测试集来评估模型预测的好坏。在此基础上可以得到多组不同的训练集和测试集，某次训练集中的某样本在下次可能成为测试集中的样本，即所谓“交叉”。　</p>
<p>那么什么时候才需要交叉验证呢？交叉验证用在数据不是很充足的时候。比如在我日常项目里面，对于普通适中问题，如果数据样本量小于一万条，我们就会采用交叉验证来训练优化选择模型。如果样本大于一万条的话，我们一般随机的把数据分成三份，一份为训练集（Training Set），一份为验证集（Validation Set），最后一份为测试集（Test Set）。用训练集来训练模型，用验证集来评估模型预测的好坏和选择模型及其对应的参数。把最终得到的模型再用于测试集，最终决定使用哪个模型以及对应参数。</p>
<p>回到交叉验证，根据切分的方法不同，交叉验证分为下面三种：
　　　</p>
<h3 id="简单交叉验证"><a href="#简单交叉验证" class="headerlink" title="简单交叉验证"></a>简单交叉验证</h3><p>第一种是<strong>简单交叉验证</strong>，所谓的简单，是和其他交叉验证方法相对而言的。首先，我们随机的将样本数据分为两部分（比如： 70%的训练集，30%的测试集），然后用训练集来训练模型，在测试集上验证模型及参数。接着，我们再把样本打乱，重新选择训练集和测试集，继续训练数据和检验模型。最后我们选择损失函数评估最优的模型和参数。　</p>
<h3 id="S折交叉验证"><a href="#S折交叉验证" class="headerlink" title="S折交叉验证"></a>S折交叉验证</h3><p> 第二种是<strong>S折交叉验证</strong>（S-Folder Cross Validation）。和第一种方法不同，S折交叉验证会把样本数据随机的分成S份，每次随机的选择S-1份作为训练集，剩下的1份做测试集。当这一轮完成后，重新随机选择S-1份来训练数据。若干轮（小于S）之后，选择损失函数评估最优的模型和参数。</p>
<h3 id="留一交叉验证"><a href="#留一交叉验证" class="headerlink" title="留一交叉验证"></a>留一交叉验证</h3><p>第三种是<strong>留一交叉验证</strong>（Leave-one-out Cross Validation），它是第二种情况的特例，此时S等于样本数N，这样对于N个样本，每次选择N-1个样本来训练数据，留一个样本来验证模型预测的好坏。此方法主要用于样本量非常少的情况，比如对于普通适中问题，N小于50时，我一般采用留一交叉验证。</p>
<p>通过反复的交叉验证，用损失函数来度量得到的模型的好坏，最终我们可以得到一个较好的模型。那这三种情况，到底我们应该选择哪一种方法呢？一句话总结，如果我们只是对数据做一个初步的模型建立，不是要做深入分析的话，简单交叉验证就可以了。否则就用S折交叉验证。在样本量少的时候，使用S折交叉验证的特例留一交叉验证。</p>
<p>此外还有一种比较特殊的交叉验证方式，也是用于样本量少的时候。叫做<strong>自助法</strong>(bootstrapping)。比如我们有m个样本（m较小），每次在这m个样本中随机采集一个样本，放入训练集，采样完后把样本放回。这样重复采集m次，我们得到m个样本组成的训练集。当然，这m个样本中很有可能有重复的样本数据。同时，用原始的m个样本做测试集。这样接着进行交叉验证。由于我们的训练集有重复数据，这会改变数据的分布，因而训练结果会有估计偏差，因此，此种方法不是很常用，除非数据量真的很少，比如小于20个。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如有不足，欢迎指出～</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[拉格朗日乘子法（Lagrange Multiplier) 和KKT条件]]></title>
      <url>/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95%EF%BC%88Lagrange-Multiplier-%E5%92%8CKKT%E6%9D%A1%E4%BB%B6.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="http://pancakeawesome.ink/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E5%B0%8F%E7%BB%93.html">无约束优化算法–最小二乘法</a></li>
<li><a href="http://pancakeawesome.ink/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%EF%BC%88Gradient-Descent%EF%BC%89%E5%B0%8F%E7%BB%93.html">无约束优化算法–梯度下降法</a></li>
<li><a href="http://pancakeawesome.ink/%E7%89%9B%E9%A1%BF%E6%B3%95%E5%B0%8F%E7%BB%93.html">无约束优化算法–牛顿法</a></li>
<li><a href="http://pancakeawesome.ink/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95%EF%BC%88Lagrange-Multiplier-%E5%92%8CKKT%E6%9D%A1%E4%BB%B6.html">约束优化算法–拉格朗日乘子法</a></li>
</ul>
<p>在求解最优化问题中，<strong>拉格朗日乘子法</strong>（Lagrange Multiplier）和<strong>KKT</strong>（Karush Kuhn Tucker）<strong>条件</strong>是两种最常用的方法。在有等式约束时使用拉格朗日乘子法，在有不等约束时使用KKT条件。</p>
<h2 id="拉格朗日乘子法（Lagrange-Multiplier-和KKT条件"><a href="#拉格朗日乘子法（Lagrange-Multiplier-和KKT条件" class="headerlink" title="拉格朗日乘子法（Lagrange Multiplier) 和KKT条件"></a>拉格朗日乘子法（Lagrange Multiplier) 和KKT条件</h2><p>　　我们这里提到的最优化问题通常是指对于给定的某一函数，<strong>求其在指定作用域上的全局最小值(因为最小值与最大值可以很容易转化，即最大值问题可以转化成最小值问题)</strong>。提到KKT条件一般会附带的提一下拉格朗日乘子。对学过高等数学的人来说比较拉格朗日乘子应该会有些印象。二者均是求解最优化问题的方法，不同之处在于应用的情形不同。</p>
<p>一般情况下，最优化问题会碰到一下三种情况：</p>
<p><strong>（1）无约束条件</strong></p>
<p>　　这是最简单的情况，解决方法通常是函数对变量求导，令求导函数等于0的点可能是极值点。将结果带回原函数进行验证即可。</p>
<p><strong>（2）等式约束条件</strong></p>
<p>设目标函数为f(x)，约束条件为h_k(x)，形如:</p>
<p>　　s.t. 表示subject to ，“受限于”的意思，l表示有l个约束条件。</p>
<p><img src="http://img.blog.csdn.net/20150609154048760?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvam9obm55Y29uc3RhbnRpbmU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>则解决方法是<strong>消元法或者拉格朗日法</strong>。消元法比较简单不在赘述，这里主要讲拉格朗日法，因为后面提到的KKT条件是对拉格朗日乘子法的一种泛化。</p>
<p>例如给定椭球:</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fp57aqv0gjj306802ewe9.jpg" alt=""></p>
<p>　  　求这个椭球的内接长方体的最大体积。这个问题实际上就是条件极值问题，即在条件    <img src="https://images0.cnblogs.com/blog/571227/201411/231637406257888.png" alt="">  下，求<img src="https://images0.cnblogs.com/blog/571227/201411/231639439217452.png" alt="">的最大值。</p>
<p>　　  当然这个问题实际可以先根据条件消去 z <strong>(消元法)</strong>，然后带入转化为无条件极值问题来处理。但是有时候这样做很困难，甚至是做不到的，这时候就需要用<strong>拉格朗日乘数法</strong>了。  </p>
<p>　　  首先定义拉格朗日函数F(x)：</p>
<p><img src="http://img.blog.csdn.net/20150609154103976?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvam9obm55Y29uc3RhbnRpbmU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">  （ 其中λk是各个约束条件的待定系数。）   </p>
<p>然后解变量的偏导方程：</p>
<p><img src="http://img.blog.csdn.net/20150609154208263?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvam9obm55Y29uc3RhbnRpbmU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">……<img src="http://img.blog.csdn.net/20150609154221648?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvam9obm55Y29uc3RhbnRpbmU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">,</p>
<p>如果有l个约束条件，就应该有l+1个方程。求出的方程组的解就可能是最优化值（高等数学中提到的极值），将结果带回原方程验证就可得到解。</p>
<p>回到上面的题目，通过拉格朗日乘数法将问题转化为<br><img src="https://images0.cnblogs.com/blog/571227/201411/231658574531311.png" alt=""></p>
<p>对<img src="https://images0.cnblogs.com/blog/571227/201411/231659273433944.png" alt="">求偏导得到</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp57d3eg4aj30bj07l746.jpg" alt=""></p>
<p>联立前面三个方程得到<img src="https://images0.cnblogs.com/blog/571227/201411/231712092968762.png" alt="">和<img src="https://images0.cnblogs.com/blog/571227/201411/231712459683193.png" alt="">，带入第四个方程解之</p>
<p><img src="https://images0.cnblogs.com/blog/571227/201411/231716003591207.png" alt=""></p>
<p>带入解得最大体积为：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp57drxninj30ca02rweb.jpg" alt=""></p>
<p>至于为什么这么做可以求解最优化？维基百科上给出了一个比较好的直观解释。</p>
<p>举个二维最优化的例子：</p>
<p>  　 min f(x,y)    </p>
<p>  　 s.t. g(x,y) = c</p>
<p>这里画出z=f(x,y)的等高线（函数登高线定义见百度百科）：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fp57e9cxqcj309u08374b.jpg" alt=""></p>
<p>绿线标出的是约束g(x,y)=c的点的轨迹。蓝线是f(x,y)的等高线。箭头表示斜率，和等高线的法线平行。从梯度的方向上来看，显然有d1&gt;d2。绿色的线是约束，也就是说，只要正好落在这条绿线上的点才可能是满足要求的点。如果没有这条约束，f(x,y)的最小值应该会落在最小那圈等高线内部的某一点上。<strong>而现在加上了约束，最小值点应该在哪里呢？显然应该是在f(x,y)的等高线正好和约束线相切的位置，因为如果只是相交意味着肯定还存在其它的等高线在该条等高线的内部或者外部，使得新的等高线与目标函数的交点的值更大或者更小，只有到等高线与目标函数的曲线相切的时候，可能取得最优值。</strong></p>
<p>　　如果我们对约束也求梯度∇g(x,y)，则其梯度如图中绿色箭头所示。<strong>很容易看出来，要想让目标函数f(x,y)的等高线和约束相切，则他们切点的梯度一定在一条直线上(f和g的斜率平行)。</strong></p>
<p><strong>也即在最优化解的时候：$∇_f(x,y)=λ（∇_g(x,y)-C)$ </strong>   （其中∇为梯度算子; 即：f(x)的梯度 = λ* g(x)的梯度，λ是常数,可以是任何非0实数，表示左右两边同向。）</p>
<p>即：$▽[f(x,y)+λ(g(x,y)−c)]=0λ≠0$</p>
<p>　　那么拉格朗日函数： F(x,y)=f(x,y)+λ(g(x,y)−c) 在达到极值时与f(x,y)相等，因为F(x,y)达到极值时g(x,y)−c总等于零。</p>
<p>　　min( F(x,λ) )取得极小值时其导数为0，即$▽f(x)+▽\Sigma_i^n=λ_ih_i(x)=0$，也就是说f(x)和h(x)的梯度共线。</p>
<p><strong>简单的说，在F(x,λ)取得最优化解的时候，即F</strong>(x,λ)取极值（导数为0，▽[f(x,y)+λ(g(x,y)−c)]=0）的时候，<strong>f(x)与g(x) 梯度共线，此时就是在条件约束g(x)下，f(x)的最优化解。</strong></p>
<p><strong>（3）不等式约束条件</strong></p>
<p>设目标函数f(x)，不等式约束为g(x)，有的教程还会添加上等式约束条件h(x)。此时的约束优化问题描述如下：</p>
<p><img src="http://img.blog.csdn.net/20150609161331945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvam9obm55Y29uc3RhbnRpbmU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>则我们定义不等式约束下的拉格朗日函数L，则L表达式为：</p>
<p><img src="http://img.blog.csdn.net/20150609160802317?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvam9obm55Y29uc3RhbnRpbmU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>其中f(x)是原目标函数，hj(x)是第j个等式约束条件，λj是对应的约束系数，gk是不等式约束，uk是对应的约束系数。</p>
<p>　　常用的方法是KKT条件，同样地，把所有的不等式约束、等式约束和目标函数全部写为一个式子L(a, b, x)= f(x) + a<em>g(x)+b</em>h(x)，</p>
<p>KKT条件是说<strong>最优值</strong>必须满足以下条件：</p>
<p>1）L(a, b, x)对x求导为零；</p>
<p>2）h(x) =0;</p>
<p><strong>3）a*g(x) = 0;</strong></p>
<p>　　求取这些等式之后就能得到候选最优值。其中第三个式子非常有趣，因为g(x)&lt;=0，如果要满足这个等式，必须a=0或者g(x)=0. 这是SVM的很多重要性质的来源，如支持向量的概念。</p>
<p>　　接下来主要介绍KKT条件，推导及应用。详细推导过程如下：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1focuapmvucj30pu0g20t4.jpg" alt=""></p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1focub1hacmj30pp0bgwev.jpg" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>参考：</p>
<p>　　【1】<a href="http://blog.csdn.net/acdreamers/article/details/41413445" target="_blank" rel="noopener">拉格朗日乘数法</a></p>
<p>　　【2】<a href="http://blog.csdn.net/johnnyconstantine/article/details/46335763" target="_blank" rel="noopener">KKT条件介绍</a></p>
<p>　　【3】<a href="http://blog.csdn.net/xianlingmao/article/details/7919597" target="_blank" rel="noopener">深入理解拉格朗日乘子法（Lagrange Multiplier) 和KKT条件</a></p>
<p>　　【4】<a href="http://www.cnblogs.com/zhangchaoyang/articles/2726873.html" target="_blank" rel="noopener">拉格朗日乘子法和KKT条件</a> </p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 优化算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[牛顿法小结]]></title>
      <url>/%E7%89%9B%E9%A1%BF%E6%B3%95%E5%B0%8F%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="http://pancakeawesome.ink/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E5%B0%8F%E7%BB%93.html">无约束优化算法–最小二乘法</a></li>
<li><a href="http://pancakeawesome.ink/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%EF%BC%88Gradient-Descent%EF%BC%89%E5%B0%8F%E7%BB%93.html">无约束优化算法–梯度下降法</a></li>
<li><a href="http://pancakeawesome.ink/%E7%89%9B%E9%A1%BF%E6%B3%95%E5%B0%8F%E7%BB%93.html">无约束优化算法–牛顿法</a></li>
<li><a href="http://pancakeawesome.ink/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95%EF%BC%88Lagrange-Multiplier-%E5%92%8CKKT%E6%9D%A1%E4%BB%B6.html">约束优化算法–拉格朗日乘子法</a></li>
</ul>
<h2 id="大纲："><a href="#大纲：" class="headerlink" title="大纲："></a>大纲：</h2><p>1.牛顿方法(Newton’s method) </p>
<p>2.指数族(Exponential family) </p>
<p>3.广义线性模型(Generalized linear models)</p>
<h3 id="1-牛顿方法"><a href="#1-牛顿方法" class="headerlink" title="1.牛顿方法"></a>1.牛顿方法</h3><p>假设有函数：<img src="http://img.blog.csdn.net/20150706110633987" alt=""> ，我们希望找到满足<img src="http://img.blog.csdn.net/20150706110724167" alt=""> 的<img src="http://img.blog.csdn.net/20150706110745198" alt=""> 值. 这里<img src="http://img.blog.csdn.net/20150706110801823" alt=""> 是实数. </p>
<p>牛顿方法执行下面的更新：<br><img src="http://img.blog.csdn.net/20150706110859861" alt=""> </p>
<p>下图为执行牛顿方法的过程：<br><img src="http://img.blog.csdn.net/20150706111014684" alt=""> </p>
<p>简单的来说就是通过求当前点的导数得到下一个点.用到的性质是导数值等于该点切线和横轴夹角的正切值.</p>
<p>令<img src="http://img.blog.csdn.net/20150706112630955" alt=""> ，我们可以用同样的算法去最大化<img src="http://img.blog.csdn.net/20150706112810083" alt=""><br><img src="http://img.blog.csdn.net/20150706112829665" alt=""> </p>
<p>牛顿方法的一般化： </p>
<p>如果<img src="http://img.blog.csdn.net/20150706113038478" alt=""> 是一个向量，那么：<br><img src="http://img.blog.csdn.net/20150706113134002" alt=""> </p>
<p>其中，<img src="http://img.blog.csdn.net/20150706113310504" alt=""> 是<img src="http://img.blog.csdn.net/20150706113341254" alt=""> 对<img src="http://img.blog.csdn.net/20150706113407533" alt=""> 的偏导数； </p>
<p>H称为<strong>黑塞矩阵(Hessian matrix)</strong>,是一个n*n的矩阵，n是特征量的个数，并且<img src="http://img.blog.csdn.net/20150706113605999" alt=""> （==当年学的各种名词又开始在脑海里翻滚==）</p>
<p>牛顿方法的收敛速度比批处理梯度下降快很多，因为其是二次收敛到最优值，很少次的迭代就能够非常接近最小值了；但是当n很大时，每次迭代求黑塞矩阵和黑塞矩阵的逆代价是很大的.这里我们可以用改进的拟牛顿法。</p>
<h3 id="2-指数族"><a href="#2-指数族" class="headerlink" title="2.指数族"></a>2.指数族</h3><p>指数族形式：<br><img src="http://img.blog.csdn.net/20150706145955215" alt=""> </p>
<p>其中，<img src="http://img.blog.csdn.net/20150706150152243" alt=""> 被称为<strong>自然参数</strong>（natural parameter）或者<strong>典范参数</strong>（canonical parameter）; </p>
<p>T(y)是<strong>充分统计量</strong>（sufficient statistic）（对于我们考虑的分布来说，通常T(y)=y）；<img src="http://img.blog.csdn.net/20150706150629710" alt=""> </p>
<p>是日志分配函数(log partition function),<img src="http://img.blog.csdn.net/20150706150937473" alt=""> 是一个规范化常数，使得分布的和为1. </p>
<p>给定T,a,b，通过改变参数<img src="http://img.blog.csdn.net/20150706151225336" alt=""> 得到不同的分布.</p>
<p>下面展示<strong>伯努利（Bernoulli）</strong>和<strong>高斯分布（Gaussian distribution）</strong>都是指数分布族的特例：</p>
<p>伯努利分布可以写成：<br><img src="http://img.blog.csdn.net/20150706152013489" alt=""> </p>
<p>因此，令<img src="http://img.blog.csdn.net/20150706152120210" alt=""> （有趣地发现其反函数为<img src="http://img.blog.csdn.net/20150706152244195" alt=""> <img src="http://img.blog.csdn.net/20150706152310735" alt=""> ），并且，<br><img src="http://img.blog.csdn.net/20150706152421266" alt=""> </p>
<p>高斯分布： </p>
<p>回忆我们对线性回归求导时，方差对我们最终结果并没有任何影响.为了使问题简化，令<img src="http://img.blog.csdn.net/20150706153327249" alt=""> 于是有，<br><img src="http://img.blog.csdn.net/20150706153356621" alt=""> </p>
<p>得：<br><img src="http://img.blog.csdn.net/20150706153538163" alt=""> </p>
<p>指数分布族还包括很多其他的分布：<br><strong>多项式分布</strong>（multinomial）<br><strong>泊松分布</strong>（poisson）：用于计数的建模<br><strong>伽马分布</strong>（gamma），<strong>指数分布</strong>（exponential）:用于对连续非负的随机变量进行建模<br><strong>β分布</strong>，<strong>Dirichlet分布</strong>：对小数建模</p>
<h3 id="3-GLMS（广义线性模型）"><a href="#3-GLMS（广义线性模型）" class="headerlink" title="3.GLMS（广义线性模型）"></a>3.GLMS（广义线性模型）</h3><p>为了导出GLM,作三个假设： </p>
<p>（1）<img src="http://img.blog.csdn.net/20150706155242811" alt=""> </p>
<p>（2）给定x，我们的目标是预测T(y)的预期值. 在大部分例子中，我们有T(y)=y，因此意味着我们通过学习得到的假设满足<img src="http://img.blog.csdn.net/20150706155656016" alt=""> （这个假设对logistic回归和线性回归都成立） </p>
<p>（3）自然参数和输入变量是线性相关的，也就是说<img src="http://img.blog.csdn.net/20150706155904652" alt=""> （如果自然参数是向量，则<img src="http://img.blog.csdn.net/20150706160004248" alt=""> ）</p>
<h4 id="3-1普通的最小二乘法"><a href="#3-1普通的最小二乘法" class="headerlink" title="3.1普通的最小二乘法"></a><strong>3.1普通的最小二乘法</strong></h4><p>为了说明普通的最小二乘法是GLM的特例，设定目标变量y(在GLM术语中叫响应变量-response variable)是连续的，并且假设服从高斯分布<img src="http://img.blog.csdn.net/20150706160927520" alt=""> ，高斯分布写成指数族的形式，有<img src="http://img.blog.csdn.net/20150706161155908" alt=""> 得到：<br><img src="http://img.blog.csdn.net/20150706161225959" alt=""> </p>
<h4 id="3-2-logistic回归"><a href="#3-2-logistic回归" class="headerlink" title="3.2 logistic回归"></a><strong>3.2 logistic回归</strong></h4><p>考虑logistic,我们感兴趣的是二元分类，也就是说<img src="http://img.blog.csdn.net/20150706162711352" alt=""> 很容易想到指数分布族的伯努利分布，有<img src="http://img.blog.csdn.net/20150706162832273" alt=""> ，同理得到：<br><img src="http://img.blog.csdn.net/20150706162917426" alt=""> </p>
<p>正则响应函数（canonical response function）：<img src="http://img.blog.csdn.net/20150706163151572" alt=""> </p>
<p>正则链接函数（canonical link function）:<img src="http://img.blog.csdn.net/20150706163448826" alt=""> </p>
<h4 id="3-3-softmax-回归"><a href="#3-3-softmax-回归" class="headerlink" title="3.3 softmax 回归"></a><strong>3.3 softmax 回归</strong></h4><p>当分类问题的y取值不止两个时，我们需要采用<strong>多项式分布（multinomial distribution）</strong>.</p>
<p>在推导多项式分布的GLM之前，先把多项式分布表达成指数族.</p>
<p>为了参数化多项式分布的k各可能结果，有人可能会用k个参数来说明每一种情况的可能性，但是这些参数是冗余的，并且并不是独立的(由于知道任何其中的k-1个，剩下的一个就可以求出，因为满足<img src="http://img.blog.csdn.net/20150706165207052" alt=""> ). 因此我们用k-1个参数<img src="http://img.blog.csdn.net/20150706165446547" alt=""> 对多项分布进行参数化，<img src="http://img.blog.csdn.net/20150706170009460" alt=""> . </p>
<p>定义<img src="http://img.blog.csdn.net/20150706170122808" alt=""> ，如下，<br><img src="http://img.blog.csdn.net/20150706170157510" alt=""> </p>
<p>介绍一个很有用的记号，<img src="http://img.blog.csdn.net/20150706170454371" alt=""> ，例如1{2=3}=0,1{3=5-2}=1. </p>
<p>因此T(y)和y的关系为<img src="http://img.blog.csdn.net/20150706170650806" alt=""> . </p>
<p>并且有<img src="http://img.blog.csdn.net/20150706170739298" alt=""> ，因此：<br><img src="http://img.blog.csdn.net/20150706170825859" alt=""> </p>
<p>链接函数为，<img src="http://img.blog.csdn.net/20150706171724655" alt=""> ，为了方便，定义<img src="http://img.blog.csdn.net/20150706171759377" alt=""> .</p>
<p>可得：<br><img src="http://img.blog.csdn.net/20150706171921306" alt=""> </p>
<p>因此<img src="http://img.blog.csdn.net/20150706172034079" alt=""> ，反代回去得到响应函数：<br><img src="http://img.blog.csdn.net/20150706172133807" alt=""> </p>
<p>从η到<img src="http://img.blog.csdn.net/20150706172447119" alt=""> 的映射叫做<strong>softmax函数</strong>.</p>
<p>根据假设3，<img src="http://img.blog.csdn.net/20150706172621524" alt=""> 得到:<br><img src="http://img.blog.csdn.net/20150706172655176" alt=""> </p>
<p>这个应用于分类问题（当<img src="http://img.blog.csdn.net/20150706172823866" alt=""> ），叫做<strong>softmax回归(softmax regression)</strong>.是logistic回归的推广.</p>
<p><img src="http://img.blog.csdn.net/20150706173028013" alt=""> </p>
<p>与最小二乘法和logistic回归类似，<br><img src="http://img.blog.csdn.net/20150706173405511" alt=""> </p>
<p>再通过梯度上升或者牛顿方法求出θ.</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如有不足，欢迎指出～</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 优化算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[梯度下降（Gradient Descent）小结]]></title>
      <url>/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%EF%BC%88Gradient-Descent%EF%BC%89%E5%B0%8F%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="http://pancakeawesome.ink/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E5%B0%8F%E7%BB%93.html">无约束优化算法–最小二乘法</a></li>
<li><a href="http://pancakeawesome.ink/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%EF%BC%88Gradient-Descent%EF%BC%89%E5%B0%8F%E7%BB%93.html">无约束优化算法–梯度下降法</a></li>
<li><a href="http://pancakeawesome.ink/%E7%89%9B%E9%A1%BF%E6%B3%95%E5%B0%8F%E7%BB%93.html">无约束优化算法–牛顿法</a></li>
<li><a href="http://pancakeawesome.ink/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95%EF%BC%88Lagrange-Multiplier-%E5%92%8CKKT%E6%9D%A1%E4%BB%B6.html">约束优化算法–拉格朗日乘子法</a></li>
</ul>
<p>在求解机器学习算法的模型参数，即无约束优化问题时，梯度下降（Gradient Descent）是最常采用的方法之一，另一种常用的方法是最小二乘法。这里就对梯度下降法做一个完整的总结。</p>
<h2 id="梯度下降（Gradient-Descent）小结"><a href="#梯度下降（Gradient-Descent）小结" class="headerlink" title="梯度下降（Gradient Descent）小结"></a>梯度下降（Gradient Descent）小结</h2><h3 id="1-梯度"><a href="#1-梯度" class="headerlink" title="1. 梯度"></a>1. 梯度</h3><p>在微积分里面，对多元函数的参数求∂偏导数，把求得的各个参数的偏导数以向量的形式写出来，就是梯度。比如函数f(x,y), 分别对x,y求偏导数，求得的梯度向量就是$(∂_f/∂_x, ∂_f/∂_y)^T$,简称grad f(x,y)或者▽f(x,y)。对于在点$(x_0,y_0)$的具体梯度向量就是$(∂_f/∂_x, ∂_f/∂_y)^T$.或者$▽_f(x_0,y_0)$，如果是3个参数的向量梯度，就是$(∂_f/∂_x, ∂_f/∂_y,∂_f/∂_z)^T$,以此类推。</p>
<p>那么这个梯度向量求出来有什么意义呢？他的意义从几何意义上讲，就是函数变化增加最快的地方。具体来说，对于函数f(x,y),在点(x0,y0)，沿着梯度向量的方向就是$(∂_f/∂_x, ∂_f/∂_y)^T$的方向是f(x,y)增加最快的地方。或者说，沿着梯度向量的方向，更加容易找到函数的最大值。反过来说，沿着梯度向量相反的方向，也就是 -$(∂_f/∂_x, ∂_f/∂_y)^T$的方向，梯度减少最快，也就是更加容易找到函数的最小值。</p>
<h3 id="2-梯度下降与梯度上升"><a href="#2-梯度下降与梯度上升" class="headerlink" title="2. 梯度下降与梯度上升"></a>2. 梯度下降与梯度上升</h3><p>在机器学习算法中，在最小化损失函数时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数，和模型参数值。反过来，如果我们需要求解损失函数的最大值，这时就需要用梯度上升法来迭代了。</p>
<p>梯度下降法和梯度上升法是可以互相转化的。比如我们需要求解损失函数f(θ)的最小值，这时我们需要用梯度下降法来迭代求解。但是实际上，我们可以反过来求解损失函数 -f(θ)的最大值，这时梯度上升法就派上用场了。</p>
<p>下面来详细总结下梯度下降法。        </p>
<h3 id="3-梯度下降法算法详解"><a href="#3-梯度下降法算法详解" class="headerlink" title="3. 梯度下降法算法详解"></a>3. 梯度下降法算法详解</h3><h4 id="3-1-梯度下降的直观解释"><a href="#3-1-梯度下降的直观解释" class="headerlink" title="3.1 梯度下降的直观解释"></a>3.1 梯度下降的直观解释</h4><p>首先来看看梯度下降的一个直观的解释。比如我们在一座大山上的某处位置，由于我们不知道怎么下山，于是决定走一步算一步，也就是在每走到一个位置的时候，求解当前位置的梯度，沿着梯度的负方向，也就是当前最陡峭的位置向下走一步，然后继续求解当前位置梯度，向这一步所在位置沿着最陡峭最易下山的位置走一步。这样一步步的走下去，一直走到觉得我们已经到了山脚。当然这样走下去，有可能我们不能走到山脚，而是到了某一个局部的山峰低处。</p>
<p>从上面的解释可以看出，梯度下降不一定能够找到全局的最优解，有可能是一个局部最优解。当然，如果损失函数是凸函数，梯度下降法得到的解就一定是全局最优解。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1focuincajcj30j209dwfe.jpg" alt=""></p>
<h4 id="3-2-梯度下降的相关概念"><a href="#3-2-梯度下降的相关概念" class="headerlink" title="3.2 梯度下降的相关概念"></a>3.2 梯度下降的相关概念</h4><p>在详细了解梯度下降的算法之前，我们先看看相关的一些概念。</p>
<ol>
<li><p>步长（Learning rate）：步长决定了在梯度下降迭代的过程中，每一步沿梯度负方向前进的长度。用上面下山的例子，步长就是在当前这一步所在位置沿着最陡峭最易下山的位置走的那一步的长度。</p>
</li>
<li><p>特征（feature）：指的是样本中输入部分，比如样本$（x_0,y_0）$,$（x_1,y_1）$,则样本特征为x，样本输出为y。</p>
</li>
<li><p>假设函数（hypothesis function）：在监督学习中，为了拟合输入样本，而使用的假设函数，记为$h_θ(x)$。比如对于样本$（x_i,y_i）$(i=1,2,…n),可以采用拟合函数如下： $h_θ(x) = θ_0+θ_1x$。</p>
</li>
<li><p>损失函数（loss function）：为了评估模型拟合的好坏，通常用损失函数来度量拟合的程度。损失函数极小化，意味着拟合程度最好，对应的模型参数即为最优参数。在线性回归中，损失函数通常为样本输出和假设函数的差取平方。比如对于样本$（x_i,y_i）$(i=1,2,…n),采用线性回归，损失函数为：<br>$$<br>J(\theta_0, \theta_1) = \sum\limits_{i=1}^{m}(h_\theta(x_i) - y_i)^2<br>$$</p>
</li>
</ol>
<p>其中$x_i$表示样本特征x的第i个元素，$y_i$表示样本输出y的第i个元素，$h_\theta(x_i)$为假设函数。   </p>
<h4 id="3-3-梯度下降的详细算法"><a href="#3-3-梯度下降的详细算法" class="headerlink" title="3.3 梯度下降的详细算法"></a>3.3 梯度下降的详细算法</h4><p>梯度下降法的算法可以有代数法和矩阵法（也称向量法）两种表示，如果对矩阵分析不熟悉，则代数法更加容易理解。不过矩阵法更加的简洁，且由于使用了矩阵，实现逻辑更加的一目了然。这里先介绍代数法，后介绍矩阵法。</p>
<h5 id="3-3-1-梯度下降法的代数方式描述"><a href="#3-3-1-梯度下降法的代数方式描述" class="headerlink" title="3.3.1 梯度下降法的代数方式描述"></a>3.3.1 梯度下降法的代数方式描述</h5><ol>
<li>先决条件： 确认优化模型的假设函数和损失函数。</li>
</ol>
<p>比如对于线性回归，假设函数表示为 $h_\theta(x_1, x_2, …x_n) = \theta_0 + \theta_{1}x_1 + … + \theta_{n}x_{n}$, 其中$\theta_i$  (i = 0,1,2… n)为模型参数，$x_i$  (i = 0,1,2… n)为每个样本的n个特征值。这个表示可以简化，我们增加一个特征$x_0 = 1$  ，这样$h_\theta(x_0, x_1, …x_n) = \sum\limits_{i=0}^{n}\theta_{i}x_{i}$。</p>
<p>同样是线性回归，对应于上面的假设函数，损失函数为：<br>$$<br>J(\theta_0, \theta_1…, \theta_n) = \frac{1}{2m}\sum\limits_{i=0}^{m}(h_\theta(x_0, x_1, …x_n) - y_i)^2<br>$$</p>
<ol>
<li><p>算法相关参数初始化：主要是初始化$\theta_0, \theta_1…, \theta_n$,算法终止距离$\varepsilon$以及步长$\alpha$。在没有任何先验知识的时候，我喜欢将所有的$\theta$初始化为0， 将步长初始化为1。在调优的时候再 优化。</p>
</li>
<li><p>算法过程：</p>
</li>
</ol>
<p>　　1）确定当前位置的损失函数的梯度，对于$\theta_i$,其梯度表达式如下：<br>$$<br>\frac{\partial}{\partial\theta_i}J(\theta_0, \theta_1…, \theta_n)<br>$$<br>　　2）用步长乘以损失函数的梯度，得到当前位置下降的距离，即$\alpha\frac{\partial}{\partial\theta_i}J(\theta_0, \theta_1…, \theta_n)$对应于前面登山例子中的某一步。</p>
<p>　　3）确定是否所有的$\theta_i$,梯度下降的距离都小于$\varepsilon$，如果小于$\varepsilon$则算法终止，当前所有的$\theta_i$(i=0,1,…n)即为最终结果。否则进入步骤4.</p>
<p>　　4）更新所有的$\theta$，对于$\theta_i$，其更新表达式如下。更新完毕后继续转入步骤1.<br>$$<br>\theta_i = \theta_i - \alpha\frac{\partial}{\partial\theta_i}J(\theta_0, \theta_1…, \theta_n)<br>$$<br>下面用线性回归的例子来具体描述梯度下降。假设我们的样本是$(x_1^{(0)}, x_2^{(0)}, …x_n^{(0)}, y_0), (x_1^{(1)}, x_2^{(1)}, …x_n^{(1)},y_1), … (x_1^{(m)}, x_2^{(m)}, …x_n^{(m)}, y_n)$,损失函数如前面先决条件所述：<br>$$<br>(\theta_0, \theta_1…, \theta_n) = \frac{1}{2m}\sum\limits_{i=0}^{m}(h_\theta(x_0, x_1, …x_n) - y_i)^2<br>$$<br>则在算法过程步骤1中对于θi\theta_i 的偏导数计算如下： 　　<br>$$<br>\frac{\partial}{\partial\theta_i}J(\theta_0, \theta_1…, \theta_n)= \frac{1}{m}\sum\limits_{j=0}^{m}(h_\theta(x_0^{j}, x_1^{j}, …x_n^{j}) - y_j)x_i^{j}<br>$$<br>由于样本中没有$x_0$上式中令所有的$x_0^{j}$为1.</p>
<p>步骤4中$\theta_i$的更新表达式如下：<br>$$<br>\theta_i = \theta_i - \alpha\frac{1}{m}\sum\limits_{j=0}^{m}(h_\theta(x_0^{j}, x_1^{j}, …x_n^{j}) - y_j)x_i^{j}<br>$$<br>从这个例子可以看出当前点的梯度方向是由所有的样本决定的，加$\frac{1}{m}$ 是为了好理解。由于步长也为常数，他们的乘机也为常数，所以这里$\alpha\frac{1}{m}$可以用一个常数表示。</p>
<p>在下面第4节会详细讲到的梯度下降法的变种，他们主要的区别就是对样本的采用方法不同。这里我们采用的是用所有样本。</p>
<h5 id="3-3-2-梯度下降法的矩阵方式描述"><a href="#3-3-2-梯度下降法的矩阵方式描述" class="headerlink" title="3.3.2 梯度下降法的矩阵方式描述"></a>3.3.2 梯度下降法的矩阵方式描述</h5><p>这一部分主要讲解梯度下降法的矩阵方式表述，相对于3.3.1的代数法，要求有一定的矩阵分析的基础知识，尤其是矩阵求导的知识。</p>
<ol>
<li><p>先决条件： 和3.3.1类似， 需要确认优化模型的假设函数和损失函数。对于线性回归，假设函数$\theta(x_1, x_2, …x_n) = \theta_0 + \theta_{1}x_1 + … + \theta_{n}x_{n}$的矩阵表达方式为：<br>$$h_\mathbf{\theta}(\mathbf{x}) = \mathbf{X\theta}$$ ，其中， 假设函数$h_\mathbf{\theta}(\mathbf{X})$为mx1的向量,$\mathbf{\theta}$为nx1的向量，里面有n个代数法的模型参数。$\mathbf{X}$为mxn维的矩阵。m代表样本的个数，n代表样本的特征数。<br>损失函数的表达式为：$J(\mathbf\theta) = \frac{1}{2}(\mathbf{X\theta} - \mathbf{Y})^T(\mathbf{X\theta} - \mathbf{Y})$, 其中$\mathbf{Y}$是样本的输出向量，维度为mx1.</p>
</li>
<li><p>算法相关参数初始化: $\theta$向量可以初始化为默认值，或者调优后的值。算法终止距离$\varepsilon$，步长$\alpha$和3.3.1比没有变化。</p>
</li>
<li><p>算法过程：</p>
</li>
</ol>
<p>　　1）确定当前位置的损失函数的梯度，对于$\theta$向量,其梯度表达式如下：<br>$$<br>\frac{\partial}{\partial\mathbf\theta}J(\mathbf\theta)<br>$$<br>　　2）用步长乘以损失函数的梯度，得到当前位置下降的距离，即$\alpha\frac{\partial}{\partial\theta}J(\theta)$对应于前面登山例子中的某一步。</p>
<p>　　3）确定$\mathbf\theta$向量里面的每个值,梯度下降的距离都小于$\varepsilon$，如果小于$\varepsilon$则算法终止，当前$\mathbf\theta$向量即为最终结果。否则进入步骤4.</p>
<p>　　4）更新$\theta$向量，其更新表达式如下。更新完毕后继续转入步骤1.<br>$$<br>\mathbf\theta= \mathbf\theta - \alpha\frac{\partial}{\partial\theta}J(\mathbf\theta)<br>$$<br>还是用线性回归的例子来描述具体的算法过程。</p>
<p>损失函数对于θ\theta向量的偏导数计算如下：<br>$$<br>\frac{\partial}{\partial\mathbf\theta}J(\mathbf\theta) = \mathbf{X}^T(\mathbf{X\theta} - \mathbf{Y})<br>$$<br>步骤4中$\theta$向量的更新表达式如下：<br>$$<br>\mathbf\theta= \mathbf\theta - \alpha\mathbf{X}^T(\mathbf{X\theta} - \mathbf{Y})<br>$$<br>对于3.3.1的代数法，可以看到矩阵法要简洁很多。这里面用到了矩阵求导链式法则，和两个矩阵求导的公式。</p>
<p>　　公式1：$\frac{\partial}{\partial\mathbf{X}}(\mathbf{XX^T}) =2\mathbf{X}$</p>
<p>　　公式2：$\frac{\partial}{\partial\mathbf\theta}(\mathbf{X\theta}) =\mathbf{X^T}$</p>
<p>如果需要熟悉矩阵求导建议参考张贤达的《矩阵分析与应用》一书。</p>
<h4 id="3-4-梯度下降的算法调优"><a href="#3-4-梯度下降的算法调优" class="headerlink" title="3.4 梯度下降的算法调优"></a>3.4 梯度下降的算法调优</h4><p>在使用梯度下降时，需要进行调优。哪些地方需要调优呢？</p>
<ol>
<li><p>算法的步长选择。在前面的算法描述中，我提到取步长为1，但是实际上取值取决于数据样本，可以多取一些值，从大到小，分别运行算法，看看迭代效果，如果损失函数在变小，说明取值有效，否则要增大步长。前面说了。步长太大，会导致迭代过快，甚至有可能错过最优解。步长太小，迭代速度太慢，很长时间算法都不能结束。所以算法的步长需要多次运行后才能得到一个较为优的值。</p>
</li>
<li><p>算法参数的初始值选择。 初始值不同，获得的最小值也有可能不同，因此梯度下降求得的只是局部最小值；当然如果损失函数是凸函数则一定是最优解。由于有局部最优解的风险，需要多次用不同初始值运行算法，关键损失函数的最小值，选择损失函数最小化的初值。</p>
</li>
<li><p>归一化。由于样本不同特征的取值范围不一样，可能导致迭代很慢，为了减少特征取值的影响，可以对特征数据归一化，也就是对于每个特征x，求出它的期望$\overline{x}$和标准差std(x)，然后转化为：<br>$$<br>\frac{x - \overline{x}}{std(x)}<br>$$<br>这样特征的新期望为0，新方差为1，迭代次数可以大大加快。</p>
</li>
</ol>
<h3 id="4-梯度下降法大家族（BGD，SGD，MBGD）"><a href="#4-梯度下降法大家族（BGD，SGD，MBGD）" class="headerlink" title="4. 梯度下降法大家族（BGD，SGD，MBGD）"></a>4. 梯度下降法大家族（BGD，SGD，MBGD）</h3><h4 id="4-1-批量梯度下降法（Batch-Gradient-Descent）"><a href="#4-1-批量梯度下降法（Batch-Gradient-Descent）" class="headerlink" title="4.1 批量梯度下降法（Batch Gradient Descent）"></a>4.1 批量梯度下降法（Batch Gradient Descent）</h4><p>批量梯度下降法，是梯度下降法最常用的形式，具体做法也就是在更新参数时使用所有的样本来进行更新，这个方法对应于前面3.3.1的线性回归的梯度下降算法，也就是说3.3.1的梯度下降算法就是批量梯度下降法。　　<br>$$<br>\theta_i = \theta_i - \alpha\sum\limits_{j=0}^{m}(h_\theta(x_0^{j}, x_1^{j}, …x_n^{j}) - y_j)x_i^{j}<br>$$<br>由于我们有m个样本，这里求梯度的时候就用了所有m个样本的梯度数据。</p>
<h4 id="4-2-随机梯度下降法（Stochastic-Gradient-Descent）"><a href="#4-2-随机梯度下降法（Stochastic-Gradient-Descent）" class="headerlink" title="4.2 随机梯度下降法（Stochastic Gradient Descent）"></a>4.2 随机梯度下降法（Stochastic Gradient Descent）</h4><p>随机梯度下降法，其实和批量梯度下降法原理类似，区别在与求梯度时没有用所有的m个样本的数据，而是仅仅选取一个样本j来求梯度。对应的更新公式是：<br>$$<br>\theta_i = \theta_i - \alpha (h_\theta(x_0^{j}, x_1^{j}, …x_n^{j}) - y_j)x_i^{j}<br>$$<br>随机梯度下降法，和4.1的批量梯度下降法是两个极端，一个采用所有数据来梯度下降，一个用一个样本来梯度下降。自然各自的优缺点都非常突出。对于训练速度来说，随机梯度下降法由于每次仅仅采用一个样本来迭代，训练速度很快，而批量梯度下降法在样本量很大的时候，训练速度不能让人满意。对于准确度来说，随机梯度下降法用于仅仅用一个样本决定梯度方向，导致解很有可能不是最优。对于收敛速度来说，由于随机梯度下降法一次迭代一个样本，导致迭代方向变化很大，不能很快的收敛到局部最优解。</p>
<p>那么，有没有一个中庸的办法能够结合两种方法的优点呢？有！这就是4.3的小批量梯度下降法。</p>
<h4 id="4-3-小批量梯度下降法（Mini-batch-Gradient-Descent）"><a href="#4-3-小批量梯度下降法（Mini-batch-Gradient-Descent）" class="headerlink" title="4.3 小批量梯度下降法（Mini-batch Gradient Descent）"></a>4.3 小批量梯度下降法（Mini-batch Gradient Descent）</h4><p>小批量梯度下降法是批量梯度下降法和随机梯度下降法的折衷，也就是对于m个样本，我们采用x个样子来迭代，1&lt;x&lt;m。一般可以取x=10，当然根据样本的数据，可以调整这个x的值。对应的更新公式是：<br>$$<br>\theta_i = \theta_i - \alpha \sum\limits_{j=t}^{t+x-1}(h_\theta(x_0^{j}, x_1^{j}, …x_n^{j}) - y_j)x_i^{j}<br>$$</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="梯度下降法和其他无约束优化算法的比较"><a href="#梯度下降法和其他无约束优化算法的比较" class="headerlink" title="梯度下降法和其他无约束优化算法的比较"></a>梯度下降法和其他无约束优化算法的比较</h3><p>在机器学习中的无约束优化算法，除了梯度下降以外，还有前面提到的最小二乘法，此外还有牛顿法和拟牛顿法。</p>
<p>梯度下降法和最小二乘法相比，梯度下降法需要选择步长，而最小二乘法不需要。梯度下降法是迭代求解，最小二乘法是计算解析解。如果样本量不算很大，且存在解析解，最小二乘法比起梯度下降法要有优势，计算速度很快。但是如果样本量很大，用最小二乘法由于需要求一个超级大的逆矩阵，这时就很难或者很慢才能求解解析解了，使用迭代的梯度下降法比较有优势。</p>
<p>梯度下降法和牛顿法/拟牛顿法相比，两者都是迭代求解，不过梯度下降法是梯度求解，而牛顿法/拟牛顿法是用二阶的海森矩阵的逆矩阵或伪逆矩阵求解。相对而言，使用牛顿法/拟牛顿法收敛更快。但是每次迭代的时间比梯度下降法长。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 优化算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo中使用mathJax渲染Latex]]></title>
      <url>/hexo%E4%B8%AD%E4%BD%BF%E7%94%A8mathJax%E6%B8%B2%E6%9F%93Latex.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们用markdown写博客时，总会遇到一些很繁琐的数学公式，这是我们需要用Latex语法去编写数学公式。下面是一些常用的数学公式及其Latex语法。</p>
<h2 id="MathJax使用与LaTex语法"><a href="#MathJax使用与LaTex语法" class="headerlink" title="MathJax使用与LaTex语法"></a>MathJax使用与LaTex语法</h2><ul>
<li>LaTex可以在<a href="https://stackedit.io/editor" target="_blank" rel="noopener">stackedit里面</a>进行练习，所见即所得</li>
<li><p>排版<br>在使用MathJax时，需要告知是使用使用inline排版还是displayed排版，后者会单独占用一行；在MathJax中默认的inline公式分隔符是<code>$...$</code>或<code>(..)</code>,而displayed的是<code>$$...$$</code></p>
<ul>
<li>例子 inline <code>$ q \in R $</code>显示为 q∈R ; displayed: <code>$$q \in R $$</code> 显示为<br>$$<br>q \in R<br>$$</li>
</ul>
</li>
<li><p>上下标<br>上标使用^ ,下标使用_ 比如 <code>x_i^2</code>:$x_i^2$,默认情况下， 上下标符号只对一个字符起作用，比如<code>10^10</code>:$101010^10$,而使用分组符号<code>10^{10}</code>:$101010^{10}$</p>
</li>
<li><p>希腊字母<br><img src="http://7xncgn.com1.z0.glb.clouddn.com/16-10-21/69388107-12" alt=""> </p>
</li>
<li><p>括号</p>
<ul>
<li>小括号与中括号，使用<code>()</code>, <code>[]</code></li>
<li>大括号：因为大括号有时被用来分组，所以需要转义使用，比如<code>\{``\}</code>,也可以 使用<code>\lbrace</code>, <code>\rbrace</code></li>
<li>尖括号：<code>\langle</code>,<code>\rangle</code>,如<code>\langle x \rangle</code>:⟨x⟩ \langle x \rangle </li>
<li>上取整：<code>\lceil</code>,<code>\rceil</code>, 如<code>\lceil x \rceil</code>: ⌈x⌉ \lceil x \rceil </li>
<li>下取整：使用<code>\lfloor</code> 和 <code>\rfloor</code> 表示。如，<code>\lfloor x \rfloor</code>：⌊x⌋\lfloor x \rfloor。</li>
</ul>
</li>
<li><p>求和与积分</p>
<ul>
<li><p>\sum是用来表示求和符合的，其下标表示下限，上标表示上限，比如`</p>
<p>sum_1^n:$sum_1^n$</p>
</li>
<li><p>\int用来表示积分符号，同样地，其上下标表示积分的上下限,比如<code>\int_1^\infty</code>: $\int_1^\infty$</p>
</li>
<li><p>与此类似的符号还有，<code>\prod</code>:$\prod$，<code>\bigcup</code>:$\bigcup$，<code>\bigcap</code>：$\bigcap$，<code>\iint</code>:$\iint$。</p>
</li>
</ul>
</li>
<li><p>分式与根式</p>
<ul>
<li><code>\frac {a}{b}</code>: $\frac {a}{b}$ 作用于其后的两个分组a,b </li>
<li><code>\sqrt[4]{\frac {x}{y}}</code>: $\sqrt[4]{\frac {x}{y}}$</li>
</ul>
</li>
<li><p>字体</p>
<ul>
<li>\mathbb显示黑板粗字体 ，比如 <code>\mathbb {CHAN}</code>:$ℂℍ$</li>
</ul>
</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如有不足，欢迎指出。谢谢～<br>不定期更新。</p>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最小二乘法小结]]></title>
      <url>/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E5%B0%8F%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="http://pancakeawesome.ink/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E5%B0%8F%E7%BB%93.html">无约束优化算法–最小二乘法</a></li>
<li><a href="http://pancakeawesome.ink/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%EF%BC%88Gradient-Descent%EF%BC%89%E5%B0%8F%E7%BB%93.html">无约束优化算法–梯度下降法</a></li>
<li><a href="http://pancakeawesome.ink/%E7%89%9B%E9%A1%BF%E6%B3%95%E5%B0%8F%E7%BB%93.html">无约束优化算法–牛顿法</a></li>
<li><a href="http://pancakeawesome.ink/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95%EF%BC%88Lagrange-Multiplier-%E5%92%8CKKT%E6%9D%A1%E4%BB%B6.html">约束优化算法–拉格朗日乘子法</a></li>
</ul>
<p>最小二乘法是用来做函数拟合或者求函数极值的方法。在机器学习，尤其是回归模型中，经常可以看到最小二乘法的身影，这里就对我对最小二乘法的认知做一个小结。</p>
<h2 id="最小二乘法小结"><a href="#最小二乘法小结" class="headerlink" title="最小二乘法小结"></a>最小二乘法小结</h2><h3 id="1-最小二乘法的原理与要解决的问题"><a href="#1-最小二乘法的原理与要解决的问题" class="headerlink" title="1.最小二乘法的原理与要解决的问题　"></a>1.最小二乘法的原理与要解决的问题　</h3><p>最小二乘法是由勒让德在19世纪发现的，原理的一般形式很简单，当然发现的过程是非常艰难的。形式如下式：</p>
<p>　　目标函数 = Σ（观测值-理论值）<sup>2</sup></p>
<p>观测值就是我们的多组样本，理论值就是我们的假设拟合函数。目标函数也就是在机器学习中常说的损失函数，我们的目标是得到使目标函数最小化时候的拟合函数的模型。举一个最简单的线性回归的简单例子，比如我们有m个只有一个特征的样本：<br>$$<br>(x^{(1)},y^{(1)}), (x^{(2)},y^{(2)}),…(x^{(m)},y^{(m)})<br>$$<br>样本采用下面的拟合函数：<br>$$<br>h_\theta(x) = \theta_0 + \theta_1 x<br>$$<br>这样我们的样本有一个特征x，对应的拟合函数有两个参数$\theta_0$ 和 $\theta_1$需要求出。</p>
<p>我们的目标函数为：<br>$$<br>J(\theta_0, \theta_1) = \sum\limits_{i=1}^{m}(y^{(i)} - h_\theta(x^{(i)}))^2 = \sum\limits_{i=1}^{m}(y^{(i)} -  \theta_0 - \theta_1 x^{(i)})^2<br>$$<br>用最小二乘法做什么呢，使$J(\theta_0, \theta_1)$最小，求出使$J(\theta_0, \theta_1)$最小时的$\theta_0$ 和 $\theta_1$，这样拟合函数就得出了。</p>
<p>那么，最小二乘法怎么才能使$J(\theta_0, \theta_1)$最小呢？</p>
<h3 id="2-最小二乘法的代数法解法"><a href="#2-最小二乘法的代数法解法" class="headerlink" title="2.最小二乘法的代数法解法"></a>2.最小二乘法的代数法解法</h3><p>上面提到要使$J(\theta_0, \theta_1)$最小，方法就是对$theta_0$ 和 $\theta_1$分别来求偏导数，令偏导数为0，得到一个关于$\theta_0$ 和 $\theta_1$的二元方程组。求解这个二元方程组，就可以得到$\theta_0$ 和 $\theta_1$的值。下面我们具体看看过程。</p>
<p>$J(\theta_0, \theta_1)$对$\theta_0$求导，得到如下方程：<br>$$<br>\sum\limits_{i=1}^{m}(y^{(i)} -  \theta_0 - \theta_1 x^{(i)}) = 0   ①<br>$$      </p>
<p>$J(\theta_0, \theta_1)$对$\theta_1$求导，得到如下方程：<br>$$<br>\sum\limits_{i=1}^{m}(y^{(i)} -  \theta_0 - \theta_1 x^{(i)})x^{(i)} = 0   ②<br>$$      </p>
<p>①和②组成一个二元一次方程组，容易求出$\theta_0$ 和 $\theta_1$的值：<br>$$<br>\theta_0 = \sum\limits_{i=1}^{m}\big(x^{(i)})^2\sum\limits_{i=1}^{m}y^{(i)} - \sum\limits_{i=1}^{m}x^{(i)}\sum\limits_{i=1}^{m}x^{(i)}y^{(i)} \Bigg/ m\sum\limits_{i=1}^{m}\big(x^{(i)})^2 - \big(\sum\limits_{i=1}^{m}x^{(i)})^2<br>$$</p>
<p>$$<br>\theta_1 = m\sum\limits_{i=1}^{m}x^{(i)}y^{(i)} - \sum\limits_{i=1}^{m}x^{(i)}\sum\limits_{i=1}^{m}y^{(i)} \Bigg/ m\sum\limits_{i=1}^{m}\big(x^{(i)})^2 - \big(\sum\limits_{i=1}^{m}x^{(i)})^2<br>$$</p>
<p>这个方法很容易推广到多个样本特征的线性拟合。</p>
<p>拟合函数表示为$h_\theta(x_1, x_2, …x_n) = \theta_0 + \theta_{1}x_1 + … + \theta_{n}x_{n}$, 其中$\theta_i$ (i = 0,1,2… n)为模型参数，$x_i$ (i = 0,1,2… n)为每个样本的n个特征值。这个表示可以简化，我们增加一个特征$x_0 = 1$ ，这样拟合函数表示为：<br>$$<br>h_\theta(x_0, x_1, …x_n) = \sum\limits_{i=0}^{n}\theta_{i}x_{i}。<br>$$<br>损失函数表示为：<br>$$<br>J(\theta_0, \theta_1…, \theta_n) = \sum\limits_{j=1}^{m}(h_\theta(x_0^{(j)}), x_1^{(j)}, …x_n^{(j)})) - y^{(j)}))^2 = \sum\limits_{j=1}^{m}(\sum\limits_{i=0}^{n}\theta_{i}x_{i}^{(j)}- y{(j)})^2<br>$$<br>利用损失函数分别对$\theta_i$(i=0,1,…n)求导,并令导数为0可得：<br>$$<br>\sum\limits_{j=0}^{m}(\sum\limits_{i=0}^{n}\theta_{i}x_{i}^{(j)} - y_j)x_i^{j} = 0   (i=0,1,…n)<br>$$</p>
<p>这样我们得到一个N+1元一次方程组，这个方程组有N+1个方程，求解这个方程，就可以得到所有的N+1个未知的$\theta$。</p>
<p>这个方法很容易推广到多个样本特征的非线性拟合。原理和上面的一样，都是用损失函数对各个参数求导取0，然后求解方程组得到参数值。这里就不累述了。</p>
<h3 id="3-最小二乘法的矩阵法解法"><a href="#3-最小二乘法的矩阵法解法" class="headerlink" title="3.最小二乘法的矩阵法解法"></a>3.最小二乘法的矩阵法解法</h3><p>矩阵法比代数法要简洁，且矩阵运算可以取代循环，所以现在很多书和机器学习库都是用的矩阵法来做最小二乘法。</p>
<p>这里用上面的多元线性回归例子来描述矩阵法解法。</p>
<p>假设函数$h_\theta(x_1, x_2, …x_n) = \theta_0 + \theta_{1}x_1 + … + \theta_{n}x_{n}$的矩阵表达方式为：<br>$$<br>h_\mathbf{\theta}(\mathbf{x}) = \mathbf{X\theta}<br>$$<br>其中， 假设函数$h_\mathbf{\theta}(\mathbf{X})$为mx1的向量,$\mathbf{\theta}$为nx1的向量，里面有n个代数法的模型参数。$\mathbf{X}$为mxn维的矩阵。m代表样本的个数，n代表样本的特征数。</p>
<p>损失函数定义为$J(\mathbf\theta) = \frac{1}{2}(\mathbf{X\theta} - \mathbf{Y})^T(\mathbf{X\theta} - \mathbf{Y})$</p>
<p>其中$\mathbf{Y}$是样本的输出向量，维度为mx1. $\frac{1}{2}$在这主要是为了求导后系数为1，方便计算。</p>
<p>根据最小二乘法的原理，我们要对这个损失函数对$\mathbf{\theta}$向量求导取0。结果如下式：<br>$$<br>\frac{\partial}{\partial\mathbf\theta}J(\mathbf\theta) = \mathbf{X}^T(\mathbf{X\theta} - \mathbf{Y}) = 0<br>$$<br><em>ps：这个方程被称为正规方程，和最小二乘法等价，是一种优化算法。</em><br>这里面用到了矩阵求导链式法则，和两个矩阵求导的公式。</p>
<p>　　公式1：$\frac{\partial}{\partial\mathbf{X}}(\mathbf{XX^T}) =2\mathbf{X}$</p>
<p>　　公式2：$\frac{\partial}{\partial\mathbf\theta}(\mathbf{X\theta}) =\mathbf{X^T}$</p>
<p>对上述求导等式整理后可得：<br>$$<br>\mathbf{X^{T}X\theta} = \mathbf{X^{T}Y}<br>$$<br>两边同时左乘$$(\mathbf{X^{T}X})^{-1}$$可得：<br>$$<br>\mathbf{\theta} = (\mathbf{X^{T}X})^{-1}\mathbf{X^{T}Y}<br>$$<br>这样我们就一下子求出了$\theta$向量表达式的公式，免去了代数法一个个去求导的麻烦。只要给了数据,我们就可以用$\mathbf{\theta} = (\mathbf{X^{T}X})^{-1}\mathbf{X^{T}Y}$算出$\theta$。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="最小二乘法的局限性和适用场景"><a href="#最小二乘法的局限性和适用场景" class="headerlink" title="最小二乘法的局限性和适用场景　　"></a>最小二乘法的局限性和适用场景　　</h3><p>从上面可以看出，最小二乘法适用简洁高效，比梯度下降这样的迭代法似乎方便很多。但是这里我们就聊聊最小二乘法的局限性。</p>
<p>首先，最小二乘法需要计算$\mathbf{X^{T}X}$的逆矩阵，有可能它的逆矩阵不存在，这样就没有办法直接用最小二乘法了，此时梯度下降法仍然可以使用。当然，我们可以通过对样本数据进行整理，去掉冗余特征。让$\mathbf{X^{T}X}$的行列式不为0，然后继续使用最小二乘法。</p>
<p>第二，当样本特征n非常的大的时候，计算$\mathbf{X^{T}X}$的逆矩阵是一个非常耗时的工作（nxn的矩阵求逆），甚至不可行。此时以梯度下降为代表的迭代法仍然可以使用。那这个n到底多大就不适合最小二乘法呢？如果你没有很多的分布式大数据计算资源，建议超过10000个特征就用迭代法吧。或者通过主成分分析降低特征的维度后再用最小二乘法。</p>
<p>第三，如果拟合函数不是线性的，这时无法使用最小二乘法，需要通过一些技巧转化为线性才能使用，此时梯度下降仍然可以用。</p>
<p>第四，讲一些特殊情况。当样本量m很少，小于特征数n的时候，这时拟合方程是欠定的，常用的优化方法都无法去拟合数据。当样本量m等于特征说n的时候，用方程组求解就可以了。当m大于n时，拟合方程是超定的，也就是我们常用与最小二乘法的场景了。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 优化算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《统计学习方法》学习笔记]]></title>
      <url>/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上学期花了一个多月读完了李航老师的《统计学习方法》，现在带着新入团队的新同学以读书会的形式读这本书，书里边全是干货，对于我理解基本的机器学习算法很有帮助，也笔头做了一些总结（不完全基于此书），现将其摘录于此作为在博客园的第一篇博客。因为并不是为了扫盲，所以仅仅是抓出脉络以及关键点，方便以后快速温习，而不是预习。</p>
<h2 id="《统计学习方法》学习笔记"><a href="#《统计学习方法》学习笔记" class="headerlink" title="《统计学习方法》学习笔记"></a>《统计学习方法》学习笔记</h2><h3 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h3><p>机器学习很多时候也被称作统计机器学习，这是因为大部分机器学习方法或多或少基于统计的方法，或者有基于统计方法的版本，即便是早期不涉及统计方法的算法在后来也都有了统计学的解释。</p>
<p>统计学习的三要素：<strong>模型</strong>、<strong>策略</strong>、<strong>算法</strong>，决定了一个统计学习的方法。整本书的算法均可从这三个思路去思考，并且从这三个思路思考可以培养一定的统计建模的意识。</p>
<ul>
<li><strong>模型</strong>是一个可以根据合法输入产生输出的“黑盒子”，也即一个从输入空间（或特征空间）到输出空间的映射。</li>
<li><strong>策略</strong>是衡量模型好坏的一个判断标准，以此可以确定向什么方向修改/优化模型。</li>
<li><strong>算法</strong>是确定了模型和策略，为了尽量满足策略所采用的优化模型的做法。</li>
</ul>
<p>简单的说，整个学习就是要学习出一个模型，而策略决定了我们所想要的模型，而算法是用来得到模型参数所采用的方法而已。</p>
<p>这本书讨论的是有监督学习，而对于有监督学习来说，共有的一个问题就是<strong>过拟合问题（overfitting）</strong>，简单地来讲，这是模型过分“迎合”训练数据而导致模型在训练数据上表现良好，而对未知输入的泛化能力很差的现象。</p>
<p>首先，过拟合是无法避免的。毕竟统计学习在训练时避免不了要拟合训练数据，这是因为我们的模型参数就是由训练数据训练而来的。这里的“过”指的是模型过于复杂（迎合数据），导致泛化能力急剧下降。这里举个例子：<br><img src="http://images0.cnblogs.com/blog2015/773645/201506/120014234577159.jpg" alt="how many boxes are there behind the tree?"></p>
<p>这里有多少盒子在树后？按照我们的直觉应该是只有一个盒子，然而事实上可能是：<br><img src="http://images0.cnblogs.com/blog2015/773645/201506/120016085985337.jpg" alt="possible cases"></p>
<p>显然，根据我们的直观认识，对于一个未知的参数（即这里的盒子数），越简单可能越符合我们的先验知识。也即简单的模型对未知的情况泛化能力更高（更加可能是对的）。所以“从贝叶斯估计的角度来看，正则化项对应于模型的先验概率”，模型越复杂，先验越小（经验告诉我们如此复杂的情况不太可能）。</p>
<p>因此，一个自然的想法便是要在策略中限制这种复杂的模型，虽然其在训练数据上比简单模型的表现更好。最常见的思路的就是添加<strong>正则化项</strong>，此项表示了模型的复杂度。在策略中和原始目标求和，即可得到既能得到较大的目标函数值，又不使模型较为复杂的模型参数。一个最简单的例子就是线性回归。</p>
<p>另一个常用的方法即<strong>交叉验证</strong>，意思是将训练数据分块，一部分作为训练数据，一部分作为测试数据，多次不同地分块以后取在测试数据上表现最优的模型参数。这种方法的缺点是计算开销太大，毕竟要多训练很多次模型。</p>
<h3 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h3><p>这是一个线性的模型，意在用一条线（超平面）对训练数据进行二分。</p>
<ul>
<li>输入：训练数据的特征向量</li>
<li>输出：二值类标</li>
</ul>
<p><strong>前提是数据严格线性可分，即存在一条线（超平面）能将正负例完美分开。</strong>而学习的目的即为学出这个分离线（超平面）。</p>
<p>学习的策略为经验风险最小化，即误分类点数最少，而假设是线性可分，因此误分类点数一定可以降为0。但是，误分类点数并不能指导我们如何修改模型（不能导出有效的算法），因此我们修改了一下策略的表示，改为误分类点到分离平面的距离之和。因此损失函数为：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmu67r98qoj30kk023mwy.jpg" alt=""></p>
<p>其中，(M)为误分类点集，(w)和(b)为参数，(y_i)是标准类标，乘上(y_i)乘积保证为正。为求其极小，分别对参数求导并令其导数为0即可：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fmu670d42aj30kb03w0sk.jpg" alt=""></p>
<p>学习算法为梯度下降法，有原始形式和对偶形式之分。<br><strong>原始形式核心递归式：</strong></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fmu678q0bmj30ka03l0sj.jpg" alt=""></p>
<p>其中(\eta)为梯度下降的步长。初始值(w)和(b)随机初始化。</p>
<p>如果将(w)和(b)初始化为0，那么根据原始形式的递归式，(w)和(b)分别可以写作(y_{i}x_{i})和(y_{i})的线性组合形式，即：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fmu67ksx2ej30k705bdfn.jpg" alt=""></p>
<p>系数相同的原因是因为每次更新w和b走过了相同个数的步长。这样就能将对(w)和(b)的更新改为对(\alpha)和(b)的更新，节约了乘法的计算开销。<br><strong>对偶形式的核心递归式：</strong></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmu684xplyj30ka03c742.jpg" alt=""></p>
<p>注意到感知机算法的梯度下降法是用的随机梯度下降，即每次随机选择一个误分点进行更新，而没有使用批量梯度下降，这是因为感知机是必然线性可分的，也即最后超平面必然存在，即算法必然收敛，因此可以选择计算开销更小的随机梯度下降法。</p>
<h3 id="KNN算法"><a href="#KNN算法" class="headerlink" title="KNN算法"></a>KNN算法</h3><p>根据近邻来估计实例点的属性。有两种方式，一种是Top-K最近邻，一种是根据距离确定近邻。前者算最近的k个邻居，而后者计算离实例的距离在一定范围以内的所有邻居。分别适用于分布密集和分布稀疏的情况。</p>
<p>KNN算法最大的问题在于计算pair之间的距离，这是(O(n^2))的问题，而每次增加点，都需要进行N次计算，这是不可接受的，于是对实例存在的特征空间进行切分，具体算法即kd树算法。按维度进行切分，思想类似于二分查找。</p>
<h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><p>模型为条件概率模型，即目的为学习一个条件概率分布（和一个先验分布）。</p>
<ul>
<li>输入：实例的特征向量</li>
<li>输出：多值类标</li>
</ul>
<p><strong>模型假设：对于任一实例，在已知类标时，各特征相互独立。</strong>这其实是将指数级参数个数（(2^n)）的联合分布降为了线性参数个数（(2n+1)）的条件概率与先验之积。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmu68c3plpj30kb02ca9v.jpg" alt=""></p>
<p>由于分母是平凡的，对于相同实例不同类标都是相同的。因此可以略去。分母中的条件概率因为模型假设，可以写为：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmu68jsctgj30k5028mwy.jpg" alt=""></p>
<p>策略是期望风险最小化，即分类正误的期望，可等价于后验概率最小化（证明略）。也即只用找到后验概率最大的类标赋给实例即可。这里模型未知参数为(P(x_i|c_k))和(P(c_k))，为了估计其值，使用的是极大似然估计，通俗的说就是用训练样本中对应项出现的频率来作为估计的概率（因为极大似然估计和强假设，因此被叫做朴素贝叶斯，或者傻瓜贝叶斯）。</p>
<p>所有涉及到共现矩阵，也即观测的频率，以及概率的算法，都需要考虑概率值为0的情况，或者分母为0的情况。朴素贝叶斯加入拉普拉斯平滑使避免出现0。</p>
<h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>if-then结构的树，目的即为学习出这样一棵树，非叶子节点是特征，叶子节点是类标。</p>
<ul>
<li>输入：特征向量</li>
<li>输出：多值类标</li>
</ul>
<p>策略是特征选择，越靠近根的特征应该有更好的区分能力，然而这一条件无法直接指导算法优化，因此引入信息增益定义。</p>
<p>几个定义：</p>
<ul>
<li>熵：表示随机变量X的不确定程度：</li>
</ul>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmu68qfr04j30jj02ejr6.jpg" alt=""></p>
<p>这里遍历了X可能的i个取值，限制条件为所有取值概率之和为1</p>
<ul>
<li>经验熵：将数据集D做分类的不确定程度：</li>
</ul>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmu68xck6pj30jk02g743.jpg" alt=""></p>
<p>其中D可被分成K个类，并且第k个类的实例个数为(\vert C_k\vert)，D中实例个数为(\vert D\vert)</p>
<ul>
<li>经验条件熵：给定特征下，将数据集做分类的不确定性（用分成某子类的概率对子类的经验熵进行加权）。</li>
</ul>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmu6931fitj30jx03r745.jpg" alt=""></p>
<p>然后<strong>信息增益</strong>可以定义为：<strong>给定特征A时D上的经验熵与经验条件熵之差。</strong></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fmu69a4dmaj30k701zgle.jpg" alt=""></p>
<p>定义<strong>信息增益比</strong>：<strong>信息增益与数据集关于特征A的值的熵之比。</strong></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmu69fu2tjj30k4025mwy.jpg" alt=""></p>
<p>其中(H_{A}(D) = -\sum\limits_{i=1}^n\frac{|D_i|}{|D|}\log\frac{|D_i|}{|D|})，n是A可取的值的个数，(D_i)是根据特征A进行分类以后得到的子类，可以被看作是经验熵。</p>
<p>算法中，<strong>ID3算法</strong>递归建树，对每个节点，选择当前使信息增益最大的特征。<strong>C4.5</strong>算法，用信息增益比来替代ID3中的信息增益。这是因为消息增益越大，表明该特征对全局熵减少得也就最大，也即能使全局不确定性降低最大，若一个特征可以取的值越多，每个分支下的实例数就越少，相应的不确定程度就越低，换句话说，信息增益会偏向取值更多的特征，因此ID3算法偏向生成那种宽而浅的树，这其实是不合理的。而信息增益比用经验熵做约束，惩罚了取值数多的特征，因此可以得到更好的树。</p>
<p>决策树模型为了防止过拟合，需要一定的<strong>剪枝</strong>，其做法是用节点个数作为正则化项。<br><strong>CART算法</strong>（建树、剪枝），用即你最小化建二叉树，即对于所有可能的特征的所有可能取值，取基尼最大的作为当前节点特征。<br><strong>基尼指数</strong>:</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fmu69m77k6j30kf02dwea.jpg" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>持续更新中～</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[React项目实战(一)：环境搭建]]></title>
      <url>/React%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-%E4%B8%80-%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>移动互联网时代时代已经到来，市场需求催化着前端技术不断的升级改造，前端大统一的时代即将来临，不管你愿不愿意相信，历史的前进步伐是不可抗拒的。</p>
<p>Web端<code>跨平台</code>的特性，在面对更新迭代频繁的场景上有其独到的优势，即使其性能、功能和体验受到浏览器的限制，产品功能依旧围绕着Web端在做着不断的尝试：</p>
<ol>
<li>手机作为日常生活中智能设备的终极形态，其硬件性能的提升加上浏览器内核的升级，让WebApp有了实际应用的可行性；</li>
<li>Html5和CSS3引入的新特性，极大的丰富了WebApp的可能性；</li>
<li>Native App内嵌WebView的方式，间接地解决了入口的问题，提升了用户体验，例如微信公众号就是一个比较优秀的场景实现。</li>
</ol>
<p>这些不断地尝试是让WebApp的使用场景变得越来越广泛，但其终究不能完全替代Native App，况且Native App还分成两大阵营：IOS和Android，前端的重复开发无疑增加了开发成本，那么有没有什么方案可以解决重复开发的困扰呢？新的技术又开始了新的尝试：</p>
<ul>
<li>React Native App，个人认为比较成功的解决方案，其利用JSBridge调用原生API渲染UI交互通信，实现了IOS和Android的开发统一（IOS和Android需要差异处理）。但其放弃了Web端无需安装的优势，有些小遗憾。</li>
<li>微信小程序，在其宣传阶段本以为是优秀的解决方案，但其自身的规则封闭限制了其场景使用；或许就因为其依赖于微信，本身就不可能过于开放。</li>
<li>Weex App，阿里巴巴开发团队在React Native App的成功案例上，重新设计出原理相同的开发模式。</li>
</ul>
<p>虽然上面说的都只是前端大统一的过渡方案，但有这些技术作为基础，前端大统一不就由可能变成肯定了吗？成熟的方案只不过是时间问题罢了。最近在找工作，发现React的技术需求变得越来越强烈，所以有所感触，不知各位看法如何？</p>
<p>前端各自领域的技术不断更新改造，加上前端大统一的步伐越来越近，总有那么一瞬间让人感觉疲惫，似乎要被时间抛弃。技术终究要靠人来实现，不断学习，不断尝试新的技术，和所有的前端开发人员共勉。</p>
<p>Web前端框架层出不穷，不可能面面俱到，这里给个小建议：</p>
<ul>
<li>如果对Weex App感兴趣，应该选择vue框架；</li>
<li>如果对React Native App感兴趣，应该选择React.js框架；</li>
</ul>
<p>本系列文章是React技术栈，Vue技术栈将会在本系列文章结束后陆续更新。</p>
<h3 id="系列文章目录链接"><a href="#系列文章目录链接" class="headerlink" title="系列文章目录链接"></a>系列文章目录链接</h3><ol>
<li><a href="http://pancakeawesome.ink/React%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-%E4%B8%80-%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html">React项目实战：环境搭建</a> </li>
<li><a href="http://pancakeawesome.ink/React%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98(%E4%BA%8C\">React项目实战：react-redux-router基本原理</a>:react-redux-router%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html) </li>
<li>React项目实战：登录页面（编辑中）</li>
</ol>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>由于本系列的文章是项目实战，需要有相关的技术基础，可以到下方给出的链接进行深入学习。项目实战用到的主要框架和插件有：</p>
<ul>
<li>webpack：预编译模块打包工具。 <a href="https://webpack.js.org/" target="_blank" rel="noopener">官方文档</a>- <a href="https://doc.webpack-china.org/" target="_blank" rel="noopener">中文翻译</a></li>
<li>React：构建用户界面的JavaScript库。 <a href="https://reactjs.org/" target="_blank" rel="noopener">官方文档</a>- <a href="https://doc.react-china.org/" target="_blank" rel="noopener">中文翻译</a></li>
<li>Redux：管理整个应用的数据流。 <a href="https://redux.js.org/" target="_blank" rel="noopener">官方文档</a>- <a href="http://www.redux.org.cn/" target="_blank" rel="noopener">中文翻译</a></li>
<li>react-router：React应用路由库。 <a href="https://github.com/ReactTraining/react-router" target="_blank" rel="noopener">官方文档</a></li>
<li>styled-components：React中的CSS最佳实践。 <a href="https://www.styled-components.com/" target="_blank" rel="noopener">官方文档</a></li>
<li>isomorphic-fetch：fetch兼容库。 <a href="https://github.com/matthew-andrews/isomorphic-fetch" target="_blank" rel="noopener">官方文档</a></li>
<li>JRoll2：移动前端滑动插件。 <a href="http://www.chjtx.com/JRoll/" target="_blank" rel="noopener">官方文档</a></li>
<li>ECharts：基于html5 Canvas图表库。 <a href="http://echarts.baidu.com/" target="_blank" rel="noopener">官方文档</a></li>
</ul>
<p>建议学习时以官方文档为准，中文翻译或者第三方作者的教程可以帮助你理清思路；会用到的重要知识点我也会进行简明的解释，如遇到错误或者不理解的内容，欢迎实时指出。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>环境搭建是最为枯燥和最容易出错的地方，不过作为开发者，我们还是很有必要了解配置的具体步骤，在后面一段时间会发布一个简易版环境搭建教程。</p>
<blockquote>
<p>系统环境：Win10 + 关闭安全管家</p>
</blockquote>
<h3 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h3><p>到官方网站下载安装包 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">点击前往</a>，<code>选择LTS版本</code>（9.0以后的版本在安装styled-components时会报错）。</p>
<h3 id="npm部署"><a href="#npm部署" class="headerlink" title="npm部署"></a>npm部署</h3><p>npm更新并部署至全局</p>
<pre><code>npm install npm  -g

#【可选】设置淘宝镜像
npm config set registry https://registry.npm.taobao.org
</code></pre><p>npm常用命令：</p>
<pre><code>npm init    #引导创建package.json文件
npm install ***    #本地安装；会在当前目录生成node_modules文件夹，并在此安装node模块
npm install *** -g    #全局安装；会在C:\Users\***\AppData\Roaming\npm\node_modules安装
npm install *** --save    #运行时依赖的模块；自动把模块和版本号添加到package.json文件dependencies部分
npm install *** --save-dev    #开发时依赖的模块；自动把模块和版本号添加到package.json文件devdependencies部分
npm update ***    #更新node模块
npm uninstall ***    #卸载node模块
</code></pre><h3 id="创建package-json文件"><a href="#创建package-json文件" class="headerlink" title="创建package.json文件"></a>创建package.json文件</h3><p>项目根目录：<code>D:\web\react-webapp-demo</code>，请根据自己实际情况设置。</p>
<pre><code>cd D:\web\react-webapp-demo    #在PowerSell中打开项目目录
npm init -y    #跳过提问阶段，直接生成一个新的 package.json 文件。
</code></pre><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><pre><code>npm install --save react react-dom redux react-redux redux-logger redux-thunk react-router react-router-redux@next history styled-components isomorphic-fetch jroll jroll-pulldown jroll-infinite echarts babel-polyfill
npm install --save-dev webpack webpack-dev-server webpack-merge clean-webpack-plugin babel-loader babel-core babel-preset-env babel-preset-react css-loader style-loader file-loader url-loader html-webpack-plugin uglifyjs-webpack-plugin
</code></pre><p>模块简要说明：</p>
<blockquote>
<p><code>react``react-dom</code>：React依赖<br><code>redux``react-redux``redux-logger``redux-thunk</code>：Redux依赖<br><code>react-router``react-router-redux``history</code>：react-router依赖<br><code>styled-components</code>：React中的CSS的实现依赖<br><code>isomorphic-fetch</code>：fetch兼容库<br><code>jroll``jroll-pulldown``jroll-infinite</code>：JRoll插件依赖<br><code>echarts</code>：基于html5 Canvas图表库<br><code>babel-polyfill</code>：用于实现浏览器不支持原生功能的代码<br><code>webpack</code>：预编译模块打包<br><code>webpack-dev-server</code>：实时重新加载的Web服务器<br><code>webpack-merge</code>：webpack配置分离插件<br><code>clean-webpack-plugin</code>：在building之前删除你以前build过的文件<br><code>babel-loader``babel-core``babel-preset-env``babel-preset-react</code>：转码器babel依赖<br><code>css-loader``style-loader``file-loader``url-loader</code>：各格式文件打包依赖<br><code>html-webpack-plugin</code>：生成HTML5文件的插件<br><code>uglifyjs-webpack-plugin</code>：代码压缩插件</p>
</blockquote>
<h3 id="配置模块"><a href="#配置模块" class="headerlink" title="配置模块"></a>配置模块</h3><p>在项目根目录生成<code>.babelrc</code>文件（Windows系统下文件重命名为.babelrc.），并写入如下数据</p>
<pre><code>{
    &quot;presets&quot;: [&quot;env&quot;,&quot;react&quot;]
}
</code></pre><p>配置package.json：运行<code>npm run build</code>启动编译模式和<code>npm run start</code>热更新模式;</p>
<pre><code>&quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;,
    &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;
},
</code></pre><p>根目录新建webpack配置文件：<code>webpack.common.js</code>、<code>webpack.dev.js</code>、<code>webpack.prod.js</code>;</p>
<p><strong>webpack.common.js</strong>（共用配置）</p>
<pre><code>const path = require(&#39;path&#39;);
const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const webpack = require(&#39;webpack&#39;);

module.exports = {
    entry: [&#39;babel-polyfill&#39;,&#39;./src/index.js&#39;],    //项目的起点入口
    output: {    //项目输出配置
        path: path.resolve(__dirname, &#39;build&#39;),    //文件的输出目录 
        filename: &#39;static/js/[name].[hash:5].js&#39;
    },
    module: {    //模块加载
        rules: [
            {
                test: /\.css$/,    //匹配规则
                use: [
                    { loader: &quot;style-loader&quot; },
                    { loader: &quot;css-loader&quot; }
                ]
            },{
                test: /\.(js|jsx)$/,
                exclude: /node_modules/,
                use: {
                    loader: &#39;babel-loader&#39;
                }
            },{
                test: /\.(png|svg|jpg|gif)$/,
                use: {
                    loader: &#39;url-loader&#39;,
                    options: {
                        limit: 8192,    //小于8192B的文件转为base64文件
                        name: &#39;static/images/[name].[hash:5].[ext]&#39;
                    }
                }
            }
        ]
    },
    plugins: [    //插件配置
        new CleanWebpackPlugin([&#39;build&#39;]),    //清空编译输出文件夹
        new HtmlWebpackPlugin({
            title: &#39;Cinglong\&#39;s Demo&#39;,
            filename: &#39;index.html&#39;,
            template: path.resolve(__dirname, &#39;templates&#39;, &#39;index.html&#39;)
        }),    //生成Html5文件
        new webpack.optimize.CommonsChunkPlugin({
            name: &#39;commons&#39;
        }),    //共用代码打包
    ]
};
</code></pre><p><strong>webpack.dev.js</strong>（开发配置）</p>
<pre><code>const merge = require(&#39;webpack-merge&#39;);
const common = require(&#39;./webpack.common.js&#39;);
const webpack = require(&#39;webpack&#39;);

module.exports = merge(common, {
    devtool: &#39;inline-source-map&#39;,    //代码关联显示方式
    devServer: {
        historyApiFallback:true,    //文件重定向，和react-router相关
        hot: true,    //开启模块热替换
        port: 80,    //服务器端口
        host: &quot;192.168.23.101&quot;,    //服务器域名
        open: true    //自动打开浏览器标签
    },
    plugins: [
        new webpack.NamedModulesPlugin(),    //显示模块的相对路径
        new webpack.HotModuleReplacementPlugin()    //加载热替换插件
    ]
});
</code></pre><p><strong>webpack.prod.js</strong>（预编译配置）</p>
<pre><code>const merge = require(&#39;webpack-merge&#39;);
const UglifyJSPlugin = require(&#39;uglifyjs-webpack-plugin&#39;);
const common = require(&#39;./webpack.common.js&#39;);

module.exports = merge(common, {
    plugins: [
        new UglifyJSPlugin()    //代码压缩
    ]
});
</code></pre><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><pre><code> react-webapp-demo
  |- /node_modules    //模块安装目录
  |- /src    //代码目录
    |- /container    //容器组件
    |- /presentational    //展示组件
      |- /images    //图片目录
    |- /reducers    //reducers操作
    |- /utils    //其他
    |- index.js    //项目入口
  |- /templates    //模板目录
  |- .babelrc    //babel编译配置
  |- package.json    //项目目录配置
  |- package-lock.json    //模块信息（自动生成）
  |- webpack.common.js    //webpack共用配置
  |- webpack.dev.js    //webpack开发配置
  |- webpack.prod.js    //webpack编译配置
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>前面有说到<code>React</code>在React Native App上的实现，其实React.js就是其在Web端的实现，加上工程化开发，这两者开发思维惊人的相似，有种<em>React就是那个离前端大统一最接近的技术</em> 的预感。</p>
<blockquote>
<p>刚好最近有时间，整理一下自己React.js的知识点，如果对React开发WebApp单页应用感兴趣的话，欢迎浏览，<a href="http://pancakeawesome.ink/React%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-%E4%B8%80-%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html">点击前往</a>。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> react </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> react </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[React项目实战（二）：react-redux-router基本原理]]></title>
      <url>/React%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98(%E4%BA%8C):react-redux-router%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="React项目实战：react-redux-router基本原理"><a href="#React项目实战：react-redux-router基本原理" class="headerlink" title="React项目实战：react-redux-router基本原理"></a>React项目实战：react-redux-router基本原理</h2><h2 id="React相关"><a href="#React相关" class="headerlink" title="React相关"></a>React相关</h2><p>React 是一个采用声明式，高效而且灵活的用来构建用户界面的框架。</p>
<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>本质上来讲，JSX 只是为<code>React.createElement(component, props, ...children)</code>方法提供的语法糖。比如下面的代码：</p>
<pre><code>const element = (
  &lt;h1 className=&quot;greeting&quot;&gt;
    Hello, world!
  &lt;/h1&gt;
);
</code></pre><p>编译为：</p>
<pre><code>const element = React.createElement(
  &#39;h1&#39;,
  {className: &#39;greeting&#39;},
  &#39;Hello, world!&#39;
);
</code></pre><p><code>React.createElement()</code>这个方法首先会进行一些避免bug的检查，之后会返回一个类似下面例子的对象：</p>
<pre><code>const element = {
  type: &#39;h1&#39;,
  props: {
    className: &#39;greeting&#39;,
    children: &#39;Hello, world&#39;
  }
};
</code></pre><p>这样的对象被称为<code>React元素</code>，它代表所有你在屏幕上看到的东西。<br>我们用 React 开发应用时一般只会定义一个根节点。要将 React 元素渲染到根DOM节点中，我们通过把它们都传递给<code>ReactDOM.render()</code>的方法来将其渲染到页面上：</p>
<pre><code>ReactDOM.render(
  element,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p>每当 React 元素发生变化时，<code>ReactDOM</code>首先会比较元素内容先后的不同，然后操作浏览器DOM更新改变了的部分。</p>
<h3 id="组件-amp-Props"><a href="#组件-amp-Props" class="headerlink" title="组件 &amp; Props"></a>组件 &amp; Props</h3><p>当 React 遇到的元素是用户自定义的组件，它会将 JSX 属性作为单个对象传递给该组件,这个对象称之为<code>props</code>。无论是使用函数或是类来声明一个组件，它决不能修改它自己的 props 。<br>例如,这段代码会在页面上渲染出<code>Hello,Sara</code>:</p>
<pre><code>//使用 ES6 class 来定义一个组件，组件名称必须以大写字母开头。
class Welcome extends React.Component {
  render() {
    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
  }
}

const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;
ReactDOM.render(
  element,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p>我们来回顾一下在这个例子中发生了什么：</p>
<ol>
<li>我们对<code>&lt;Welcome name=&quot;Sara&quot; /&gt;</code>元素调用了<code>ReactDOM.render()</code>方法。</li>
<li>React 将<code>{name: &#39;Sara&#39;}</code>作为<code>props</code>传入并调用 Welcome 组件。</li>
<li>Welcome 组件将<code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>元素作为结果返回。</li>
<li>ReactDOM 将DOM更新为<code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>。</li>
</ol>
<h3 id="State-amp-生命周期"><a href="#State-amp-生命周期" class="headerlink" title="State &amp; 生命周期"></a>State &amp; 生命周期</h3><p>组件的通过<code>props</code>获取属性，且其不能修改；当我们需要修改当前组件的状态时，要用到<code>state</code>来设置局部状态，需要通过<code>this.setState()</code>来更新组件局部状态：</p>
<pre><code>class Toggle extends React.Component {
  constructor(props) {
    super(props);    //初始化this，并赋值this.props
    this.state = {isToggleOn: true};    //初始化this.state
    this.handleClick = this.handleClick.bind(this);    //为this.handleClick绑定this对象
  }

  handleClick() {
    this.setState(prevState =&gt; ({
      isToggleOn: !prevState.isToggleOn
    }));    //用this.setState()更新this.state
  }

  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;
        {this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;}
      &lt;/button&gt;
    );
  }
}

ReactDOM.render(
  &lt;Toggle /&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p>每一个组件都有几个你可以重写以让代码在处理环节的特定时期运行的“生命周期方法”。方法中带有前缀<code>will</code>的在特定环节之前被调用，而带有前缀<code>did</code>的方法则会在特定环节之后被调用。</p>
<ul>
<li><strong>装配</strong>：这些方法会在组件实例被创建和插入DOM中时被调用：</li>
</ul>
<pre><code>- constructor(`props`)
- componentWillMount()
- render()
- componentDidMount()
</code></pre><ul>
<li><strong>更新</strong>：属性或状态的改变会触发一次更新。当一个组件在被重渲时，这些方法将会被调用：</li>
</ul>
<pre><code>- componentWillReceiveProps(`nextProps`)
- shouldComponentUpdate(`nextProps`, `nextState`)
- componentWillUpdate(`nextProps`, `nextState`)
- render()
- componentDidUpdate(`prevProps`, `prevState`)
</code></pre><ul>
<li><strong>卸载</strong>：当一个组件被从DOM中移除时，该方法被调用：</li>
</ul>
<pre><code>- componentWillUnmount()
</code></pre><p>当项目视图交互复杂且频繁的时候，依旧采用 state 进行状态更改会显得异常繁琐和不可预测。<br>这时我们就需要借助 Redux 框架，将状态数据全部转交给 Redux 处理，React 专一负责视图显示，这样会让项目逻辑变得简单而清晰。</p>
<h2 id="Redux相关"><a href="#Redux相关" class="headerlink" title="Redux相关"></a>Redux相关</h2><p>三大原则：</p>
<ul>
<li>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个<code>store</code>中。</li>
<li>惟一改变 state 的方法就是触发<code>action</code>，action 是一个用于描述事件的普通对象。</li>
<li>为了描述 action 如何改变 state tree ，你需要编写<code>reducers</code>。</li>
</ul>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action 是把数据从项目传到 store 的有效载荷。它是 store 数据的唯一来源。通常你会通过<code>store.dispatch()</code>将 action 传到 store。</p>
<p>Action 本质上是 JavaScript 普通对象，添加新 todo 任务的 action 是这样的：</p>
<pre><code>{
  type: &#39;ADD_TODO&#39;,
  text: &#39;Build my first Redux app&#39;
}
</code></pre><p><code>Action 创建函数</code>就是生成 action 的方法。在 Redux 中的 action 创建函数只是简单的返回一个 action:</p>
<pre><code>function addTodo(text) {
  return {
    type: &#39;ADD_TODO&#39;,
    text: text
  }
}
</code></pre><p>这样做将使 action 创建函数更容易被移植和测试。只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。</p>
<pre><code>dispatch(addTodo(text));

//或者创建一个 被绑定的 action 创建函数 来自动 dispatch：
const boundAddTodo = (text) =&gt; dispatch(addTodo(text));
boundAddTodo(text);
</code></pre><p>store 里能直接通过 store.dispatch() 调用 dispatch() 方法，但是多数情况下你会使用 react-redux 提供的<code>connect()</code>帮助器来调用。</p>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>Action 只是描述了有事情发生了这一事实，而<code>reducer</code>要做的事情正是指明应用如何更新 state 。reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。</p>
<pre><code>(previousState, action)=&gt; newState
</code></pre><p>保持 reducer 纯净非常重要。永远不要在 reducer 里做这些操作：</p>
<ul>
<li>修改传入参数；</li>
<li>执行有副作用的操作，如 API 请求和路由跳转；</li>
<li>调用非纯函数，如 Date.now() 或 Math.random()。</li>
</ul>
<p>我们将以指定 state 的初始状态作为开始。Redux 首次执行时，state 为 undefined，此时我们可借机设置并返回应用的初始 state：</p>
<pre><code>const initialState = {};    //初始化state

function todoApp(state = initialState, action) {
  switch (action.type) {
    case &#39;ADD_TODO&#39;:
      return Object.assign({}, state, {
        text: action.text
      })
    default:
      return state    //在 default 情况下返回旧的 state
  }
}
</code></pre><p>每个 reducer 只负责管理全局 state 中它负责的一部分。每个 reducer 的 state 参数都不同，分别对应它管理的那部分 state 数据。</p>
<p><code>combineReducers()</code>所做的只是生成一个函数，这个函数来调用你的一系列 reducer，每个 reducer 根据它们的 key 来筛选出 state 中的一部分数据并处理，然后这个生成的函数再将所有 reducer 的结果合并成一个大的对象。</p>
<pre><code>import { combineReducers } from &#39;redux&#39;;

const todoApp = combineReducers({
  visibilityFilter,
  todos
})

export default todoApp;
</code></pre><p>注意上面的写法和下面完全等价：</p>
<pre><code>export default function todoApp(state = {}, action) {
  return {
    visibilityFilter: visibilityFilter(state.visibilityFilter, action),
    todos: todos(state.todos, action)
  }
}
</code></pre><blockquote>
<p>combineReducers 接收一个对象，可以把所有顶级的 reducer 放到一个独立的文件中，通过 export 暴露出每个 reducer 函数，然后使用 import * as reducers 得到一个以它们名字作为 key 的 object：</p>
</blockquote>
<pre><code>import { combineReducers } from &#39;redux&#39;
import * as reducers from &#39;./reducers&#39;

const todoApp = combineReducers(reducers)
</code></pre><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>action 描述发生了什么，reducers 根据 action 更新 state，<code>Store</code>就是把它们联系到一起的对象。Store 有以下职责：</p>
<ul>
<li>维持应用的 state；</li>
<li>提供<code>getState()</code>方法获取 state；</li>
<li>提供<code>dispatch(action)</code>方法更新state；</li>
<li>通过<code>subscribe(listener)</code>注册监听器;</li>
<li>通过<code>subscribe(listener)</code>返回的函数注销监听器。</li>
</ul>
<p>我们使用 combineReducers() 将多个 reducer 合并成为一个。现在我们将其导入，并传递 <code>createStore()</code>。</p>
<pre><code>import { createStore } from &#39;redux&#39;
import todoApp from &#39;./reducers&#39;
let store = createStore(todoApp)
</code></pre><p>createStore() 的第二个参数是可选的, 用于设置 state 初始状态。这对开发同构应用时非常有用，服务器端 redux 应用的 state 结构可以与客户端保持一致, 那么客户端可以将从网络接收到的服务端 state 直接用于本地数据初始化。</p>
<pre><code>let store = createStore(todoApp, window.STATE_FROM_SERVER);
</code></pre><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>Redux 应用中数据的生命周期遵循下面 4 个步骤：</p>
<ol>
<li>调用 store.dispatch(action)。</li>
<li>Redux store 调用传入的 reducer 函数。</li>
<li>根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。</li>
<li>Redux store 保存了根 reducer 返回的完整 state 树。</li>
</ol>
<h2 id="Router相关"><a href="#Router相关" class="headerlink" title="Router相关"></a>Router相关</h2><p>直接使用整合后的<code>react-router-redux</code>，后面抽时间再详细讲一下，具体使用的话模仿官方案例吧，<a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2FReactTraining%2Freact-router%2Ftree%2Fmaster%2Fpackages%2Freact-router-redux%23readme" target="_blank" rel="noopener">官方文档</a> 。</p>
<h3 id="容器组件-和-展示组件"><a href="#容器组件-和-展示组件" class="headerlink" title="容器组件 和 展示组件"></a>容器组件 和 展示组件</h3><p>Redux 的 React 绑定库包含了 容器组件和展示组件相分离 的开发思想。</p>
<p>明智的做法是只在最顶层组件（如路由操作）里使用 Redux。其余内部组件仅仅是展示性的，所有数据都通过 props 传入。</p>
<p><img src="https://img.funteas.com/91203073913747ce6dd77f8bfef1710a?imageView2/2/w/800" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="系列目录"><a href="#系列目录" class="headerlink" title="系列目录"></a>系列目录</h3><ol>
<li><a href="http://pancakeawesome.ink/React%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-%E4%B8%80-%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html">React项目实战：环境搭建</a> </li>
<li><a href="http://pancakeawesome.ink/React%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98(%E4%BA%8C\">React项目实战：react-redux-router基本原理</a>:react-redux-router%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html) </li>
<li>React项目实战：登录页面（编辑中）</li>
</ol>
]]></content>
      
        <categories>
            
            <category> react </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> react </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[理解ES6的 Iterator 、Iterable 、 Generator]]></title>
      <url>/%E7%90%86%E8%A7%A3ES6%E7%9A%84-Iterator-%E3%80%81Iterable-%E3%80%81-Generator.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fn3a6uc58nj30yj0jdab7.jpg" alt=""> </p>
<h3 id="理解ES6的-Iterator-、Iterable-、-Generator"><a href="#理解ES6的-Iterator-、Iterable-、-Generator" class="headerlink" title="理解ES6的 Iterator 、Iterable 、 Generator"></a>理解ES6的 Iterator 、Iterable 、 Generator</h3><h3 id="什么是迭代器-Iterator-？"><a href="#什么是迭代器-Iterator-？" class="headerlink" title="什么是迭代器(Iterator)？"></a>什么是迭代器(Iterator)？</h3><p>满足<a href="https://link.funteas.com?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FIteration_protocols%23%25E8%25BF%25AD%25E4%25BB%25A3%25E5%2599%25A8%25E5%258D%258F%25E8%25AE%25AE" target="_blank" rel="noopener">迭代器协议</a> 的对象。<br><a href="https://link.funteas.com?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FIteration_protocols%23%25E8%25BF%25AD%25E4%25BB%25A3%25E5%2599%25A8%25E5%258D%258F%25E8%25AE%25AE" target="_blank" rel="noopener">迭代器协议</a> : 对象的<code>next</code>方法是一个无参函数，它返回一个对象，该对象拥有<code>done</code>和<code>value</code>两个属性：</p>
<ul>
<li><p><code>done</code>(<code>boolean</code>):</p>
</li>
<li><p>如果迭代器已经经过了被迭代序列时为<code>true</code>。这时<code>value</code>可能描述了该迭代器的返回值。</p>
</li>
<li><p>如果迭代器可以产生序列中的下一个值，则为<code>false</code>。这等效于连同<code>done</code>属性也不指定。</p>
</li>
<li><p><code>value</code>: 迭代器返回的任何 JavaScript值。<code>done</code>为<code>true</code>时可省略。</p>
</li>
</ul>
<p>ES5实现一个简单的迭代器：</p>
<pre><code>function createIterator(items) {
    var i = 0;

    return {
        next: function() {

            var done = (i &gt;= items.length);
            var value = !done ? items[i++] : undefined;

            return {
                done: done,
                value: value
            };
        }
    };
}

var iterator = createIterator([1, 2, 3]);

console.log(iterator.next());           // &quot;{ value: 1, done: false }&quot;
console.log(iterator.next());           // &quot;{ value: 2, done: false }&quot;
console.log(iterator.next());           // &quot;{ value: 3, done: false }&quot;
console.log(iterator.next());           // &quot;{ value: undefined, done: true }&quot;
// 之后的所有调用
console.log(iterator.next());           // &quot;{ value: undefined, done: true }&quot;
</code></pre><h3 id="什么是可迭代对象-Iterable-？"><a href="#什么是可迭代对象-Iterable-？" class="headerlink" title="什么是可迭代对象(Iterable)？"></a>什么是可迭代对象(Iterable)？</h3><p>满足<a href="https://link.funteas.com?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FIteration_protocols%23%25E5%258F%25AF%25E8%25BF%25AD%25E4%25BB%25A3%25E5%258D%258F%25E8%25AE%25AE" target="_blank" rel="noopener">可迭代协议</a> 的对象是可迭代对象。<br><a href="https://link.funteas.com?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FIteration_protocols%23%25E5%258F%25AF%25E8%25BF%25AD%25E4%25BB%25A3%25E5%258D%258F%25E8%25AE%25AE" target="_blank" rel="noopener">可迭代协议</a> : 对象的<code>[Symbol.iterator]</code>值是一个无参函数，该函数返回一个迭代器。</p>
<p>在ES6中，所有的集合对象（<code>Array</code>、 <code>Set</code> 与 <code>Map</code>）以及<code>String</code>、<code>arguments</code>都是可迭代对象，它们都有默认的迭代器。</p>
<p>可迭代对象可以在以下语句中使用：</p>
<pre><code>for (let value of [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) {
  console.log(value);
}
// &quot;a&quot;
// &quot;b&quot;
// &quot;c&quot;
</code></pre><pre><code>[...&#39;abc&#39;];   // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
console.log(...[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);   // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre><pre><code>function* gen() {
  yield* [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
}

gen().next(); // { value: &quot;a&quot;, done: false }
</code></pre><pre><code>let [a, b, c] = new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);
a;   // &#39;a&#39;
</code></pre><p><code>for...of</code>接受一个可迭代对象（Iterable），或者能被强制转换/包装成一个可迭代对象的值（如’abc’）。遍历时，<code>for...of</code>会获取可迭代对象的<code>[Symbol.iterator]()</code>，对该迭代器逐次调用next()，直到迭代器返回对象的<code>done</code>属性为<code>true</code>时，遍历结束，不对该value处理。</p>
<p><code>for...of</code>循环实例：</p>
<pre><code>var a = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;];

for (var val of a) {
    console.log( val );
}
// &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot;
</code></pre><p>转换成普通for循环示例，等价于上面<code>for...of</code>循环：</p>
<pre><code>var a = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;];

for (var val, ret, it = a[Symbol.iterator]();
    (ret = it.next()) &amp;&amp; !ret.done;
) {
    val = ret.value;
    console.log( val );
}
// &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot;
</code></pre><h4 id="使迭代器可迭代"><a href="#使迭代器可迭代" class="headerlink" title="使迭代器可迭代"></a>使迭代器可迭代</h4><p>在什么是迭代器部分，我们自定义了一个简单的生成迭代器的函数<code>createIterator</code>，但并该函数生成的迭代器并没有实现可迭代协议，所以不能在<code>for...of</code>等语法中使用。可以为该对象实现可迭代协议，在<code>[Symbol.iterator]</code>函数中返回该迭代器自身。</p>
<pre><code>function createIterator(items) {
    var i = 0;

    return {
        next: function () {

            var done = (i &gt;= items.length);
            var value = !done ? items[i++] : undefined;

            return {
                done: done,
                value: value
            };
        },
        [Symbol.iterator]: function () { return this }
    };
}

var iterator = createIterator([1, 2, 3]);
console.log(...iterator)
</code></pre><h3 id="什么是生成器-Generator-？"><a href="#什么是生成器-Generator-？" class="headerlink" title="什么是生成器(Generator)？"></a>什么是生成器(Generator)？</h3><h4 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h4><p><a href="https://link.funteas.com?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Ffunction*" target="_blank" rel="noopener">生成器函数（GeneratorFunction）</a> 是能返回一个<a href="https://link.funteas.com?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FGenerator" target="_blank" rel="noopener">生成器（generator）</a> 的函数。生成器函数由放在 function 关键字之后的一个星号（ * ）来表示，并能使用新的 yield 关键字。</p>
<pre><code>function *aGeneratorfunction(){
  yield 1
  yield 2
  yield 3
};

var aGeneratorObject = aGeneratorfunction()
// 生成器对象
aGeneratorObject.toString()   // &quot;[object Generator]&quot;
function *aGeneratorfunction(){
  yield 1
  yield 2
  yield 3
};

var aGeneratorObject = aGeneratorfunction()

// 满足迭代器协议，是迭代器
aGeneratorObject.next()   // {value: 1, done: false}
aGeneratorObject.next()   // {value: 2, done: false}
aGeneratorObject.next()   // {value: 3, done: false}
aGeneratorObject.next()   // {value: undefined, done: true}

// [Symbol.iterator]是一个无参函数，该函数执行后返回生成器对象本身（是迭代器），所以是可迭代对象
aGeneratorObject[Symbol.iterator]() === aGeneratorObject   // true

// 可以被迭代
var aGeneratorObject1 = aGeneratorfunction()
[...aGeneratorObject1]   // [1, 2, 3]
</code></pre><h4 id="在生成器中return"><a href="#在生成器中return" class="headerlink" title="在生成器中return"></a>在生成器中return</h4><p>遍历返回对象的<code>done</code>值为<code>true</code>时迭代即结束，不对该<code>value</code>处理。</p>
<pre><code>function *createIterator() {
  yield 1;
  return 42;
  yield 2;
}

let iterator = createIterator();
iterator.next();   // {value: 1, done: false}
iterator.next();   // {value: 42, done: true}
iterator.next();   // {value: undefined, done: true}
</code></pre><p><code>done</code>值为true时迭代即结束，迭代不对该value处理。所以对这个迭代器遍历，不会对值42处理。</p>
<pre><code>let iterator1 = createIterator();
console.log(...iterator);   // 1
</code></pre><h3 id="添加-Symbol-iterator-使Object可迭代"><a href="#添加-Symbol-iterator-使Object可迭代" class="headerlink" title="添加[Symbol.iterator]使Object可迭代"></a>添加<code>[Symbol.iterator]</code>使<code>Object</code>可迭代</h3><p>根据<a href="https://link.funteas.com?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FIteration_protocols" target="_blank" rel="noopener">可迭代协议</a> ，给<code>Object</code>的原型添加<code>[Symbol.iterator]</code>，值为返回一个对象的无参函数，被返回对象符合迭代器协议。</p>
<pre><code>Object.prototype[Symbol.iterator] = function () {
  var i = 0
  var items = Object.entries(this)
  return {
    next: function () {
      var done = (i &gt;= items.length);
      var value = !done ? items[i++] : undefined;

      return {
          done: done,
          value: value
      };
    }
  }
}

var a = {
  name: &#39;Jimmy&#39;,
  age: 18,
  job: &#39;actor&#39;
}

console.log(...a)   // [ &#39;name&#39;, &#39;Jimmy&#39; ] [ &#39;age&#39;, 18 ] [ &#39;job&#39;, &#39;actor&#39; ]
</code></pre><p>使用生成器简化代码：</p>
<pre><code>Object.prototype[Symbol.iterator] = function* () {
  for (const key in this) {
    if (this.hasOwnProperty(key)) {
      yield [key, this[key]];
    }
  }
}

var a = {
  name: &#39;Jimmy&#39;,
  age: 18,
  job: &#39;actor&#39;
}

console.log(...a)   // [ &#39;name&#39;, &#39;Jimmy&#39; ] [ &#39;age&#39;, 18 ] [ &#39;job&#39;, &#39;actor&#39; ]
</code></pre><pre><code>function* g1() {
  yield 1;
  yield 2;
}

function* g2() {
  yield* g1();
  yield* [3, 4];
  yield* &quot;56&quot;;
  yield* arguments;
}

var generator = g2(7, 8);
console.log(...generator);   // 1 2 3 4 &quot;5&quot; &quot;6&quot; 7 8
</code></pre><h3 id="最后一个例子"><a href="#最后一个例子" class="headerlink" title="最后一个例子"></a>最后一个例子</h3><p>分析下面这段代码：</p>
<pre><code>function* fibs() {
  var a = 0;
  var b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

var [first, second, third, fourth, fifth, sixth] = fibs();
console.log(first, second, third, fourth, fifth, sixth);
</code></pre><p>在这段代码里，<code>fibs</code>是一个生成无限长的斐波那契数列的生成器，<code>[a, b] = [b, a + b]</code>是利用解构赋值的交换赋值写法（=赋值是从右到左计算，所以先计算右侧<code>a+b</code>，然后才结构，所有有交换赋值的效果），写成生成有限长的数组的ES5写法如下：</p>
<pre><code>function fibs1(n) {
  var a = 0;
  var b = 1;
  var c = 0;
  var result = []
  for (var i = 0; i &lt; n; i++) {
    result.push(a);
    c = a;
    a = b;
    b = c + b;
  }

  return result;
}

console.log(fibs1(6))   // [0, 1, 1, 2, 3, 5]
</code></pre><p>而第一段代码里，就是从<code>fibs()</code>迭代器（生成器是迭代器的子集）中解构出前六个值，代码示例如下：</p>
<pre><code>function* fibs2(n) {
  var a = 0;
  var b = 1;
  for (var i = 0; i &lt; n; i++) {
    yield a;
    [a, b] = [b, a + b];
  }
}

console.log(...fibs2(6))
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="为什么要使用迭代器、生成器，有什么好处？"><a href="#为什么要使用迭代器、生成器，有什么好处？" class="headerlink" title="为什么要使用迭代器、生成器，有什么好处？"></a>为什么要使用迭代器、生成器，有什么好处？</h3><p>…还没想清楚</p>
<p>以上，有很多个人理解的部分，欢迎纠错(*￣︶￣)</p>
]]></content>
      
        <categories>
            
            <category> es6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 前端技术 </tag>
            
            <tag> 面试 </tag>
            
            <tag> es6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网页适配 iPhoneX，就是这么简单]]></title>
      <url>/%E7%BD%91%E9%A1%B5%E9%80%82%E9%85%8D-iPhoneX%EF%BC%8C%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iPhoneX 取消了物理按键，改成底部小黑条，这一改动导致网页出现了比较尴尬的屏幕适配问题。对于网页而言，顶部（刘海部位）的适配问题浏览器已经做了处理，所以我们只需要关注底部与小黑条的适配问题即可（即常见的吸底导航、返回顶部等各种相对底部 fixed 定位的元素）。</p>
<p>笔者通过查阅了一些官方文档，以及结合实际项目中的一些处理经验，整理了一套简单的适配方案分享给大家，希望对大家有所帮助，以下是处理前后效果图：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fn297hfohoj30h80gtmzo.jpg" alt=""></p>
<h2 id="适配之前需要了解的几个新知识"><a href="#适配之前需要了解的几个新知识" class="headerlink" title="适配之前需要了解的几个新知识"></a>适配之前需要了解的几个新知识</h2><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全区域指的是一个可视窗口范围，处于安全区域的内容不受圆角（corners）、齐刘海（sensor housing）、小黑条（Home Indicator）影响，如下图蓝色区域：</p>
<p>也就是说，我们要做好适配，必须保证页面可视、可操作区域是在安全区域内。</p>
<p><a href="https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/" target="_blank" rel="noopener">更详细说明，参考文档：Human Interface Guidelines - iPhoneX</a></p>
<h3 id="viewport-fit"><a href="#viewport-fit" class="headerlink" title="viewport-fit"></a>viewport-fit</h3><p>iOS11 新增特性，苹果公司为了适配 iPhoneX 对现有 viewport meta 标签的一个扩展，用于设置网页在可视窗口的布局方式，可设置三个值：</p>
<ul>
<li><p>contain: 可视窗口完全包含网页内容（左图）</p>
</li>
<li><p>cover：网页内容完全覆盖可视窗口（右图）</p>
</li>
<li><p>auto：默认值，跟 contain 表现一致</p>
</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fn298t7lqwj30iq09e0t5.jpg" alt=""> </p>
<p>注意：网页默认不添加扩展的表现是 viewport-fit=contain，需要适配 iPhoneX 必须设置 viewport-fit=cover，这是适配的关键步骤。</p>
<p>更详细说明，参考文档：viewport-fit-descriptor</p>
<h2 id="constant-函数"><a href="#constant-函数" class="headerlink" title="constant 函数"></a>constant 函数</h2><p>iOS11 新增特性，Webkit 的一个 CSS 函数，用于设定安全区域与边界的距离，有四个预定义的变量：</p>
<ul>
<li><p>safe-area-inset-left：安全区域距离左边边界距离</p>
</li>
<li><p>safe-area-inset-right：安全区域距离右边边界距离</p>
</li>
<li><p>safe-area-inset-top：安全区域距离顶部边界距离</p>
</li>
<li><p>safe-area-inset-bottom：安全区域距离底部边界距离</p>
</li>
</ul>
<p>这里我们只需要关注 safe-area-inset-bottom 这个变量，因为它对应的就是小黑条的高度（横竖屏时值不一样）。</p>
<p>注意：当 viewport-fit=contain 时 constant 函数是不起作用的，必须要配合 viewport-fit=cover 使用。对于不支持 constant 的浏览器，浏览器将会忽略它。</p>
<p>官方文档中提到 env 函数即将要替换 constant 函数，笔者测试过暂时还不可用。</p>
<p>更详细说明，参考文档：Designing Websites for iPhone X</p>
<h2 id="如何适配"><a href="#如何适配" class="headerlink" title="如何适配"></a>如何适配</h2><p>了解了以上所说的几个知识点，接下来我们适配的思路就很清晰了。</p>
<h3 id="第一步：设置网页在可视窗口的布局方式"><a href="#第一步：设置网页在可视窗口的布局方式" class="headerlink" title="第一步：设置网页在可视窗口的布局方式"></a>第一步：设置网页在可视窗口的布局方式</h3><p>新增 viweport-fit 属性，使得页面内容完全覆盖整个窗口：</p>
<pre><code>&lt;metaname=&quot;viewport&quot;content=&quot;width=device-width, viewport-fit=cover&quot;&gt;
</code></pre><p>前面也有提到过，只有设置了 viewport-fit=cover，才能使用 constant 函数。</p>
<h3 id="第二步：页面主体内容限定在安全区域内"><a href="#第二步：页面主体内容限定在安全区域内" class="headerlink" title="第二步：页面主体内容限定在安全区域内"></a>第二步：页面主体内容限定在安全区域内</h3><p>这一步根据实际页面场景选择，如果不设置这个值，可能存在小黑条遮挡页面最底部内容的情况。</p>
<pre><code>body {

  padding-bottom: constant(safe-area-inset-bottom);

}
</code></pre><h3 id="第三步：fixed-元素的适配"><a href="#第三步：fixed-元素的适配" class="headerlink" title="第三步：fixed 元素的适配"></a>第三步：fixed 元素的适配</h3><p>类型一：fixed 完全吸底元素（bottom = 0），比如下图这两种情况：</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt=""></p>
<p>可以通过加内边距 padding 扩展高度：</p>
<pre><code>{

  padding-bottom: constant(safe-area-inset-bottom);

}
</code></pre><p>或者通过计算函数 calc 覆盖原来高度：</p>
<pre><code>{

  height: calc(60px(假设值) + constant(safe-area-inset-bottom));

}
</code></pre><p>注意，这个方案需要吸底条必须是有背景色的，因为扩展的部分背景是跟随外容器的，否则出现镂空情况。</p>
<p>还有一种方案就是，可以通过新增一个新的元素（空的颜色块，主要用于小黑条高度的占位），然后吸底元素可以不改变高度只需要调整位置，像这样：</p>
<pre><code>{

  margin-bottom: constant(safe-area-inset-bottom);

}
</code></pre><p>空的颜色块：</p>
<pre><code>{

  position: fixed;

  bottom: 0;

  width: 100%;

  height: constant(safe-area-inset-bottom);

  background-color: #fff;

}
</code></pre><p>类型二：fixed 非完全吸底元素（bottom ≠ 0），比如 “返回顶部”、“侧边广告” 等</p>
<p>像这种只是位置需要对应向上调整，可以仅通过外边距 margin 来处理：</p>
<pre><code>{

  margin-bottom: constant(safe-area-inset-bottom);

}
</code></pre><p>或者，你也可以通过计算函数 calc 覆盖原来 bottom 值：</p>
<pre><code>{

  bottom: calc(50px(假设值) + constant(safe-area-inset-bottom));

}
</code></pre><h3 id="别忘了使用-supports"><a href="#别忘了使用-supports" class="headerlink" title="别忘了使用 @supports"></a>别忘了使用 @supports</h3><p>写到这里，我们常见的两种类型的 fixed 元素适配方案已经了解了吧，但别忘了，一般我们只希望 iPhoneX 才需要新增适配样式，我们可以配合 @supports 这样编写样式：</p>
<pre><code>@supports (bottom: constant(safe-area-inset-bottom)) {

  div {

    margin-bottom: constant(safe-area-inset-bottom);

  }

}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上几种方案仅供参考，笔者认为，现阶段适配处理起来是有点折腾，但是至少能解决，具体需要根据页面实际场景，在不影响用户体验与操作的大前提下不断尝试与探索，才能更完美的适配。</p>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS 实用 Tips]]></title>
      <url>/CSS-%E5%AE%9E%E7%94%A8-Tips.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为前端，日常开发充满了各种挑战与乐趣，我们穷尽一切在奇葩的需求中提升用户体验。本文将列举一些前端开发中碰到的小众需求，并提供解决方案以供参考。</p>
<h2 id="CSS-实用-Tips"><a href="#CSS-实用-Tips" class="headerlink" title="CSS 实用 Tips"></a>CSS 实用 Tips</h2><h3 id="一、修改鼠标手势图标"><a href="#一、修改鼠标手势图标" class="headerlink" title="一、修改鼠标手势图标"></a>一、修改鼠标手势图标</h3><p>很多童鞋可能都用过：</p>
<pre><code>cursor: pointer | wait | hand | text | move |not-allowed;
</code></pre><p>但是，它还支持用户自定义图片，你知道吗？</p>
<pre><code>cursor: url(jartto.cur), url(http://jartto.wang/jartto.gif), auto;
</code></pre><p>下图为各浏览器支持情况：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmt0w88h1yj30hx05n74v.jpg" alt="tips1"></p>
<p>记得在定义完自定义的游标之后在末尾加上一般性的游标，以防那些url所定义的游标不能使用。</p>
<p>这里有详细说明：</p>
<p>1.<a href="https://link.funteas.com?target=https%3A%2F%2Fwww.cnblogs.com%2FMY0101%2Fp%2F6130089.html" target="_blank" rel="noopener">css cursor 的可选值（鼠标的各种样式）</a><br>2.<a href="https://link.funteas.com?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FCSS%2FCSS_User_Interface%2FUsing_URL_values_for_the_cursor_property" target="_blank" rel="noopener">Using URL values for the cursor property</a> </p>
<h3 id="二、box-shadow-三边阴影"><a href="#二、box-shadow-三边阴影" class="headerlink" title="二、box-shadow 三边阴影"></a>二、box-shadow 三边阴影</h3><p><code>box-shadow</code> 大家都不陌生，我们一般这么用：</p>
<pre><code>box-shadow: h-shadow v-shadow blur spread color inset;
</code></pre><p>可是三边阴影该如何设置呢？请不要忽视设计师的脑洞🙈：</p>
<pre><code>#shadowBox {
  background-color: #ddd;
  margin: 0px auto;
  padding: 10px;
  width: 220px;
  box-shadow: 0px 8px 10px gray,
        -10px 8px 15px gray, 10px 8px 15px gray;
}
</code></pre><p>也许你会用得到，详情请参考：<a href="https://link.funteas.com?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F8738768%2Fcss-box-shadow-on-three-sides-of-a-div" target="_blank" rel="noopener">CSS box-shadow on three sides of a div?</a> </p>
<h3 id="三、超好用的-currentColor"><a href="#三、超好用的-currentColor" class="headerlink" title="三、超好用的 currentColor"></a>三、超好用的 currentColor</h3><p>先来举个例子，html代码：</p>
<pre><code>&lt;a href=&quot;##&quot; class=&quot;link&quot;&gt;&lt;i class=&quot;icon&quot;&gt;&lt;/i&gt;返回&lt;/a&gt;
</code></pre><p>css 代码：</p>
<pre><code>.icon {
  display: inline-block;
  width: 16px; 
  height: 20px;
  background-image: url(http:jartto.wang/test.png);
  background-color: currentColor; /* 该颜色控制图标的颜色 */
  background-position: 0 0;
}
.link:hover {
  color: #333; /* 虽然改变的是文字颜色，但是图标颜色也一起变化了 */
}
</code></pre><p>currentColor 表示“当前的标签所继承的文字颜色”</p>
<p>了解更多，请参考：<a href="https://link.funteas.com?target=http%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2014%2F10%2Fcurrentcolor-css3-powerful-css-keyword%2F" target="_blank" rel="noopener">CSS3 超高校级好用 CSS 变量</a> </p>
<h3 id="四、png-图片如何改颜色"><a href="#四、png-图片如何改颜色" class="headerlink" title="四、png 图片如何改颜色"></a>四、png 图片如何改颜色</h3><p>网页中大多使用透明图片 <code>png</code> 格式，可是如果有天产品经理说，这个图标颜色能不能改成红色，恰巧设计师不能支持你，你该如何办？<br>其一：自己重新 <code>ps</code> 一下图片，换个颜色；<br>其二：只能上 <code>svg</code> 喽，搞成 <code>icon font</code>；</p>
<p>这里，我们来说第三种方式，妙不妙可以试试哦！</p>
<pre><code>.icon {
  display: inline-block;
  width: 20px; 
  height: 20px;
  overflow: hidden;
}
.icon-del {
  background: url(delete.png) no-repeat center;
}
.icon &gt; .icon {
  position: relative;
  left: -20px;
  border-right: 20px solid transparent; /*下文注意点 2 有解释*/
  -webkit-filter: drop-shadow(20px 0);
  filter: drop-shadow(20px 0);    
}
</code></pre><p>html 代码:</p>
<pre><code>&lt;p&gt;&lt;strong&gt;原始图标&lt;/strong&gt;&lt;/p&gt;
&lt;i class=&quot;icon icon-del&quot;&gt;&lt;/i&gt;
&lt;p&gt;&lt;strong&gt;可以变色的图标&lt;/strong&gt;&lt;/p&gt;
&lt;i class=&quot;icon&quot;&gt;&lt;i class=&quot;icon icon-del&quot;&gt;&lt;/i&gt;&lt;/i&gt;
</code></pre><p>需要注意几点：<br>1.对于背景透明的 <code>png</code> 小图标而言，如果我们施加一个不带模糊的投影，就等同于生成了另外一个颜色的小图标；<br>2.在 <code>chrome</code> 浏览器下，如果一个元素的主体部分，无论以何种方式，只要在页面中不可见，其 <code>drop-shadow</code> 是不可见的。实体部分哪怕有 <code>1px</code> 可见，则 <code>drop-shadow</code> 完全可见。</p>
<p>原理其实很简单，使用了 <code>css3</code> 滤镜 <code>filter</code> 中的 <code>drop-shadow</code>，<code>drop-shadow</code> 滤镜可以给元素或图片非透明区域添加投影。</p>
<p>了解更多，请参考：<br>1.<a href="https://link.funteas.com?target=http%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2016%2F06%2Fpng-icon-change-color-by-css%2F" target="_blank" rel="noopener">PNG 格式小图标的 CSS 任意颜色赋色技术</a><br>2.<a href="https://link.funteas.com?target=http%3A%2F%2Fwww.zhangxinxu.com%2Fstudy%2F201606%2Fpng-icon-color-fill.html" target="_blank" rel="noopener">demo 演示</a> </p>
<h3 id="五、vh-与-vw"><a href="#五、vh-与-vw" class="headerlink" title="五、vh 与 vw"></a>五、vh 与 vw</h3><p>相对于视口的宽度。视口被均分为 <code>100</code> 单位的 <code>vw</code>，<code>vh</code> 同理。</p>
<p>我一般会在强制某一个容器占一整屏的时候使用，如：</p>
<pre><code>.box{
  height: calc(100vh-50px);}
</code></pre><p>视口高度减去页头固定区域，剩下的高度设置给容器。当然，我们也可以用它设置大小，如下：</p>
<pre><code>h1 {
  font-size:8vw;}
</code></pre><p>如果视口的宽度是 <code>200mm</code>，那么上述代码中h1元素的字号将为 <code>16mm</code>，即 (8x200)/100</p>
<p>值得注意的是，<code>less</code> 中使用需要加 <code>～</code></p>
<pre><code>min-height:~&quot;calc(100vh - 68px)&quot;;
</code></pre><p>此外，还有一些如 <code>ch</code> ，<code>vmax</code>，<code>vmin</code> 等属性等着你去扩展，详情请移步：<a href="https://link.funteas.com?target=http%3A%2F%2Fwww.css88.com%2Fbook%2Fcss%2Fvalues%2Flength%2Fvw.htm" target="_blank" rel="noopener">css 参考手册之 vw</a> </p>
<h3 id="六、如何去掉-chrome-input-的背景黄色"><a href="#六、如何去掉-chrome-input-的背景黄色" class="headerlink" title="六、如何去掉 chrome input 的背景黄色"></a>六、如何去掉 chrome input 的背景黄色</h3><p>当我们在做登陆页面的时候，在 <code>chrome</code> 中 <code>input</code> 会带上自动补全的黄色背景，大大影响美观。很多网站都没有去处理，但这并不难处理。作为高逼格的前端，这里就可以体现出你的价值，解决方案如下：</p>
<pre><code>input:-webkit-autofill {
  -webkit-box-shadow: 0 0 0px 1000px rgba(255, 255, 255, 0.5) inset !important;
}
</code></pre><p>当然，你也可以使用方案二，如下：</p>
<pre><code>input:-webkit-autofill {
  -webkit-animation-name: autofill;
  -webkit-animation-fill-mode: both;
}
@-webkit-keyframes autofill {
  to {
    color: #fff;
    background: transparent;
  }
}
</code></pre><p>深入了解请移步：<br>1.<a href="https://link.funteas.com?target=http%3A%2F%2Fblog.csdn.net%2Fwangxiaohui6687%2Farticle%2Fdetails%2F10149579" target="_blank" rel="noopener">chrome 表单自动填充去掉 input 黄色背景解决方案</a><br>2.<a href="https://link.funteas.com?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F2781549%2Fremoving-input-background-colour-for-chrome-autocomplete" target="_blank" rel="noopener">Removing input background colour for Chrome autocomplete</a> </p>
<h3 id="七、chrome-中设置小于-12px-的字体"><a href="#七、chrome-中设置小于-12px-的字体" class="headerlink" title="七、chrome 中设置小于 12px 的字体"></a>七、chrome 中设置小于 12px 的字体</h3><p>这种改小字体，绝大部分肯定都是设计师的需求，因为小显得精致。</p>
<pre><code>ant-checkbox-wrapper {
 cursor: pointer;
 font-size: 10px;
 display: inline-block;
 -webkit-text-size-adjust: none; // 不支持
 transform: scale(0.9);
}
</code></pre><h3 id="八、0-5px-border-如何操作"><a href="#八、0-5px-border-如何操作" class="headerlink" title="八、0.5px border 如何操作"></a>八、0.5px border 如何操作</h3><p>现行方法大致有如下几条：<br>1.使用渐变 <code>linear-gradient</code> 来操作，但需要注意浏览器兼容前缀；</p>
<pre><code>.div::after {
  content: &quot; &quot;;
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 1px;
  background-image: linear-gradient(0deg, transparent 50%, #e0e0e0 50%);
}
</code></pre><p>2.缩放 <code>scale</code> 处理：</p>
<pre><code>div::after{
  content: &quot;&quot;;
  display: block;
  position: absolute;
  left: -50%;
  bottom: 0;
  width: 200%;
  height: 1px;
  background: #c3c3c3;
  -webkit-transform: scale(0.5);
}
</code></pre><p>3.使用 <code>background-image</code> 和 <code>css3</code> 的九宫格裁减</p>
<pre><code>.bd-t::after {
  content: &quot; &quot;;
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  border-top: 1px solid transparent;
  /* 下面用 stretch 和 round 都可以 */
  border-image: url(&#39;pic.png&#39;) 2 1 1 1 stretch; 
  -webkit-border-image: url(&#39;pic.png&#39;) 2 1 1 1 stretch;
}
</code></pre><p>深入了解可以参考：<br>1.<a href="https://link.funteas.com?target=http%3A%2F%2Fblog.csdn.net%2Ftyro_java%2Farticle%2Fdetails%2F52013531" target="_blank" rel="noopener">使用 css3 做 0.5px 的细线</a><br>2.<a href="https://link.funteas.com?target=http%3A%2F%2Fwww.cnblogs.com%2Fraoyunxiao%2Fp%2F4241982.html" target="_blank" rel="noopener">移动端页面0.5px border的实现</a> </p>
<h3 id="九、border-颜色渐变"><a href="#九、border-颜色渐变" class="headerlink" title="九、border 颜色渐变"></a>九、border 颜色渐变</h3><pre><code>border-color:red green blue pink;
</code></pre><p>“border-width” 属性如果单独使用的话是不会起作用的。请首先使用 “border-style” 属性来设置边框。</p>
<h3 id="十、css3-画小箭头"><a href="#十、css3-画小箭头" class="headerlink" title="十、css3 画小箭头"></a>十、css3 画小箭头</h3><p>这里推荐两种方式：<br>其一，通过 border 来实现</p>
<pre><code>/*箭头向上*/
.arrow-up {
  width:0;
  height:0;
  border-left:30px solid transparent;
  border-right:30px solid transparent;
  border-bottom:30px solid #fff;
}
/*箭头向下*/
.arrow-down {
  width:0;
  height:0;
  border-left:20px solid transparent;
  border-right:20px solid transparent;
  border-top:20px solid #0066cc;
}
</code></pre><p>其二，拼凑法（伪类或元素），将 <code>div</code> 隐藏两边或设置 <code>z-index</code>，然后旋转，放到合适位置。</p>
<pre><code>div {
  position: absolute;
  bottom: -2px;
  left: 7px;
  width: 10px;
  height: 10px;
  transform: rotate(-45deg);
  z-index: -1; /* 放在容器后，被遮盖住*/
}
</code></pre><p>比较简单，就不赘述了。</p>
<h3 id="十一、有趣的-drop-shadow"><a href="#十一、有趣的-drop-shadow" class="headerlink" title="十一、有趣的 drop-shadow"></a>十一、有趣的 drop-shadow</h3><p>用法如下：</p>
<pre><code>filter: drop-shadow(x偏移, y偏移, 模糊大小, 色值);
filter:drop-shadow(5px 5px 10px black)
</code></pre><p>CSS3 滤镜 filter 中的 drop-shadow，drop-shadow 滤镜可以给元素或图片非透明区域添加投影。</p>
<p>上文中已经提到了一种使用场景，这里还想说另一种，即使用拼凑法作出的小气泡，如果气泡需要阴影的话，请用 <code>drop-shadow</code> 来替代 <code>box-shadow</code>。</p>
<p>更多细节请查看：<a href="https://link.funteas.com?target=http%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2016%2F05%2Fcss3-filter-drop-shadow-vs-box-shadow%2F" target="_blank" rel="noopener">drop-shadow 滤镜与 box-shadow 区别应用</a> </p>
<h3 id="十二、修改浏览器默认滚动条"><a href="#十二、修改浏览器默认滚动条" class="headerlink" title="十二、修改浏览器默认滚动条"></a>十二、修改浏览器默认滚动条</h3><p>有时候一些不期而遇的滚动条会让页面很尴尬，这时候你还可以强行美化一下，参考代码如下：</p>
<pre><code>/*滚动条 start*/
::-webkit-scrollbar {
  width: 1px;
  height: 4px;
  background-color: #F5F5F5;
}
/*定义滚动条轨道 内阴影+圆角*/
::-webkit-scrollbar-track {
  box-shadow: inset 0 0 6px rgba(0,0,0,0.3);
  background: #fff ;
}
/*定义滑块 内阴影+圆角*/
::-webkit-scrollbar-thumb {
  border-radius: 3px;
  box-shadow: inset 0 0 6px rgba(0,0,0,.3);
  // background-color:rgba(7, 170, 247, 0.7);
  background-color: transparent;
}
::-webkit-scrollbar-thumb:hover {
  border-radius: 3px;
  box-shadow: inset 0 0 6px rgba(0,0,0,.3);
  background-color:rgba(7, 170, 247, 1);
}
</code></pre><p>细节请参考：<a href="https://link.funteas.com?target=http%3A%2F%2Fblog.csdn.net%2Fning0_o%2Farticle%2Fdetails%2F52188953" target="_blank" rel="noopener">修改浏览器默认的滚动条样式</a> </p>
<h3 id="十三、safari-placeholder-bugs"><a href="#十三、safari-placeholder-bugs" class="headerlink" title="十三、safari placeholder bugs"></a>十三、safari placeholder bugs</h3><p>在项目中遇到 <code>input</code> 的 <code>placeholder</code> 在 <code>safari</code> 下设置行高失效的问题，解决思路如下：<br>1.使用 <code>padding</code> 使提示文字居中，如果 <code>font-size:14px</code>, <code>UI</code> 高度为 <code>40px</code>,我们可以设 <code>height：14px,padding:13px 0;</code><br>2.使用 <code>line-height:1px;</code><br>3.使用 <code>vertical-align: middle;</code></p>
<p>补充一条：Safari 来写 hack 即 [;line-height:1;]</p>
<p>详情请参考：<a href="https://link.funteas.com?target=http%3A%2F%2Fwww.cnblogs.com%2Fhumaotegong%2Fp%2F6629060.html%3Futm_source%3Ditdadao%26amp%3Butm_medium%3Dreferral" target="_blank" rel="noopener">input 的 placeholder 在 safari 下设置行高失效</a> </p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这些都是在我日常开发中碰到的奇葩问题，回头想想其实挺有意思，遂整理总结之。如果日常开发中没有一些挑战，那开发还有什么乐趣。</p>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[20 个 CSS 高级技巧汇总]]></title>
      <url>/20-%E4%B8%AA-CSS-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用技巧会让人变的越来越懒，没错，我就是想让你变懒。下面是我收集的CSS高级技巧，希望你懒出境界。</p>
<h2 id="20-个-CSS-高级技巧汇总"><a href="#20-个-CSS-高级技巧汇总" class="headerlink" title="20 个 CSS 高级技巧汇总"></a>20 个 CSS 高级技巧汇总</h2><h3 id="1-黑白图像"><a href="#1-黑白图像" class="headerlink" title="1. 黑白图像"></a>1. 黑白图像</h3><p>这段代码会让你的彩色照片显示为黑白照片，是不是很酷？</p>
<pre><code>img.desaturate {
    filter: grayscale(100%);
    -webkit-filter: grayscale(100%);
    -moz-filter: grayscale(100%);
    -ms-filter: grayscale(100%);
    -o-filter: grayscale(100%);
}
</code></pre><h3 id="2-使用-not-在菜单上应用-取消应用边框"><a href="#2-使用-not-在菜单上应用-取消应用边框" class="headerlink" title="2. 使用 :not() 在菜单上应用/取消应用边框"></a>2. 使用 <code>:not()</code> 在菜单上应用/取消应用边框</h3><p>先给每一个菜单项添加边框</p>
<pre><code>/* add border */
.nav li {
  border-right: 1px solid #666;
}
</code></pre><p>……然后再除去最后一个元素……</p>
<pre><code>// remove border /

.nav li:last-child {
  border-right: none;
}
</code></pre><p>……可以直接使用 :not() 伪类来应用元素：</p>
<pre><code>.nav li:not(:last-child) {
  border-right: 1px solid #666;
}
</code></pre><p>这样代码就干净，易读，易于理解了。</p>
<p>当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：</p>
<pre><code>..nav li:first-child ~ li {

  border-left: 1px solid #666;
}
</code></pre><h3 id="3-页面顶部阴影"><a href="#3-页面顶部阴影" class="headerlink" title="3. 页面顶部阴影"></a>3. 页面顶部阴影</h3><p>下面这个简单的 CSS3 代码片段可以给网页加上漂亮的顶部阴影效果：</p>
<pre><code>body:before {
          content: &quot;&quot;;
          position: fixed;
          top: -10px;
          left: 0;
          width: 100%;
          height: 10px;

          -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8);
          -moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8);
          box-shadow: 0px 0px 10px rgba(0,0,0,.8);

          z-index: 100;
}
</code></pre><h3 id="4-给-body-添加行高"><a href="#4-给-body-添加行高" class="headerlink" title="4. 给 body 添加行高"></a>4. 给 body 添加行高</h3><p>你不需要分别添加 line-height 到每个p,h标记等。只要添加到 body 即可：</p>
<pre><code>body {
  line-height: 1;
}
</code></pre><p>这样文本元素就可以很容易地从 body 继承。</p>
<h3 id="5-所有一切都垂直居中"><a href="#5-所有一切都垂直居中" class="headerlink" title="5. 所有一切都垂直居中"></a>5. 所有一切都垂直居中</h3><p>要将所有元素垂直居中，太简单了：</p>
<pre><code>html, body {
  height: 100%;
  margin: 0;
}

body {
  -webkit-align-items: center;  
  -ms-flex-align: center;  
  align-items: center;
  display: -webkit-flex;
  display: flex;
}
</code></pre><p>看，是不是很简单。</p>
<p>注意：在IE11中要小心flexbox。</p>
<h3 id="6-逗号分隔的列表"><a href="#6-逗号分隔的列表" class="headerlink" title="6. 逗号分隔的列表"></a>6. 逗号分隔的列表</h3><p>让HTML列表项看上去像一个真正的，用逗号分隔的列表：</p>
<pre><code>ul &gt; li:not(:last-child)::after {
  content: &quot;,&quot;;
}
</code></pre><p>对最后一个列表项使用 :not() 伪类。</p>
<h3 id="7-使用负的-nth-child-选择项目"><a href="#7-使用负的-nth-child-选择项目" class="headerlink" title="7. 使用负的 nth-child 选择项目"></a>7. 使用负的 nth-child 选择项目</h3><p>在CSS中使用负的 nth-child 选择项目1到项目n。</p>
<pre><code>li {
  display: none;
}

/* select items 1 through 3 and display them */
li:nth-child(-n+3) {
  display: block;
}
</code></pre><h3 id="8-对图标使用-SVG"><a href="#8-对图标使用-SVG" class="headerlink" title="8. 对图标使用 SVG"></a>8. 对图标使用 SVG</h3><p>我们没有理由不对图标使用SVG：</p>
<pre><code>.logo {
  background: url(&quot;logo.svg&quot;);
}
</code></pre><p>SVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。</p>
<h3 id="9-优化显示文本"><a href="#9-优化显示文本" class="headerlink" title="9. 优化显示文本"></a>9. 优化显示文本</h3><p>有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：</p>
<pre><code>html {
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
}
</code></pre><p>注：请负责任地使用 optimizeLegibility。此外，IE /Edge没有 text-rendering 支持。</p>
<h3 id="10-对纯-CSS-滑块使用-max-height"><a href="#10-对纯-CSS-滑块使用-max-height" class="headerlink" title="10. 对纯 CSS 滑块使用 max-height"></a>10. 对纯 CSS 滑块使用 max-height</h3><p>使用 max-height 和溢出隐藏来实现只有CSS的滑块：</p>
<pre><code>.slider ul {
  max-height: 0;
  overlow: hidden;
}

.slider:hover ul {
  max-height: 1000px;
  transition: .3s ease;
}
</code></pre><h3 id="11-继承-box-sizing"><a href="#11-继承-box-sizing" class="headerlink" title="11. 继承 box-sizing"></a>11. 继承 box-sizing</h3><p>让 box-sizing 继承 html：</p>
<pre><code>html {
  box-sizing: border-box;
}

*, *:before, *:after {
  box-sizing: inherit;
}
</code></pre><p>这样在插件或杠杆其他行为的其他组件中就能更容易地改变 box-sizing 了。</p>
<h3 id="12-表格单元格等宽"><a href="#12-表格单元格等宽" class="headerlink" title="12. 表格单元格等宽"></a>12. 表格单元格等宽</h3><p>表格工作起来很麻烦，所以务必尽量使用 table-layout: fixed 来保持单元格的等宽：</p>
<pre><code>.calendar {
  table-layout: fixed;
}
</code></pre><h3 id="13-用-Flexbox-摆脱外边距的各种-hack"><a href="#13-用-Flexbox-摆脱外边距的各种-hack" class="headerlink" title="13. 用 Flexbox 摆脱外边距的各种 hack"></a>13. 用 Flexbox 摆脱外边距的各种 hack</h3><p>当需要用到列分隔符时，通过flexbox的 space-between 属性，你就可以摆脱nth-，first-，和 last-child 的hack了：</p>
<pre><code>.list {
  display: flex;
  justify-content: space-between;
}

.list .person {
  flex-basis: 23%;
}
</code></pre><p>现在，列表分隔符就会在均匀间隔的位置出现。</p>
<h3 id="14-使用属性选择器用于空链接"><a href="#14-使用属性选择器用于空链接" class="headerlink" title="14. 使用属性选择器用于空链接"></a>14. 使用属性选择器用于空链接</h3><p>当a元素没有文本值，但 href 属性有链接的时候显示链接：</p>
<pre><code>a[href^=&quot;http&quot;]:empty::before {
  content: attr(href);
}
</code></pre><p>相当方便。</p>
<h3 id="15-检测鼠标双击"><a href="#15-检测鼠标双击" class="headerlink" title="15. 检测鼠标双击"></a>15. 检测鼠标双击</h3><p>HTML：</p>
<pre><code>&lt;div class=&quot;test3&quot;&gt;
  &lt;span&gt;&lt;input type=&quot;text&quot; value=&quot; &quot; readonly=&quot;true&quot; /&gt;
  &lt;a href=&quot;http://renpingjun.com&quot;&gt;Double click me&lt;/a&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre><p>CSS：</p>
<pre><code>.test3 span {
  position: relative;
}
.test3 span a {
  position: relative;
  z-index: 2;
}
.test3 span a:hover, .test3 span a:active {
  z-index: 4;
}
.test3 span input {
  background: transparent;
  border: 0;
  cursor: pointer;
  position: absolute;
  top: -1px;
  left: 0;
  width: 101%;  /* Hacky */
  height: 301%; /* Hacky */
  z-index: 3;
}
.test3 span input:focus {
  background: transparent;
  border: 0;
  z-index: 1;
}
</code></pre><h3 id="16-CSS-写出三角形"><a href="#16-CSS-写出三角形" class="headerlink" title="16. CSS 写出三角形"></a>16. CSS 写出三角形</h3><pre><code>/* create an arrow that points up */
div.arrow-up {
  width:0px;
  height:0px;
  border-left:5px solid transparent;  /* left arrow slant */
  border-right:5px solid transparent; /* right arrow slant */
  border-bottom:5px solid #2f2f2f; /* bottom, add background color here */
  font-size:0px;
  line-height:0px;
}

/* create an arrow that points down */
div.arrow-down {
  width:0px;
  height:0px;
  border-left:5px solid transparent;
  border-right:5px solid transparent;
  border-top:5px solid #2f2f2f;
  font-size:0px;
  line-height:0px;
}

/* create an arrow that points left */
div.arrow-left {
  width:0px;
  height:0px;
  border-bottom:5px solid transparent;  /* left arrow slant */
  border-top:5px solid transparent; /* right arrow slant */
  border-right:5px solid #2f2f2f; /* bottom, add background color here */
  font-size:0px;
  line-height:0px;
}

/* create an arrow that points right */
div.arrow-right {
  width:0px;
  height:0px;
  border-bottom:5px solid transparent;  /* left arrow slant */
  border-top:5px solid transparent; /* right arrow slant */
  border-left:5px solid #2f2f2f; /* bottom, add background color here */
  font-size:0px;
  line-height:0px;
}
</code></pre><h3 id="17-CSS3-calc-的使用"><a href="#17-CSS3-calc-的使用" class="headerlink" title="17. CSS3 calc() 的使用"></a>17. CSS3 calc() 的使用</h3><p>calc() 用法类似于函数，能够给元素设置动态的值：</p>
<pre><code>/* basic calc */
.simpleBlock {
  width: calc(100% - 100px);
}

/* calc in calc */
.complexBlock {
  width: calc(100% - 50% / 3);
  padding: 5px calc(3% - 2px);
  margin-left: calc(10% + 10px);
}
</code></pre><h3 id="18-文本渐变"><a href="#18-文本渐变" class="headerlink" title="18. 文本渐变"></a>18. 文本渐变</h3><p>文本渐变效果很流行，使用 CSS3 能够很简单就实现：</p>
<pre><code>h2[data-text] {
  position: relative;
}
h2[data-text]::after {
  content: attr(data-text);
  z-index: 10;
  color: #e3e3e3;
  position: absolute;
  top: 0;
  left: 0;
  -webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,0)), color-stop(50%, rgba(0,0,0,1)), to(rgba(0,0,0,0)));}
</code></pre><h3 id="19-禁用鼠标事件"><a href="#19-禁用鼠标事件" class="headerlink" title="19. 禁用鼠标事件"></a>19. 禁用鼠标事件</h3><p>CSS3 新增的 pointer-events 让你能够禁用元素的鼠标事件，例如，一个连接如果设置了下面的样式就无法点击了。</p>
<pre><code>.disabled { pointer-events: none; }
</code></pre><h3 id="20-模糊文本"><a href="#20-模糊文本" class="headerlink" title="20. 模糊文本"></a>20. 模糊文本</h3><p>简单但很漂亮的文本模糊效果，简单又好看！</p>
<pre><code>.blur {
   color: transparent;
   text-shadow: 0 0 5px rgba(0,0,0,0.5);
}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这就是常用的css高级技巧。</p>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2018年，前端应该怎么学？]]></title>
      <url>/2018%E5%B9%B4%EF%BC%8C%E5%89%8D%E7%AB%AF%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%AD%A6%EF%BC%9F.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>面向2018年，我觉得前端有这么三个方向可以突破</p>
<ol>
<li><strong>前端逻辑层</strong>（包括三大框架，webpack，前端数据管理）</li>
<li><strong>前端交互层</strong>（包括css3，canvas，svg，vr等，以及对应性能优化）</li>
<li><strong>node服务器层</strong> （即服务器领域，以及前端开发工具的开发）</li>
</ol>
<p>当然还可以说，有electron这样开发桌面应用的，但是我觉得大部分人的规划还是在web领域范畴的。</p>
<h2 id="一、前端逻辑层"><a href="#一、前端逻辑层" class="headerlink" title="一、前端逻辑层"></a><strong>一、前端逻辑层</strong></h2><p>前端逻辑层解决的问题：前端的渲染问题。<br>其实就是，从后端拿到的各种数据（数据库的结构化数据，各种素材），如何组合成页面元素。</p>
<p>前端的渲染，其实就是   模板+数据 = 页面</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmn2gohvx2j30ea07jq2w.jpg" alt=""></p>
<p>① html 负责结构<br>② css 负责样式<br>③ js 负责逻辑<br>只有模板没有后端数据的页面我们可以理解为静态页面<br>而我们目前主流的三大框架，则提供 模板与数据之间的映射关系。<br>在逻辑层的研究，主要就是学习并熟练三大框架： Vue, React, Angular  </p>
<p>这一块是我们90%前端，日常工作的主要部分。也是很多公司面试会去重点考察的内容。<br>但是，目前的行情已经不是，你会个新框架就可以任性拿OFFER的时期了。<br>前端的井喷的情况下，仅仅会一些基础知识是不够的。你必须往下深挖。</p>
<p><strong>可以深挖的部分</strong><br>①<strong>框架部分</strong>： 举个例子，如 Vue+ Vuex+ Vue-router+axios的全家桶<br>react和angular的也类似，有这么一套全家桶。<br>要想在前端竞争中取得优势，需要在这些框架的原理上深挖。<br>研究：<br>a. 源码和实现原理 （理论）<br>b. 常见的应用场景和常见问题的实现 （经验）<br>c. 同类问题的横向对比（比如用了vuex 需要了解一下 redux是怎么实现的）</p>
<p>②<strong>构建部分</strong>：  webpack + npm/yarn +  脚手架（如vue-cli） +sass<br>构建部分，其实是一块很容易出区分度的领域。你研究透一点，你就越能驾驭住项目的变化。<br>研究：<br>a. webpack的配置和对应应用场景<br>b. npm的命令使用，以及一些高级的用法（架设私有npm或者自己写全局包等）<br>c. 脚手架快速搭建的过程，以及如何自定义更改<br>d. 如何配置eslint和单元测试等</p>
<p>③<strong>代码规范部分</strong>：   es6 + ts + css规范 等等等<br>代码规范不多说，前端的js和css都是设计得很粗糙的语言。如果你想hold住更大型的项目，那么规范是你不可忽视的地方。</p>
<p>逻辑层部分，是我们通常意义上理解的前端本职。</p>
<h2 id="二、前端交互层"><a href="#二、前端交互层" class="headerlink" title="二、前端交互层"></a>二、前端交互层</h2><p>所谓交互层，可以理解为我们常说的  特效。<br>当前的趋势下，移动端浏览器的性能逐步提升。未来一个大的趋势就是<br>前端开发的效果，正无限逼近原生效果</p>
<p>同时一些大厂也在纷纷提前布局了，之前惊艳四方的天猫造物节 H5<br><a href="http://www.jianshu.com/p/111ee1fde39f" target="_blank" rel="noopener">淘宝造物节-风靡朋友圈的h5怎么做的？</a> </p>
<p>如果我们要在这波浪潮上取得先机，那么就必须提前学习。<br>也许再过三年，前端的开发特效的能力，也会成为标配技能。</p>
<p>可以分三块来看<br><strong>1.呈现效果学习：</strong><br>很多同学不是不会特效，而是不知道要实现成什么样子。用前端的各种东西鼓捣了，终于出来了特效，但是效果却很难看。<br>不不不，做特效，应该先把特效样子调好了再去做。<br>建议学习Adobe Effects （AE），直观地看动效是什么样子，然后再翻译成前端的动效。</p>
<p><strong>2.相关数学/视觉原理：</strong><br>a.贝塞尔曲线原理<br>b.视差原理<br>c.阻尼公式</p>
<p><strong>3.相关技术手段实现</strong><br>前端目前实现动画特效的八种方式<br><a href="http://www.offcn.com/it/2017/0110/5881.html" target="_blank" rel="noopener">http://www.offcn.com/it/2017/…</a> </p>
<p><strong>①gif:</strong> 设计直接出GIF，前端直接用<br><strong>②逐帧动画</strong>： css3 step属性 或  js制作逐帧动画<br><strong>③css3</strong> ：  transition/ transform/animation<br><strong>④svg</strong> :  svg 很适合移动端<br><strong>⑤canvas</strong>:   canvas适合一些比较大面积的动效<br><strong>⑥flash</strong> 转 canvas :  这个我不了解<br><strong>⑦video</strong>:  用h5 video标签<br><strong>⑧js动画</strong>：  可以配合平台提供的api（重力感应等）开发更复杂的动效</p>
<h2 id="三、node-服务层"><a href="#三、node-服务层" class="headerlink" title="三、node 服务层"></a><strong>三、node 服务层</strong></h2><p>node在前端应该是无人不知了。在实际使用中node的使用场景应该有这几个：<br><strong>① 作为前端构建辅助工具</strong>： 如各种脚手架中，经常有node的参与<br><strong>② 作为服务端做渲染层</strong>： 实现接口合并和模板渲染<br><strong>③ 作为完整服务器</strong>：  一般是创业公司中，可以一人搭建起全部web功能。如微信公众号项目等</p>
<p>那么如果要学习的话，要从哪里入手呢？<br>学习一个新技术，我个人的方式都是<br><strong>先把原生的文档，快速过一遍，然后学框架。</strong></p>
<p>不看原生的，很容易学一套框架，就是一次学习量。<br>学习原生知识，可以让你学框架速度提升。</p>
<p>框架里面常用的：<br>①express   ②koa   ③基于以上两者衍生的框架   ④其余框架</p>
<p><strong>我建议新手学习express 框架。理由很简单，易学，使用多，教程多。</strong><br><strong>我个人想学习的node框架是天猫的egg.js 。</strong></p>
<p>推荐理由是<br>①大厂开发，面向工程<br>②经受住了双十一的考验，质量有保障<br>总结</p>
<p><strong>前端是端工程师，一切特性依赖于客户端。</strong><br>因此各位前端的同仁，除了上述的功能外，还是要多留意浏览器以及移动端环境的变迁。<br>一些类似与 HTTP2协议，PWA，openGL等技术，都随时有可能改变前端的工作方式。</p>
<p>我上面列了那么多，其实我很多都没有学过（手动狗头）。但是除了技术能力，也许以下几个综合能力，对于前端er也是要注意的<br><strong>①自我规划能力</strong>：对于技术领域的趋势的洞察，以及个人对应的学习计划<br><strong>②快速学习能力</strong>：搜索能力（利用网上的各种知识），知识迁移能力<br><strong>③沟通能力和知识输出能力</strong>：  面向产品，以及面向后端，面向社区同仁</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这就是2018年前端人才发展的规划，如有不足请指出。</p>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[H5的Notification特性 - Web的桌面通知功能]]></title>
      <url>/H5%E7%9A%84Notification%E7%89%B9%E6%80%A7-Web%E7%9A%84%E6%A1%8C%E9%9D%A2%E9%80%9A%E7%9F%A5%E5%8A%9F%E8%83%BD.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="H5的Notification特性-Web的桌面通知功能"><a href="#H5的Notification特性-Web的桌面通知功能" class="headerlink" title="H5的Notification特性 - Web的桌面通知功能"></a>H5的Notification特性 - Web的桌面通知功能</h3><blockquote>
<p>目前，<code>web</code>网页使用桌面通知功能的越来越多，包括微博，腾讯视频等大厂站，桌面通知功能是<code>H5</code>的一个<code>API</code> - <code>Notifications</code>。它允许网页或应用程序可以发出通知，通知将被显示在页面之外的系统层面上（通常使用操作系统的标准通知机制，但是在不同的平台和浏览器上的表现会有差异），这样即使应用程序空闲或在后台也可以向用户发送信息。</p>
</blockquote>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><code>Notifications</code>的诞生简化了网站或者应用与用户之间的沟通成本（时间成本和开发成本），增强用户黏性（减少了用户离开应用的可能）。传统的通知方式，大多是通过站内信（消息），邮件，短信等方式，它们通常需要刷新（跳转）页面、离开应用打开其他应用或终端来查看消息；而桌面通知功能大大的简化了这个过程，消息的传递基本不消耗时间（如果不设置<code>setTimeout</code>，用时基本不会超过<code>1s</code>），并且用户不需要离开应用，这都带来了极大的方便。可以预见，<code>Notifications</code>将会在很多网页或应用中被大量使用。当然<code>Notifications</code>也具有它的局限性：无法存档、即看即毁<br>那么，这个功能到底能用在哪些场景呢？只能说能应用的场景很多：</p>
<ul>
<li><p>社交类网站</p>
</li>
<li><p>资讯类网站</p>
</li>
<li><p>网页版邮件服务</p>
</li>
<li><p>即时通知类网站</p>
</li>
<li><p>…</p>
</li>
</ul>
<p>举个例子，当你打开微博页面，你可能会看到（使用新版浏览器）如下图的通知：<br><img src="https://img.funteas.com/f909b1aa4add36264f20d783d4b23859?imageView2/2/w/800" alt=""></p>
<p>这就是网站使用了桌面通知功能，当你选择允许，那么当网站有推送消息或者你登陆账号有新的消息将会在桌面的右下角出现一个小弹窗通知，如下：<br><img src="https://img.funteas.com/7f39205b4f6be3ef3f66565e8ebaf1c2?imageView2/2/w/800" alt=""></p>
<p>感觉有点酷酷的！！！</p>
<h2 id="用户权限-Notification-permission"><a href="#用户权限-Notification-permission" class="headerlink" title="用户权限 - Notification.permission"></a>用户权限 - Notification.permission</h2><p><code>Notification.permission</code>是一个静态方法，可以获取用户当前的通知权限状态，返回一个<code>String</code>，可以根据返回值判断用户是否授予了通知权限。返回值有三种情况：</p>
<ul>
<li><p>default</p>
</li>
<li><p>granted</p>
</li>
<li><p>表示之前已经询问过用户，并且用户已经授予了显示通知的权限。</p>
</li>
<li><p>denied</p>
</li>
</ul>
<p>当值为<code>default</code>或者<code>denied</code>时都不会显示通知消息，只有明确的被设置成<code>granted</code>才会显示通知消息</p>
<pre><code>const permission = Notification.permission;
if(permission === &#39;granted&#39;){
    console.log(&#39;已经授权通知，可以进行你的通知啦！&#39;);
}else{
    console.log(&#39;用户还未授权，请先授权！&#39;);
}
</code></pre><h2 id="请求权限-Notification-requestPermission-CALLBACK"><a href="#请求权限-Notification-requestPermission-CALLBACK" class="headerlink" title="请求权限 - Notification.requestPermission(CALLBACK)"></a>请求权限 - Notification.requestPermission(CALLBACK)</h2><p>应用发送通知之前必须要取得发送通知的权限，才能成功进行通知。<code>Notification.requestPermission(CALLBACK)</code>是请求获取权限的方法（有点类似<code>javascript</code>的<code>confirm</code>弹窗窗），允许传入一个回调，回调会返回用户选择的何种权限，返回两个值，<code>granted</code>代表允许，<code>denied</code>代表拒绝。并且<code>Notification.requestPermission()</code>支持<code>then</code>方式的链式调用，也就意味着可以异步调用它。</p>
<pre><code>Notification.requestPermission(function (permission) {
    console.log(&#39;用户是否允许通知： &#39;,permission === &#39;granted&#39; ? &#39;允许&#39; : &#39;拒绝&#39;);
});
//两种方式是等价的
Notification.requestPermission().then(function (permission) {
    console.log(&#39;用户是否允许通知： &#39;,permission === &#39;granted&#39; ? &#39;允许&#39; : &#39;拒绝&#39;);
});
</code></pre><h2 id="创建通知-new-Notification-TITLE-OPTIONS"><a href="#创建通知-new-Notification-TITLE-OPTIONS" class="headerlink" title="创建通知 - new Notification(TITLE, OPTIONS)"></a>创建通知 - new Notification(TITLE, OPTIONS)</h2><p><code>new Notification(TITLE, OPTIONS)</code>方法创建可以创建一个通知实例，允许参入参数两个参数<code>TITLE</code>和<code>OPTIONS</code>。注意默认情况下（实际可以通过<code>OPTIONS</code>中的<code>timestamp</code>参数控制）一旦通知实例被创建出来，它会立即被显示出来。</p>
<h3 id="TITLE参数"><a href="#TITLE参数" class="headerlink" title="TITLE参数"></a>TITLE参数</h3><p><code>TITLE</code>表示通知的标题。必须参数，允许数字、字符串和空</p>
<h3 id="OPTIONS参数"><a href="#OPTIONS参数" class="headerlink" title="OPTIONS参数"></a>OPTIONS参数</h3><p><code>OPTIONS</code>是非必须参数，必须为一个对象，它包含：<br>ps: 部分参数在某些浏览器可能会不生效，建议使用最新版的谷歌浏览器。以下某些内容从<a href="http://link.funteas.com/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2Fnotification" target="_blank" rel="noopener">Notification-MDN-EN</a> 结合谷歌翻译得来，很有可能翻译不准确，如有，请提出。</p>
<pre><code>{
    //通知显示正文。非必须，默认为空
    body: &#39;你的好友XX上线了！&#39;,
    //通知显示正文的图片地址。非必须，默认为空
    image: &#39;imgae url&#39;,
    //通知左侧图标。非必须，默认为空
    icon: &#39;imgae url&#39;,
    //通知的分类标记（ID）。非必须，默认为空
    tag: &#39;test&#39;,
    //通知相关联的数据，通常用于方法的回调，传参。非必须，默认为空
    data: &#39;可以是任意数据类型&#39;,
    //通知显示延迟的时间。非必须，默认通知实例创建完成就显示
    timestamp: &#39;&#39;,
    //通知主体内容的水平展示顺序，有点类似direction属性。非必须，默认值是auto, 可以是ltr或rtl
    dir: &#39;auto&#39;,
    //当没有足够的空间来显示通知本身时，用于表示通知的图像的URL。非必须，默认为空
    badge: &#39;xxx&#39;,
    //通知的语言。非必须默认为空
    lang: &#39;&#39;,
    //通知显示时，设备的振动模式。非必须，默认为空
    vibrate: [200, 100, 200],
    //新通知出现是否覆盖旧的通知，覆盖（true）则永远只显示一条通知，不覆盖（false）则会多条通知重叠。非必须，默认为true
    renotify: true,
    //通知是否静音。非必须，默认为false，表示无声
    silent: false,
    //通知声源文件地址。非必须，默认为空
    sound: &#39;mp3&#39;,
    //是否不在屏幕上显示通知信息。非必须，默认为false表示要显示
    noscreen: false,
    //指定通知是否应该粘滞性，即不容易被用户清理。非必须，默认false表示不具粘滞性
    sticky: false,
    //指定通知是否保持活性，知道用户点击或关闭。非必须，默认为false
    requireInteraction: false
}
</code></pre><h3 id="事件及事件钩子"><a href="#事件及事件钩子" class="headerlink" title="事件及事件钩子"></a>事件及事件钩子</h3><p>当通知被创建成功后：</p>
<ul>
<li><p>通知实例具有一个静态方法可以用来关闭通知</p>
</li>
<li><p>通知实例具有四个事件钩子，来跟踪通知当前的状态。这些事件可以通过事件处理跟踪<code>onshow</code>、<code>onclick</code>、<code>onclose</code>和<code>onerror</code>。因为<code>Notification</code>同样继承自<code>EventTarget</code>，因此可以对它调用<code>addEventListener()</code>方法。</p>
</li>
</ul>
<pre><code>const n = new Notification(&#39;XX网站消息通知&#39;, {
    body: &#39;你的朋友有新状态啦，快去围观吧！&#39;,
    tag: &#39;2ue&#39;,
    icon: &#39;https://2ue.github.io/images/common/avatar.png&#39;,
    data: {
        url: &#39;https://2ue.github.io&#39;
    },
    timestamp: 3000
});

n.onshow = function () {
    console.log(&#39;通知显示了！&#39;);
}
n.onclick = function (e) {
    //可以直接通过实例的方式获取data内自定义的数据
    //也可以通过访问回调参数e来获取data的数据
    window.open(n.data.url, &#39;_blank&#39;);
    n.close();
}
n.onclose = function () {
    console.log(&#39;你墙壁了我！！！&#39;);
}
n.onerror = function (err) {
    console.log(&#39;出错了，小伙子在检查一下吧&#39;);
    throw err;
}
</code></pre><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>写一个简单的例子，可以打开页面体验一下，建议用最新版谷歌浏览器打开~ <a href="http://link.funteas.com/?target=https%3A%2F%2Fcodepen.io%2F2ue%2Fpen%2FrYYzwB" target="_blank" rel="noopener">Notification.js</a> </p>
<pre><code>const NotificationInstance = Notification || window.Notification;
if (!!NotificationInstance) {
    const permissionNow = NotificationInstance.permission;
    if (permissionNow === &#39;granted&#39;) {//允许通知
        CreatNotification();
    } else if (permissionNow === &#39;denied&#39;) {
        console.log(&#39;用户拒绝了你!!!&#39;);
    } else {
        setPermission();
    }
    function setPermission() {
        //请求获取通知权限
        NotificationInstance.requestPermission(function (PERMISSION) {
            if (PERMISSION === &#39;granted&#39;) {
                CreatNotification();
            } else {
                console.log(&#39;用户无情残忍的拒绝了你!!!&#39;);
            }
        });
    }
    function CreatNotification() {
        const n = new NotificationInstance(&#39;XX网站消息通知&#39;, {
            body: &#39;你的朋友有新状态啦，快去围观吧！&#39;,
            tag: &#39;2ue&#39;,
            icon: &#39;https://2ue.github.io/images/common/avatar.png&#39;,
            data: {
                url: &#39;https://2ue.github.io&#39;
            }
        });
        n.onshow = function () {
            console.log(&#39;通知显示了！&#39;);
        }
        n.onclick = function (e) {
            //可以直接通过实例的方式获取data内自定义的数据
            //也可以通过访问回调参数e来获取data的数据
            window.open(n.data.url, &#39;_blank&#39;);
            n.close();
        }
        n.onclose = function () {
            console.log(&#39;你墙壁了我！！！&#39;);
        }
        n.onerror = function (err) {
            console.log(&#39;出错了，小伙子在检查一下吧&#39;);
            throw err;
        }
        setTimeout(() =&gt; {
            n.close();
        }, 2000);
    }
}
</code></pre><h2 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h2><p><code>Notifications</code>是<code>H5</code>的新特性，毫无疑问，它的兼容肯定是一篇哀嚎.<br><img src="https://img.funteas.com/340c2c889621a28bd304618c7a309c1a?imageView2/2/w/800" alt=""><img src="https://img.funteas.com/d8a80df35e73a7aaa99fcbf944fcbd40?imageView2/2/w/800" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> html </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> html </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jsonp的原理介绍及Promise封装]]></title>
      <url>/jsonp%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E5%8F%8APromise%E5%B0%81%E8%A3%85.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么叫jsonp"><a href="#什么叫jsonp" class="headerlink" title="什么叫jsonp?"></a>什么叫jsonp?</h3><p>jsonp是json with padding（填充式json或参数式json）的简写，是通过ajax请求跨域接口，获取数据的新实现方式</p>
<h2 id="jsonp的实现原理："><a href="#jsonp的实现原理：" class="headerlink" title="jsonp的实现原理："></a>jsonp的实现原理：</h2><p>动态创建script标签，因为script标签是没有同源策略限制，可以跨域的。 把script标签的src指向正式服务端地址，这个地址跟个参数callback=xxx, 服务端在返回数据时，在xxx里包裹一个方法（里面是返回的数据），相当于在前端执行xxx这个方法，但是浏览器并没有这个方法，所以在发送请求之前在window注册这个方法，<a href="http://link.funteas.com/?target=http%3A%2F%2Fxn--window-og8iw9wvwlnru0xhb8r207bolbe65a675cixmror.xxx" target="_blank" rel="noopener">这样的话相当于在前端执行window.xxx</a> ()这个方法去获取数据。 具体看接下来的实现！</p>
<p><a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fwebmodules%2Fjsonp" target="_blank" rel="noopener">https://github.com/webmodules…</a><br>这个是jsonp库的具体实现，建议下载来研究一下，最好自己动手写一遍。本文主要是Promise封装，所以就不具体介绍jsonp的具体实现</p>
<h2 id="步骤一："><a href="#步骤一：" class="headerlink" title="步骤一："></a>步骤一：</h2><p>首先安装这个库，因为我是在node npm环境下开发，所以</p>
<pre><code>$ npm install jsonp
</code></pre><p><strong>参数介绍</strong><br>jsonp(url, opts, fn)<br>url (String) 服务器端数据接口地址<br>opts (Object) 一般只需关注param即可</p>
<ul>
<li><p>param (String) 默认是callback,这是与后端约定的参数名称，也可以随便定义，只要前后端统一</p>
</li>
<li><p>timeout (Number) 请求超时时间，默认是6000ms</p>
</li>
<li><p>prefix (String) callback值的前缀，默认是__jp</p>
</li>
<li><p>name (String) 指定全局注册的回调方法名，一般不会用到，因为默认是prefix+自增数字</p>
</li>
</ul>
<p>fn 回调方法，用es6 Promise</p>
<h2 id="步骤二："><a href="#步骤二：" class="headerlink" title="步骤二："></a>步骤二：</h2><p><strong>下面是具体用法：</strong><br>建一个名叫jsonp.js的文件<br>先引入jsonp库文件</p>
<pre><code>import originJSONP from&#39;jsonp&#39;
</code></pre><p>对外暴露方法 url:请求服务器地址，data:参数</p>
<pre><code>export default function jsonp(url,data,option) {
    url += (url.indexOf(&#39;?&#39;)&lt;0?&#39;?&#39;:&#39;&amp;&#39;)+param(data)
    return new Promise(function(resolve,reject) {
        originJSONP(url,option, function(err,data) {
            if(!err){
                resolve(data)
            }else{
                reject(err)
            }
        })
    })
}
</code></pre><p>定义一个将Object的参数处理成为 url挂载参数的形式 的函数</p>
<pre><code>export function param(data) {
  let url = &#39;&#39;
  for (var k in data) {
    let value = data[k] !== undefined ? data[k] : &#39;&#39;
    url += &#39;&amp;&#39; + k + &#39;=&#39; + encodeURIComponent(value)
  }
  return url ? url.substring(1) : &#39;&#39;
}
</code></pre><p>到这里 这个Promise 就封装好了，接下来就具体调用来获取数据</p>
<h2 id="步骤三："><a href="#步骤三：" class="headerlink" title="步骤三："></a>步骤三：</h2><p>建一个js文件，名字自己定义<br>引入前面封装的jsonp.js</p>
<pre><code>import jsonp from&#39;../common/js/jsonp.js&#39;
</code></pre><p>定义参数</p>
<pre><code>const commonParams = {
    g_tk:1319877694,
    inCharset:&#39;utf-8&#39;,
    outCharset:&#39;utf-8&#39;,
    notice:0,
    format:&#39;jsonp&#39;
};
</code></pre><p>定义前后端统一参数</p>
<pre><code>const options = {
    param:&#39;jsonpCallback&#39;
};
</code></pre><p>定义获取数据函数 这里我是拿QQ音乐的数据<a href="http://link.funteas.com/?target=https%3A%2F%2Fm.y.qq.com%2F" target="_blank" rel="noopener">https://m.y.qq.com/</a> （感谢QQ音乐的接口支持）</p>
<pre><code>export function getDataFunc() { 
    const url = &#39;https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg&#39;
    const data = Object.assign({},commonParams,{
        platform:&#39;h5&#39;,
        uin:0,
        needNewCode:1,
    })
    return jsonp(url,data,options)
}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>到此，咱们就完成用jsonp库进行Promise封装，并获取数据的过程！ 感谢阅读！</p>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> es6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[undefined与null的区别]]></title>
      <url>/undefined%E4%B8%8Enull%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>undefined与null看起来用法都是一样的，但是还有一些本质的区别。</p>
<h2 id="undefined与null的区别"><a href="#undefined与null的区别" class="headerlink" title="undefined与null的区别"></a>undefined与null的区别</h2><ul>
<li><code>undefined</code>表示一个变量没有被声明，或者被声明了但没有被赋值</li>
<li><code>null</code>是一个表示“没有值”的值</li>
<li>Javascript将未赋值的变量默认值设为<code>undefined</code></li>
<li>Javascript从来不会将变量设为<code>null</code>。它是用来让程序员表明某个用<code>var</code>声明的变量时没有值的。</li>
<li><code>undefined</code>不是一个有效的JSON，而<code>null</code>是</li>
<li><code>undefined</code>的类型(typeof)是<code>undefined</code></li>
<li><code>null</code>的类型(typeof)是<code>object</code>. <a href="http://link.funteas.com/?target=http%3A%2F%2Fwww.2ality.com%2F2013%2F10%2Ftypeof-null.html" target="_blank" rel="noopener">为什么?</a> </li>
<li>它们都是基本类型</li>
<li>他们都是<a href="http://link.funteas.com/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2FFalsy" target="_blank" rel="noopener">falsy</a><br>(<code>Boolean(undefined) // false</code>, <code>Boolean(null) // false</code>)</li>
<li>你可以这样判断一个变量是否是<a href="http://link.funteas.com/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2Fundefined" target="_blank" rel="noopener">undefined</a> </li>
</ul>
<pre><code>typeof variable ===&quot;undefined&quot;
</code></pre><ul>
<li>你可以这样判断一个变量是否是<a href="http://link.funteas.com/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2Fnull" target="_blank" rel="noopener">null</a> </li>
</ul>
<pre><code>  variable ===null
</code></pre><ul>
<li><strong>双等号</strong>比较时它们相等，但<strong>三等号</strong>比较时不相等</li>
</ul>
<pre><code>null==undefined// truenull===undefined// false
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>undefined和null的区别在平常的面试和开发过程中算是比较常见的语法知识。希望大家能够记得这些知识。，</p>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[入门 node.js 你必须知道的那些事]]></title>
      <url>/%E5%85%A5%E9%97%A8-node-js-%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="最基本的一些操作和概念"><a href="#最基本的一些操作和概念" class="headerlink" title="最基本的一些操作和概念"></a>最基本的一些操作和概念</h2><h3 id="用-node-执行一段-js-代码"><a href="#用-node-执行一段-js-代码" class="headerlink" title="用 node 执行一段 js 代码"></a>用 node 执行一段 js 代码</h3><ol>
<li><p>在命令行中用 cd 切换到桌面</p>
</li>
<li><p>创建一个文件夹和并用 cd 命令切换到这个文件夹mkdir nodeTest &amp;&amp; cd nodeTest</p>
</li>
<li><p>创建一个 js 文件并写上简单的 js 代码 touch a.js</p>
</li>
</ol>
<pre><code>    var a = 10;
    console.log(a);
    console.log(a + 10);
</code></pre><ol>
<li>在命令行中输入 node a.js 命令行会输出 10 20</li>
</ol>
<h3 id="node-引用文件的方式"><a href="#node-引用文件的方式" class="headerlink" title="node 引用文件的方式"></a>node 引用文件的方式</h3><ol>
<li><p>Node.js 采用了 CommonJS 规范, 通过 require 来引入一个 js 文件</p>
</li>
<li><p>新建文件 b.js 并在文件中引入 a.js</p>
</li>
</ol>
<ul>
<li><p>touch b.js</p>
</li>
<li><p>require(‘./a.js’)</p>
</li>
</ul>
<ol>
<li>执行 b.js</li>
</ol>
<ul>
<li>node b.js 命令行会输出 10 20</li>
</ul>
<h3 id="node-中的模块概念"><a href="#node-中的模块概念" class="headerlink" title="node 中的模块概念"></a>node 中的模块概念</h3><ol>
<li><p>node 中一个模块就是一个 js 文件，多个模块组成一个特定功能的一堆文件叫包</p>
</li>
<li><p>一个 js 文件可以定义它自己暴露给外部的变量 (意思就是另一个文件通过 require 引用它后需要怎么使用它),node 中提供共了 exports 和 module.exports 两个变量来实现它</p>
</li>
</ol>
<p>a.js</p>
<pre><code>function func1() {
   console.log(&#39;aaa&#39;)
}
function func2() {
   console.log(&#39;bbb&#39;)
}
exports.a = func1
exports.b = func2
</code></pre><p>b.js</p>
<pre><code>var a = require(&#39;./a.js&#39;)
a.func1() //会打印出aaa
a.func2() //会打印出bbb
</code></pre><p>c.js</p>
<pre><code>//es6 模式匹配写法
var {fun1,fun2} = require(&#39;./a.js&#39;)//fun1和fun2必须跟a.js中的变量名相同，这里是固定的
fun1() //会打印出aaa
fun2() //会打印出bbb
</code></pre><p>a.js</p>
<pre><code>//类的写法
function Test() {
   this.func1 = function() {
       console.log(&#39;aaa&#39;)
   }
   this.func2 = function() {
       console.log(&#39;bbb&#39;)
   }
}
module.exports = Hello
</code></pre><p>b.js</p>
<pre><code>var Test = require(&#39;./a.js&#39;)
var test = new Test()
test.func1()
test.func2()
</code></pre><ol>
<li>exports 和 module.exports 的关系</li>
</ol>
<p>exports 是 module.exports 的一个引用，意思就是指向同一块内存地址，node 中真正生效的是 module.exports, 修改 exports 本质上也是修改 module.exports 的值，</p>
<p>比如 exports.a = 3，实际上 module.exports.a 也是等于 3 的</p>
<p>又比如 exports = {}，这样 exports 就和 module.exports 的指向的对象就不一样了，后面再怎么修改 exports 也不会影响到 module.exports 的值，也不会影响到文件输出的变量</p>
<p>再比如 module.exports={}，这样造成的效果和上面 exports={} 的效果是一样的</p>
<p>建议：如果你还傻傻分不清楚它们的区别，以后在不是必须用到 module.exports 的时候只用 exports, 如果导出一个类这样的必须用到 module.exports 就不要使用 exports 了, 不要混在一起用就不会出错了</p>
<ol>
<li>node 中的 npm</li>
</ol>
<p>node 中默认自带了 npm，npm 是一个包管理器，上面说到包就是一个个模块 (js 文件) 组成的一个具有特定功能的一堆 js 文件，通过 npm 我们可以引入这些包 (如果不理解，把包理解成一个个插件也没有错) 来轻松实现一些功能</p>
<p>安装一个模块你只需要 npm install xxx 就可以安装了，然后在你自己的 js 中用 var xxx = require(‘./xxx’) 就可以使用了</p>
<p>通过 npm install xxx 安装完 xxx 模块后，你会发现当前目录下多了一个 node<em>modules 文件夹，打开 node</em>modules 文件夹你会发现里面有一个 xxx 文件夹。你在执行 npm install xxx 的时候，实际上 npm 也只是帮你把 xxx 这个包下载下来了而已，仅此而已</p>
<p>当你通过 npm 安装了十来个或者更多的包的时候你可能自己早就不知道自己安装了哪些包了，因为很多包依赖了其它的包 (一个包用到另一个包提供的功能是非常正常的行为，就像我们在用别人包里的功能一样), 所以 npm 提供了 package.json 这个文件来管理包</p>
<p>package.json 是一个文件，里面可以定义很多键值对，其中有几个字段非常重要，dependencies 表示上线运行时依赖的包，devDependencies 表示开发时依赖的包，scripts 可以定义自己的脚本，main 表示所有的包你都会通过这个文件引入</p>
<p>当你在 dependencies 和 devDependencies 定义好依赖，然后在命令行中输入 npm install，npm 就会帮你自动安装好这些包；反过来你在命令行中输入 npm install xxx –save 后 npm 就会在 package.json 中的 dependencies 自动加上 xxx，如果执行的是 npm install xxx –save-dev 就会在 devDependencies 中自动加上 xxx。</p>
<p>而在 scripts 中定义的脚本就直接可以在命令行中运行了，如果还弄不懂，可以看一下我的另一篇文章，如何制作自己的 npm 包</p>
<h2 id="node-js-中自带的那些模块"><a href="#node-js-中自带的那些模块" class="headerlink" title="node.js 中自带的那些模块"></a>node.js 中自带的那些模块</h2><h3 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h3><p>使用别人的模块，其实就是使用别人写好的方法 (函数)，只需要搞清楚别人提供的方法是怎么用的就可以了，可以查 node.js 官网查 api 或者看看网上写的教程就好。</p>
<p>下面演示了一个最简单的 http 模块的使用方法，在当前目录下在命令行中输入 node test.js，http 会挂起一个监听，只需要在浏览器中输入 <a href="http://localhost:8000，test.js" target="_blank" rel="noopener">http://localhost:8000，test.js</a> 就会跟浏览器返回 <code>&lt;div&gt;hello world&lt;/div&gt;</code>显示在页面上：</p>
<pre><code>test.js
var http = require(&#39;http&#39;)
var callBack = function(req, res) {
    res.write(&#39;&lt;div&gt;hello world&lt;/div&gt;&#39;)
    res.end()
}
http.createServer(callBack).listen(8000)
</code></pre><h3 id="url-模块"><a href="#url-模块" class="headerlink" title="url 模块"></a>url 模块</h3><p>在 http 模块的例子中传入了一个回调函数，两个参数分别是 request 和 response，前者是浏览器传给我们的对象，后者是我们传给浏览器的对象。</p>
<p>其中 req 中包含了 url 这个属性，可以在回调函数中把它打印出来 <code>console.log(req.url)</code>, 加入你在浏览器中输入的是：<a href="http://localhost:8000/aaa/bbb?abc=3，那么打印出来的值是：/aaa/bbb?abc=3" target="_blank" rel="noopener">http://localhost:8000/aaa/bbb?abc=3，那么打印出来的值是：/aaa/bbb?abc=3</a></p>
<p>在这里我们需要使用到的是 / aaa/bbb 和 abc=3 分开来的结果，node 给我们提供了一个处理 url 的模块，就叫做 url 模块. 当然如果你自己想处理这个 url 也是完全可以的，用正则表达式就可以，但是已经有现成的为啥不用呢</p>
<p>下面简单演示一下用法，在浏览器输入：<a href="http://localhost:8000/aaa/bbb?abc=3" target="_blank" rel="noopener">http://localhost:8000/aaa/bbb?abc=3</a></p>
<pre><code>test.js
var http = require(&#39;http&#39;)
var url = require(&#39;url&#39;)
var callBack = function(req, res) {
    var urlString = url.parse(req.url)
    var path = urlString.pathname
    var query = urlString.query
    console.log(path,query)//打印出/aaa/bbb abc=3
   res.write(&#39;&lt;div&gt;hello world&lt;/div&gt;&#39;)
   res.end()
}
http.createServer(callBack).listen(8000)
</code></pre><h3 id="fs-模块"><a href="#fs-模块" class="headerlink" title="fs 模块"></a>fs 模块</h3><p>fs 是一个提供文件操作功能的模块，可以对文件进行读写存删等操作，下面演示向浏览器返回本 js 的内容：</p>
<pre><code>test.js
var http = require(&#39;http&#39;)
var fs = require(&#39;fs&#39;)
var callBack = function(req, res) {
    fs.readFile(&#39;./test.js&#39;, &#39;utf-8&#39;, function(err, data) {
        res.write(data)
        res.end()
    })
}
http.createServer(callBack).listen(8000)
</code></pre><h2 id="用-http-模块、url-模块、http-模块搭建一个静态服务器"><a href="#用-http-模块、url-模块、http-模块搭建一个静态服务器" class="headerlink" title="用 http 模块、url 模块、http 模块搭建一个静态服务器"></a>用 http 模块、url 模块、http 模块搭建一个静态服务器</h2><pre><code>var http = require(&#39;http&#39;)
var url = require(&#39;url&#39;)
var fs = require(&#39;fs&#39;)
var callBack = function(req, res) {
var pathname = url.parse(req.url).pathname
if (pathname == &#39;/&#39;) {
    pathname = &#39;/index.html&#39;
}
fs.readFile(&#39;.&#39; + pathname, &#39;utf-8&#39;, function(err, data) {
        if (err) {
            res.write(&#39;Error 404&#39;)
        } else {
            res.write(data)
        }
        res.end()
    }
)}
http.createServer(callBack).listen(8000)
</code></pre><h2 id="使用外部模块"><a href="#使用外部模块" class="headerlink" title="使用外部模块"></a>使用外部模块</h2><h3 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h3><p>外部模块都是第三方提供的模块，node.js 默认是不提供的，所以需要用 npm 安装，这里提供 package.json 文件，只需要执行 npm install 安装就行了，另外是管理 MongoDB 数据库的一个包，所以本地需要把 MongoDB 单独安装一下。</p>
<pre><code>package.json
{
  &quot;dependencies&quot;: {
    &quot;cheerio&quot;: &quot;^1.0.0-rc.2&quot;,
    &quot;eventproxy&quot;: &quot;^1.0.0&quot;,
    &quot;express&quot;: &quot;^4.16.2&quot;,
    &quot;koa&quot;: &quot;^2.4.1&quot;,&lt;!--koa是用来替代express的框架--&gt;
    &quot;superagent&quot;: &quot;^3.8.1&quot;
  }
}
</code></pre><h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><p>express 提供了基本的路由和静态文件访问的功能，当然还有其它的功能，这里主要演示它的基本使用 下面 1,2,3 都是设置 public 和 files 目录下为静态文件，可以直接通过文件路径访问，1、2 可以同时存在，即可以指定几个目录均为静态文件目录，在指定目录为静态文件后，访问静态文件需要省略这个目录，比如访问 public 目录下的 css/index.css：localhost:8000/css/index.css, 直接省略了 public， 可以通过 3 来指定替换目录名称的路径，通过 3 设置后，要访问 public 下的 css/index.css：localhost:8000/public/css/index.css</p>
<pre><code>var express = require(&#39;express&#39;)
var app = express()
1\. app.use(express.static(&#39;public&#39;))
2\. app.use(express.static(&#39;files&#39;))
3\. app.use(&#39;/static&#39;,express.static(public))
app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;Hello World&#39;);//一个回调方法对应一个路径
})
app.get(&#39;/user&#39;, function (req, res) {
  res.send(&#39;user&#39;);
})
app.listen(8000, function () {
  console.log(&#39;app is listening at port 3000&#39;);
})
</code></pre><h3 id="superagent、cheerio-模块"><a href="#superagent、cheerio-模块" class="headerlink" title="superagent、cheerio 模块"></a>superagent、cheerio 模块</h3><p>superagent 是一个可以发 http 请求的模块，回调函数中的 res 就是请求到的内容</p>
<p>cheerio 是在服务器端类式 jquery 的框架，看代码应该能看出来</p>
<p>下面演示的是抓取糯米网的餐品列表链接</p>
<pre><code>var superagent = require(&#39;superagent&#39;)
var cheerio = require(&#39;cheerio&#39;)
var spideUrl = &#39;https://t10.nuomi.com/pc/t10/index&#39;
superagent.get(spideUrl)
    .end(function(err, res) {
        if (err) {
            return console.error(err);
        }
        var foodUrls = [];
        var $ = cheerio.load(res.text)
        // 获取首页所有的链接
        $(&#39;.j-item a&#39;).each(function(idx, element) {
            var $element = $(element)
            foodUrls.push($element.attr(&#39;href&#39;))
        })
        console.log(topicUrls)
    })
</code></pre><h3 id="eventproxy"><a href="#eventproxy" class="headerlink" title="eventproxy"></a>eventproxy</h3><p>在爬取一堆类式的链接的时候，一个个链接写挺麻烦的，eventproxy 提供了监听，然后触发回调的方式来处理这类问题，下面是我拷贝的一段代码，应该挺容易看懂的</p>
<pre><code>//得到一个 eventproxy 的实例
var ep = new eventproxy() 
// 命令 ep 重复监听 urls.length 次（在这里也就是 10 次） 
ep.after(&#39;topic_html&#39;, urls.length, function (topics) {
  topics = topics.map(function(page) {
    var $ = cheerio.load(page)
    var userId = $(&#39;.runUserName a font&#39;).eq(0).text()
    return userId
  });
  console.log(topics);
})
urls.forEach(function(item) {
  superagent.get(item)
    .end(function (err, res) {
      ep.emit(&#39;topic_html&#39;, res.text)
    })
})
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>大部分学习前端其实是没必要深入学习 node.js 的，一方面没那个精力，然后也没那么必要，但是一些基本的东西还是有必要好好学学的</p>
<p>大多数前端同学之所以觉得应该学前端，其实是平时接触到的 npm、require 模块、es6 的语法等问题觉得比较棘手，以为是自己不懂 node.js，其实这些和 node.js 并无太大关系，这些已经影响到学习前端其它内容的地方还是需要好好学习的</p>
<p>学习 node.js 基本的东西还是有必要的，比如搭建个简单的服务器，做点基本的逻辑处理和数据处理，做个爬虫啥的。而这些都很简单，看两篇博客做几个练习就够了，再深入就根据实际情况学习就好了。</p>
]]></content>
      
        <categories>
            
            <category> nodejs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> nodejs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[10个React小模式]]></title>
      <url>/10%E4%B8%AAReact%E5%B0%8F%E6%A8%A1%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><del>在过去的几年，我经手过很多大大小小的React项目，在这个过程中，我不断的重复重复，逐渐的形成了一些模式，在这里分享给大家。</del></p>
<p>如果你是刚开始接触React，能看到这篇文章，只能说你很幸运 ：）。</p>
<p>如果你没有接触过React，你可以跳过（3，6，8，10）节。</p>
<h2 id="10个React小模式"><a href="#10个React小模式" class="headerlink" title="10个React小模式"></a>10个React小模式</h2><h3 id="1-数据向下和向上传递"><a href="#1-数据向下和向上传递" class="headerlink" title="1 数据向下和向上传递"></a>1 数据向下和向上传递</h3><p>对于刚接触React新手，我通常都会告诉他们数据的传递模式，也就是父组件向子组件传递数据（比如一个对象，一个字符串等等），也可以是一个方法，使得父组件可以得到子组件的数据。</p>
<p>就像把一包薯片和一个对讲机传递到被困井下的矿工手上。</p>
<p>下图是最简单的模式</p>
<p><img src="https://img.funteas.com/ba8c793625abf7e86b2c6b15afa4544b.png?imageView2/2/w/800" alt=""> （此图胜过千言万语）</p>
<p>父组件在左边，子组件在右边。连接两个组件的props允许信息在两个方向任意流动。</p>
<p>一个 props 是<code>items</code>，传递信息到子组件。 一个 props 是<code>deleteitem</code>，给子组件一个方法来告诉父组件（“ 删除这个item ”）。</p>
<h3 id="2-修复HTML的input标签"><a href="#2-修复HTML的input标签" class="headerlink" title="2 修复HTML的input标签"></a>2 修复HTML的input标签</h3><p>关于React组件化的一个重要方面就是，如果HTML中的标签不能按照你想要的方式工作，你可以按照你的方式定义它。</p>
<p>当我创建一个页面，页面有很多用户输入框，第一步先处理这些标签。</p>
<p><img src="https://img.funteas.com/04d8fda42368628d19df33668bb8f32b.png?imageView2/2/w/800" alt=""></p>
<p>还需要注意:</p>
<ul>
<li><p>输入框应该通过<code>onChange</code>方法返回输入值。</p>
</li>
<li><p>确保输入值的类型与<code>onChange</code>返回值的类型相同，如果<code>typeof props.value</code>的类型是<code>number</code>，那么就需要将<code>e.target.value</code>的类型转换成<code>number</code>。</p>
</li>
<li><p>一组单选按钮的功能和<code>&lt;Select&gt;</code>一样，只是UI不同。可以在你的应用中统一成一个组件（比如<code>&lt;PickOneFromMany /&gt;</code>），然后通过传递<code>ui=&quot;radio&quot;</code> 或者 <code>ui=&quot;dropDown&quot;</code>来区分。</p>
</li>
</ul>
<h3 id="3-为input绑定唯一的ID"><a href="#3-为input绑定唯一的ID" class="headerlink" title="3 为input绑定唯一的ID"></a>3 为input绑定唯一的ID</h3><p>我们会为input绑定唯一的ID，但是为每一个input定义一个唯一的ID很费事。</p>
<p>你可以为每一对input/label标签生成一个随机ID，但是客户端和服务器端渲染的HTML无法匹配。</p>
<p>所以，你可以写一个方法自增生成ID，如下：</p>
<pre><code>class  Input  extends  React.Component {

    constructor(props) {

        super(props);

        this.id  =  getNextId();

        this.onChange  =  this.onChange.bind(this);

    }

    onChange(e) {

        this.props.onChange(e.target.value);

    }

    render() {

        return (

            &lt;label htmlFor={this.id}&gt;

            {this.props.label}

            &lt;input

            id={this.id}

            value={this.props.value}

            onChange={this.onChange}

            /&gt;

            &lt;/label&gt;

        );

    }

}
</code></pre><p>如果每次调用<code>getNextId()</code>时，仅仅是一个数字自增，那么在服务器端渲染，这个数字将会无限大。所以在每次网络请求的时候需要重置这个数字。代码如下：</p>
<pre><code>let count = 1;

export const resetId = () =&gt; {

    count = 1;

 }

 export const getNextId = () =&gt; {

     return `element-id-${count++}`;

}
</code></pre><h3 id="4-用props控制CSS"><a href="#4-用props控制CSS" class="headerlink" title="4 用props控制CSS"></a>4 用props控制CSS</h3><p>如果你想把不同CSS应用在不同的实例中（比如：普通按钮和高亮按钮），你可以传props来控制CSS。</p>
<p>表面看起来超级简单，但我保证有很多坑等你跳的。</p>
<p>个人觉得有三种实现的方法：</p>
<h4 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h4><p>把许多CSS打包放到一起，然后使用属性<code>themes</code>来控制。比如：</p>
<p><code>&lt;Button theme=&quot;secondary&quot;&gt;Hello&lt;/Button&gt;</code></p>
<h4 id="设置boolean属性"><a href="#设置boolean属性" class="headerlink" title="设置boolean属性"></a>设置boolean属性</h4><p>比如一些特殊的按钮需要倒角，但与你定义的主题不一致。</p>
<p>要么你去找UI，让它设计时保持一致，要么你就设置一个值为boolean的属性来区分：</p>
<p><code>&lt;Button theme=&quot;secondary&quot; rounded&gt;Hello&lt;/Button&gt;</code></p>
<p>类似HTML的二进制属性，所以你不需要写成<code>rounded = [true]</code>。</p>
<h4 id="设置属性值"><a href="#设置属性值" class="headerlink" title="设置属性值"></a>设置属性值</h4><p>在某些情况下，您可能希望直接传递CSS属性的值（在组件中，将其设置为内联样式）：</p>
<p><code>&lt;Icon width=&quot;25&quot; height=&quot;25&quot; type=&quot;search&quot; /&gt;</code></p>
<h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>假设你正在创建一个链接组件，有三种主题，是否添加下划线是可选的。</p>
<p><img src="https://img.funteas.com/308756e69607e168e9595e50518b1f03.png?imageView2/2/w/800" alt=""></p>
<p>代码如下：</p>
<pre><code>const Link = (props) =&gt; {

    let className = `link link--${props.theme}-theme`;

    if (!props.underline) className += &#39; link--no-underline&#39;;

    return &lt;a  href={props.href}  className={className}&gt;{props.children}&lt;/a&gt;;

};

Link.propTypes = {

    theme: PropTypes.oneOf([

        &#39;default&#39;, // primary color, no underline

        &#39;blend&#39;, // inherit surrounding styles

        &#39;primary-button&#39;, // primary color, solid block

    ]),

    underline: PropTypes.bool,

    href: PropTypes.string.isRequired,

    children: PropTypes.oneOfType([

        PropTypes.element,

        PropTypes.array,

        PropTypes.string,

    ]).isRequired,

};

Link.defaultProps = {

    theme: &#39;default&#39;,

    underline: false,

};
</code></pre><p>CSS:</p>
<pre><code>.link--default-theme,

.link--blend-theme:hover {

    color: #D84315;

}

.link--blend-theme {

    color: inherit;

}

.link--default-theme:hover,

.link--blend-theme:hover {

    text-decoration: underline;

}

.link--primary-button-theme {

    display: inline-block;

    padding: 12px 25px;

    font-size: 18px;

    background: #D84315;

    color: white;

}

.link--no-underline {

    text-decoration: none;

}
</code></pre><h3 id="5-动态组件"><a href="#5-动态组件" class="headerlink" title="5 动态组件"></a>5 动态组件</h3><p>动态组件可以渲染任何一个组件。 它可以是一个动态的页面组件，来展示一堆页面中的某一个页面，比如:</p>
<pre><code>import  HomePage  from  &#39;./HomePage.jsx&#39;;

import  AboutPage  from  &#39;./AboutPage.jsx&#39;;

import  UserPage  from  &#39;./UserPage.jsx&#39;;

import  FourOhFourPage  from  &#39;./FourOhFourPage.jsx&#39;;

const PAGES = {

    home: HomePage,

    about: AboutPage,

    user: UserPage,

};

const Page = (props) =&gt; {

    const Handler = PAGES[props.page] || FourOhFourPage;

    return  &lt;Handler {...props} /&gt;

};

Page.propTypes  = {

    page:  PropTypes.oneOf(Object.keys(PAGES)).isRequired,

};
</code></pre><p>如果你把<code>home</code>，<code>about</code> 和 <code>user</code> 换成<code>/</code>，<code>/about</code> 和 <code>/user</code>，恭喜你，你已经把它变成了半个路由器了。</p>
<h3 id="6-优化组件"><a href="#6-优化组件" class="headerlink" title="6 优化组件"></a>6 优化组件</h3><p>当打开一个页面，input输入框自动获取光标，这会大大提升用户体验。</p>
<p>比如打开一个注册页面，光标自动获取到用户名输入栏。</p>
<p>有人在写这个组件的时候会想到，为input绑定一个id，然后通过<code>document.getElementById(&#39;user-name-input&#39;).focus()</code>来实现。</p>
<p>但我认为这并不是一个很好的方式，我有一个更好的实现方式:</p>
<pre><code>class Input extends Component {

    focus() {

        this.el.focus();

    }

    render() {

        return (

            &lt;input

                ref={el=&gt; { this.el = el; }}

            /&gt;

        );

    }

}
</code></pre><p>ok，一个拥有<code>focus()</code>方法的<code>Input</code>组件完成了。</p>
<p>在父亲组件中，我们可以调到子组件的<code>focus()</code> 方法：</p>
<pre><code>class SignInModal extends Component {

componentDidMount() {

    this.InputComponent.focus();

}

render() {

    return (

        &lt;div&gt;

            &lt;label&gt;User name: &lt;/label&gt;

            &lt;Input

                ref={comp =&gt; { this.InputComponent = comp; }}

            /&gt;

        &lt;/div&gt;

    )

}

}
</code></pre><p>注意，当您在一个组件上使用ref时，它是对组件(而不是底层元素)的引用，因此您可以访问它的方法。</p>
<h3 id="7-别过早组件化"><a href="#7-别过早组件化" class="headerlink" title="7 别过早组件化"></a>7 别过早组件化</h3><p>一个搜索组件，当你输入的时候，可以看到模糊查询到的列表，如下：</p>
<p><img src="https://img.funteas.com/21312590fab421f25931a31659129d79.png?imageView2/2/w/800" alt=""></p>
<p>(我在搜索喜欢讽刺政治的人，我和很多人一样，对别人的政治观点非常感兴趣。)</p>
<p>当设计这个组件的时候，你可能会想：是否需要新建一个搜索结果组件<code>searchResult</code>来展示搜索结果，这个组件可能只需要几行HTML和CSS代码……但我曾告诫自己，当自己犹豫是否要新建的时候，就别新建。</p>
<p>这种情况我不会新建一个独立的组件，而是添加一个<code>renderSearchResult</code>方法，返回相应的DOM。如下：</p>
<pre><code>const SearchSuggestions = (props) =&gt; {

    // renderSearchSuggestion() behaves as a pseduo SearchSuggestion component

    // keep it self contained and it should be easy to extract later if needed

    const renderSearchSuggestion = listItem =&gt; (

        &lt;li  key={listItem.id}&gt;{listItem.name} {listItem.id}&lt;/li&gt;

    );

    return (

        &lt;ul&gt;

            {props.listItems.map(renderSearchSuggestion)}

        &lt;/ul&gt;

    );

}
</code></pre><p>如果其他组件也有类似的需求，你应该复制粘贴代码到那个组件，而不是过早的组件化。</p>
<h3 id="8-用于文本格式化的组件"><a href="#8-用于文本格式化的组件" class="headerlink" title="8 用于文本格式化的组件"></a>8 用于文本格式化的组件</h3><p>这是一个<code>Price</code>组件，将数字处理成含或者不含小数点或者`&lt;div class=“markdown-html language-javascript” id=”article-text”符号的字符串。</p>
<pre><code>const Price = (props) =&gt; {

    const price = props.children.toLocaleString(&#39;en&#39;, {

        style: props.showSymbol ? &#39;currency&#39; : undefined,

        currency: props.showSymbol ? &#39;USD&#39; : undefined,

        maximumFractionDigits: props.showDecimals ? 2 : 0,

    });

    return &lt;span  className={props.className}&gt;{price}&lt;/span&gt;

};

Price.propTypes = {

    className: React.PropTypes.string,

    children: React.PropTypes.number,

    showDecimals: React.PropTypes.bool,

    showSymbol: React.PropTypes.bool,

};

Price.defaultProps = {

    children: 0,

    showDecimals: true,

    showSymbol: true,

};

const Page = () =&gt; {

    const lambPrice = 1234.567;

    const jetPrice = 999999.99;

    const bootPrice = 34.567;

    return (

        &lt;div&gt;

            &lt;p&gt;One lamb is &lt;Price  className=&quot;expensive&quot;&gt;{lambPrice}&lt;/Price&gt;&lt;/p&gt;

            &lt;p&gt;One jet is &lt;Price  showDecimals={false}&gt;{jetPrice}&lt;/Price&gt;&lt;/p&gt;

            &lt;p&gt;Those gumboots will set ya back &lt;Price  showDecimals={false}  showSymbol={false}&gt;{bootPrice}&lt;/Price&gt; bucks.&lt;/p&gt;

        &lt;/div&gt;

    );

};
</code></pre><p>正如你所看到的，我用使用了一个强大的字符串格式化库，<a href="http://link.funteas.com/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FNumber%2FtoLocaleString" target="_blank" rel="noopener">链接在这里</a> (target=undefined)。</p>
<p>用更少的代码实现（我不是很喜欢）:</p>
<pre><code>function numberToPrice(num, options = {}) {

    const showSymbol = options.showSymbol !== false;

    const showDecimals = options.showDecimals !== false;

    return num.toLocaleString(&#39;en&#39;, {

        style: showSymbol ? &#39;currency&#39; : undefined,

        currency: showSymbol ? &#39;USD&#39; : undefined,

        maximumFractionDigits: showDecimals ? 2 : 0,

    });

}

const Page = () =&gt; {

    const lambPrice = 1234.567;

    const jetPrice = 999999.99;

    const bootPrice = 34.567;

    return (

    &lt;div&gt;

        &lt;p&gt;One lamb is &lt;span  className=&quot;expensive&quot;&gt;{numberToPrice(lambPrice)}&lt;/span&gt;&lt;/p&gt;

        &lt;p&gt;One jet is {numberToPrice(jetPrice, { showDecimals: false })}&lt;/p&gt;

        &lt;p&gt;Those gumboots will set ya back {numberToPrice(bootPrice, { showDecimals: false, showSymbol: false })} bucks.&lt;/p&gt;

    &lt;/div&gt;

    );

};
</code></pre><p>注意：我并没有检查传入数字的的有效性，是因为…………lan。</p>
<h3 id="9-降低组件复杂度"><a href="#9-降低组件复杂度" class="headerlink" title="9 降低组件复杂度"></a>9 降低组件复杂度</h3><p>我可能写过上千次这种判断：</p>
<pre><code>if (props.user.signInStatus === SIGN_IN_STATUSES.SIGNED_IN)...
</code></pre><p>这是一个错误示范，我应该判断“用户是否登录”而不是判断“用户登录状态===登录”</p>
<p>我的组件已经够复杂了，不应该让它去考虑传入的价格是不是数字，亦或者boolean值是否是‘true’。</p>
<p>正如你所见，如果你的数据store和你的组件是相匹配的，那么你的组件将会简单得多。我以前就说过，“复杂”是bug的藏身之处。组件越简单，出bug的概率就越小。</p>
<p>但是“复杂”无法避免，如何处理呢？</p>
<p>我建议创建一个模块，来专门处理输入数据，比如重命名<code>props</code>，字符串转成数字，对象转成数组，数据字符串转成数据对象，等等。</p>
<p>全部在一个地方处理和测试。</p>
<p>如果你设置<code>react/redux</code>，你应该这样在<code>action</code>中写请求搜索结果：</p>
<pre><code>fetch(`/api/search?${queryParams}`) 

    .then(response =&gt; response.json()) 

    .then(normalizeSearchResultsApiData) // 处理所有数据 

    .then(normalData =&gt; { 

    // 得到处理后的数据

});
</code></pre><p>这样会大大降低组件的复杂度。</p>
<h3 id="10-不用相对路径来导入组件"><a href="#10-不用相对路径来导入组件" class="headerlink" title="10 不用相对路径来导入组件"></a>10 不用相对路径来导入组件</h3><p>别这样写:</p>
<pre><code>**import** Button **from** &#39;../../../../Button/Button.jsx&#39;;
**import** Icon **from** &#39;../../../../Icon/Icon.jsx&#39;;
**import** Footer **from** &#39;../../Footer/Footer.jsx&#39;;
</code></pre><p>要这样写:</p>
<pre><code>`import {Button, Icon, Footer} from &#39;Components&#39;;`
</code></pre><p>理论上你可以这样实现:</p>
<ul>
<li><p>创建一个<code>index.js</code>做索引，让你所有的组件可以被引用。</p>
</li>
<li><p>使用Webpack的 <code>resolve.alias</code> 来重定向组件的索引文件</p>
</li>
</ul>
<p>我按照以上理论实现的时候发现这样做并不好，有三个原因：</p>
<ol>
<li><p>Webpack 2删除了<code>alias</code>方法</p>
</li>
<li><p><code>eslint</code>会报错，因为组件并没有在<code>node_modules</code>中。</p>
</li>
<li><p>如果你用<code>WebStorm</code>，<code>cmd</code>/<code>ctrl</code> + 左键组件名的时候，会自动打开该组件文件。但是这个功能将会失效。</p>
</li>
</ol>
<p><img src="https://img.funteas.com/7bd63a32fee471e4389e79ddf5070659.png?imageView2/2/w/800" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>写了很多，希望对您有帮助！</p>
]]></content>
      
        <categories>
            
            <category> react </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[详解 CSS 居中布局技巧]]></title>
      <url>/%E8%AF%A6%E8%A7%A3-CSS-%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>居中布局是前端页面开发过程中一种很常见的布局方式。</p>
<h2 id="水平居中元素："><a href="#水平居中元素：" class="headerlink" title="水平居中元素："></a>水平居中元素：</h2><p>方式一：CSS3 transform</p>
<pre><code>.parent {
    position: relative;
}
.child {
    position: absolute;
    left: 50%:
    transform: translateX(-50%);
}
</code></pre><p>方式二：flex 布局</p>
<pre><code>.parent {
    display: flex;
    justify-content: center;
}
</code></pre><p>适用于子元素为浮动，绝对定位，内联元素，均可水平居中。</p>
<ul>
<li><strong>居中的元素为常规文档流中的内联元素(display: inline)</strong></li>
</ul>
<p>常见的内联元素有：span, a, img, input, label 等等</p>
<pre><code>.parent {
    text-align: center;
}
</code></pre><ul>
<li><strong>居中的元素为常规文档流中的块元素(display: block)</strong></li>
</ul>
<p>常见的块元素：div, h1~h6, table, p, ul, li 等等</p>
<p>方式一：设置 margin</p>
<pre><code>.parent {
    width: 100%;
}
.child {
    width: 600px;
    height: 50px;
    margin: 0 auto;
    background: #999;
}
</code></pre><p>方式二：修改为 inline-block 属性</p>
<pre><code>.parent {
    text-align: center;
}
.child {
    display: inline-block;
}
</code></pre><pre><code>.child {
    width: 100px;
    float: left;
    position: relative;
    left: 50%;
    margin-left: -50px;
}
</code></pre><p>方式一：</p>
<pre><code>.parent {
    position: relative;
}
.child {
    position: absolute;
    width: 100px;
    left: 50%;
    margin-left: -50px;
}
</code></pre><p>方式二：</p>
<pre><code>.parent {
    position: relative;
}
.child {
    position: absolute;
    width: 100px;
    left: 0;
    right: 0;
    margin: 0 auto;
}
</code></pre><h2 id="垂直居中元素："><a href="#垂直居中元素：" class="headerlink" title="垂直居中元素："></a>垂直居中元素：</h2><p>方式一：CSS3 transform</p>
<pre><code>.parent {
    position: relative;
}
.child {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
}
</code></pre><p>方式二：flex 布局</p>
<pre><code>.parent {
    display: flex;
    align-items: center;
}
</code></pre><p>适用于子元素为浮动，绝对定位，内联元素，均可垂直居中。</p>
<pre><code>.text {
    line-height: 200px;
    height: 200px;
}
</code></pre><p>方式一：</p>
<pre><code>.parent {
    position: relative;
}
.child{
    position: absolute;
    top: 50%;
    height: 100px;
    margin-top: -50px;
}
</code></pre><p>方式二：</p>
<pre><code>.parent {
    position: relative;
}
.child{
    position: absolute;
    top: 0;
    bottom: 0;
    height: 100px;
    margin: auto 0;
}
</code></pre><h2 id="垂直居中元素：-1"><a href="#垂直居中元素：-1" class="headerlink" title="垂直居中元素："></a>垂直居中元素：</h2><pre><code>div {
    width: 100px;
    height: 100px;
    margin: auto;
    position: fixed;
    //absolute is ok
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
}
</code></pre><p>优点：</p>
<ol>
<li><p>不仅可以实现在正中间，还可以在正左方，正右方</p>
</li>
<li><p>元素的宽高支持百分比 % 属性值和 min-/max- 属性</p>
</li>
<li><p>可以封装为一个公共类，可做弹出层</p>
</li>
<li><p>浏览器支持性好</p>
</li>
</ol>
<pre><code>.child {
    width: 100px;
    height: 100px;
    position: absolute;
    top: 50%;
    left: 50%;
    margin-left: -50px;
    margin-top: -50px;
}
</code></pre><p>特点：</p>
<ol>
<li><p>良好的跨浏览器特性,兼容 IE6 - IE7</p>
</li>
<li><p>灵活性差，不能自适应，宽高不支持百分比尺寸和 min-/max- 属性</p>
</li>
</ol>
<pre><code>.child {
    width: 100px;
    height: 100px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);  
}
</code></pre><p>特点：</p>
<ol>
<li><p>内容可自适应，可以封装为一个公共类，可做弹出层</p>
</li>
<li><p>可能干扰其他 transform 效果</p>
</li>
</ol>
<pre><code>.parent {
    display: flex;
    justify-content: center;
    align-items: center;
}
</code></pre><p>这是 CSS 布局未来的趋势。Flexbox 是 CSS3 新增属性，设计初衷是为了解决像垂直居中这样的常见布局问题。</p>
<pre><code>text {
    height: 100px;
    line-height: 100px;
    text-align: center;
}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这就是css居中布局的一些常用技巧。</p>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[详解 CSS 七种三栏布局技巧]]></title>
      <url>/%E8%AF%A6%E8%A7%A3-CSS-%E4%B8%83%E7%A7%8D%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>三栏布局，顾名思义就是两边固定，中间自适应。三栏布局在开发十分常见，那么什么是三栏布局？比如我打开某东的首页：</p>
<p><img src="https://img.funteas.com/bac807a8c0f10cd4a5eef440123dab99?imageView2/2/w/800" alt=""></p>
<p>映入眼帘的就是一个常见的三栏布局：即左边商品导航和右边导航固定宽度，中间的主要内容随浏览器宽度自适应。</p>
<p>下面围绕的这样的目的，即左右模块固定宽度，中间模块随浏览器变化自适应，想要完成的最终效果如下图所示：</p>
<p><img src="https://img.funteas.com/8c0caa243fe962aaf371e9ca018366eb?imageView2/2/w/800" alt=""></p>
<p>红色和蓝色宽度固定，绿色宽度自适应，下面七种方法实现的最终效果跟这个差不多，可能会稍有不同。</p>
<p><strong>下面七种技巧各有千秋，在开发中可以根据实际需求选择适合自己的方法进行编码。</strong></p>
<h2 id="1-流体布局"><a href="#1-流体布局" class="headerlink" title="1. 流体布局"></a>1. 流体布局</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;style&gt;
    .left {
        float: left;
        height: 200px;
        width: 100px;
        background-color: red;
    }
    .right {
        width: 200px;
        height: 200px;
        background-color: blue;
        float: right;
    }
    .main {
        margin-left: 120px;
        margin-right: 220px;
        height: 200px;
        background-color: green;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>左右模块各自向左右浮动，并设置中间模块的 margin 值使中间模块宽度自适应。</p>
<p>缺点就是主要内容无法最先加载，当页面内容较多时会影响用户体验。</p>
<h2 id="2-BFC-三栏布局"><a href="#2-BFC-三栏布局" class="headerlink" title="2. BFC 三栏布局"></a>2. BFC 三栏布局</h2><p>BFC 规则有这样的描述：BFC 区域，不会与浮动元素重叠。因此我们可以利用这一点来实现 3 列布局。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;style&gt;
    .left {
        float: left;
        height: 200px;
        width: 100px;
        margin-right: 20px;
        background-color: red;
    }
    .right {
        width: 200px;
        height: 200px;
        float: right;
        margin-left: 20px;
        background-color: blue;
    }    
    .main {
        height: 200px;
        overflow: hidden;
        background-color: green;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>缺点跟方法一类似，主要内容模块无法最先加载，当页面中内容较多时会影响用户体验。因此为了解决这个问题，有了下面要介绍的布局方案双飞翼布局。</p>
<h2 id="3-双飞翼布局"><a href="#3-双飞翼布局" class="headerlink" title="3. 双飞翼布局"></a>3. 双飞翼布局</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;style&gt;
        .content {
          float: left;
          width: 100%;
        }
        .main {
          height: 200px;
          margin-left: 110px;
          margin-right: 220px;
          background-color: green;
        }
        //用于清除浮动
        .main::after {
          display: block;
          content: &#39;&#39;;
          font-size: 0;
          height: 0;
          clear: both;
          zoom: 1;
        }
    .left {
        float: left;
        height: 200px;
        width: 100px;
        margin-left: -100%;
        background-color: red;
    }
    .right {
        width: 200px;
        height: 200px;
        float: right;
        margin-left: -200px;
        background-color: blue;
    }    
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;content&quot;&gt;
        &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>利用的是浮动元素 margin 负值的应用，感兴趣的同学可以上网搜搜原理。</p>
<p>主体内容可以优先加载，HTML 代码结构稍微复杂点。</p>
<h2 id="4-圣杯布局"><a href="#4-圣杯布局" class="headerlink" title="4. 圣杯布局"></a>4. 圣杯布局</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;style&gt;
    .container {
        margin-left: 120px;
        margin-right: 220px;
    }
    .main {
        float: left;
        width: 100%;
        height: 300px;
        background-color: red;
    }
    .left {
        float: left;
        width: 100px;
        height: 300px;
        margin-left: -100%;
        position: relative;
        left: -120px;
        background-color: blue;
    }
    .right {
        float: left;
        width: 200px;
        height: 300px;
        margin-left: -200px;
        position: relative;
        right: -220px;
        background-color: green;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>跟双飞翼布局很像，有一些细节上的区别，相对于双飞翼布局来说，HTML 结构相对简单，但是样式定义就稍微复杂，也是优先加载内容主体。</p>
<h2 id="5-Flex-布局"><a href="#5-Flex-布局" class="headerlink" title="5. Flex 布局"></a>5. Flex 布局</h2><p><strong>推荐</strong></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;style&gt;
    .container {
            display: flex;
    }
    .main {
            flex-grow: 1;
        height: 300px;
        background-color: red;
    }
    .left {
        order: -1;
        flex: 0 1 200px;
        margin-right: 20px;
        height: 300px;
        background-color: blue;
    }
    .right {
        flex: 0 1 100px;
            margin-left: 20px;
        height: 300px;
        background-color: green;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>简单实用，未来的趋势，需要考虑浏览器的兼容性。</p>
<h2 id="6-Table-布局"><a href="#6-Table-布局" class="headerlink" title="6. Table 布局"></a>6. Table 布局</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;style&gt;
        .container {
        display: table;
        width: 100%;
        }
        .left, .main, .right {
        display: table-cell;
        }
        .left {
        width: 200px;
        height: 300px;
        background-color: red;
        }
        .main {
        background-color: blue;
        }
        .right {
        width: 100px;
        height: 300px;
        background-color: green;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>缺点：无法设置栏间距</p>
<h2 id="7-绝对定位布局"><a href="#7-绝对定位布局" class="headerlink" title="7. 绝对定位布局"></a>7. 绝对定位布局</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;style&gt;
    .container {
        position: relative;
    }
    .main {
        height: 400px;
        margin: 0 120px;
        background-color: green;
    }
    .left {
        position: absolute;
        width: 100px;
        height: 300px;
        left: 0;
        top: 0;
        background-color: red;
    }
    .right {
        position: absolute;
        width: 100px;
        height: 300px;
        background-color: blue;
            right: 0;
        top: 0;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>简单实用，并且主要内容可以优先加载。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上就是css常见的七种布局方式。如有不足，欢迎指出。</p>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[React特性精华]]></title>
      <url>/React%E7%89%B9%E6%80%A7%E7%B2%BE%E5%8D%8E.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以下内容是我在学习和研究 React 时，对 React 的特性、重点和注意事项的提取、精练和总结，可以做为 React 特性的字典，方便大家查阅</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><pre><code>1\. JSX语法
2\. 注释
3\. React元素
4\. 组件
5\. 标签属性
6\. 元素的子代
7\. 状态state
8\. Props和State
9\. 事件处理
10\. key
11\. 表单
12\. props的类型检查
13\. props的默认值
14\. 元素的引用
15\. 不使用ES6
16\. React的特性
17\. 性能优化
</code></pre><h3 id="1-JSX语法"><a href="#1-JSX语法" class="headerlink" title="1. JSX语法"></a>1. JSX语法</h3><ul>
<li><p>JSX 语法的解析规则是：遇到 XML 标签 &lt;…&gt;，以 XML 规则解析；遇到代码块 {…}，就用 JavaScript 规则解析；</p>
</li>
<li><p>我认为，在JSX中，XML可以理解为是创建虚拟DOM对象的字面量写法；在编译之后呢，XML标签 会被转化为 React.createElement() 函数的调用；<br>下面两种代码的作用是完全相同的：</p>
</li>
</ul>
<pre><code>const element = (
    &lt;h1 className=&quot;greeting&quot;&gt;
    Hello, world!
    &lt;/&gt;
 );
</code></pre><p>等效于：</p>
<pre><code>const element = React.createElement(
    &#39;h1&#39;,
    {className: &#39;greeting&#39;},
    &#39;Hello, world!&#39;
 );
</code></pre><p>React.createElement() 这个方法首先会进行一些避免bug的检查，之后会返回一个类似下面例子的对象：</p>
<pre><code> // 注意: 以下示例是简化过的（不代表在 React 源码中是这样）
 const element = {
     type: &#39;h1&#39;,
     props: {
         className: &#39;greeting&#39;,
         children: &#39;Hello, world&#39;
     }
 };
</code></pre><p>这样的对象被称为 “React 元素”。它代表所有你在屏幕上看到的东西。React 通过读取这些对象来构建 DOM 并保持数据内容一致。</p>
<ul>
<li><p>JSX 允许直接在模板插入 JavaScript 变量；如果这个变量是一个数组，则会展开这个数组的所有成员；</p>
</li>
<li><p>如果 JSX 中的XML带有换行，则推荐，有XML的外面加上一个小括号，这样可以防止 分号自动插入 的bug；</p>
</li>
<li><p>在JSX中的XML，通过引号定义以字符串为值的标签属性：<code>const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;;</code>，通过大括号来定义以 JavaScript 表达式为值的标签属性：<code>const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;</code>；切注意：如果使用了大括号包裹的 JavaScript 表达式时就不要再到外面套引号了。JSX 会将引号当中的内容识别为字符串而不是表达式；</p>
</li>
<li><p>JSX不允许没有闭合的标签；</p>
</li>
<li><p>因为 JSX 的特性更接近 JavaScript 而不是 HTML , 所以 XML 使用 camelCase 小驼峰命名 来定义属性的名称，而不是使用 HTML 的属性名称;例如：class 用 className 代替，而 tabindex 用 tabIndex 代替；</p>
</li>
<li><p>React DOM 在渲染之前默认会 过滤 所有传入的值。它可以确保应用不会被注入攻击。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS(跨站脚本) 攻击；</p>
</li>
</ul>
<h3 id="2-注释"><a href="#2-注释" class="headerlink" title="2. 注释"></a>2. 注释</h3><p>由于JSX的本质是JavaScript，所以在JSX中的注释还是JavaScript的注释；为了JSX的XML中使用注释，所以需要用先用花括号<code>{}</code>产生JavaScript环境，然后在<code>{}</code>内使用JavaScript注释；<br>所以，关于的注释的规则总结如下：</p>
<ol>
<li>在标签内部的注释需要花括号<code>{}</code>括住；</li>
<li>在标签外的注释不使用花括号<code>{}</code>；</li>
</ol>
<h3 id="3-React元素"><a href="#3-React元素" class="headerlink" title="3. React元素"></a>3. React元素</h3><ul>
<li>元素是构成 React 应用的最小单位；元素用来描述你在屏幕上看到的内容，如下：<code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</code>；</li>
<li>React元素与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致；</li>
<li>React 元素都是不可变的。当元素被创建之后，是无法改变其内容或属性的。一个元素就好像是动画里的一帧，它代表应用界面在某一时间点的样子。更新界面的唯一办法是创建一个新的元素，然后将它传入 ReactDOM.render() 方法；在实际生产开发中, 大多数React应用只会调用一次 ReactDOM.render()；</li>
<li>在更新视图时，React DOM 首先会比较元素内容先后的不同，而在渲染过程中只会更新改变了的部分；</li>
<li>JSX 的标签名决定了 React 元素的类型；小写开头的 JSX 标签名表示一个原生HTM元素，即内置的组件，如 <code>&lt;div&gt;</code> 或 <code>&lt;span&gt;</code>，在编译时，会将字符串 ‘div’ 或 ‘span’ 传 递给 React.createElement 方法；大写开头的 JSX 标签名表示一个 React 组件，如 <code>&lt;Foo /&gt;</code>，在编译时，会被编译为同名变量并被引用，如 <code>React.createElement(Foo)</code>，所以如果使用了 大家开头的标签，如：<code>&lt;Foo /&gt;</code>，则必须在作用域中先声明与该标签名同名的变量，如 Foo 变量；</li>
<li>由于 JSX 编译后会调用 React.createElement 方法，所以在 JSX 代码中必须首先声明或导入 React 变量；</li>
<li>JSX 的标签名可以是打点的属性调用；如： <code>&lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;</code>；但不能是表达式，如：<code>&lt;MyComponents[&quot;DatePicker&quot;] color=&quot;blue&quot; /&gt;</code> 是错误的；</li>
</ul>
<h3 id="4-组件"><a href="#4-组件" class="headerlink" title="4. 组件"></a>4. 组件</h3><ul>
<li>从概念上看组件就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素；</li>
<li>当React遇到的元素是用户自定义的组件时，它会将标签的所有标签属性作为单个对象传递给该组件构造函数,这个对象称之为“props”；</li>
<li>在组件内部，不允许修改props；</li>
<li>可以通过props.children获取组件元素的开关标签之间的内容；</li>
<li>组件可以嵌套；</li>
<li>唯一一种在 React 之外获取 React 组件实例句柄的方式就是保存 React.render 的返回值。在其它组件内，可以使用 refs 得到相同的结果；</li>
</ul>
<h4 id="定义组件的方式："><a href="#定义组件的方式：" class="headerlink" title="定义组件的方式："></a>定义组件的方式：</h4><ol>
<li>用函数定义组件：<br>定义一个组件最简单的方式是使用JavaScript函数：</li>
</ol>
<pre><code>function Welcome(props) {
    return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
 }
</code></pre><p>该函数是一个有效的React组件，它接收一个单一的“props”对象并返回了一个React元素。我们之所以称这种类型的组件为函数定义组件，是因为从字面上来看，它就是一个JavaScript函数。</p>
<ol>
<li>通过 ES6 class 来定义组件：</li>
</ol>
<pre><code>class Welcome extends React.Component {
    render() {
        return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
     }
 }
</code></pre><h4 id="组件的渲染"><a href="#组件的渲染" class="headerlink" title="组件的渲染"></a>组件的渲染</h4><ul>
<li>组件通过触发组件实例的render方法渲染自己；</li>
<li>每个组件在渲染时也会触发子组件的render方法渲染子组件；</li>
<li>根组件需要通过ReactDom.render方法把自身添加到指定的Dom元素上，并渲染自己；</li>
<li>组件类的顶层标签只能有一个；</li>
<li>如果 render 返回 null，则不会渲染该组件，但并不会影响该组件生命周期方法的回调；</li>
</ul>
<h3 id="5-标签属性"><a href="#5-标签属性" class="headerlink" title="5. 标签属性"></a>5. 标签属性</h3><p>在 JSX 中有如下几种不同的方式来指定标签属性：</p>
<ul>
<li><p>使用 JavaScript 表达式<br>可以传递任何 {} 包裹的 JavaScript 表达式作为一个标签属性值，如： <code>&lt;MyComponent foo={1 + 2 + 3 + 4} /&gt;</code>，表达式的值最终会被赋给相应的标签属性。if 语句和 for 循环在 JavaScript 中不是表达式，因此它们不能直接用在标签属性中；</p>
</li>
<li><p>字符串常量<br>可以将字符串常量作为标签属性值传递。当你传递一个字符串常量时，它不会对其进行 HTML 转义，所以下面几个 JSX 表达式是等价的：</p>
</li>
</ul>
<pre><code>&lt;MyComponent message=&quot;&lt;3&quot; /&gt;
&lt;MyComponent message=&quot;&lt;3&quot; /&gt;
&lt;MyComponent message={&#39;&lt;3&#39;} /&gt;
</code></pre><ul>
<li>默认为 True<br>如果没有给标签属性传值，则它默认为 true。因此下面两个 JSX 是等价的：</li>
</ul>
<pre><code>&lt;MyTextBox autocomplete /&gt;
&lt;MyTextBox autocomplete={true} /&gt;
</code></pre><ul>
<li>扩展属性<br>在 JSX中，你可以使用 … 作为扩展操作符来传递整个属性对象。<br>下面两个组件是等效的：</li>
</ul>
<pre><code>function App1() {
  return &lt;Greeting firstName=&quot;Ben&quot; lastName=&quot;Hector&quot; /&gt;;
}

function App2() {
  const props = {firstName: &#39;Ben&#39;, lastName: &#39;Hector&#39;};
  return &lt;Greeting {...props} /&gt;;
}
</code></pre><h3 id="6-元素的子代"><a href="#6-元素的子代" class="headerlink" title="6. 元素的子代"></a>6. 元素的子代</h3><p>在 JSX 中，开始标签和结束标签之间的子代内容会作为props.children传递；开始标签和结束标签之间可以是任何类型的东西，只要该组件在 React 渲染前能将其转换成 React 能够理解的东西即可；</p>
<p>例如，可以传递如下类型的子代：</p>
<ul>
<li><p>字符串常量：如果在开始和结束标签之间放入一个字符串，则 props.children 就是那个字符串；因为 HTML 未被转义，所以可以像写 HTML 一样写 JSX；JSX 会移除行空行和开始和结尾处的空格。标签邻近的新行也会被移除，字符串常量内部的换行会被压缩成一个空格；</p>
</li>
<li><p>JSX：可以开始和结束标签之间嵌入更多的 JSX 元素；</p>
</li>
<li><p>JavsScript 表达式：可以将任何 {} 包裹的 JavaScript 表达式作为子代传递；</p>
</li>
<li><p>函数：可以将用 {} 包裹的函数作为子代传递；</p>
</li>
<li><p>布尔值、Null 和 Undefined 被忽略：<br>false、null、undefined 和 true 都是有效的子代，但它们不会直接被渲染；而当子代是React 提供的一些 “falsy” 值 （即：除了false 外，0，“”，null，undefined 和 NaN）时，则会被渲染；<br>下面的表达式是等价的：</p>
</li>
</ul>
<pre><code>&lt;div /&gt;

&lt;div&gt;&lt;/div&gt;

&lt;div&gt;{false}&lt;/div&gt;

&lt;div&gt;{null}&lt;/div&gt;

&lt;div&gt;{undefined}&lt;/div&gt;

&lt;div&gt;{true}&lt;/div&gt;
</code></pre><h3 id="7-状态state"><a href="#7-状态state" class="headerlink" title="7. 状态state"></a>7. 状态state</h3><ul>
<li><p>构造函数是唯一能够初始化 this.state 的地方；</p>
</li>
<li><p>直接更新状态不会重新渲染组件，如：<code>this.state.comment = &#39;Hello&#39;;</code>；应当使用 setState()设置状态，如：<code>this.setState({comment: &#39;Hello&#39;});</code>；</p>
</li>
<li><p>状态更新可能是异步的；React 可以将多个setState() 调用合并成一个调用来提高性能。因为 this.props 和 this.state 可能是异步更新的，所以不应该依靠它们的值来计算下一个状态，如：</p>
</li>
</ul>
<pre><code>//错误的示范
this.setState({
    counter: this.state.counter + this.props.increment,
 });
</code></pre><p>应该给 setState() 传一个函数而不是一个对象。 该函数将接收先前的状态作为第一个参数，如：</p>
<pre><code>//正确的示范
this.setState((prevState, props) =&gt; ({
    counter: prevState.counter + props.increment
 }));
</code></pre><p>上方代码使用了箭头函数，但它也适用于常规函数；</p>
<ul>
<li>当你调用 setState(参数对象) 时，参数对象中的属性会完全替换掉this.state中相应的属性；</li>
</ul>
<h3 id="8-Props和State"><a href="#8-Props和State" class="headerlink" title="8. Props和State"></a>8. Props和State</h3><ul>
<li>Props是组件实例的标签属性的集合；它可以接收组件外传进来的值，在组件内部是不可修改Props的属性的，在组件外部可以通过标签属性给它赋值，所以可以用来从组件外部给组件内部传值；</li>
<li>State是组件实例的内部数据的集合；在组件内部是可以更改State的属性的值，且每次更改后，都会触发render方法渲染组件；<br>组件的标签属性在使用前不用先定义；而组件的内部数据State的属性在使用前需要先通过getInitialState方法定义；</li>
</ul>
<h3 id="9-事件处理"><a href="#9-事件处理" class="headerlink" title="9. 事件处理"></a>9. 事件处理</h3><ul>
<li>React事件绑定属性的命名采用驼峰式写法，而不是小写。</li>
<li>如果采用 JSX 的语法，则需要传入一个函数作为事件处理函数，而不是一个字符串(DOM元素的写法)；处理函数接收一个事件对象，这个事件对象是 React 根据 W3C spec 来合成的事件对象，所以不需要担心跨浏览器的兼容性问题；</li>
<li>不能使用返回 false 的方式阻止默认行为，必须明确的使用 preventDefault 来阻止默认行为；</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code>function ActionLink() {

  function handleClick(e) {
    e.preventDefault();
    console.log(&#39;已被点击！&#39;);
  }

  return (
    &lt;a href=&quot;#&quot; onClick={handleClick}&gt;
      点击我
    &lt;/a&gt;
  );
}
</code></pre><h3 id="10-key"><a href="#10-key" class="headerlink" title="10. key"></a>10. key</h3><ul>
<li>key必须在其兄弟节点中是唯一的，而非全局唯一；</li>
<li>key会作为给React的提示，但不会传递给你的组件，即不会成为props中的属性；</li>
</ul>
<h3 id="11-表单"><a href="#11-表单" class="headerlink" title="11. 表单"></a>11. 表单</h3><ul>
<li>对于 textarea 元素，在HTML当中，是通过子节点（开关标签之间的内容）来定义它的文本内容的，而在React中，是通过 标签属性value来设置它的文本内容的；</li>
<li>对于 select 标签，在HTML中，是通过在设置它的选项option元素的标签属性selected来设置被选中的选项的；而在React中，是通过设置 select 元素的标签属性 value 来设置被选中的值的；</li>
<li>通过给表单元素设置标签属性 defaultValue 可以为其指定初始值；</li>
</ul>
<h3 id="12-props的类型检查"><a href="#12-props的类型检查" class="headerlink" title="12. props的类型检查"></a>12. props的类型检查</h3><p>要给组件的props限制类型，则需要设置组件类的propTypes属性；<br><strong>示例代码：</strong></p>
<pre><code>import PropTypes from &#39;prop-types&#39;;

class Greeting extends React.Component {
  render() {
    return (
      &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;
    );
  }
}

Greeting.propTypes = {
  name: PropTypes.string,
  children: PropTypes.element.isRequired
};
</code></pre><p>可以通过设置propTypes的children属性 <code>propTypes.children</code> 来限传入的子代内容；</p>
<h3 id="13-props的默认值"><a href="#13-props的默认值" class="headerlink" title="13. props的默认值"></a>13. props的默认值</h3><p>要给组件的props设置默认值，则需要设置组件类的defaultProps属性；<br>defaultProps 用来确保 <a href="http://link.funteas.com/?target=http%3A%2F%2Fthis.props.name" target="_blank" rel="noopener">this.props.name</a> (target=undefined) 在父组件没有特别指定的情况下，有一个初始值。类型检查发生在 defaultProps 赋值之后，所以类型检查也会应用在 defaultProps 上面；<br><strong>示例代码：</strong></p>
<pre><code>class Greeting extends React.Component {
  render() {
    return (
      &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;
    );
  }
}

// 为属性指定默认值:
Greeting.defaultProps = {
  name: &#39;Stranger&#39;
};

// 渲染 &quot;Hello, Stranger&quot;:
ReactDOM.render(
  &lt;Greeting /&gt;,
  document.getElementById(&#39;example&#39;)
);
</code></pre><h3 id="14-元素的引用"><a href="#14-元素的引用" class="headerlink" title="14. 元素的引用"></a>14. 元素的引用</h3><p>元素的标签属性 ref 接受一个回调函数，它在元素被加载或卸载时执行；该回调函数接收一个参数element，<br>在元素被加载时：<br>如果该元素是原生的HTML元素，则参数element是该元素的DOM节点实例；<br>如果该元素是React组件，则参数element是该元素的Reac实例；<br>在元素被卸载时：参数element是null；</p>
<p><strong>注意：</strong></p>
<ul>
<li>对函数式组件（用函数定义的组件）设置ref无效；</li>
<li>如果 ref 回调以内联函数的方式定义，在更新期间它会被调用两次，第一次参数是 null ，之后参数是元素的实例。这是因为在每次渲染中都会创建一个新的函数实例。因此，React 需要清理旧的 ref 并且设置新的；</li>
</ul>
<h3 id="15-不使用ES6"><a href="#15-不使用ES6" class="headerlink" title="15. 不使用ES6"></a>15. 不使用ES6</h3><p>以上是用ES6的语法创建的React组件的，当然也可以仅用ES5及以下的语法特性来创建，如下：</p>
<p>用 <code>create-react-class</code> 模块创建组件类，代替ES6的用class创建组件类：</p>
<pre><code>var createReactClass = require(&#39;create-react-class&#39;);
var Greeting = createReactClass({
  render: function() {
    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
  }
});
</code></pre><p>ES6 中 class 相关的接口与 createReactClass 方法十分相似，但有以下几个区别：</p>
<ol>
<li>声明默认属性：</li>
</ol>
<ul>
<li>如果使用 class 关键字创建组件，可以直接把自定义属性对象写到类的 defaultProps 属性中；</li>
<li>如果使用 createReactClass 方法创建组件，那就需要在配置对象中定义 getDefaultProps 方法，并且在这个方法中返回包含自定义属性的对象；</li>
</ul>
<ol>
<li>设置初始状态：</li>
</ol>
<ul>
<li>如果使用 class 关键字创建组件，你可以通过在 constructor 中给 this.state 赋值的方式来定义组件的初始状态；</li>
<li>如果使用 createReactClass 方法创建组件，你就需要多写一个 getInitialState 方法，并让这个方法返回你要定义的初始属性；</li>
</ul>
<ol>
<li>自动绑定：</li>
</ol>
<ul>
<li>对于使用 class 关键字创建的 React 组件，组件中的方法是不会自动绑定 this 的。类似地，通过 ES6 class 生成的实例，实例上的方法也不会绑定 this。因此，你需要在 constructor 中为方法手动添加 .bind(this)；</li>
<li>如果使用 createReactClass 方法创建组件，组件中的方法会自动绑定至实例，不需要加 .bind(this)；</li>
</ul>
<h3 id="16-React的特性"><a href="#16-React的特性" class="headerlink" title="16. React的特性"></a>16. React的特性</h3><ol>
<li>JSX使用大、小写的约定来区分标签是定义的组件类还是原生的HTML标签；</li>
<li>由于JSX就是JavaScript，所以一些标识符（如：class和for）不能作为XML标签的属性名。在JSX中，使用className替代XML标签的class属性，htmlFor替代XML的for属性；</li>
<li>在JSX中的XML中的花括号<code>{}</code>表达式中不能使用<code>if else</code>语句，可以使用条件表达式(三元运算<code>条件?值1: 值2</code>)代替；</li>
<li>组件类的顶层标签只能有一个；</li>
<li>每次调用this.setState方法修改状态值，都会触发this.render方法渲染组件；</li>
</ol>
<h3 id="17-性能优化"><a href="#17-性能优化" class="headerlink" title="17. 性能优化"></a>17. 性能优化</h3><ul>
<li>虽然 props 由React本身设置以及 state 用于存储状态，但如果需要存储不用于视觉输出的东西，则建议通过手动向类或实例中添加相应属性来存储，而不应用 state 和 props 来存储；</li>
<li>如果在组件的钩子方法shouldComponentUpdate中返回false，则React不会对该组件及其子组件进行变化检查和渲染，所以，应在组件不需要更新的情况下，让钩子方法shouldComponentUpdate内返回false；</li>
<li>因为 <code>React.PureComponent</code> 类型的组件在做变化检查时是用浅比较来判断是否有变化的，所以性能较快，所以：对于没有必须进行深比较的组件，优先使用 <code>React.PureComponent</code> 而不是 <code>React.Componen</code>；</li>
<li>合理的使用key；</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上就是react的特性精华。如有不足，欢迎指出。</p>
]]></content>
      
        <categories>
            
            <category> react </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 前端技术 </tag>
            
            <tag> react </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[变量类型、原型、闭包、作用域面试题及知识点简单总结]]></title>
      <url>/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于变量类型、原型、闭包、作用域面试题及知识点简单总结的一篇文章，可以当作参考书来查资料。</p>
<h2 id="变量类型和计算知识点："><a href="#变量类型和计算知识点：" class="headerlink" title="变量类型和计算知识点："></a>变量类型和计算知识点：</h2><h3 id="值类型、引用类型"><a href="#值类型、引用类型" class="headerlink" title="值类型、引用类型"></a>值类型、引用类型</h3><pre><code>//值类型
var a=100
var b=a
a=200
console.log(b) //100
//引用类型
var a={age:20}
var b=a
b.age=21
console.log(a.age) //21
</code></pre><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><pre><code>// Numbers
typeof 37 === &#39;number&#39;;
typeof 3.14 === &#39;number&#39;;
typeof Math.LN2 === &#39;number&#39;;
typeof Infinity === &#39;number&#39;;
typeof NaN === &#39;number&#39;; // 尽管NaN是&quot;Not-A-Number&quot;的缩写
typeof Number(1) === &#39;number&#39;; // 但不要使用这种形式!
// Strings
typeof &quot;&quot; === &#39;string&#39;;
typeof &quot;bla&quot; === &#39;string&#39;;
typeof (typeof 1) === &#39;string&#39;; // typeof总是返回一个字符串
typeof String(&quot;abc&quot;) === &#39;string&#39;; // 但不要使用这种形式!
// Booleans
typeof true === &#39;boolean&#39;;
typeof false === &#39;boolean&#39;;
typeof Boolean(true) === &#39;boolean&#39;; // 但不要使用这种形式!
// Symbols
typeof Symbol() === &#39;symbol&#39;;
typeof Symbol(&#39;foo&#39;) === &#39;symbol&#39;;
typeof Symbol.iterator === &#39;symbol&#39;;
// Undefined
typeof undefined === &#39;undefined&#39;;
typeof declaredButUndefinedVariable === &#39;undefined&#39;;
typeof undeclaredVariable === &#39;undefined&#39;; 
// Objects
typeof {a:1} === &#39;object&#39;;
// 使用Array.isArray 或者 Object.prototype.toString.call
// 区分数组,普通对象
typeof [1, 2, 4] === &#39;object&#39;;
typeof new Date() === &#39;object&#39;;
// 下面的容易令人迷惑，不要使用！
typeof new Boolean(true) === &#39;object&#39;;
typeof new Number(1) ==== &#39;object&#39;;
typeof new String(&quot;abc&quot;) === &#39;object&#39;;
// 函数
typeof function(){} === &#39;function&#39;;
typeof Math.sin === &#39;function&#39;;
//NaN
typeof 1/0 === &#39;NaN&#39;;
//null
typeof null === &#39;object&#39;;
</code></pre><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><pre><code>//逻辑运算符
console.log(10 &amp; 0) //0  转换为true&amp;&amp;0
console.log(&#39;&#39;||&#39;abc&#39;) //abc  转换为false||&#39;abc&#39;
console.log(!window.abc) //true  !undefined为true
//if语句 false情况
null &#39;&#39; false 0 NaN undefined
//判断一个变量是否当作true或者false
var a = 100
console.log(!!a)
</code></pre><h3 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h3><p>1.JS中使用typeof能得到哪些类型<br>undefined null string number object function boolean symbol<br>2.何时使用’===’，何时使用’==‘<br>参考jQuery源码 只有这种情况下使用’==’:</p>
<pre><code>if(obj.a == null) {
}
//这句相当于obj.a === null || obj.a === undefined
</code></pre><p>3.JS有哪些内置函数<br>Object Array String Number Function Boolean Date RegExp Error<br>4.JS变量按照存储方式分为哪些类型，并描述其特点<br>值类型、引用类型。<br>值类型是将变量的值存在内存中。<br>引用类型的变量是真实变量的指针（对象、数组、函数）。可以无限扩张属性。<br>5.如何理解JSON<br>是JavaScript的对象，内置两个方法 JSON.stringify JSON.parse</p>
<h2 id="原型知识点："><a href="#原型知识点：" class="headerlink" title="原型知识点："></a>原型知识点：</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code>function Foo(name, age) {
  this.name = name
  this.age = age 
  this.class = &#39;class-1&#39;
  //return this  默认有这行
}

var f = new Foo(&#39;zs&#39;, 20)

//执行过程：1.new函数执行时this会变成空对象 2.this. 的时候赋值 3.return this 4.给f赋值

//var a = {}         ===&gt; var a = new Object()
//var a =[]          ===&gt; var a = new Array()
//function Foo(){}   ===&gt; var Foo = new Function()
//instanceof 用于判断一个函数是否是一个变量的构造函数
</code></pre><h3 id="原型规则"><a href="#原型规则" class="headerlink" title="原型规则"></a>原型规则</h3><pre><code>//所有的引用类型（数组、对象、函数）都具有对象特性，除了null之外，都可以自由扩展属性
//所有的引用类型 都有__proto__ 隐式原型
//所有的函数都有 prototype 显式原型   属性值也是一个普通对象
//所有的引用类型（数组、对象、函数），__proto__属性值指向它的构造函数的prototype属性值
var obj = {}; obj.a = 100
var arr = []; arr.a = 100
function fn () {}
fn.a = 100

console.log(obj.__proto__)
console.log(arr.__proto__)
console.log(fn.__proto__)

console.log(fn.prototype)

console.log(obj.__proto__ === Object.prototype)

//试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__(构造函数的prototype)中寻找
function Foo(name, age) {
  this.name = name
}

Foo.prototype.alertName = function () {
  alert(this.name)
}

var f = new Foo(&#39;zs&#39;)
f.printName = function () {
  console.log(this.name)
}

f.printName()
f.alertName()
</code></pre><h3 id="原型链-instanceof"><a href="#原型链-instanceof" class="headerlink" title="原型链 instanceof"></a>原型链 instanceof</h3><pre><code>//instanceof 是用于判断引用类型属于哪个构造函数的方法
//构造函数
function Foo(name, age) {
  this.name = name
}

Foo.prototype.alertName = function () {
  alert(this.name)
}

//创建实例
var f = new Foo(&#39;zs&#39;)
f.printName = function () {
  console.log(this.name)
}

f.printName()
f.alertName()
f.toString()

// f instanceof Foo 判断过程：
// f 的 __proto__一层层往上找到是否对应Foo.prototype
// 再判断f instanceof Object
</code></pre><p>直角矩形是构造函数 圆角矩形是对象<br><img src="https://img.funteas.com/2b915fcafa6ffbc2c00a38c792aeb082?imageView2/2/w/800" alt=""></p>
<h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h3><pre><code>var obj={
x:100,
y:200,
z:300
}
var key
for(key in obj){
//hasOwnProperty会返回一个布尔值，判断是否是原生的属性，以此来排除原型链上的属性
if(obj.hasOwnProperty(key)){
  console.log(key,obj[key]);
}
}
//x 100
//y 200
//z 300
</code></pre><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>6.如何准确判断一个变量是数组函数</p>
<pre><code>var arr =[]
arr instanceofArraytypeof arr //object, typeof 是无法判断是否是数组的
</code></pre><p>7.写一个原型链继承的例子</p>
<pre><code>function Elem(id) {
  this.elem = document.getElementById(id)
}

Elem.prototype.html = function (val) {
  var elem = this.elem
  if (val) {
    elem.innerHTML = val
    return this
  } else {
    return elem.innerHTML
  }
}

Elem.prototype.on = function (type, fn) {
  var elem = this.elem
  elem.addEventListener(type, fn)
  return this
}

var div1 = new Elem(&#39;wrapper&#39;)
div1.html(&#39;&lt;p&gt;hello&lt;/p&gt;&#39;).on(&#39;click&#39;, function () {
  alert(&#39;clicked&#39;)
}).html(&#39;&lt;p&gt;javascript&lt;/p&gt;&#39;)
</code></pre><p>8.描述new一个对象的过程</p>
<pre><code>//创建一个对象
//this指向这个对象
//执行代码  即对this赋值
//返回this
function Foo(name, age) {
  this.name = name 
  this.age = age
  this.class = &#39;class-1&#39;
  //return this   构造函数最好不要写return
}

var f = new Foo(&#39;zs&#39;, 20)
</code></pre><h2 id="作用域和闭包知识点："><a href="#作用域和闭包知识点：" class="headerlink" title="作用域和闭包知识点："></a>作用域和闭包知识点：</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><pre><code>//执行上下文：当前被执行代码的环境/作用域
console.log(a)
var a = 100

fn(&#39;zs&#39;)
//函数声明
function fn(name) {

  console.log(this)
  console.log(arguments)

  age = 20
  console.log(name, age)
  var age

  bar(100)

  function bar(num) {
    console.log(num)
  }
}
//函数表达式： var fn = function () {}

//在全局代码执行前，会将变量定义和函数声明先提出来
//在函数代码执行前，会将变量定义，函数声明，this，arguments(所有参数的集合)先提出来
</code></pre><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><pre><code>//this的值执行时才能确定
var a = {
  name: &#39;A&#39;,
  fn: function () {
    console.log(this.name)  //这个阶段的this无法确定值
  }
}

a.fn()                  //this === a
a.fn.call({name: &#39;B&#39;})  //this === {name: &#39;B&#39;}
var fn1 = a.fn
fn1()                   //this === window

//作为构造函数执行
function Foo(name) {
  // this = {}
  this.name = name
  // return this
}
var f = new Foo(&#39;zs&#39;)
//作为对象属性执行
var obj = {
  name: &#39;A&#39;,
  printName: function () {
    console.log(this.name)    //这里this就是obj
  }
}
obj.printName
//作为普通函数执行
function fn() {
  console.log(this)       //这里的this就是window
}
fn
//call apply bind
function fn1(name, age) {
  console.log(name)
  console.log(this)       //这里的this是{x:100}
}
fn1.call({x:100}, &#39;zs&#39;, 20)

var fn2h = function fn2(name, age) {
  console.log(name)
  console.log(this)       //这里的this是{y:200}
}.bind({y:200})
fn2(&#39;zs&#39;, 20)
</code></pre><h3 id="作用域-作用域链"><a href="#作用域-作用域链" class="headerlink" title="作用域 作用域链"></a>作用域 作用域链</h3><pre><code>//不断向父级作用域寻找变量的过程形成了作用域链
//没有块级作用域概念
if (true) {
  var name = &#39;zs&#39;
}
console.log(name)

//函数、全局作用域
var a = 10
function fn() {
  var a = 200
  console.log(&#39;fn&#39;, a)
}
console.log(&#39;global&#39;, a)
fn()

var b = 100
function fn() {
  var c = 200

  console.log(b)  //当前作用域没有定义的变量叫做自由变量
  console.log(c)  
}
fn()

var a = 100
function f1() {
  var b = 200
  function f2() {
    var c = 300

    console.log(a)
    console.log(b)
    console.log(c)
  }
  f2()
}
f1()
//哪个作用域定义了f1这个函数,f1的父级作用域就是谁
</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><pre><code>//闭包应用：1.函数作为返回值
function F1() {
  var a = 100

  //返回一个函数  
  return function () {
    console.log(a)     //100
  }
}

//f1得到一个函数
var f1 = F1()
var a = 200
f1()

//2.函数作为参数传递
function F1() {
  var a = 100
  return function() {
    console.log(a)  //100
  }
}

var f1 = F1()

function F2(fn) {
  var a = 200
  fn()
}
F2(f1)
</code></pre><h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><p>9.说一下对变量提升的理解<br>变量定义、函数声明会提前。<br>10.说明this几种不同的使用场景<br>作为构造函数、对象属性、普通函数执行，call apply bind<br>11.创建10个<code>&lt;a&gt;</code>标签，点击时弹出对应序号</p>
<pre><code>var i
  for (i = 0; i &lt; 10; i++) {
    (function (i) {
      var a = document.createElement(&#39;a&#39;)
      a.innerHTML = i + &#39;&lt;br&gt;&#39;
      a.addEventListener(&#39;click&#39;, function (e) {
        e.preventDefault()
        alert(i)
      })
      document.body.appendChild(a)
    })(i)
  }
</code></pre><p>12.如何理解作用域<br>自由变量、作用域链，即自由变量的寻找、闭包的两个场景。<br>13.实际开发中闭包的应用<br>封装变量，收敛权限 案例：</p>
<pre><code>function isFirstLoad() {
  var _list = []
  return function (id) {
    if (_list.indexOf(id) &gt;=0) {
      return false
    } else {
      _list.push(id)
      return true
    }
  }
}

var firstLoad = isFirstLoad()
console.log(firstLoad(10))
console.log(firstLoad(10))
console.log(firstLoad(20))
console.log(firstLoad(20))
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上就是JavaScript中一些常见的变量类型、原型、闭包、作用域面试题及知识点简单总结，会不定期更新，欢迎大家补充。</p>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 前端技术 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器的渲染：过程与原理]]></title>
      <url>/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%EF%BC%9A%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文不是关于浏览器渲染的底层原理或前端优化具体细节的讲解，而是关于浏览器对页面的渲染——这一过程的描述及其背后原理的解释。这是因为前端优化是一个非常庞大且零散的知识集合，一篇文章如果要写优化的具体方法恐怕只能做一些有限的列举。</p>
<p>然而，如果了解清楚浏览器的渲染过程、渲染原理，其实就掌握了指导原则。根据优化原则，可以实现出无数种具体的优化方案，各种预编译、预加载、资源合并、按需加载方案都是针对浏览器渲染习惯的优化。</p>
<h2 id="关键渲染路径"><a href="#关键渲染路径" class="headerlink" title="关键渲染路径"></a><strong>关键渲染路径</strong></h2><p>提到页面渲染，有几个相关度非常高的概念，最重要的是关键渲染路径，其他几个概念都可以从它展开，下面稍作说明。</p>
<p><strong>关键渲染路径（Critical Rendering Path）</strong>是指与当前用户操作有关的内容。例如用户刚刚打开一个页面，首屏的显示就是当前用户操作相关的内容，具体就是浏览器收到 HTML、CSS 和 JavaScript 等资源并对其进行处理从而渲染出 Web 页面。</p>
<p>了解浏览器渲染的过程与原理，很大程度上是为了<strong>优化关键渲染路径</strong>，但优化应该是针对具体问题的解决方案，所以优化没有一定之规。例如为了保障<strong>首屏内容</strong>的最快速显示，通常会提到<strong>渐进式页面渲染</strong>，但是为了渐进式页面渲染，就需要做资源的拆分，那么以什么粒度拆分、要不要拆分，不同页面、不同场景策略不同。具体方案的确定既要考虑体验问题，也要考虑工程问题。</p>
<h2 id="浏览器渲染页面的过程"><a href="#浏览器渲染页面的过程" class="headerlink" title="浏览器渲染页面的过程"></a><strong>浏览器渲染页面的过程</strong></h2><p>从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面<a href="http://link.funteas.com/?target=https%3A%2F%2Flink.juejin.im%3Ftarget%3Dhttp%253A%252F%252Flink.zhihu.com%252F%253Ftarget%253Dhttps%25253A%252F%252Fdevelopers.google.com%252Fspeed%252Fdocs%252Finsights%252Fmobile" target="_blank" rel="noopener">五件事情</a> 上：</p>
<ol>
<li>DNS 查询</li>
<li>TCP 连接</li>
<li>HTTP 请求即响应</li>
<li>服务器响应</li>
<li>客户端渲染</li>
</ol>
<p>本文讨论第五个部分，即浏览器对内容的渲染，这一部分（渲染树构建、布局及绘制），又可以分为下面<a href="http://link.funteas.com/?target=https%3A%2F%2Flink.juejin.im%3Ftarget%3Dhttp%253A%252F%252Flink.zhihu.com%252F%253Ftarget%253Dhttps%25253A%252F%252Fdevelopers.google.com%252Fweb%252Ffundamentals%252Fperformance%252Fcritical-rendering-path%252Frender-tree-construction" target="_blank" rel="noopener">五个步骤</a> ：</p>
<ol>
<li>处理 HTML 标记并构建 DOM 树。</li>
<li>处理 CSS 标记并构建 CSSOM 树。</li>
<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>
<li>根据渲染树来布局，以计算每个节点的几何信息。</li>
<li>将各个节点绘制到屏幕上。</li>
</ol>
<p>需要明白，这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM，下面就来看看它们的影响方式。</p>
<h2 id="阻塞渲染：CSS-与-JavaScript"><a href="#阻塞渲染：CSS-与-JavaScript" class="headerlink" title="阻塞渲染：CSS 与 JavaScript"></a><strong>阻塞渲染：CSS 与 JavaScript</strong></h2><p>谈论资源的阻塞时，我们要清楚，现代浏览器总是并行加载资源。例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。</p>
<p>同时，由于下面两点：</p>
<ol>
<li>默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。</li>
<li>JavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性。</li>
</ol>
<p>存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外：</p>
<ol>
<li>当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。</li>
<li>JavaScript 可以查询和修改 DOM 与 CSSOM。</li>
<li>CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。</li>
</ol>
<p>所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：</p>
<ol>
<li>CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。</li>
<li>JavaScript 应尽量少影响 DOM 的构建。</li>
</ol>
<p>浏览器的发展日益加快（目前的 Chrome 官方稳定版是 61），具体的渲染策略会不断进化，但了解这些原理后，就能想通它进化的逻辑。下面来看看 CSS 与 JavaScript 具体会怎样阻塞资源。</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a><strong>CSS</strong></h2><pre><code>&lt;style&gt; p { color: red;}&lt;/style&gt;&lt;linkrel=&quot;stylesheet&quot;href=&quot;index.css&quot;&gt;
</code></pre><p>这样的 link 标签（无论是否 inline）会被视为阻塞渲染的资源，浏览器会优先处理这些 CSS 资源，直至 CSSOM 构建完毕。</p>
<p>渲染树（Render-Tree）的关键渲染路径中，要求同时具有 DOM 和 CSSOM，之后才会构建渲染树。即，HTML 和 CSS 都是阻塞渲染的资源。HTML 显然是必需的，因为包括我们希望显示的文本在内的内容，都在 DOM 中存放，那么可以从 CSS 上想办法。</p>
<p>最容易想到的当然是<strong>精简 CSS 并尽快提供它</strong>。除此之外，还可以用媒体类型（media type）和媒体查询（media query）来解除对渲染的阻塞。</p>
<pre><code>&lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;
&lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 30em) and (orientation: landscape)&quot;&gt;
</code></pre><p>第一个资源会加载并阻塞。<br>第二个资源设置了媒体类型，会加载但不会阻塞，print 声明只在打印网页时使用。<br>第三个资源提供了媒体查询，会在符合条件时阻塞渲染。</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><strong>JavaScript</strong></h2><p>JavaScript 的情况比 CSS 要更复杂一些。观察下面的代码：</p>
<pre><code>&lt;p&gt;Do not go gentle into that good night,&lt;/p&gt;
&lt;script&gt;console.log(&quot;inline&quot;)&lt;/script&gt;
&lt;p&gt;Old age should burn and rave at close of day;&lt;/p&gt;
&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;
&lt;p&gt;Rage, rage against the dying of the light.&lt;/p&gt;

&lt;p&gt;Do not go gentle into that good night,&lt;/p&gt;
&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;
&lt;p&gt;Old age should burn and rave at close of day;&lt;/p&gt;
&lt;script&gt;console.log(&quot;inline&quot;)&lt;/script&gt;
&lt;p&gt;Rage, rage against the dying of the light.&lt;/p&gt;
</code></pre><p>这样的 script 标签会阻塞 HTML 解析，无论是不是 inline-script。上面的 P 标签会从上到下解析，这个过程会被两段 JavaScript 分别打算一次（加载、执行）。</p>
<p>所以实际工程中，我们常常将资源放到文档底部。</p>
<h2 id="改变阻塞模式：defer-与-async"><a href="#改变阻塞模式：defer-与-async" class="headerlink" title="改变阻塞模式：defer 与 async"></a><strong>改变阻塞模式：defer 与 async</strong></h2><p>为什么要将 script 加载的 defer 与 async 方式放到后面呢？因为这两种方式是的出现，全是由于前面讲的那些阻塞条件的存在。换句话说，defer 与 async 方式可以改变之前的那些阻塞情形。</p>
<p>首先，注意 async 与 defer 属性对于 inline-script 都是无效的，所以下面这个示例中三个 script 标签的代码会从上到下依次执行。</p>
<pre><code>&lt;!-- 按照从上到下的顺序输出 1 2 3 --&gt;
&lt;script async&gt;
  console.log(&quot;1&quot;);
&lt;/script&gt;
&lt;script defer&gt;
  console.log(&quot;2&quot;);
&lt;/script&gt;
&lt;script&gt;
  console.log(&quot;3&quot;);
&lt;/script&gt;
</code></pre><p>故，下面两节讨论的内容都是针对设置了 src 属性的 script 标签。</p>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a><strong>defer</strong></h2><pre><code>&lt;script src=&quot;app1.js&quot; defer&gt;&lt;/script&gt;
&lt;script src=&quot;app2.js&quot; defer&gt;&lt;/script&gt;
&lt;script src=&quot;app3.js&quot; defer&gt;&lt;/script&gt;
</code></pre><p>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</p>
<p>defer 不会改变 script 中代码的执行顺序，示例代码会按照 1、2、3 的顺序执行。所以，defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。</p>
<h2 id="async"><a href="#async" class="headerlink" title="async"></a><strong>async</strong></h2><pre><code>&lt;script src=&quot;app.js&quot; async&gt;&lt;/script&gt;
&lt;script src=&quot;ad.js&quot; async&gt;&lt;/script&gt;
&lt;script src=&quot;statistics.js&quot; async&gt;&lt;/script&gt;
</code></pre><p>async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</p>
<p>从上一段也能推出，多个 async-script 的执行顺序是不确定的。值得注意的是，向 document 动态添加 script 标签时，async 属性默认是 true，下一节会继续这个话题。</p>
<h2 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement"></a><strong>document.createElement</strong></h2><p>使用 document.createElement 创建的 script 默认是异步的，示例如下。</p>
<pre><code>console.log(document.createElement(&quot;script&quot;).async);// true
</code></pre><p>所以，通过动态添加 script 标签引入 JavaScript 文件默认是不会阻塞页面的。如果想同步执行，需要将 async 属性人为设置为 false。</p>
<p>如果使用 document.createElement 创建 link 标签会怎样呢？</p>
<pre><code>const style = document.createElement(&quot;link&quot;);
style.rel = &quot;stylesheet&quot;;
style.href = &quot;index.css&quot;;
document.head.appendChild(style); // 阻塞？
</code></pre><p>其实这只能通过试验确定，已知的是，Chrome 中已经<a href="http://link.funteas.com/?target=https%3A%2F%2Flink.juejin.im%3Ftarget%3Dhttp%253A%252F%252Flink.zhihu.com%252F%253Ftarget%253Dhttps%25253A%252F%252Fbugs.chromium.org%252Fp%252Fchromium%252Fissues%252Fdetail%25253Fid%25253D571725" target="_blank" rel="noopener">不会阻塞渲染</a> ，Firefox、IE 在以前是阻塞的，现在会怎样我没有试验。</p>
<h2 id="document-write-与-innerHTML"><a href="#document-write-与-innerHTML" class="headerlink" title="document.write 与 innerHTML"></a><strong>document.write 与 innerHTML</strong></h2><p>通过 document.write 添加的 link 或 script 标签都相当于添加在 document 中的标签，因为它操作的是 document stream（所以对于 loaded 状态的页面使用 document.write 会自动调用 document.open，这会覆盖原有文档内容）。即正常情况下， link 会阻塞渲染，script 会同步执行。不过这是不推荐的方式，Chrome 已经会显示警告，提示未来有可能禁止这样引入。如果给这种方式引入的 script 添加 async 属性，Chrome 会检查是否同源，对于非同源的 async-script 是不允许这么引入的。</p>
<p>如果使用 innerHTML 引入 script 标签，其中的 JavaScript 不会执行。当然，可以通过 eval() 来手工处理，不过不推荐。如果引入 link 标签，我试验过在 Chrome 中是可以起作用的。另外，outerHTML、insertAdjacentHTML() 应该也是相同的行为，我并没有试验。这三者应该用于文本的操作，即只使用它们添加 text 或普通 HTML Element。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p><a href="http://link.funteas.com/?target=https%3A%2F%2Flink.juejin.im%3Ftarget%3Dhttp%253A%252F%252Flink.zhihu.com%252F%253Ftarget%253Dhttps%25253A%252F%252Fdevelopers.google.com%252Fspeed%252Fdocs%252Finsights%252Fmobile" target="_blank" rel="noopener">Mobile Analysis in PageSpeed Insights</a> </p>
<p><a href="http://link.funteas.com/?target=https%3A%2F%2Flink.juejin.im%3Ftarget%3Dhttp%253A%252F%252Flink.zhihu.com%252F%253Ftarget%253Dhttps%25253A%252F%252Fdevelopers.google.com%252Fweb%252Ffundamentals%252F" target="_blank" rel="noopener">Web Fundamentals</a> </p>
<p><a href="http://link.funteas.com/?target=https%3A%2F%2Flink.juejin.im%3Ftarget%3Dhttp%253A%252F%252Flink.zhihu.com%252F%253Ftarget%253Dhttps%25253A%252F%252Fdeveloper.mozilla.org%252Fen-US%252Fdocs%252FWeb%252FHTML%252FElement%252Fscript" target="_blank" rel="noopener">MDN - HTML element reference</a> </p>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack构建react项目]]></title>
      <url>/webpack%E6%9E%84%E5%BB%BAreact%E9%A1%B9%E7%9B%AE.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在书写文章之前，我假设大家已经有了 <code>JavaScript</code>，<code>Node 包管理工具</code>，<code>Linux 终端操作</code> 这些基本技能，接下来，我将一步一步指引大家从头搭建一个 <code>React</code> 项目</p>
<h2 id="重新回顾-Webpack-Babel-和-React"><a href="#重新回顾-Webpack-Babel-和-React" class="headerlink" title="重新回顾 Webpack, Babel 和 React"></a>重新回顾 Webpack, Babel 和 React</h2><h2 id="最终实现的效果"><a href="#最终实现的效果" class="headerlink" title="最终实现的效果"></a>最终实现的效果</h2><p>我们将使用 <code>Webpack</code> 和 <code>Babel</code> 搭建一个 <code>React</code> 应用，我们的目的很清晰，就是 <code>更好的理解和掌握这些工具的使用</code></p>
<p>我们创建的应用程序既要做到 <code>最小</code>，也要遵循 <code>最佳实践</code>，为不是特别熟练的同学巩固一下基础</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>创建你的项目，并添加的你的配置文件 <code>package.json</code></p>
<pre><code>mkdir webpack-babel-react-revisited
cd webpack-babel-react-revisited

yarn init
</code></pre><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>我们首先安装 <code>Webpack</code>，它是目前非常流行的 <code>模块打包器</code>，它将应用程序包含的每个模块打包成少量的 <code>块</code>，以便这些代码从服务器加载到浏览器中</p>
<pre><code>yarn add webpack --dev
</code></pre><p>接下来，我们开始书写一些模块。我们将源文件 <code>app.js</code> 保存到 <code>src</code> 目录中</p>
<pre><code>/** app.js */

console.log(&#39;Hello from 枫上雾棋!&#39;);
</code></pre><p>然后，我们跑一下 <code>Webpack</code></p>
<pre><code>./node_modules/webpack/bin/webpack.js ./src/app.js --output-filename ./dist/app.bundle.js
</code></pre><p>如果你打开生成的 <code>app.bundle.js</code>，你会发现上面是 <code>webpack</code> 的模块处理代码，下面是我们书写的 <code>console.log</code></p>
<p>这条指令是将我们的 <code>app.js</code> 作为 <code>Webpack</code> 的 <code>入口文件</code>，将结果输出到 <code>dist</code> 文件夹中，指令有些冗长，在实际开发中，我们使用 <code>webpack</code> 配置文件来代替，为了文档结构看起来更加清晰，参考 <code>目录</code> 如下</p>
<pre><code>├── config
│├── paths.js
│├── webpack.config.prod.js
├── src
│├── app.js
├──package.json
</code></pre><p>下面是参考 <code>配置</code></p>
<p><code>paths.js</code></p>
<pre><code>const path = require(&#39;path&#39;);
const fs = require(&#39;fs&#39;);

const appDirectory = fs.realpathSync(process.cwd());
const resolveApp = relativePath =&gt; path.resolve(appDirectory, relativePath);

module.exports = {
  appDist: resolveApp(&#39;dist&#39;),
  appSrc: resolveApp(&#39;src&#39;),
};
</code></pre><p>这个文件不是必须的，但在项目增大后，它的意义就瞬间出来了</p>
<p><code>webpack.config.prod.js</code></p>
<pre><code>const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

const paths = require(&#39;./paths&#39;);

const plugins = [
  new HtmlWebpackPlugin({
    title: &#39;webpack babel react revisited&#39;,
    filename: path.join(paths.appDist, &#39;index.html&#39;),
  }),
];

const config = {
  entry: {
    app: path.join(paths.appSrc, &#39;app&#39;),
  },
  output: {
    path: paths.appDist,
    filename: &#39;assets/js/[name].js&#39;,
  },
  resolve: {
    extensions: [&#39;.js&#39;, &#39;.jsx&#39;],
  },
  plugins,
};

module.exports = config;
</code></pre><p>这里我们还添加了一个 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fjantimon%2Fhtml-webpack-plugin" target="_blank" rel="noopener">html-webpack-plugin</a> ，它简化了我们 <code>HTML</code> 文件的创建，安装我们就不再这里赘述了，如果还不知道的同学可以点击链接查看</p>
<p>其中，我们还使用了一个 <code>语法糖</code>，这样在我们导入 <code>.js</code>，<code>.jsx</code> 时就不需要指定扩展名了</p>
<p>接下来，我们指定配置文件再跑一下 <code>Webpack</code></p>
<pre><code>./node_modules/webpack/bin/webpack.js --config config/webpack.config.prod.js
</code></pre><p>发现除了实现上面的效果外，还自动帮我们生成了一个 <code>index.html</code>，我们可以点击这个 <code>html</code>，在控制台中查看效果，相比上面，是不是方便了很多</p>
<p>当然，最后我们肯定也不是使用这种方式来 <code>build</code>，打开 <code>package.json</code>，添加如下 <code>脚本命令</code>，然后执行 <code>yarn build</code>，是不是瞬间感觉 <code>nice</code> 了很多</p>
<pre><code>&quot;scripts&quot;: {
  &quot;clean&quot;: &quot;rimraf dist *.log .DS_Store&quot;,
  &quot;build&quot;: &quot;yarn run clean &amp;&amp; webpack --config config/webpack.config.prod.js --progress&quot;
}
</code></pre><pre><code>const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const OpenBrowserPlugin = require(&#39;open-browser-webpack-plugin&#39;);

const paths = require(&#39;./paths&#39;);

const hostname = process.env.HOST || &#39;localhost&#39;;
const port = process.env.PORT || 3000;

const plugins = [
  new HtmlWebpackPlugin({
    title: &#39;webpack babel react revisited&#39;,
    filename: path.join(paths.appDist, &#39;index.html&#39;),
  }),
  new OpenBrowserPlugin({ url: `http://${hostname}:${port}` }),
];

const config = {
  entry: {
    app: path.join(paths.appSrc, &#39;app&#39;),
  },
  output: {
    path: paths.appDist,
    filename: &#39;assets/js/[name].js&#39;,
  },
    resolve: {
    extensions: [&#39;.js&#39;, &#39;.jsx&#39;],
  },
  plugins,
  devServer: {
    contentBase: paths.appDist,
    compress: true,
    port,
  },
};

module.exports = config;
</code></pre><p>在 <code>webpack.config.prod.js</code> 的基础上，我们增加了 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fbaldore%2Fopen-browser-webpack-plugin" target="_blank" rel="noopener">open-browser-webpack-plugin</a>  插件和 <code>devServer</code> 配置，<code>open-browser-webpack-plugin</code> 插件顾名思义，会帮我们自动打开 <code>dev server</code> 最后返回给我们的地址</p>
<p>更新 <code>package.json</code></p>
<pre><code>&quot;scripts&quot;: {
  &quot;clean&quot;: &quot;rimraf dist *.log .DS_Store&quot;,
  &quot;webpack:dev&quot;:
    &quot;NODE_ENV=development webpack-dev-server --config config/webpack.config.dev.js --progress&quot;,
  &quot;webpack:prod&quot;:
    &quot;NODE_ENV=production webpack --config config/webpack.config.prod.js --progress&quot;,
  &quot;start&quot;: &quot;yarn run clean &amp;&amp; yarn run webpack:dev&quot;,
  &quot;build&quot;: &quot;yarn run clean &amp;&amp; yarn run webpack:prod&quot;
}
</code></pre><p>现在，我们就可以通过如下方式来启动</p>
<pre><code>yarn start
</code></pre><p>启动后，有没有瞬间感觉很棒</p>
<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>为了能够使用 <code>ES6</code> 以及更高版本，我们需要一个 <code>转换编译器</code>，我们选择 <code>Babel</code>，它能将 <code>ES6</code> 转换成可以在浏览器中运行的代码，除此之外，他还内置了 <code>React JSX</code> 扩展，可以说它的出现推动了 <code>JavaScipt</code> 的发展</p>
<p>所有，我们安装下面这些依赖包</p>
<pre><code>yarn add --dev babel-loader babel-core babel-preset-env babel-preset-react
</code></pre><p>创建 <code>Babel</code> 默认配置文件 <code>.babelrc</code></p>
<pre><code>{&quot;presets&quot;:[&quot;env&quot;,&quot;react&quot;]}
</code></pre><p>这个是告诉 <code>Babel</code> 用我们刚刚安装的两个 <code>presets</code></p>
<p>接下来，更新 <code>webpack</code> 配置文件</p>
<pre><code>config.module = {
  rules: [
    {
      test: /\.(js|jsx)$/,
      exclude: /node_modules/,
      use: [&#39;babel-loader&#39;],
    },
  ],
}
</code></pre><p>更新以后，虽然看不到什么变化，但事实上我们可以使用 <code>ES6</code> 了</p>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>最后，我们来添加 <code>React</code>，这也可能是你阅读这篇文章的原因</p>
<p>首先，我们还是先安装它</p>
<pre><code>yarn add react react-dom
</code></pre><p>用下面代码替换 <code>console.log</code></p>
<pre><code>import React, { Component } from &#39;react&#39;;
import { render } from &#39;react-dom&#39;;

export default class Hello extends Component {
  render() {
    return &lt;h1&gt;Hello from 枫上雾棋!&lt;/h1&gt;;
  }
}

render(&lt;Hello /&gt;, document.getElementById(&#39;app&#39;));
</code></pre><p>因为要添加 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，所以我们要修改一下 <code>html-webpack-plugin</code> 的配置</p>
<pre><code>new HtmlWebpackPlugin({
  template: path.join(paths.appSrc, &#39;index.html&#39;),
}),
</code></pre><p>参考 <code>template</code> 如下</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;
    &lt;title&gt;webpack babel react revisited&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;noscript&gt;
      You need to enable JavaScript to run this app.
    &lt;/noscript&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>接下来，就是见证奇迹的时刻</p>
<p>重新启动服务，你有没有发现搭建一个 <code>React</code> 应用程序就这么简单</p>
<p>接下里，大家就可以 <code>自行探索</code>，添加更多的东西来适应自身应用程序的需要</p>
<p>下面再补充一下如何添加 <code>CSS</code> 和 <code>图片</code></p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>每个 web 应用程序都离不开 <code>CSS</code>，我们在 <code>src</code> 目录中创建 <code>style.css</code></p>
<pre><code>body,
html,
#app {
  margin: 0;
  width: 100%;
  height: 100%;
}

#app {
  padding: 30px;
  font-family: &#39;微软雅黑&#39;;
}
</code></pre><p>将其添加到应用程序中我们需要使用 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fcss-loader" target="_blank" rel="noopener">css-loader</a> </p>
<p>如果想将 <code>css</code> 注入 <code>style</code> 标签中，我们还需要 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fstyle-loader" target="_blank" rel="noopener">style-loader</a> ，通常，是将这两个结合使用</p>
<p>我们使用 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fextract-text-webpack-plugin" target="_blank" rel="noopener">extract-text-webpack-plugin</a>  将其解压到外部</p>
<p>为此，我们首先安装</p>
<pre><code>yarn add --dev css-loader style-loader extract-text-webpack-plugin
</code></pre><p>然后在 <code>app.js</code> 中导入 <code>style.css</code></p>
<pre><code>import&#39;./style.css&#39;;
</code></pre><p>最后更新 <code>webpack</code> 配置文件</p>
<pre><code>config.module = {
  rules: [
    {
      test: /\.css$/,
      use: ExtractTextPlugin.extract({
        fallback: &#39;style-loader&#39;,
        use: &#39;css-loader&#39;,
      }),
    },
  ],
}

config.plugins.push([
  new ExtractTextPlugin(&quot;styles.css&quot;),
])
</code></pre><p>看起来稍显复杂，但是大功告成，为了更好地使用它，我们都得经历这个过程</p>
<p>重新启动服务，你会发现你的 <code>dist</code> 目录中多了一个 <code>styles.css</code></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>最后我们增加 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Ffile-loader" target="_blank" rel="noopener">file-loader</a>  来处理我们引入的图片等文件</p>
<p>首先，安装 <code>file-loader</code></p>
<pre><code>yarn add --dev file-loader
</code></pre><p>我们在 <code>src/images</code> 中放入一张图片，在 <code>app.js</code> 中导入</p>
<pre><code>import avatar from &#39;./images/avatar.jpg&#39;;

export default class Hello extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;img src={avatar} alt=&quot;avatar&quot; style={{ width: 400, height: 250 }} /&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre><p>更新 <code>webpack</code> 配置文件</p>
<pre><code>config.module = {
  rules: [
    {
      test: /\.(png|jpg|gif)$/,
      use: [
        {
          loader: &#39;file-loader&#39;,
          options: {
            name: &#39;[name].[ext]&#39;,
            outputPath: &#39;assets/images/&#39;,
          },
        },
      ],
    },
  ],
}
</code></pre><p>重启服务，哈哈</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如果有什么问题，可以查看 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2FFengShangWuQi%2Fwebpack-babel-react-revisited" target="_blank" rel="noopener">webpack-babel-react-revisited</a>  仓库</p>
<p>现在，大家对搭建 <code>React</code> 应用程序是不是感觉轻松了很多，但 <code>React</code> 整个技术栈并不止包括这些，还有 <code>Redux</code>，<code>React Router</code>，<code>单元测试</code>，<code>代码校验</code> 等内容，关于 <code>React</code> 其他内容，欢迎查看日志其他文章</p>
]]></content>
      
        <categories>
            
            <category> react </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS实现常用算法]]></title>
      <url>/JS%E5%AE%9E%E7%8E%B0%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目标：总结本书主要内容，相应算法使用js来模仿实现</p>
<blockquote>
<p>在计算机科学领域，我们用算法这个词来描述一种有限、确定、有效的并适合用计算机程序来实现的解决问题的方法。</p>
<p>我们关注的大多数算法都需要<code>适当地组织数据</code>，而为了组织数据就产生了<code>数据结构</code></p>
</blockquote>
<p><strong>原书所有代码是基于JAVA语法的，这里，我们使用js来实现所有算法逻辑</strong></p>
<h2 id="队列、栈的实现"><a href="#队列、栈的实现" class="headerlink" title="队列、栈的实现"></a>队列、栈的实现</h2><blockquote>
<p>队列是一种先进先出的集合类型，栈是一种先进后出的集合类型</p>
</blockquote>
<p>首先定义要实现的队列、栈的API<br><strong>Queue</strong>说明Queue()创建空队列enqueue(item)添加一个元素dequeue()删除最近添加的元素isEmpty()队列是否为空size（）队列中元素的数量iterator()返回一个可迭代对象</p>
<p><strong>Stack</strong>说明Stack()创建空栈push(item)添加一个元素pop()删除最近添加的元素isEmpty()栈是否为空size（）栈中元素的数量iterator()返回一个可迭代对象</p>
<p>Iterator说明hasNext()是否还有下一个元素next()返回下一个元素<br>由于JS语言的特殊性，采用数组的方式来实现队列、栈是非常容易的,js中数组本来就提供了从头部插入、删除元素，从尾部插入、删除元素的功能。这里只需要简单的封装一下(js的弱类型特点，不需要像JAVA那样采用泛型来声明可以储存任意类型的数据，同时，js中数组是不定长的，可以动态扩展)</p>
<p><strong>实现</strong></p>
<p>队列的数组方式实现，并模拟可迭代功能</p>
<pre><code>    function Queue() {
    this.container = []
}
Queue.prototype.enqueue = function (ele) {
    this.container.push(ele)
}
Queue.prototype.dequeue = function () {
    return this.container.shift()
}
Queue.prototype.isEmpty = function () {
    return !this.container.length
}
Queue.prototype.size = function () {
    return this.container.length
}

Queue.prototype.iterator = function () {
    var container = this.container
    var current = 0
    return {
        hasNext: function () {
            return current !== container.length
        },
        next: function () {
            return container[current++]
        }
    }
}

用例:
var Qu = new Queue()
Qu.enqueue(&#39;to&#39;)
Qu.enqueue(&#39;be&#39;)
Qu.enqueue(&#39;or&#39;)
Qu.enqueue(&#39;not&#39;)
Qu.dequeue()
var iterator = Qu.iterator()
while (iterator.hasNext()) {
    console.log(iterator.next())
}
输出:
be
or
not
</code></pre><p>栈的数组方式实现，并模拟可迭代功能</p>
<pre><code>class Stack {

    constructor() {
        this.container = []
    }

    push(ele) {
        this.container.unshift(ele)
    }

    pop() {
        return this.container.shift()
    }

    isEmpty() {
        return !this.container.length
    }
    size() {
        return this.container.length
    }

    iterator() {
        const container = this.container
        let current = 0
        return {
            hasNext: function () {
                return current !== container.length
            },
            next: function () {
                return container[current++]
            }
        }
    }

}
用例:
var St = new Stack()
Stack.push(&#39;to&#39;)
Stack.push(&#39;be&#39;)
Stack.push(&#39;or&#39;)
Stack.push(&#39;not&#39;)
Stack.pop()
var iterator = Stack.iterator()
while (iterator.hasNext()) {
    console.log(iterator.next())
}
输出:
or
be
to
</code></pre><blockquote>
<p>链表是一种递归的数据结构，它或者为空(null)，或者是指向一个结点(node)的引用，该结点含有一个泛型的元素和一个指向另一个链表的引用。</p>
</blockquote>
<p>在这个定义中，结点是一个可能含有任意类型数据的抽象实体，它所包含的指向结点的应用显示了它在构造链表之中的作用。</p>
<p>结点表示:</p>
<pre><code> function Node(){
        this.item=null
        this.next=null
    }
</code></pre><p>构造链表：</p>
<p><img src="https://img.funteas.com/ee445ad64319177f007f2a53102cbb29?imageView2/2/w/800" alt=""></p>
<p>在表头插入结点</p>
<pre><code>var oldFirst=first
    first=new Node()
    first.next=oldFirst
</code></pre><p>从表头删除结点</p>
<pre><code>first=first.next
</code></pre><p>从表尾插入结点</p>
<pre><code> var oldlast=last
    lst=new Node()
    oldlast.next=last
</code></pre><blockquote>
<p>实现任意插入和删除操作的标准解决方案是双向链表，其中每个结点都含有两个链接，分别指向不同的方向</p>
</blockquote>
<pre><code>function Node(item) {
    this.item = item
    this.next = null
}

function Stack() {
    this.count = 0 //元素数量
    this.first = null //指向栈顶
}

Stack.prototype.isEmpty = function () {
    return this.first == null
}
Stack.prototype.size = function () {
    return this.count
}
Stack.prototype.push = function (ele) {
    var oldfirst = this.first
    var newnode = new Node(ele)
    newnode.next = oldfirst
    this.first = newnode
    this.count++
}
Stack.prototype.pop = function () {
    var ele = this.first.item
    this.first = this.first.next
    this.count--
    return ele
}
Stack.prototype.iterator = function () {
    var firstnode = this.first
    var count = this.count
    return {
        hasNext: function () {
            return  count
        },
        next: function () {
            var ele=firstnode.item
            firstnode=firstnode.next
            count--
            return ele
        }
    }
}
用例：
var stack=new Stack()
stack.push(&#39;to&#39;)
stack.push(&#39;be&#39;)
stack.push(&#39;or&#39;)
stack.push(&#39;not&#39;)
stack.push(&#39;to&#39;)
stack.push(&#39;be&#39;)
console.log(stack.size())
var iterator=stack.iterator()
while(iterator.hasNext()){
    console.log(iterator.next())
}
输出：
6
be
to
not
or
be
to
</code></pre><blockquote>
<p>将链表表示为一条从最早插入的元素到最近插入的元素的链表，实例变量first指向队列的开头，last指向队列的结尾。这样，要讲一个元素入列，就将它添加到表尾，要将一个元素出列，就删除表头的结点.</p>
</blockquote>
<pre><code>function Node(item) {
    this.item = item
    this.next = null
}

class Queue {

    constructor() {
        this.first = null
        this.last = null
        this.count = 0
    }

    isEmpty() {
        return this.first == null
    }
    size() {
        return this.count
    }
    enqueue(item) {
        const oldlast = this.last
        const last = new Node(item)
        this.last = last
        if (this.isEmpty()) {
            this.first = last
        } else {
            oldlast.next = last
        }
        this.count++
    }
    dequeue() {
        const ele = this.first.item
        this.first = this.first.next
        if (this.isEmpty()) {
            this.last = null
        }
        this.count--
        return ele
    }
    iterator() {
        let firstnode = this.first
        let count = this.count
        return {
            hasNext: function () {
                return count
            },
            next: function () {
                var ele = firstnode.item
                firstnode = firstnode.next
                count--
                return ele
            }
        }
    }
}
用例:
const queue=new Queue()
queue.enqueue(&#39;to&#39;)
queue.enqueue(&#39;be&#39;)
queue.enqueue(&#39;or&#39;)
queue.enqueue(&#39;not&#39;)
queue.enqueue(&#39;to&#39;)
queue.enqueue(&#39;be&#39;)
queue.dequeue()
console.log(queue.size())
const iterator=queue.iterator()
while(iterator.hasNext()){
    console.log(iterator.next())
}

输出:
5
be
or
not 
to
be
</code></pre><blockquote>
<p>在结构化存储数据集时，链表是数组的一种重要的替代方式，两者都非常基础，常常被称为顺序存储和链式存储。</p>
</blockquote>
<p><img src="https://img.funteas.com/70ac99ef5b679cc727dad3b2b4aa9f86?imageView2/2/w/800" alt=""></p>
<h2 id="常见的时间复杂度的级别"><a href="#常见的时间复杂度的级别" class="headerlink" title="常见的时间复杂度的级别"></a>常见的时间复杂度的级别</h2><p><img src="https://img.funteas.com/baa593fe9ffa490960a5c8acec7f70fa?imageView2/2/w/800" alt=""></p>
<p>问题描述：</p>
<blockquote>
<p>假设所有整数都不相同，统计一个数组中所有和为0的三整数元组的数量</p>
</blockquote>
<pre><code>function threesum(arr){
    var N=arr.length
    var count=0
    for(var i=0;i&lt;N;i++){
        for(var j=i+1;j&lt;N;j++){
            for(var k=j+1;k&lt;N;k++){
                if(arr[i]+arr[j]+arr[k]==0){
                    count++
                }
            }
        }
    }
    return count
}
</code></pre><p>分析：</p>
<p>执行最频繁的指令决定了程序执行的总时间，对上面的threesum算法，最频繁的部分就是if语句判断，它套在三个for循环内，对于给定的N，if语句执行次数为<code>N*(N-1)*(N-2)/6=N^3/6-N^2/2+N/3</code>,当N很大时，首项后的其他项都相对较小可以忽略，所以if语句的执行次数约等于<code>N^3/6</code>,表示为(~N^3/6)</p>
<p>所以暴力算法的threesum执行用时的增长数量级为<code>N^3</code></p>
<blockquote>
<p>学习程序的增长数量级的一个重要动力是为了帮助我们为同一个问题设计更快的算法</p>
</blockquote>
<p>改进后的算法的思路是：当且仅当-( a[i]+a[j] )在数组中( 不是a[i]也不是a[j] )时,整数对( a[i]和a[j] )为某个和为0的三元组的一部分。要解决这个问题，首先对数组进行排序(为二分查找做准备),然后对数组中的每个a[i]+a[j],使用二分查找算法对-(a[i]+a[j])进行二分查找，如果结果为k，且k&gt;j,则count加一。</p>
<p>下面中的代码会将数组排序并进行N*(N-1)/2次二分查找，每次查找所需的时间都和logN成正比，因此总的运行时间和N^2logN成正比。</p>
<pre><code>//二分查找
function binarySearch(key, arr) {
    var start = 0
    var end = arr.length - 1
    while (start &lt;= end) {
        var mid = start + Math.floor((end - start) / 2)
        if (key &lt; arr[mid]) {
            end = mid - 1
        } else if (key &gt; arr[mid]) {
            start = mid + 1
        } else {
            return mid
        }
    }
    return -1
}

function threesum(arr) {
    var N = arr.length
    var count = 0
    arr = arr.sort(function (a, b) {
        return a &gt; b ? 1 : -1
    })
    for (var i = 0; i &lt; N; i++) {
        for (var j = i + 1; j &lt; N; j++) {
            if (binarySearch(-arr[i] - arr[j], arr) &gt; j) {
                count++
            }
        }
    }
    return count
}
</code></pre><p><img src="https://img.funteas.com/86e3c247a4e4a51fa7d20afcbac520b3?imageView2/2/w/800" alt=""></p>
<h2 id="案例研究-union-find算法"><a href="#案例研究-union-find算法" class="headerlink" title="案例研究:union-find算法"></a>案例研究:union-find算法</h2><h3 id="动态连通性问题"><a href="#动态连通性问题" class="headerlink" title="动态连通性问题"></a>动态连通性问题</h3><p>首先我们详细说明一下问题</p>
<blockquote>
<p>问题的输入是一列整数对，对于一对整数p,q,如果p,q不相连，则将p,q连接</p>
</blockquote>
<p>所谓的相连:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 自反性: p与p是相连的</li>
<li style="list-style: none"><input type="checkbox" checked> 对称性: 若p与q是相连的,则q与p是相连的</li>
<li style="list-style: none"><input type="checkbox" checked> 传递性: 若p与q是相连的,且q和r相连，则p与r是相连的</li>
</ul>
<p>我们假设相连的整数构成了一个“集合”,对于新的连接，就是在将新的元素加入“集合”来构成更大的“集合”,若判断p,q是否相连，只要判断p,q是否在同一个“集合”中即可。</p>
<p><img src="https://img.funteas.com/32b475d705dc8beb69db82db1c877b3c?imageView2/2/w/800" alt=""></p>
<blockquote>
<p>这里我们应用动态连通性来处理计算机网络中的主机之间的连通关系</p>
<p>输入中的整数表示的可能是一个大型计算机网络中的计算机，而整数对则表示网络中的连接，这个程序能够判定我们是否需要在p和q之间架设一条新的连接来通信，或是我们可以通过已有的连接在两者之间建立通信线路。</p>
</blockquote>
<p>这里我们使用网络方面的术语，将<code>输入的整数</code>称为<code>触点</code>，将形成的<code>集合</code>称为<code>连通分量</code></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>为了说明问题，我们设计一份API来封装所需的基本操作:初始化、连接两个触点、判断包含某个触点的分量、判断两个触点是否存在于同一个分量之中以及返回所有分量的数量<br>UF说明UF(N)以整数标识（0到N-1）初始化N个触点union(p,q)连接触点p、qfind§返回p所在分量的标识符connected(p,q)判断p,q是否存在于同一个连通分量中count()连通分量的数量<br><strong>我们看到，为解决动态连通性问题设计算法的任务转化成了实现这份API，所有的实现都应该</strong></p>
<p>[x] 定义一种数据结构表示已知的连接</p>
<p>[x] 基于此数据结构实现高效的union()、find()、connected()、count()</p>
<p><strong>我们用一个以触点为索引的数组id[]作为基本数据结构来表示所有分量，我们将使用分量中的某个触点的名称作为分量的标识符</strong></p>
<p>一开始，我们有N个分量，每个触点都构成了一个只含有自己的分量，因此我们将id[i]的值设为i。</p>
<pre><code>class UF {

    /**
     * 
     * @param {number} N 
     */
    constructor(N) {
        this.id = new Array(N).fill(0).map((x, index) =&gt; index)
        this.count = 0
    }

    count(){
        return this.count
    }

    /**
     * 
     * @param {number} p 
     * @param {number} q 
     */
    connected(p,q){
        return this.find(p)===this.find(q)
    }

    /** 
     * @param {number} p 
     */
    find(p){

    }
    /**
     * 
     * @param {number} p 
     * @param {number} q 
     */
    union(p,q){

    }

}
</code></pre><pre><code>**find()和union()是实现的重点,我们将讨论三种不同的实现，它们均根据以触点为索引的id[]数组来确定两个触点是否存在于相同的连通分量中**
</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>思想是:保证当且仅当<code>id[p]==id[q]</code>时，p和q是连通的。换句话说，在同一个连通分量中的所有触点在id[]数组中的值都一样。</p>
<pre><code> /** 
     * @param {number} p 
     */
    find(p){
        return this.id[p]
    }

    /**
     * 
     * @param {number} p 
     * @param {number} q 
     */
    union(p,q){
        var pId=this.find(p)
        var qId=this.find(q)
        if(pId==qId) return
        this.id.forEach(x=&gt;{
            if(id[x]==pId){
                id[x]==qId
            }
        })
        this.count--
    }
</code></pre><p>复杂度分析:</p>
<p>find()操作很快，它只访问id[]数组一次,但union()会整个扫描id[]数组</p>
<p>在union()中,find p、q会访问2次数组，for循环及赋值操作会访问数组 N+1 ~ N+（N-1）次。</p>
<p>所以union()方法访问数组的次数在(2+N+1) ~(2+N+(N-1)) 即 N+3 ~ 2N+1 次之间</p>
<p>假设我们使用quick-union算法来解决动态连通性问题并最后只得到一个连通分量，则至少需要调用(N-1)次 union(),<br>即（N+3）<em>（N-1） ~（2N+1）</em>（N-1）次数组访问</p>
<p>所以此算法的时间复杂度是<code>平方级别的</code></p>
<p>此算法的重点是提高union()方法的速度，它也是基于相同的数据结构–以触点作为索引的id[]数组，但我们赋予这些值的意义不同，我们需要用他们来定义更加复杂的数据结构:</p>
<blockquote>
<p>每个触点所对应的id[]元素都是同一个分量中的另一个触点的名称（也可以说是它自己，即根触点）–我们将这种联系称为链接。</p>
</blockquote>
<pre><code> /** 
     * 找到根触点，即分量的标识符
     * @param {number} p 
     */
    find(p) {
        while (p !== this.id[p]) p = this.id[p]
        return p
    }

    /**
     * 
     * @param {number} p 
     * @param {number} q 
     */
    union(p, q) {
        let pRoot = this.find(p)
        let qRoot = this.find(q)
        if (pRoot == qRoot) return
        id[pRoot] = qRoot
        this.count--
    }
</code></pre><p><img src="https://img.funteas.com/1ac6aaeb8ea65151f887c2e9e8c7e55b?imageView2/2/w/800" alt=""></p>
<p>如图所示：id[]数组用父链接的形式表示了一片森林</p>
<p>复杂度分析：</p>
<blockquote>
<p>一棵树的大小是它的节点的数量，树中一个节点的深度是它到根节点路径上的链接数</p>
</blockquote>
<p>quick-union算法的分析依赖于输入的特点，find()访问数组的次数为1加上给定的触点所对应的节点的深度的2倍。</p>
<p>在最好的情况下，find()只需要访问数组1次就能够得到当前触点所在分量的标识符</p>
<p>在最坏的情况下，find()需要1 + 2*(N-1) 即 2N-1 次数组访问</p>
<p>如下图所示</p>
<p><img src="https://img.funteas.com/46d986d30409f03990188874ac65fef2?imageView2/2/w/800" alt=""></p>
<p>对最坏的情况，处理N对整数所需的所有find()操作访问数组的总次数为:</p>
<p>等差数列 (1+ 2N-1) *N /2 = N^2,即<code>在最差的情况下，quick-union算的复杂度为平方级的</code></p>
<p>union()访问数组的次数是两次find()操作，(如果union中给定的两个触点在不同的分量还要加1)</p>
<p>由此，我们构造了一个最佳情况的输入使得算法的运行时间是线性的，最差情况的输入使得算法的运行时间是平方级的。</p>
<ul>
<li>加权 quick-union算法 (控制树的深度)</li>
</ul>
<blockquote>
<p>与其在union()中随意将一颗树连接到另一棵树，我们现在会记录每一颗树的大小并总是将较小的树连接到较大的树上。</p>
</blockquote>
<p><img src="https://img.funteas.com/a8309189a668bb00186e3ff92c355c5e?imageView2/2/w/800" alt=""></p>
<pre><code>class UF {

    /**
     * 
     * @param {number} N 
     */
    constructor(N) {
        this.id = new Array(N).fill(0).map((x, index) =&gt; index)
        //各个根节点所对应的分量的大小
        this.sz = new Array(N).fill(1)
        this.count = 0
    }

    count() {
        return this.count
    }

    /**
     * 
     * @param {number} p 
     * @param {number} q 
     */
    connected(p, q) {
        return this.find(p) === this.find(q)
    }

    /** 
     * 找到根触点，即分量的标识符
     * @param {number} p 
     */
    find(p) {
        while (p !== this.id[p]) p = this.id[p]
        return p
    }
    /**
     * 
     * @param {number} p 
     * @param {number} q 
     */
    union(p, q) {
        let pRoot = this.find(p)
        let qRoot = this.find(q)
        if (pRoot == qRoot) return
        //将小树连接到大树上
        if (sz[pRoot] &lt; sz[qRoot]) {
            id[p] = qRoot
            sz[qRoot] += sz[pRoot]
        } else {
            id[q] = pRoot
            sz[pRoot] += sz[qRoot]
        }
        this.count--
    }

}
</code></pre><p>复杂度分析：</p>
<p><img src="https://img.funteas.com/5d818b417482f6348f82ce4ad6f9850c?imageView2/2/w/800" alt=""></p>
<p>如图所示，在最坏的情况下，其中将要被归并的树的大小总是相等的，它们均含有2^n个节点（树的高度为n）,当我们归并两个2^n个节点的树时，得到的树的高度增加到n+1。</p>
<p>对于加权quick-union算法和N个触点，在最坏的情况下，find() union()的运行时间的增长数量级为logN</p>
<blockquote>
<p>加权quick-union算法处理N个触点和M条连接时最多访问数组cMlgN次，这与quick-find需要MN形成了鲜明对比</p>
</blockquote>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>通过《算法》第一章我学习了</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 基本的数据类型栈、队列</li>
<li style="list-style: none"><input type="checkbox" checked> 通过数组、链表来构造队列和栈</li>
<li style="list-style: none"><input type="checkbox" checked> 数组和链表是两种基本的数据结构</li>
<li style="list-style: none"><input type="checkbox" checked> 时间复杂度的分析和常见的复杂度增长数量级</li>
<li style="list-style: none"><input type="checkbox" checked> 二分查找算法</li>
<li style="list-style: none"><input type="checkbox" checked> 对一个问题寻求解决方案时，要确定好基本的数据结构，好的数据结构是构造高效算法的前提</li>
<li style="list-style: none"><input type="checkbox" checked> 动态连通性问题</li>
<li style="list-style: none"><input type="checkbox" checked> 动态连通性问题的解决方案，并不断优化算法</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法思想 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法思想 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[移动端 Web 开发踩坑之旅]]></title>
      <url>/%E7%A7%BB%E5%8A%A8%E7%AB%AF-Web-%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>移动端的整体布局一般来说可以分为上中下三个部分，分别为 header、main、footer，其中 header、footer 是固定高度，分别固定在页面顶部和页面底部，而 main 是占据页面其余位置，并且可以滚动</p>
<p>最近在一个移动端的 Web 项目中踩了很多的坑，感觉有必要把它们记录下来，分享给即将踏入移动端 Web 开发大门的新人们。</p>
<h2 id="一、从布局说起"><a href="#一、从布局说起" class="headerlink" title="一、从布局说起"></a>一、从布局说起</h2><p>移动端的整体布局一般来说可以分为上中下三个部分，分别为 header、main、footer，其中header、footer 是固定高度，分别固定在页面顶部和页面底部，而 main 是占据页面其余位置，并且可以滚动。</p>
<p><img src="https://img.funteas.com/1c3510b27e5f15614bb2c21c82c4e064?imageView2/2/w/800" alt=""></p>
<p>（上图是使用纯 CSS 实现，然后截图，上传到专栏有点失真，看官老爷们将就着看吧。）</p>
<p>页面布局如下：</p>
<pre><code>&lt;body&gt;

  &lt;div class=&quot;header&quot;&gt;&lt;/div&gt;

  &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;

  &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;

&lt;/body&gt;
</code></pre><p>根据页面滚动的位置分为两种布局，一种是滚动 body，另一种是固定 body 的高度为100%，在 main 中滚动。</p>
<p>第一种布局有个优点，就是页面的地址栏会随着 body 的滚动隐藏起来，并且 Android 设备中，滚动 body 会更加的流畅，如果项目中有类似需求可以考虑。</p>
<p>实现布局的方式如下:</p>
<pre><code>body {
  overflow: auto;
}

.header,
.footer {
  position: fixed;
  left: 0;
  right: 0;
  height: 44px;
}

.header {
  top: 0;
}

.footer {
  bottom: 0;
}

.main {
  height: 100%;
  padding: 44px 0;
}
</code></pre><p>第一种情况比较适合长列表页面，整个页面除了 header 和 footer 之外都需要滚动，但很多时候，我们只希望页面的某个元素滚动，这个时候，就采取第二种布局方式。</p>
<p>这种页面布局有三种相对简单的实现方式：</p>
<ol>
<li><p>fixed 定位</p>
</li>
<li><p>absolute 定位</p>
</li>
<li><p>flex 定位</p>
</li>
</ol>
<p>最容易想到的实现方式是 fixed 定位，实现方式如下：</p>
<pre><code>html, body {
  height: 100%;
  overflow: hidden;
}
.header,
.footer {
  position: fixed;
  left: 0;
  right: 0;
  height: 44px;
}

.header {
  top: 0;
}

.footer {
  bottom: 0;
}

.main {
  height: 100%;
  padding: 44px 0;
  box-sizing: border-box;
}
</code></pre><p>fixed 定位实现起来简单，在大多数浏览器中也能正常显示，但是 fixed 定位在移动端会有兼容性问题，后面会提到，所以不建议这种实现方式。</p>
<p>absolute 定位和 fixed 定位类似，只要把 header 的 footer 的 position 改为 absolute 就可以了。</p>
<p>细心的小伙伴可能发现了，这里的 main 没有设置 overflow ，因为这里有一个坑，不管是absolute 定位还是 fixed 定位都一样，为了方便描述，以下只说 fixed 定位(在 absolute 定位也一样成立)。在PC端没有问题，但是在移动端，如果 main 设置了 overflow 为 true，header 会被 main 遮住，对，没有错，虽然是 fixed 定位，但是在移动端，<strong>如果 fixed 定位节点后面紧接跟着的兄弟节点是可滚动的(也就是设置了 overflow 为 true )，那么 fixed 节点会被其后的兄弟节点遮住。</strong></p>
<p>这个问题解决方式有很多，既然是 fixed 定位后面紧接着可滚动的兄弟节点才会有这个坑，只要让他的条件有一个不成立就好了，有以下解决方案：</p>
<ol>
<li><p>让 fixed 定位节点后面不紧接着可滚动的节点</p>
</li>
<li><p>不让 scroll 节点遮住 fixed 节点</p>
</li>
</ol>
<p>第一种方方案有以下可选方法:</p>
<ol>
<li>把所有 fixed 节点放在 scroll 元素后面，即把 header 节点放在 main 节点后面</li>
</ol>
<pre><code>&lt;body&gt;
  &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;header&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre><p>但这样显然不太符合一般人的思维习惯，代码可读性降低。</p>
<ol>
<li>使 main 不可滚动，给 main 嵌套一层可滚动的子节点</li>
</ol>
<pre><code>&lt;body&gt;
  &lt;div class=&quot;header&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;main&quot;&gt;
    &lt;div class=&quot;scroll-container&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;
&lt;/body&gt;

&lt;style&gt;
  .main {
    overflow: hidden;
  }
  .scroll-container {
    height: 100%;
    overflow: auto;
  }
&lt;/style&gt;
</code></pre><p>第二种方案有以下可选方法:</p>
<ol>
<li>让 scroll 节点不与 fixed 节点有重合</li>
</ol>
<pre><code>body {
  padding: 44px 0;
}

.main {
  padding: 0;
}
</code></pre><ol>
<li>给 fixed 节点设置 z-index</li>
</ol>
<pre><code>.header,
.footer {
    z-index: 8888;
}
</code></pre><p>看到这里可能会有小伙伴觉得，一个简单的布局，还要绕过这么多坑，难道没有简单的方式吗，答案当然是肯定的，那就是第三种实现方式，flex 布局。flex 定位在移动端兼容到了 iOS 7.1+，Android 4.4+,如果使用 autoprefixer 等工具还可以降级为旧版本的 flexbox ，可以兼容到 iOS 3.2 和 Android 2.1。而且用 flex 实现起来相对简单，在各个浏览器里表现也相对一致。实现如下:</p>
<pre><code>body {
  display: flex;
  flex-direction: column;
}
.main {
  flex: 1;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}
.header {
  height: 44px;
}
.footer {
  height: 44px;
}
</code></pre><h2 id="二、fixed-与-input"><a href="#二、fixed-与-input" class="headerlink" title="二、fixed 与 input"></a>二、fixed 与 input</h2><p>刚接触移动端 Web 开发的小伙伴应该都会听前辈们说过，不要在有 input 标签的页面使用 fixed 定位，因为这两者在一起的时候，总是会有奇奇怪怪的问题。</p>
<p>在 iOS 上，当点击 input 标签获取焦点唤起软键盘的时候，fixed 定位会暂时失效，或者可以理解为变成了 absolute 定位，在含有滚动的页面，fixed 定位的节点和其他节点一起滚动。</p>
<p>其实这个问题也很好解决，只要保证 fixed 定位的节点的父节点不可滚动，那么即使 fixed 定位失效，也不会和其他滚动节点一起滚动，影响界面。</p>
<p>但是除此之外，还有很多坑比较难以解决，例如 Android 软键盘唤起后遮挡住 input 标签，用户没法看到自己输入的字符串，iOS 则需要在输入至少一个字符之后，才能将对应的 input 标签滚动到合适的位置，所以为了避开这些难以解决的坑，在有表单输入的页面，尽量用absolute 或者 flex 替换 fixed。</p>
<h2 id="三、input-的-compositionstart-和-compositionend-事件"><a href="#三、input-的-compositionstart-和-compositionend-事件" class="headerlink" title="三、input 的 compositionstart 和 compositionend 事件"></a>三、input 的 compositionstart 和 compositionend 事件</h2><p>在 Web 开发中，经常要对表单元素的输入进行限制，比如说不允许输入特殊字符，标点。通常我们会监听 input 事件:</p>
<pre><code>inputElement.addEventListener(&#39;input&#39;, function(event) {
  let regex = /[^1-9a-zA-Z]/g;
  event.target.value = event.target.value.replace(regex, &#39;&#39;);
  event.returnValue = false
});
</code></pre><p>这段代码在 Android 上是没有问题的，但是在 iOS 中，input 事件会截断非直接输入，什么是非直接输入呢，在我们输入汉字的时候，比如说「喜茶」，中间过程中会输入拼音，每次输入一个字母都会触发 input 事件，然而在没有点选候选字或者点击「选定」按钮前，都属于非直接输入。</p>
<p><img src="https://img.funteas.com/ea3aa45e414168e2ddfc0539480ee7b9?imageView2/2/w/800" alt="">所以输入「喜茶」两个字，会触发6次 input 事件，如果把每次 input 的 value 打印出来，结果如下：</p>
<p><img src="https://img.funteas.com/f89919765cfc34c7355699fce12b3a64?imageView2/2/w/800" alt="">这显然不是我们想要的结果，我们希望在直接输入之后才触发 input 事件，这就需要引出我要说的两个事件—— compositionstart 和 compositionend。</p>
<p>compositionstart 事件在用户开始进行非直接输入的时候触发，而在非直接输入结束，也即用户点选候选词或者点击「选定」按钮之后，会触发 compositionend 事件。</p>
<pre><code>var inputLock = false;
function do(inputElement) {
    var regex = /[^1-9a-zA-Z]/g;
    inputElement.value = inputElement.value.replace(regex, &#39;&#39;);
}

inputElement.addEventListener(&#39;compositionstart&#39;, function() {
  inputLock = true;
});

inputElement.addEventListener(&#39;compositionend&#39;, function(event) {
  inputLock = false;
  do(event.target);
})

inputElement.addEventListener(&#39;input&#39;, function(event) {
  if (!inputLock) {
    do(event.target);
    event.returnValue = false;
  }
});
</code></pre><p>添加一个 inputLock 变量，当用户未完成直接输入前，inputLock 为 true，不触发 input 事件中的逻辑，当用户完成有效输入之后，inputLock 设置为 false，触发 input 事件的逻辑。这里需要注意的一点是，compositionend 事件是在 input 事件后触发的，所以在 compositionend事件触发时，也要调用 input 事件处理逻辑。</p>
<h2 id="四、iOS-1px-border-实现"><a href="#四、iOS-1px-border-实现" class="headerlink" title="四、iOS 1px border 实现"></a>四、iOS 1px border 实现</h2><p>iOS设备上，由于retina屏的原因，1px 的 border 会显示成两个物理像素，所以看起来会感觉很粗，这是一个移动端开发常见的问题。解决方案有很多，但都有自己的优缺点。</p>
<p><strong>0.5px border</strong></p>
<p>从iOS 8开始，iOS 浏览器支持 0.5px 的 border，但是在 Android 上是不支持的，0.5px 会被认为是 0px，所以这种方法，兼容性是很差的。</p>
<p><strong>背景渐变</strong></p>
<p>CSS3 有了渐变背景，可以通过渐变背景实现 1px 的 border，实现原理是设置 1px 的渐变背景，50% 有颜色，50% 是透明的。</p>
<pre><code>@mixin commonStyle() {
  background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%;
  background-repeat: no-repeat;
  background-position: top, right top,  bottom, left top;
}

@mixin border($border-color) {
  @include commonStyle();
  background-image:linear-gradient(180deg, $border-color, $border-color 50%, transparent 50%),
  linear-gradient(270deg, $border-color, $border-color 50%, transparent 50%),
  linear-gradient(0deg, $border-color, $border-color 50%, transparent 50%),
  linear-gradient(90deg, $border-color, $border-color 50%, transparent 50%);
}
</code></pre><p>这种方法虽然可行，但是没有办法实现圆角。</p>
<p><strong>伪类 + transform</strong></p>
<p>这类方法的实现原理是用伪元素的 box-shadow 或 border 实现 border，然后用 transform缩小到原来的一半。即使有圆角的需求也能很好的实现。</p>
<pre><code>@mixin hairline-common($border-radius) {
  position: relative;
  z-index: 0;
  &amp;:before {
    position: absolute;
    content: &#39;&#39;;
    border-radius: $border-radius;
    box-sizing: border-box;
    transform-origin: 0 0;
  }
}
@mixin hairline($direct: &#39;all&#39;, $border-color: #ccc, $border-radius: 0) {
  @include hairline-common($border-radius);
  &amp;:before {
    transform: scale(.5);
    @if $direct == &#39;all&#39; {
      top: 0;
      left: 0;
      width: 200%;
      height: 200%;
      box-shadow: 0 0 0 1px $border-color;
      z-index: -1;
    } @else if $direct == &#39;left&#39; or $direct == &#39;right&#39; {
      #{$direct}: 0;
      top: 0;
      width: 0;
      height: 200%;
      border-#{$direct}: 1px solid $border-color;
    } @else {
      #{$direct}: 0;
      left: 0;
      width: 200%;
      height: 0;
      border-#{$direct}: 1px solid $border-color;
    }
  }
}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上的坑都是在项目里频繁遇到的，每一个都给出了对应的解决方式，但由于笔者也是初入坑移动 Web 开发的新人一枚，所以给出的方案未必是最合适的，做了点微小的工作，希望能为大家提供一点帮助，不足的地方也请大家多多指正。</p>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 移动端web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[列举一些前端优化点---移动端优化]]></title>
      <url>/%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%82%B9---%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BC%98%E5%8C%96.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://pancakeawesome.ink/%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%82%B9---PC%E7%AB%AF%E4%BC%98%E5%8C%96.html">前一篇博客</a>我介绍了前端开发中比较常用的pc端优化点，包括网络加载和页面渲染类的优化。</p>
<p>这篇博客我们讨论下移动端web开发的常用优化点，包括缓存类，图片类，脚本类，渲染类，架构协议类的相关常用优化点。</p>
<h2 id="移动端浏览器前端优化策略"><a href="#移动端浏览器前端优化策略" class="headerlink" title="移动端浏览器前端优化策略"></a>移动端浏览器前端优化策略</h2><p>相对于桌面端浏览器，移动端 Web 浏览器上有一些较为明显的特点：设备屏幕较小、新特性兼容性较好、支持一些较新的 HTML5 和 CSS3 特性、需要与 Native 应用交互等。但移动端浏览器可用的 CPU 计算资源和网络资源极为有限，因此要做好移动端 Web 上的优化往往需要做更多的事情。首先，在移动端 Web 的前端页面渲染中，桌面浏览器端上的优化规则同样适用，此外针对移动端也要做一些极致的优化来达到更好的效果。需要注意的是，并不是移动端的优化原则在桌面浏览器端就不适用，而是由于兼容性和差异性的原因，一些优化原则在移动端更具代表性。</p>
<h3 id="网络加载类"><a href="#网络加载类" class="headerlink" title="网络加载类"></a>网络加载类</h3><h4 id="1．首屏数据请求提前，避免-JavaScript-文件加载后才请求数据"><a href="#1．首屏数据请求提前，避免-JavaScript-文件加载后才请求数据" class="headerlink" title="1．首屏数据请求提前，避免 JavaScript 文件加载后才请求数据"></a>1．首屏数据请求提前，避免 JavaScript 文件加载后才请求数据</h4><p>为了进一步提升页面加载速度，可以考虑将页面的数据请求尽可能提前，避免在 JavaScript 加载完成后才去请求数据。通常数据请求是页面内容渲染中关键路径最长的部分，而且不能并行，所以如果能将数据请求提前，可以极大程度上缩短页面内容的渲染完成时间。</p>
<h4 id="2．首屏加载和按需加载，非首屏内容滚屏加载，保证首屏内容最小化"><a href="#2．首屏加载和按需加载，非首屏内容滚屏加载，保证首屏内容最小化" class="headerlink" title="2．首屏加载和按需加载，非首屏内容滚屏加载，保证首屏内容最小化"></a>2．首屏加载和按需加载，非首屏内容滚屏加载，保证首屏内容最小化</h4><p>由于移动端网络速度相对较慢，网络资源有限，因此为了尽快完成页面内容的加载，需要保证首屏加载资源最小化，非首屏内容使用滚动的方式异步加载。一般推荐移动端页面首屏数据展示延时最长不超过 3 秒。目前中国联通 3G 的网络速度为 338KB/s（2.71Mb/s），所以推荐首屏所有资源大小不超过 1014KB，即大约不超过 1MB。</p>
<h4 id="3．模块化资源并行下载"><a href="#3．模块化资源并行下载" class="headerlink" title="3．模块化资源并行下载"></a>3．模块化资源并行下载</h4><p>在移动端资源加载中，尽量保证 JavaScript 资源并行加载，主要指的是模块化 JavaScript 资源的异步加载，例如 AMD 的异步模块，使用并行的加载方式能够缩短多个文件资源的加载时间。</p>
<h4 id="4．inline-首屏必备的-CSS-和-JavaScript"><a href="#4．inline-首屏必备的-CSS-和-JavaScript" class="headerlink" title="4．inline 首屏必备的 CSS 和 JavaScript"></a>4．inline 首屏必备的 CSS 和 JavaScript</h4><p>通常为了在 HTML 加载完成时能使浏览器中有基本的样式，需要将页面渲染时必备的 CSS 和 JavaScript 通过 <code>&lt;script&gt;</code> 或 <code>&lt;style&gt;</code> 内联到页面中，避免页面 HTML 载入完成到页面内容展示这段过程中页面出现空白。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;htmllang=&quot;en&quot;&gt;
    &lt;head&gt;
    &lt;metacharset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;样例&lt;/title&gt;
    &lt;meta&gt;
    &lt;style&gt;
    /*必备的首屏CSS*/
    html,body{
        margin:0;
        padding:0;
        background-color:#ccc;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="5．meta-dns-prefetch-设置-DNS-预解析"><a href="#5．meta-dns-prefetch-设置-DNS-预解析" class="headerlink" title="5．meta dns prefetch 设置 DNS 预解析"></a>5．meta dns prefetch 设置 DNS 预解析</h4><p>设置文件资源的 DNS 预解析，让浏览器提前解析获取静态资源的主机 IP，避免等到请求时才发起 DNS 解析请求。通常在移动端 HTML 中可以采用如下方式完成。</p>
<pre><code>&lt;!--cdn域名预解析--&gt;
&lt;metahttp-equiv=&quot;x-dns-prefetch-control&quot;content=&quot;on&quot;&gt;
&lt;linkrel=&quot;dns-prefetch&quot;href=&quot;//cdn.domain.com&quot;&gt;
</code></pre><h4 id="6．资源预加载"><a href="#6．资源预加载" class="headerlink" title="6．资源预加载"></a>6．资源预加载</h4><p>对于移动端首屏加载后可能会被使用的资源，需要在首屏完成加载后尽快进行加载，保证在用户需要浏览时已经加载完成，这时候如果再去异步请求就显得很慢。</p>
<h4 id="7．合理利用-MTU-策略"><a href="#7．合理利用-MTU-策略" class="headerlink" title="7．合理利用 MTU 策略"></a>7．合理利用 MTU 策略</h4><p>通常情况下，我们认为 TCP 网络传输的最大传输单元（Maximum Transmission Unit，MTU）为 1500B，即一个 RTT（Round-Trip Time，网络请求往返时间）内可以传输的数据量最大为 1500 字节。因此，在前后端分离的开发模式中，尽量保证页面的 HTML 内容在 1KB 以内，这样整个 HTML 的内容请求就可以在一个 RTT 内请求完成，最大限度地提高 HTML 载入速度。</p>
<h3 id="缓存类"><a href="#缓存类" class="headerlink" title="缓存类"></a>缓存类</h3><h4 id="1．合理利用浏览器缓存"><a href="#1．合理利用浏览器缓存" class="headerlink" title="1．合理利用浏览器缓存"></a>1．合理利用浏览器缓存</h4><p>除了上面说到的使用 Cache-Control、Expires、Etag 和 Last-Modified 来设置 HTTP 缓存外，在移动端还可以使用 localStorage 等来保存 AJAX 返回的数据，或者使用 localStorage 保存 CSS 或 JavaScript 静态资源内容，实现移动端的离线应用，尽可能减少网络请求，保证静态资源内容的快速加载。</p>
<h4 id="2．静态资源离线方案"><a href="#2．静态资源离线方案" class="headerlink" title="2．静态资源离线方案"></a>2．静态资源离线方案</h4><p>对于移动端或 Hybrid 应用，可以设置离线文件或离线包机制让静态资源请求从本地读取，加快资源载入速度，并实现离线更新。关于这块内容，我们会在后面的章节中重点讲解。</p>
<h4 id="3．尝试使用-AMP-HTML"><a href="#3．尝试使用-AMP-HTML" class="headerlink" title="3．尝试使用 AMP HTML"></a>3．尝试使用 AMP HTML</h4><p>AMP HTML 可以作为优化前端页面性能的一个解决方案，使用 AMP Component 中的元素来代替原始的页面元素进行直接渲染。</p>
<pre><code>

&lt;!--不推荐--&gt;
&lt;videowidth=&quot;400&quot;height=&quot;300&quot;src=&quot;http://www.domain.com/videos/myvideo.mp4&quot;
poster=&quot;path/poster.jpg&quot;&gt;
    &lt;divfallback&gt;
        &lt;p&gt;Your browser doesn’t support HTML5 video&lt;/p&gt;
    &lt;/div&gt;
    &lt;sourcetype=&quot;video/mp4&quot;src=&quot;foo.mp4&quot;&gt;
    &lt;sourcetype=&quot;video/webm&quot;src=&quot;foo.webm&quot;&gt;
&lt;/video&gt;
&lt;!--推荐--&gt;
&lt;amp-videowidth=&quot;400&quot;height=&quot;300&quot;src=&quot;http://www.domain.com/videos/myvideo.mp4&quot;
poster=&quot;path/poster.jpg&quot;&gt;
    &lt;divfallback&gt;
        &lt;p&gt;Your browser doesn’t support HTML5 video&lt;/p&gt;
    &lt;/div&gt;
    &lt;sourcetype=&quot;video/mp4&quot;src=&quot;foo.mp4&quot;&gt;
    &lt;sourcetype=&quot;video/webm&quot;src=&quot;foo.webm&quot;&gt;
&lt;/amp-video&gt;
</code></pre><h4 id="4．尝试使用-PWA-模式"><a href="#4．尝试使用-PWA-模式" class="headerlink" title="4．尝试使用 PWA 模式"></a>4．尝试使用 PWA 模式</h4><p>PWA（Progressive Web Apps）是 Google 提出的用前沿的 Web 技术为网页提供 App 般使用体验的一系列方案。</p>
<h3 id="图片类"><a href="#图片类" class="headerlink" title="图片类"></a>图片类</h3><h4 id="1．图片压缩处理"><a href="#1．图片压缩处理" class="headerlink" title="1．图片压缩处理"></a>1．图片压缩处理</h4><p>在移动端，通常要保证页面中一切用到的图片都是经过压缩优化处理的，而不是以原图的形式直接使用的，因为那样很消耗流量，而且加载时间更长。</p>
<h4 id="2．使用较小的图片，合理使用-base64-内嵌图片"><a href="#2．使用较小的图片，合理使用-base64-内嵌图片" class="headerlink" title="2．使用较小的图片，合理使用 base64 内嵌图片"></a>2．使用较小的图片，合理使用 base64 内嵌图片</h4><p>在页面使用的背景图片不多且较小的情况下，可以将图片转化成 base64 编码嵌入到 HTML 页面或 CSS 文件中，这样可以减少页面的 HTTP 请求数。需要注意的是，要保证图片较小，一般图片大小超过 2KB 就不推荐使用 base64 嵌入显示了。</p>
<pre><code>.class-name{
    background-image : url(&#39;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAALCAMAAABxsOwqAAAAYFBMVEWnxwusyQukxQudwQyZvgyhxAyfwgyxzAsUHQGOuA0aJAERGAFIXwSTugyEqgtqhghQZgUwQQIpOQKbuguVtQuKrAuCowp2kQlheghTbQZHWQU7SwVAVgQ6TgQlLwMeKwFOemyQAAAAVElEQVQI1y3JVRaAIAAF0UconXbvf5ei8HfPDIQQhBAAFE10iKig3SLRNN4SP/p+N08VC0YnfIlNWtqIkhg/TPYbCvhqdHAWRXPZSp3g3CWZvVLXC6OJA3ukv0AaAAAAAElFTkSuQmCC&#39;);
}
</code></pre><h4 id="3．使用更高压缩比格式的图片"><a href="#3．使用更高压缩比格式的图片" class="headerlink" title="3．使用更高压缩比格式的图片"></a>3．使用更高压缩比格式的图片</h4><p>使用具有较高压缩比格式的图片，如 webp（需要设计降级兼容方案）等。在同等图片画质的情况下，高压缩比格式的图片体积更小，能够更快完成文件传输，节省网络流量。</p>
<pre><code>&lt;imgsrc=&quot;//cdn.domain.com/path/photo.webp&quot;alt=&quot;webp格式图片&quot;&gt;
</code></pre><h4 id="4．图片懒加载"><a href="#4．图片懒加载" class="headerlink" title="4．图片懒加载"></a>4．图片懒加载</h4><p>为了保证页面内容的最小化，加速页面的渲染，尽可能节省移动端网络流量，页面中的图片资源推荐使用懒加载实现，在页面滚动时动态载入图片。</p>
<pre><code>&lt;imgdata-src=&quot;//cdn.domain.com/path/photo.jpg&quot;alt=&quot;懒加载图片&quot;&gt;
</code></pre><h4 id="5．使用-MediaQuery-或-srcset-根据不同屏幕加载不同大小图片"><a href="#5．使用-MediaQuery-或-srcset-根据不同屏幕加载不同大小图片" class="headerlink" title="5．使用 MediaQuery 或 srcset 根据不同屏幕加载不同大小图片"></a>5．使用 MediaQuery 或 srcset 根据不同屏幕加载不同大小图片</h4><p>在介绍响应式的章节中我们了解到，针对不同的移动端屏幕尺寸和分辨率，输出不同大小的图片或背景图能保证在用户体验不降低的前提下节省网络流量，加快部分机型的图片加载速度，这在移动端非常值得推荐。</p>
<h4 id="6．使用-iconfont-代替图片图标"><a href="#6．使用-iconfont-代替图片图标" class="headerlink" title="6．使用 iconfont 代替图片图标"></a>6．使用 iconfont 代替图片图标</h4><p>在页面中尽可能使用 iconfont 来代替图片图标，这样做的好处有以下几个：</p>
<ul>
<li><p>使用 iconfont 体积较小，而且是矢量图，因此缩放时不会失真；</p>
</li>
<li><p>可以方便地修改图片大小尺寸和呈现颜色。</p>
</li>
</ul>
<p>但是需要注意的是，iconfont 引用不同 webfont 格式时的兼容性写法，根据经验推荐尽量按照以下顺序书写，否则不容易兼容到所有的浏览器上。</p>
<pre><code>@font-face{
    font-family:iconfont;
    src:url(&quot;./iconfont.eot&quot;);
    src:url(&quot;./iconfont.eot?#iefix&quot;)  format(&quot;eot&quot;),
        url(&quot;./iconfont.woff&quot;)  format(&quot;woff&quot;),
        url(&quot;./iconfont.ttf&quot;)  format(&quot;truetype&quot;);
}
</code></pre><h4 id="7．定义图片大小限制"><a href="#7．定义图片大小限制" class="headerlink" title="7．定义图片大小限制"></a>7．定义图片大小限制</h4><p>加载的单张图片一般建议不超过 30KB，避免大图片加载时间长而阻塞页面其他资源的下载，因此推荐在 10KB 以内。如果用户上传的图片过大，建议设置告警系统，帮助我们观察了解整个网站的图片流量情况，做出进一步的改善。</p>
<h4 id="8．强缓存策略"><a href="#8．强缓存策略" class="headerlink" title="8．强缓存策略"></a>8．强缓存策略</h4><p>对于一些「永远」不会变的图片可以使用强缓存的方式缓存在用户的浏览器上。</p>
<h3 id="脚本类"><a href="#脚本类" class="headerlink" title="脚本类"></a>脚本类</h3><h4 id="1．尽量使用-id"><a href="#1．尽量使用-id" class="headerlink" title="1．尽量使用 id"></a>1．尽量使用 id</h4><p>选择器选择页面 DOM 元素时尽量使用 id 选择器，因为 id 选择器速度最快。</p>
<h4 id="2．合理缓存-DOM-对象"><a href="#2．合理缓存-DOM-对象" class="headerlink" title="2．合理缓存 DOM 对象"></a>2．合理缓存 DOM 对象</h4><p>对于需要重复使用的 DOM 对象，要优先设置缓存变量，避免每次使用时都要从整个 DOM 树中重新查找。</p>
<pre><code>//不推荐
$(&#39;#mod.active&#39;).remove(&#39;active&#39;);
$(&#39;#mod.not-active&#39;).addClass(&#39;active&#39;);
//推荐
let $mod=$(&#39;#mod&#39;);
$mod.find(&#39;.active&#39;).remove(&#39;active&#39;);
$mod.find(&#39;.not-active&#39;).addClass(&#39;active&#39;);
</code></pre><h4 id="3．页面元素尽量使用事件代理，避免直接事件绑定"><a href="#3．页面元素尽量使用事件代理，避免直接事件绑定" class="headerlink" title="3．页面元素尽量使用事件代理，避免直接事件绑定"></a>3．页面元素尽量使用事件代理，避免直接事件绑定</h4><p>使用事件代理可以避免对每个元素都进行绑定，并且可以避免出现内存泄露及需要动态添加元素的事件绑定问题，所以尽量不要直接使用事件绑定。</p>
<pre><code>//不推荐
$(&#39;.btn&#39;).on(&#39;click&#39;,function(e){
    console.log(this);
});
//推荐
$(&#39;body&#39;).on(&#39;click&#39;,&#39;.btn&#39;,function(e){
    console.log(this);
});
</code></pre><h4 id="4．使用-touchstart-代替-click"><a href="#4．使用-touchstart-代替-click" class="headerlink" title="4．使用 touchstart 代替 click"></a>4．使用 touchstart 代替 click</h4><p>由于移动端屏幕的设计， touchstart 事件和 click 事件触发时间之间存在 300 毫秒的延时，所以在页面中没有实现 touchmove 滚动处理的情况下，可以使用 touchstart 事件来代替元素的 click 事件，加快页面点击的响应速度，提高用户体验。但同时我们也要注意页面重叠元素 touch 动作的点击穿透问题。</p>
<pre><code>//不推荐
$(&#39;body&#39;).on(&#39;click&#39;,&#39;.btn&#39;,function(e){
    console.log(this);
});
//推荐
$(&#39;body&#39;).on(&#39;touchstart&#39;,&#39;.btn&#39;,function(e){
    console.log(this);
});
</code></pre><h4 id="5．避免-touchmove、scroll-连续事件处理"><a href="#5．避免-touchmove、scroll-连续事件处理" class="headerlink" title="5．避免 touchmove、scroll 连续事件处理"></a>5．避免 touchmove、scroll 连续事件处理</h4><p>需要对 touchmove、scroll 这类可能连续触发回调的事件设置事件节流，例如设置每隔 16ms（60 帧的帧间隔为 16.7ms，因此可以合理地设置为 16ms ）才进行一次事件处理，避免频繁的事件调用导致移动端页面卡顿。</p>
<pre><code>//不推荐
$(&#39;.scroller&#39;).on(&#39;touchmove&#39;,&#39;.btn&#39;,function(e){
    console.log(this);
});
//推荐
$(&#39;.scroller&#39;).on(&#39;touchmove&#39;,&#39;.btn&#39;,function(e){
    letself=this;
    setTimeout(function(){
        console.log(self);
    },16);
});
</code></pre><h4 id="6．避免使用-eval、with，使用-join-代替连接符＋，推荐使用-ECMAScript6-的字符串模板"><a href="#6．避免使用-eval、with，使用-join-代替连接符＋，推荐使用-ECMAScript6-的字符串模板" class="headerlink" title="6．避免使用 eval、with，使用 join 代替连接符＋，推荐使用 ECMAScript6 的字符串模板"></a>6．避免使用 eval、with，使用 join 代替连接符＋，推荐使用 ECMAScript6 的字符串模板</h4><p>这些都是一些基础的安全脚本编写问题，尽可能使用较高效率的特性来完成这些操作，避免不规范或不安全的写法。</p>
<h4 id="7．尽量使用-ECMAScript6＋的特性来编程"><a href="#7．尽量使用-ECMAScript6＋的特性来编程" class="headerlink" title="7．尽量使用 ECMAScript6＋的特性来编程"></a>7．尽量使用 ECMAScript6＋的特性来编程</h4><p>ECMAScript6＋ 一定程度上更加安全高效，而且部分特性执行速度更快，也是未来规范的需要，所以推荐使用 ECMAScript6＋ 的新特性来完成后面的开发。</p>
<h3 id="渲染类"><a href="#渲染类" class="headerlink" title="渲染类"></a>渲染类</h3><h4 id="1．使用-Viewport-固定屏幕渲染，可以加速页面渲染内容"><a href="#1．使用-Viewport-固定屏幕渲染，可以加速页面渲染内容" class="headerlink" title="1．使用 Viewport 固定屏幕渲染，可以加速页面渲染内容"></a>1．使用 Viewport 固定屏幕渲染，可以加速页面渲染内容</h4><p>一般认为，在移动端设置 Viewport 可以加速页面的渲染，同时可以避免缩放导致页面重排重绘。在移动端固定 Viewport 设置的方法如下。</p>
<pre><code>&lt;!--设置viewport不缩放--&gt;
&lt;meta&gt;
</code></pre><h4 id="2．避免各种形式重排重绘"><a href="#2．避免各种形式重排重绘" class="headerlink" title="2．避免各种形式重排重绘"></a>2．避免各种形式重排重绘</h4><p>页面的重排重绘很耗性能，所以一定要尽可能减少页面的重排重绘，例如页面图片大小变化、元素位置变化等这些情况都会导致重排重绘。</p>
<h4 id="3．使用-CSS3-动画，开启-GPU-加速"><a href="#3．使用-CSS3-动画，开启-GPU-加速" class="headerlink" title="3．使用 CSS3 动画，开启 GPU 加速"></a>3．使用 CSS3 动画，开启 GPU 加速</h4><p>使用 CSS3 动画时可以设置 transform:translateZ(0) 来开启移动设备浏览器的 GPU 图形处理加速，让动画过程更加流畅，但需要注意的是，在 Native WebView 下 GPU 加速有几率产生 App Crash。</p>
<pre><code>-webkit-transform:translateZ(0);
    -ms-transform:translateZ(0);
     -o-transform:translateZ(0);
        transform:translateZ(0);
</code></pre><h4 id="4．合理使用-Canvas-和-requestAnimationFrame"><a href="#4．合理使用-Canvas-和-requestAnimationFrame" class="headerlink" title="4．合理使用 Canvas 和 requestAnimationFrame"></a>4．合理使用 Canvas 和 requestAnimationFrame</h4><p>选择 Canvas 或 requestAnimationFrame 等更高效的动画实现方式，尽量避免使用 setTimeout、setInterval 等方式来直接处理连续动画。</p>
<h4 id="5．SVG-代替图片"><a href="#5．SVG-代替图片" class="headerlink" title="5．SVG 代替图片"></a>5．SVG 代替图片</h4><p>部分情况下可以考虑使用 SVG 代替图片实现动画，因为使用 SVG 格式内容更小，而且 SVG DOM 结构方便调整。</p>
<h4 id="6．不滥用-float"><a href="#6．不滥用-float" class="headerlink" title="6．不滥用 float"></a>6．不滥用 float</h4><p>在 DOM 渲染树生成后的布局渲染阶段，使用 float 的元素布局计算比较耗性能，所以尽量减少 float 的使用，推荐使用固定布局或 flex-box 弹性布局的方式来实现页面元素布局。</p>
<h4 id="7．不滥用-web-字体或过多-font-size-声明"><a href="#7．不滥用-web-字体或过多-font-size-声明" class="headerlink" title="7．不滥用 web 字体或过多 font-size 声明"></a>7．不滥用 web 字体或过多 font-size 声明</h4><p>过多的 font-size 声明会增加字体的大小计算，而且也没有必要的。</p>
<h4 id="8．做好脚本容错"><a href="#8．做好脚本容错" class="headerlink" title="8．做好脚本容错"></a>8．做好脚本容错</h4><p>脚本容错可以避免「非正常环境」的执行错误影响页面的加载和不相关功能的使用</p>
<h3 id="架构协议类"><a href="#架构协议类" class="headerlink" title="架构协议类"></a>架构协议类</h3><h4 id="1．尝试使用-SPDY-和-HTTP2"><a href="#1．尝试使用-SPDY-和-HTTP2" class="headerlink" title="1．尝试使用 SPDY 和 HTTP2"></a>1．尝试使用 SPDY 和 HTTP2</h4><p>在条件允许的情况下可以考虑使用 SPDY 协议来进行文件资源传输，利用连接复用加快传输过程，缩短资源加载时间。HTTP2 在未来也是可以考虑尝试的。</p>
<h4 id="2．使用后端数据渲染"><a href="#2．使用后端数据渲染" class="headerlink" title="2．使用后端数据渲染"></a>2．使用后端数据渲染</h4><p>使用后端数据渲染的方式可以加快页面内容的渲染展示，避免空白页面的出现，同时可以解决移动端页面 SEO 的问题。如果条件允许，后端数据渲染是一个很不错的实践思路。后面的章节会详细介绍后端数据渲染的相关内容。</p>
<h4 id="3．使用-NativeView-代替-DOM-的性能劣势"><a href="#3．使用-NativeView-代替-DOM-的性能劣势" class="headerlink" title="3．使用 NativeView 代替 DOM 的性能劣势"></a>3．使用 NativeView 代替 DOM 的性能劣势</h4><p>可以尝试使用 NativeView 的 MNV＊ 开发模式来避免 HTML DOM 性能慢的问题，目前使用 MNV＊ 的开发模式已经可以将页面内容渲染体验做到接近客户端 Native 应用的体验了。但需要避免 js Framework 和 native Framework 的频繁交互。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>关于页面优化的常用技术手段和思路主要包括以上这些，尽管列举出很多，但仍可能有少数遗漏，可见前端性能优化不是一件简简单单的事情，其涉及的内容很多。大家可以根据实际情况将这些方法应用到自己的项目当中，要想全部做到几乎是不可能的，但做到用户可接受的原则还是很容易实现的。</p>
<p>另外，如果你有比较好的优化点想要扩充，欢迎下方评论。</p>
]]></content>
      
        <categories>
            
            <category> 前端优化 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 前端优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[列举一些前端优化点---PC端优化]]></title>
      <url>/%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%82%B9---PC%E7%AB%AF%E4%BC%98%E5%8C%96.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>围绕前端的性能多如牛毛，涉及到方方面面，以我我们将围绕 PC 浏览器和移动端浏览器的优化策略进行罗列 注意，是罗列不是展开，遇到不会不懂的点还请站外扩展</p>
</blockquote>
<p>开车速度有点快，坐稳了。</p>
<blockquote>
<p>tips : 这么多前端优化点你都记得住吗？反正我是收藏起来备查的。<br>由于优化点很多，所以分了两篇博客来讲，本篇讲pc端的优化，包括网络加载类, 页面渲染类的优化点。<a href="http://pancakeawesome.ink/%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%82%B9---PC%E7%AB%AF%E4%BC%98%E5%8C%96.html">下篇博客</a> 会讲一下移动端的优化点，<a href="http://pancakeawesome.ink/%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%82%B9---PC%E7%AB%AF%E4%BC%98%E5%8C%96.html">传送门。</a></p>
</blockquote>
<h2 id="PC-浏览器前端优化策略"><a href="#PC-浏览器前端优化策略" class="headerlink" title="PC 浏览器前端优化策略"></a>PC 浏览器前端优化策略</h2><p>PC 端优化的策略很多，如 YSlow（YSlow 是 Yahoo 发布的一款 Firefox 插件，现 Chrome 也可安装，可以对网站的页面性能进行分析，提出对该页面性能优化的建议）原则，或者 Chrome 自带的 Audits 等，总结起来主要包括网络加载类、页面渲染类、CSS 优化类、JavaScript 执行类、缓存类、图片类、架构协议类等几类，下面逐一介绍。</p>
<h3 id="网络加载类"><a href="#网络加载类" class="headerlink" title="网络加载类"></a>网络加载类</h3><h4 id="1．减少-HTTP-资源请求次数"><a href="#1．减少-HTTP-资源请求次数" class="headerlink" title="1．减少 HTTP 资源请求次数"></a>1．减少 HTTP 资源请求次数</h4><p>在前端页面中，通常建议尽可能合并静态资源图片、JavaScript 或 CSS 代码，减少页面请求数和资源请求消耗，这样可以缩短页面首次访问的用户等待时间。通过构建工具合并雪碧图、CSS、JavaScript 文件等都是为了减少 HTTP 资源请求次数。另外也要尽量避免重复的资源，防止增加多余请求。</p>
<h4 id="2．减小-HTTP-请求大小"><a href="#2．减小-HTTP-请求大小" class="headerlink" title="2．减小 HTTP 请求大小"></a>2．减小 HTTP 请求大小</h4><p>除了减少 HTTP 资源请求次数，也要尽量减小每个 HTTP 请求的大小。如减少没必要的图片、JavaScript、CSS 及 HTML 代码，对文件进行压缩优化，或者使用 gzip 压缩传输内容等都可以用来减小文件大小，缩短网络传输等待时延。前面我们使用构建工具来压缩静态图片资源以及移除代码中的注释并压缩，目的都是为了减小 HTTP 请求的大小。</p>
<h4 id="3．将-CSS-或-JavaScript-放到外部文件中，避免使用-style或-script标签直接引入"><a href="#3．将-CSS-或-JavaScript-放到外部文件中，避免使用-style或-script标签直接引入" class="headerlink" title="3．将 CSS 或 JavaScript 放到外部文件中，避免使用 style或 script标签直接引入"></a>3．将 CSS 或 JavaScript 放到外部文件中，避免使用 <code>style</code>或 <code>script</code>标签直接引入</h4><p>在 HTML 文件中引用外部资源可以有效利用浏览器的静态资源缓存，但有时候在移动端页面 CSS 或 JavaScript 比较简单的情况下为了减少请求，也会将 CSS 或 JavaScript 直接写到 HTML 里面，具体要根据 CSS 或 JavaScript 文件的大小和业务的场景来分析。如果 CSS 或 JavaScript 文件内容较多，业务逻辑较复杂，建议放到外部文件引入。</p>
<pre><code>&lt;linkrel=&quot;stylesheet&quot;href=&quot;//cdn.domain.com/path/main.css&quot;&gt;
...
&lt;scriptsrc=&quot;//cdn.domain.com/path/main.js&quot;&gt;&lt;/script&gt;
</code></pre><h4 id="4．避免页面中空的-href-和-src"><a href="#4．避免页面中空的-href-和-src" class="headerlink" title="4．避免页面中空的 href 和 src"></a>4．避免页面中空的 href 和 src</h4><p>当 <code>&lt;link&gt;</code>标签的 href 属性为空，或 <code>&lt;script&gt;</code>、 <code>&lt;img&gt;</code>、 <code>&lt;iframe&gt;</code>标签的 src 属性为空时，浏览器在渲染的过程中仍会将 href 属性或 src 属性中的空内容进行加载，直至加载失败，这样就阻塞了页面中其他资源的下载进程，而且最终加载到的内容是无效的，因此要尽量避免。</p>
<pre><code>&lt;!--不推荐--&gt;
&lt;imgsrc=&quot;&quot;alt=&quot;photo&quot;&gt;
&lt;ahref=&quot;&quot;&gt;点击链接&lt;/a&gt;
</code></pre><h4 id="5．为-HTML-指定-Cache-Control-或-Expires"><a href="#5．为-HTML-指定-Cache-Control-或-Expires" class="headerlink" title="5．为 HTML 指定 Cache-Control 或 Expires"></a>5．为 HTML 指定 Cache-Control 或 Expires</h4><p>为 HTML 内容设置 Cache-Control 或 Expires 可以将 HTML 内容缓存起来，避免频繁向服务器端发送请求。前面讲到，在页面 Cache-Control 或 Expires 头部有效时，浏览器将直接从缓存中读取内容，不向服务器端发送请求。</p>
<pre><code>&lt;metahttp-equiv=&quot;Cache-Control&quot;content=&quot;max-age=7200&quot;&gt;
&lt;metahttp-equiv=&quot;Expires&quot;content=&quot;Mon,20Jul201623:00:00GMT&quot;&gt;
</code></pre><h4 id="6．合理设置-Etag-和-Last-Modified"><a href="#6．合理设置-Etag-和-Last-Modified" class="headerlink" title="6．合理设置 Etag 和 Last-Modified"></a>6．合理设置 Etag 和 Last-Modified</h4><p>合理设置 Etag 和 Last-Modified 使用浏览器缓存，对于未修改的文件，静态资源服务器会向浏览器端返回 304，让浏览器从缓存中读取文件，减少 Web 资源下载的带宽消耗并降低服务器负载。</p>
<pre><code>&lt;metahttp-equiv=&quot;last-modified&quot;content=&quot;Sun,05 Nov 2017 13:45:57 GMT&quot;&gt;
</code></pre><h4 id="7．减少页面重定向"><a href="#7．减少页面重定向" class="headerlink" title="7．减少页面重定向"></a>7．减少页面重定向</h4><p>页面每次重定向都会延长页面内容返回的等待延时，一次重定向大约需要 200 毫秒不等的时间开销（无缓存），为了保证用户尽快看到页面内容，要尽量避免页面重定向。</p>
<h4 id="8．使用静态资源分域存放来增加下载并行数"><a href="#8．使用静态资源分域存放来增加下载并行数" class="headerlink" title="8．使用静态资源分域存放来增加下载并行数"></a>8．使用静态资源分域存放来增加下载并行数</h4><p>浏览器在同一时刻向同一个域名请求文件的并行下载数是有限的，因此可以利用多个域名的主机来存放不同的静态资源，增大页面加载时资源的并行下载数，缩短页面资源加载的时间。通常根据多个域名来分别存储 JavaScript、CSS 和图片文件。</p>
<pre><code>&lt;linkrel=&quot;stylesheet&quot;href=&quot;//cdn1.domain.com/path/main.css&quot;&gt;
...
&lt;scriptsrc=&quot;//cdn2.domain.com/path/main.js&quot;&gt;&lt;/script&gt;
</code></pre><h4 id="9．使用静态资源-CDN-来存储文件"><a href="#9．使用静态资源-CDN-来存储文件" class="headerlink" title="9．使用静态资源 CDN 来存储文件"></a>9．使用静态资源 CDN 来存储文件</h4><p>如果条件允许，可以利用 CDN 网络加快同一个地理区域内重复静态资源文件的响应下载速度，缩短资源请求时间。</p>
<h4 id="10．使用-CDN-Combo-下载传输内容"><a href="#10．使用-CDN-Combo-下载传输内容" class="headerlink" title="10．使用 CDN Combo 下载传输内容"></a>10．使用 CDN Combo 下载传输内容</h4><p>CDN Combo 是在 CDN 服务器端将多个文件请求打包成一个文件的形式来返回的技术，这样可以实现 HTTP 连接传输的一次性复用，减少浏览器的 HTTP 请求数，加快资源下载速度。例如同一个域名 CDN 服务器上的 a.js，b.js，c.js 就可以按如下方式在一个请求中下载。</p>
<pre><code>&lt;scriptsrc=&quot;//cdn.domain.com/path/a.js,b.js,c.js&quot;&gt;&lt;/script&gt;
</code></pre><h4 id="11．使用可缓存的-AJAX"><a href="#11．使用可缓存的-AJAX" class="headerlink" title="11．使用可缓存的 AJAX"></a>11．使用可缓存的 AJAX</h4><p>对于返回内容相同的请求，没必要每次都直接从服务端拉取，合理使用 AJAX 缓存能加快 AJAX 响应速度并减轻服务器压力。</p>
<pre><code>$.ajax({
    url: url,
    type: &#39;get&#39;,
    cache: true,
    //推荐使用缓存
    data: {},
    success() {
        //
        ...
    },
    error() {
        //
        ...
    }
});
</code></pre><h4 id="12．使用-GET-来完成-AJAX-请求"><a href="#12．使用-GET-来完成-AJAX-请求" class="headerlink" title="12．使用 GET 来完成 AJAX 请求"></a>12．使用 GET 来完成 AJAX 请求</h4><p>使用 XMLHttpRequest 时，浏览器中的 POST 方法会发起两次 TCP 数据包传输，首先发送文件头，然后发送 HTTP 正文数据。而使用 GET 时只发送头部，所以在拉取服务端数据时使用 GET 请求效率更高。</p>
<pre><code>$.ajax({
    url: url,
    type: &#39;get&#39;,
    //推荐使用get完成请求
    data: {},
    success() {
        //
        ...
    },
    error() {
        //
        ...
    }
});
</code></pre><h4 id="13．减少-Cookie-的大小并进行-Cookie-隔离"><a href="#13．减少-Cookie-的大小并进行-Cookie-隔离" class="headerlink" title="13．减少 Cookie 的大小并进行 Cookie 隔离"></a>13．减少 Cookie 的大小并进行 Cookie 隔离</h4><p>HTTP 请求通常默认带上浏览器端的 Cookie 一起发送给服务器，所以在非必要的情况下，要尽量减少 Cookie 来减小 HTTP 请求的大小。对于静态资源，尽量使用不同的域名来存放，因为 Cookie 默认是不能跨域的，这样就做到了不同域名下静态资源请求的 Cookie 隔离。</p>
<h4 id="14．缩小-favicon-ico-并缓存"><a href="#14．缩小-favicon-ico-并缓存" class="headerlink" title="14．缩小 favicon.ico 并缓存"></a>14．缩小 favicon.ico 并缓存</h4><p>有利于 favicon.ico 的重复加载，因为一般一个 Web 应用的 favicon.ico 是很少改变的。</p>
<h4 id="15．推荐使用异步-JavaScript-资源"><a href="#15．推荐使用异步-JavaScript-资源" class="headerlink" title="15．推荐使用异步 JavaScript 资源"></a>15．推荐使用异步 JavaScript 资源</h4><p>异步的 JavaScript 资源不会阻塞文档解析，所以允许在浏览器中优先渲染页面，延后加载脚本执行。例如 JavaScript 的引用可以如下设置，也可以使用模块化加载机制来实现。</p>
<pre><code>&lt;scriptsrc=&quot;main.js&quot;defer&gt;&lt;/script&gt;
&lt;scriptsrc=&quot;main.js&quot;async&gt;&lt;/script&gt;
</code></pre><p>使用 async 时，加载和渲染后续文档元素的过程和 main.js 的加载与执行是并行的。使用 defer 时，加载后续文档元素的过程和 main.js 的加载是并行的，但是 main.js 的执行要在页面所有元素解析完成之后才开始执行。</p>
<h4 id="16．消除阻塞渲染的-CSS-及-JavaScript"><a href="#16．消除阻塞渲染的-CSS-及-JavaScript" class="headerlink" title="16．消除阻塞渲染的 CSS 及 JavaScript"></a>16．消除阻塞渲染的 CSS 及 JavaScript</h4><p>对于页面中加载时间过长的 CSS 或 JavaScript 文件，需要进行合理拆分或延后加载，保证关键路径的资源能快速加载完成。</p>
<h4 id="17．避免使用-CSS-import-引用加载-CSS"><a href="#17．避免使用-CSS-import-引用加载-CSS" class="headerlink" title="17．避免使用 CSS import 引用加载 CSS"></a>17．避免使用 CSS import 引用加载 CSS</h4><p>CSS 中的 <code>＠import</code> 可以从另一个样式文件中引入样式，但应该避免这种用法，因为这样会增加 CSS 资源加载的关键路径长度，带有 <code>＠import</code> 的 CSS 样式需要在 CSS 文件串行解析到 <code>@import</code> 时才会加载另外的 CSS 文件，大大延后 CSS 渲染完成的时间。</p>
<pre><code>&lt;!--不推荐--&gt;
&lt;style&gt;
    @import&quot;path/main.css&quot;;
&lt;/style&gt;
&lt;!--推荐--&gt;
&lt;linkrel=&quot;stylesheet&quot;href=&quot;//cdn1.domain.com/path/main.css&quot;&gt;
</code></pre><h3 id="页面渲染类"><a href="#页面渲染类" class="headerlink" title="页面渲染类"></a>页面渲染类</h3><h4 id="1．把-CSS-资源引用放到-HTML-文件顶部"><a href="#1．把-CSS-资源引用放到-HTML-文件顶部" class="headerlink" title="1．把 CSS 资源引用放到 HTML 文件顶部"></a>1．把 CSS 资源引用放到 HTML 文件顶部</h4><p>一般推荐将所有 CSS 资源尽早指定在 HTML 文档 <code>&lt;head&gt;</code> 中，这样浏览器可以优先下载 CSS 并尽早完成页面渲染。</p>
<h4 id="2．JavaScript-资源引用放到-HTML-文件底部"><a href="#2．JavaScript-资源引用放到-HTML-文件底部" class="headerlink" title="2．JavaScript 资源引用放到 HTML 文件底部"></a>2．JavaScript 资源引用放到 HTML 文件底部</h4><p>JavaScript 资源放到 HTML 文档底部可以防止 JavaScript 的加载和解析执行对页面渲染造成阻塞。由于 JavaScript 资源默认是解析阻塞的，除非被标记为异步或者通过其他的异步方式加载，否则会阻塞 HTML DOM 解析和 CSS 渲染的过程。</p>
<h4 id="3．尽量预先设定图片等大小"><a href="#3．尽量预先设定图片等大小" class="headerlink" title="3．尽量预先设定图片等大小"></a>3．尽量预先设定图片等大小</h4><p>在加载大量的图片元素时，尽量预先限定图片的尺寸大小，否则在图片加载过程中会更新图片的排版信息，产生大量的重排</p>
<h4 id="4．不要在-HTML-中直接缩放图片"><a href="#4．不要在-HTML-中直接缩放图片" class="headerlink" title="4．不要在 HTML 中直接缩放图片"></a>4．不要在 HTML 中直接缩放图片</h4><p>在 HTML 中直接缩放图片会导致页面内容的重排重绘，此时可能会使页面中的其他操作产生卡顿，因此要尽量减少在页面中直接进行图片缩放。</p>
<h4 id="5．减少-DOM-元素数量和深度"><a href="#5．减少-DOM-元素数量和深度" class="headerlink" title="5．减少 DOM 元素数量和深度"></a>5．减少 DOM 元素数量和深度</h4><p>HTML 中标签元素越多，标签的层级越深，浏览器解析 DOM 并绘制到浏览器中所花的时间就越长，所以应尽可能保持 DOM 元素简洁和层级较少。</p>
<pre><code>&lt;!--不推荐--&gt;
&lt;div&gt;
    &lt;span&gt;
        &lt;ahref=&quot;javascript:void(0);&quot;&gt;
            &lt;imgsrc=&quot;./path/photo.jpg&quot;alt=&quot;图片&quot;&gt;
        &lt;/a&gt;
    &lt;/span&gt;
&lt;/div&gt;
&lt;!--推荐--&gt;
&lt;imgsrc=&quot;./path/photo.jpg&quot;alt=&quot;图片&quot;&gt;
</code></pre><h4 id="6．尽量避免在选择器末尾添加通配符"><a href="#6．尽量避免在选择器末尾添加通配符" class="headerlink" title="6．尽量避免在选择器末尾添加通配符"></a>6．尽量避免在选择器末尾添加通配符</h4><p>CSS 解析匹配到 渲染树的过程是从右到左的逆向匹配，在选择器末尾添加通配符至少会增加一倍多计算量。</p>
<h4 id="7．减少使用关系型样式表的写法"><a href="#7．减少使用关系型样式表的写法" class="headerlink" title="7．减少使用关系型样式表的写法"></a>7．减少使用关系型样式表的写法</h4><p>直接使用唯一的类名即可最大限度的提升渲染引擎绘制渲染树等效率</p>
<h4 id="8．尽量减少使用-JS-动画"><a href="#8．尽量减少使用-JS-动画" class="headerlink" title="8．尽量减少使用 JS 动画"></a>8．尽量减少使用 JS 动画</h4><p>JS 直接操作 DOM 极容易引起页面的重排</p>
<h4 id="9．CSS-动画使用-translate、scale-代替-top、height"><a href="#9．CSS-动画使用-translate、scale-代替-top、height" class="headerlink" title="9．CSS 动画使用 translate、scale 代替 top、height"></a>9．CSS 动画使用 translate、scale 代替 top、height</h4><p>尽量使用 CSS3 的 translate、scale 属性代替 top、left 和 height、width，避免大量的重排计算</p>
<h4 id="10．尽量避免使用-table、-iframe"><a href="#10．尽量避免使用-table、-iframe" class="headerlink" title="10．尽量避免使用 table、 iframe"></a>10．尽量避免使用 <code>table</code>、 <code>iframe</code></h4><p><code>&lt;table&gt;</code> 内容的渲染是将 table 的 DOM 渲染树全部生成完并一次性绘制到页面上的，所以在长表格渲染时很耗性能，应该尽量避免使用它，可以考虑使用列表元素 <code>&lt;ul&gt;</code> 代替。尽量使用异步的方式动态添加 iframe，因为 iframe 内资源的下载进程会阻塞父页面静态资源的下载与 CSS 及 HTML DOM 的解析。</p>
<h4 id="11．避免运行耗时的-JavaScript"><a href="#11．避免运行耗时的-JavaScript" class="headerlink" title="11．避免运行耗时的 JavaScript"></a>11．避免运行耗时的 JavaScript</h4><p>长时间运行的 JavaScript 会阻塞浏览器构建 DOM 树、DOM 渲染树、渲染页面。所以，任何与页面初次渲染无关的逻辑功能都应该延迟加载执行，这和 JavaScript 资源的异步加载思路是一致的。</p>
<h4 id="12．避免使用-CSS-表达式或-CSS-滤镜"><a href="#12．避免使用-CSS-表达式或-CSS-滤镜" class="headerlink" title="12．避免使用 CSS 表达式或 CSS 滤镜"></a>12．避免使用 CSS 表达式或 CSS 滤镜</h4><p>CSS 表达式或 CSS 滤镜的解析渲染速度是比较慢的，在有其他解决方案的情况下应该尽量避免使用。</p>
<pre><code>//不推荐
.opacity{
    filter : progid :DXImageTransform.Microsoft.Alpha( opacity =50);
}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这样我们就对web前端开发过程中pc端的常用优化点做了粗略的分析，下篇博客讨论一下移动端的常用优化点。<a href="http://pancakeawesome.ink/%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%82%B9---PC%E7%AB%AF%E4%BC%98%E5%8C%96.html">传送门。</a></p>
<p>关于页面优化的常用技术手段和思路主要包括以上这些，尽管列举出很多，但仍可能有少数遗漏，可见前端性能优化不是一件简简单单的事情，其涉及的内容很多。大家可以根据实际情况将这些方法应用到自己的项目当中，要想全部做到几乎是不可能的，但做到用户可接受的原则还是很容易实现的。</p>
<p>另外，如果你有比较好的优化点想要扩充，欢迎下方评论。</p>
]]></content>
      
        <categories>
            
            <category> 前端优化 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 前端优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器「内核」都做了些什么？]]></title>
      <url>/%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%8C%E5%86%85%E6%A0%B8%E3%80%8D%E9%83%BD%E5%81%9A%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>四不四经常有人在你面前念(zhūang)叨(bī)，「这是浏览器内核的问题！Safari[səˈfɑri]的内核不支持！」？</p>
</blockquote>
<p>今天咱们就来聊聊所谓的「内核」！</p>
<p>要讲内核首先要讲浏览器基础，浏览器基础是前端知识网中的一个小分支，也是前端开发人员必须掌握的基础知识点。他贯穿着前端的整个网络体系，项目优化也是围绕着浏览器进行的。</p>
<h2 id="浏览器「内核」都做了些什么？"><a href="#浏览器「内核」都做了些什么？" class="headerlink" title="浏览器「内核」都做了些什么？"></a>浏览器「内核」都做了些什么？</h2><h3 id="一个网址引发的操作"><a href="#一个网址引发的操作" class="headerlink" title="一个网址引发的操作"></a>一个网址引发的操作</h3><p>开发人员在面试的时候或许会被问到：</p>
<p>从你在浏览器输入一个网址到网页内容完全被展示的这段时间内，都发生了什么事情？ 确实是个老生常谈的问题，但问题的答案并不是唯一的，或许在三五年前，这个问题还会有一个「相对」标准的答案。</p>
<ol>
<li><p>浏览器在接收到这个指令时，会开启一个单独的线程来处理这个指令，首先要判断用户输入的是否为合法或合理的 URL 地址，是否为 HTTP 协议请求，如果是那就进入下一步</p>
</li>
<li><p>浏览器的浏览器引擎将对此 URL 进行分析，如果存在缓存「cache-control」且未过期，则会从本地缓存提取文件（From Memory Cache，200返回码），如果缓存「cache-control」不存在或过期，浏览器将发起远程请求</p>
</li>
<li><p>通过 DNS 解析域名获取该网站地址对应的 IP 地址，连同浏览器的 Cookie、 userAgent 等信息向此 IP 发出 GET 请求。</p>
</li>
<li><p>接下来就是经典的「三次握手」，HTTP 协议会话，浏览器客户端向 Web 服务器发送报文，进行通讯和数据传输。</p>
</li>
<li><p>进入网站的后端服务，如 Tomcat、Apache 等，还有近几年流行的 Node.js 服务器，这些服务器上部署着应用代码，语言有很多，如 Java、 PHP、 C++、 C# 和 Javascript 等。</p>
</li>
<li><p>服务器根据 URL 执行相应的后端应用逻辑，期间会使用到「服务器缓存」或「数据库」。</p>
</li>
<li><p>服务器处理请求并返回响应报文，如果浏览器访问过该页面，缓存上有对应资源，与服务器最后修改记录对比，一致则返回 304，否则返回 200 和对应的内容。</p>
</li>
<li><p>浏览器接收到返回信息并开始下载该 HTML文件（无缓存、200返回码）或从本地缓存提取文件（有缓存、304返回码）</p>
</li>
<li><p>浏览器的渲染引擎在拿到 HTML 文件后，便开始解析构建 DOM 树，并根据 HTML 中的标记请求下载指定的 MIME 类型文件（如 CSS、 JavaScript 脚本等），同时使用&amp;设置缓存等内容。</p>
</li>
<li><p>渲染引擎根据 CSS 样式规则将 DOM 树扩充为渲染树，然后进行重排、重绘。</p>
</li>
<li><p>如果含有 JS 文件将会执行，进行 Dom 操作、缓存读存、事件绑定等操作。最终页面将被展示在浏览器上。</p>
</li>
</ol>
<p>此答案精简的概括了「后端为主的 MVC 模式」及早期 Web 应用的浏览器响应的全过程。前端技术发展到现在，「前后端分离」「中间件直出」和「MNV*模式」也已问世，再谈及此问题，答案会有所不同。</p>
<p>就以「前后端分离」为例，在上方答案的第4步后，紧接着就不会直接进入后端服务器了。而会被 HTTP 和反向代理服务器，如 Ngnix，拦截。</p>
<ul>
<li><p>前置步骤1、2、3、4</p>
</li>
<li><p>Ngnix 在监听到 HTTP（80端口）或 HTTPS（443端口）请求，根据 URL 做服务分发，分发（rewrite）到后端服务器或静态资源服务器，首页请求基本是分发到静态服务器，返回一个 HTML 文件</p>
</li>
<li><p>步骤7、8、9、10</p>
</li>
<li><p>执行 JS 脚本，异步 ajax、 fetch 发起 POST、 GET 请求，重新进入 Ngnix 分发，此次分发到后端服务器，步骤5、6、7，然后返回一个 xml 或 json 格式的信息，一般含有 code（返回码）和 result（依赖信息）</p>
</li>
<li><p>js 回调根据返回码执行不同的逻辑，增删改页面元素，此时可能会发生重排或重绘。首页加载结束。</p>
</li>
</ul>
<p>从以上步骤可以发现，浏览器可能会触发两次重绘，极易产生「白屏」或「页面抖动」现象，为了解决这个问题「中间件直出」的模式应运而生。另外为了扩充大前端的阵营，吸纳 IOS 和 Android，Google 设计了「MNV*模式」，典型代表就是 ReactNative，但此模式已经脱离了浏览器的范畴，此处就不再做扩展。</p>
<p>以上讨论的渲染过程中使用到了较多的浏览器功能，如用户地址栏输入框、网络请求、浏览器文档解析、渲染引擎渲染网页、 JavaScript 引擎执行 js 脚本、客户端存储等。 接下来我们介绍下浏览器的基本结构组成。</p>
<h3 id="浏览器的结构组成"><a href="#浏览器的结构组成" class="headerlink" title="浏览器的结构组成"></a>浏览器的结构组成</h3><p>浏览器一般由七个模块组成，User Interface（用户界面）、Browser engine（浏览器引擎）、Rendering engine（渲染引擎）、Networking（网络）、JavaScript Interpreter（js解释器）、UI Backend（UI 后端）、Date Persistence（数据持久化存储） 如下图：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fllfkpe04bj30eo09z74c.jpg" alt=""></p>
<ul>
<li><p><strong>用户界面</strong> －包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了页面显示窗口之外的其他部分</p>
</li>
<li><p><strong>浏览器引擎</strong> －可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据等，是浏览器中各个部分之间相互通信的核心</p>
</li>
<li><p><strong>渲染引擎</strong> －解析DOM文档和CSS规则并将内容排版到浏览器中显示有样式的界面，也有人称之为排版引擎，我们常说的浏览器内核主要指的就是渲染引擎</p>
</li>
<li><p><strong>网络</strong> －用来完成网络调用或资源下载的模块</p>
</li>
<li><p><strong>UI 后端</strong> －用来绘制基本的浏览器窗口内控件，如输入框、按钮、单选按钮等，根据浏览器不同绘制的视觉效果也不同，但功能都是一样的。</p>
</li>
<li><p><strong>JS解释器</strong> －用来解释执行JS脚本的模块，如 V8 引擎、JavaScriptCore</p>
</li>
<li><p><strong>数据存储</strong> －浏览器在硬盘中保存 cookie、localStorage等各种数据，可通过浏览器引擎提供的API进行调用</p>
</li>
</ul>
<p>作为前端开发人员，我们需要重点理解渲染引擎的工作原理，灵活应用数据存储技术，在实际项目开发中会经常涉及到这两个部分，尤其是在做项目性能优化时，理解浏览器渲染引擎的工作原理尤为重要。而其他部分则是由浏览器自行管理的，开发者能控制的地方较少。今天我们就围绕这两个重点其中的一个部分「浏览器渲染引擎」也就是进行展开，「浏览器内核」。</p>
<h3 id="浏览器渲染引擎"><a href="#浏览器渲染引擎" class="headerlink" title="浏览器渲染引擎"></a>浏览器渲染引擎</h3><p>浏览器渲染引擎是由各大浏览器厂商依照 W3C 标准自行研发的，也被称之为「浏览器内核」。</p>
<p>目前，市面上使用的主流浏览器内核有5类：Trident、Gecko、Presto、Webkit、Blink。</p>
<p><strong>Trident</strong>：俗称 IE 内核，也被叫做 MSHTML 引擎，目前在使用的浏览器有 IE11 -，以及各种国产多核浏览器中的IE兼容模块。另外微软的 Edge 浏览器不再使用 MSHTML 引擎，而是使用类全新的引擎 EdgeHTML。</p>
<p><strong>Gecko</strong>：俗称 Firefox 内核，Netscape6 开始采用的内核，后来的 Mozilla FireFox（火狐浏览器）也采用了该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko 内核的浏览器也很多，这也是 Gecko 内核虽然年轻但市场占有率能够迅速提高的重要原因。</p>
<p><strong>Presto</strong>：Opera 前内核，为啥说是前内核呢？因为 Opera12.17 以后便拥抱了 Google Chrome 的 Blink 内核，此内核就没了寄托</p>
<p><strong>Webkit</strong>：Safari 内核，也是 Chrome 内核原型，主要是 Safari 浏览器在使用的内核，也是特性上表现较好的浏览器内核。也被大量使用在移动端浏览器上。</p>
<p><strong>Blink</strong>： 由 Google 和 Opera Software 开发，在Chrome（28及往后版本）、Opera（15及往后版本）和Yandex浏览器中使用。Blink 其实是 Webkit 的一个分支，添加了一些优化的新特性，例如跨进程的 iframe，将 DOM 移入 JavaScript 中来提高 JavaScript 对 DOM 的访问速度等，目前较多的移动端应用内嵌的浏览器内核也渐渐开始采用 Blink。</p>
<h3 id="渲染引擎的工作流程"><a href="#渲染引擎的工作流程" class="headerlink" title="渲染引擎的工作流程"></a>渲染引擎的工作流程</h3><p>浏览器渲染引擎最重要的工作就是将 HTML 和 CSS 文档解析组合最终渲染到浏览器窗口上。如下图所示，渲染引擎在接受到 HTML 文件后主要进行了以下操作：解析 HTML 构建 DOM 树 -&gt; 构建渲染树 -&gt; 渲染树布局 -&gt; 渲染树绘制。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fllfkzy0elj30hr02gmx3.jpg" alt=""></p>
<p>解析 HTML 构建 DOM 树时渲染引擎会将 HTML 文件的便签元素解析成多个 DOM 元素对象节点，并且将这些节点根据父子关系组成一个树结构。同时 CSS 文件被解析成 CSS 规则表，然后将每条 CSS 规则按照「从右向左」的方式在 DOM 树上进行逆向匹配，生成一个具有样式规则描述的 DOM 渲染树。接下来就是将渲染树进行布局、绘制的过程。首先根据 DOM 渲染树上的样式规则，对 DOM 元素进行大小和位置的定位，关键属性如 <code>position;width;margin;padding;top;border;...</code>，接下来再根据元素样式规则中的 <code>color;background;shadow;...</code>规则进行绘制。</p>
<p>另外，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<p>再者，需要注意的是，在浏览器渲染完首屏页面后，如果对 DOM 进行操作会引起浏览器引擎对 DOM 渲染树的重新布局和重新绘制，我们叫做「重排」和「重绘」，由于重排和重绘是前后依赖的关系，重绘发生时未必会触发渲染引擎的重排，但是如果发生了重排就必然会触发重绘操作，这样带来的性能损害就是巨大的。因此我们在做性能优化的时候应该遵循「避免重排；减少重绘」的原则。</p>
<h3 id="不同浏览器内核间的差异"><a href="#不同浏览器内核间的差异" class="headerlink" title="不同浏览器内核间的差异"></a>不同浏览器内核间的差异</h3><p>在不同的浏览器内核下， 浏览器页面渲染的流程略有不同</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fllflc4s2xj30hj08e74d.jpg" alt=""></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fllfm1l1b1j30hq08f0tj.jpg" alt=""> </p>
<p>上面两幅图分别是 Webkit 和 Geoko 内核渲染 DOM 的工作流程，对比可以看出，两者的区别主要在于 CSS 样式表的解析时机，Webkit 内核下，HTML 和 CSS 文件的解析是同步的，而 Geoko 内核下，CSS 文件需要等到 HTML 文件解析成内容 Sink 后才进行解析。</p>
<p>另外描述术语也有不同，除此之外两者的流程就基本相同了，其中最重要的三个部分就是 「HTML 的解析」「CSS 的解析」「渲染树的生成」。这三个部分的原理比较深，会涉及到「词法分析」「语法分析」「转换」「解释」等数据结构的知识，比较枯燥，一般我们了解到这里就够了，想深入了解的同学可以阅读此篇译文，浏览器的工作原理，里面详细的解释了以上三个部分的流程和原理。此处就不再多做赘述了。</p>
<h3 id="关于-CSS-规则的匹配"><a href="#关于-CSS-规则的匹配" class="headerlink" title="关于 CSS 规则的匹配"></a>关于 CSS 规则的匹配</h3><p>上面我们提到过， CSS 规则是按照「从右向左」的方式在 DOM 树上进行逆向匹配的，最终生成一个具有样式规则描述的 DOM 渲染树。</p>
<p>但是你知道为什么要「从右向左」做逆向匹配吗？</p>
<p>我们重新回看【webkit 内核工作流程图】</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fllfmecm8zj30hs08d74d.jpg" alt=""></p>
<p>CSS 规则匹配是发生在webkit引擎的「Attachment」过程中，浏览器要为每个 DOM Tree 中的元素扩充 CSS 样式规则（匹配 Style Rules）。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。</p>
<p>我们来举一个最简单的栗子：</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;divclass=&quot;t&quot;&gt;
            &lt;span&gt;test&lt;/span&gt;
            &lt;p&gt;test&lt;/p&gt;
            &lt;div&gt;
            &lt;/div&gt;
&lt;/template&gt;
&lt;style&gt;
div {
    color: #000;
}

div .t span {
    color: red;
}

div .t p {
    color: blue;
}
&lt;/style&gt;
</code></pre><p>此处我们有一个 html 元素 和一个 style 元素，两者需要做遍历匹配</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fllfmlb3g2j30hg08xglk.jpg" alt=""></p>
<p>此处会有 4*3 个匹配项，如果做正向匹配，在遇到 <code>&lt;span&gt;</code> 标签匹配 <code>div .t p{color: red; }</code> 到匹配项时，计算机首先要找到 <code>&lt;span&gt;</code> 标签的父标签和祖父标签，判断他们是否满足 <code>div .t</code>的规则，然后再匹配 <code>&lt;span&gt;</code>是否为 <code>p</code>标签，此处匹配不成功，产生了三次浪费。</p>
<p>如果时逆向匹配，那么第一次对比是否为p标签便可排除此规则，效率更高。</p>
<p>如果将 HTML 结构变复杂，CSS 规则表变庞大，那么，「逆向匹配」的优势就远大于「正向匹配」了，因为匹配的情况远远低于不匹配的情况。另外，如果在选择器结尾加上通配符「*」，那么「逆向匹配」的优势就大打折扣了，这也就是很多优化原则提到的「尽量避免在选择器末尾添加通配符」的原因。</p>
<p>极限了想，如果我们的样式表不存在嵌套关系，如下：</p>
<pre><code>&lt;template&gt;
    &lt;divclass=&quot;t&quot;&gt;
        &lt;spanclass=&quot;div_t_span&quot;&gt;test&lt;/span&gt;
            &lt;pclass=&quot;div_t_p&quot;&gt;test&lt;/p&gt;
                &lt;div&gt;
&lt;/template&gt;
&lt;style&gt;
div {
    color: #000;
}

.div_t_span {
    color: red;
}

.div_t_p {
    color: blue;
}
&lt;/style&gt;
</code></pre><p>那么引擎的「Attachment」过程将得到极大的精简，效率也是可想而知的，这就是为什么「微信小程序」样式表不建议使用关系行写法的原因。</p>
<h3 id="相关的性能优化"><a href="#相关的性能优化" class="headerlink" title="相关的性能优化"></a>相关的性能优化</h3><p>我们大致可以在以上案例中看到同浏览器渲染引擎相关的可行优化点。</p>
<p>大致为以下几种</p>
<h4 id="减少-JS-加载对-Dom-渲染的影响"><a href="#减少-JS-加载对-Dom-渲染的影响" class="headerlink" title="减少 JS 加载对 Dom 渲染的影响"></a>减少 JS 加载对 Dom 渲染的影响</h4><p>将 JS 文件放在 HTML 文档后加载，或者使用异步的方式加载 JS 代码</p>
<h4 id="避免重排，减少重绘"><a href="#避免重排，减少重绘" class="headerlink" title="避免重排，减少重绘"></a>避免重排，减少重绘</h4><p>在做 css 动画的时候减少使用 width、 margin、 padding 等影响 CSS 布局对规则，可以使用 CSS3 的 transform 代替。另外值得注意的是，在加载大量的图片元素时，尽量预先限定图片的尺寸大小，否则在图片加载过程中会更新图片的排版信息，产生大量的重排。</p>
<h4 id="减少使用关系型样式表的写法"><a href="#减少使用关系型样式表的写法" class="headerlink" title="减少使用关系型样式表的写法"></a>减少使用关系型样式表的写法</h4><p>直接使用唯一的类名即可最大限度的提升渲染效率，另外尽量避免在选择器末尾添加通配符</p>
<h4 id="减少-DOM-的层级"><a href="#减少-DOM-的层级" class="headerlink" title="减少 DOM 的层级"></a>减少 DOM 的层级</h4><p>减少无意义的 dom 层级可以减少 渲染引擎 Attachment 过程中的匹配计算量</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我所认识的JavaScript正则表达式]]></title>
      <url>/%E6%88%91%E6%89%80%E8%AE%A4%E8%AF%86%E7%9A%84JavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果说这是一篇关于正则表达式的小结，我更愿意把它当做一个手册。</p>
<h2 id="我所认识的JavaScript正则表达式"><a href="#我所认识的JavaScript正则表达式" class="headerlink" title="我所认识的JavaScript正则表达式"></a>我所认识的JavaScript正则表达式</h2><h3 id="RegExp-三大方法"><a href="#RegExp-三大方法" class="headerlink" title="RegExp 三大方法"></a>RegExp 三大方法</h3><p>本文的RegExp采用直接量语法表示：/pattern/attributes。attributes有三个选择，i、m和g，m（多行匹配）不常用直接省略，所以一个pattern（匹配模式）可以表示如下：</p>
<pre><code>var pattern =/hello/ig;
</code></pre><p>i（ignore）表示不区分大小写（地搜索匹配），比较简单，以下例子中不加述说；g（global）表示全局（搜索匹配），即找到一个后继续找下去，相对复杂，以下各种方法中会特别介绍。</p>
<p>既然是RegExp的三大方法，所以都是pattern.test/exec/complie的格式。</p>
<p>主要功能：检测指定字符串是否含有某个子串（或者匹配模式），返回true或者false。</p>
<p>示例如下：</p>
<pre><code>var s = &#39;you love me and I love you&#39;;
var pattern = /you/;
var ans = pattern.test(s);
console.log(ans);
// true
</code></pre><p>如果attributes用了g，则可以继续找下去，其中还会涉及lastIndex属性（参照exec中搭配g的介绍）。</p>
<p>主要功能：提取指定字符串中的符合要求的子串（或者匹配模式），返回一个数组存放匹配结果；如果没有，则返回null。（也可自己写方法循环提取所有或者指定index的数据）</p>
<p>exec可以说是test的升级版本，因为它不仅可以检测，而且检测到了可以直接提取结果。</p>
<p>示例如下：</p>
<pre><code>var s = &#39;you love me and I love you&#39;;
var pattern = /you/;
var ans = pattern.exec(s);
console.log(ans);
// [&quot;you&quot;, index: 0, input: &quot;you love me and I love you&quot;]
console.log(ans.index);
// 0
console.log(ans.input);
// you love me and I love you
</code></pre><p>输出的东西很有意思。此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。</p>
<p>啥叫“与子表达式相匹配的文本”？看下面的例子：</p>
<pre><code>var s = &#39;you love me and I love you&#39;;
var pattern = /y(o?)u/;
var ans = pattern.exec(s);
console.log(ans);
// [&quot;you&quot;, &quot;o&quot;, index: 0, input: &quot;you love me and I love you&quot;]
console.log(ans.length)
// 2
</code></pre><p>所谓的子表达式就是pattern里（）内的东西（具体可以参考下文对子表达式的介绍）。再看上面例子的数组长度，是2！！index和input只是数组属性（chrome中以上的输出可能会让人误会）。</p>
<p>除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。我们可以看得出，<strong>在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的</strong>。</p>
<p>如果使用 “g” 参数，exec() 的工作原理如下（还是以上的例子 ps：如果test使用g参数类似）：</p>
<ol>
<li>找到第一个 “you”，并存储其位置</li>
<li>如果再次运行 exec()，则从存储的位置（lastIndex）开始检索，并找到下一个 “you”，并存储其位置</li>
</ol>
<p>当 RegExpObject 是一个全局正则表达式时，exec() 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，我们可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。这里引入lastIndex属性，这货只有跟g和test（或者g和exec）三者搭配时才有作用。它是pattern的一个属性，一个整数，标示开始下一次匹配的字符位置。</p>
<p>实例如下：</p>
<pre><code>var s = &#39;you love me and I love you&#39;;
var pattern = /you/g;
var ans;
do {
    ans = pattern.exec(s);
    console.log(ans);
    console.log(pattern.lastIndex);
} while (ans !== null)
</code></pre><p>结果如下：</p>
<p><img src="https://img.funteas.com/a301222db5d77dd9038aa49a6fa50a74.png?imageView2/2/w/800" alt=""></p>
<p>应该还容易理解，当第三次循环时，找不到“you”了，于是返回null，lastIndex值也变成0了。</p>
<p>如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串（仍然使用旧的pattern），就必须手动地把 lastIndex 属性重置为 0。</p>
<p>主要功能：改变当前匹配模式（pattern）</p>
<p>这货是改变匹配模式时用的，用处不大，略过。详见JavaScript compile() 方法</p>
<h3 id="String-四大护法"><a href="#String-四大护法" class="headerlink" title="String 四大护法"></a>String 四大护法</h3><p>和RegExp三大方法分庭抗礼的是String的四大护法，四大护法有些和RegExp三大方法类似，有的更胜一筹。</p>
<p>既然是String家族下的四大护法，所以肯定是string在前，即str.search/match/replace/split形式。</p>
<p>既然是String的方法，当然参数可以只用字符串而不用pattern。</p>
<p>主要功能：搜索指定字符串中是否含有某子串（或者匹配模式），如有，返回子串在原串中的初始位置，如没有，返回-1。</p>
<p>是不是和test类似呢？test只能判断有木有，search还能返回位置！当然test()如果有需要能继续找下去，而search则会自动忽略g（如果有的话）。实例如下：</p>
<pre><code>var s = &#39;you love me and I love you&#39;;
var pattern = /you/;
var ans = s.search(pattern);
console.log(ans);
// 0
</code></pre><p>话说和String的indexOf方法有点相似，不同的是indexOf方法可以从指定位置开始查找，但是不支持正则。</p>
<p>主要功能：和exec类似，从指定字符串中查找子串或者匹配模式，找到返回数组，没找到返回null</p>
<p>match是exec的轻量版，当不使用全局模式匹配时，match和exec返回结果一致；当使用全局模式匹配时，match直接返回一个字符串数组，获得的信息远没有exec多，但是使用方式简单。</p>
<p>实例如下：</p>
<pre><code>var s =&#39;you love me and I love you&#39;;
console.log(s.match(/you/));
// [&quot;you&quot;, index: 0, input: &quot;you love me and I love you&quot;]
console.log(s.match(/you/g));
// [&quot;you&quot;, &quot;you&quot;]
</code></pre><p>主要功能：用另一个子串替换指定字符串中的某子串（或者匹配模式），返回替换后的新的字符串  str.replace(‘搜索模式’,’替换的内容’)  如果用的是pattern并且带g，则全部替换；否则替换第一处。</p>
<p>实例如下：</p>
<pre><code>var s =&#39;you love me and I love you&#39;;
console.log(s.replace(&#39;you&#39;,&#39;zichi&#39;));
// zichi love me and I love you
console.log(s.replace(/you/,&#39;zichi&#39;));
// zichi love me and I love you
console.log(s.replace(/you/g,&#39;zichi&#39;));
// zichi love me and I love zichi
</code></pre><p>如果需要替代的内容不是指定的字符串，而是跟匹配模式或者原字符串有关，那么就要用到$了（记住这些和$符号有关的东东只和replace有关哦）。</p>
<p><img src="https://img.funteas.com/af7727482590a48709ff28d8de0d1dd2.png?imageView2/2/w/800" alt=""></p>
<p>怎么用？看个例子就明白了。</p>
<pre><code>var s = &#39;I love you&#39;;
var pattern = /love/;
var ans = s.replace(pattern, &#39;&lt;div class=&quot;article-entry&quot; id=&quot;article-entry&quot;&#39; + &#39;&gt;&lt;&#39; + &quot;/div&gt;&quot;);
console.log(ans);
// I I love you you
</code></pre><p>没错，’<div class="“article-entry”" id="“article-entry”’" +="" ‘="">&lt;’ + “$’”其实就相当于原串了！</div></p>
<p>replace的第二个参数还能是函数，看具体例子前先看一段介绍：</p>
<blockquote>
<p>注意：第一个参数是匹配到的子串，接下去是子表达式匹配的值，如果要用子表达式参数，则必须要有第一个参数（表示匹配到的串），也就是说，如果要用第n个参数代表的值，则左边参数都必须写出来。最后两个参数跟exec后返回的数组的两个属性差不多。</p>
</blockquote>
<pre><code>var s = &#39;I love you&#39;;
var pattern = /love/;
var ans = s.replace(pattern, function(a) {　　 
// 只有一个参数，默认为匹配到的串（如还有参数，则按序表示子表达式和其他两个参数）
    return a.toUpperCase();
});
console.log(ans);
// I LOVE you
</code></pre><p>主要功能：分割字符串</p>
<p>字符串分割成字符串数组的方法（另有数组变成字符串的join方法）。直接看以下例子：</p>
<pre><code>var s = &#39;you love me and I love you&#39;;
var pattern = &#39;and&#39;;
var ans = s.split(pattern);
console.log(ans);
// [&quot;you love me &quot;, &quot; I love you&quot;]
</code></pre><p>如果你嫌得到的数组会过于庞大，也可以自己定义数组大小，加个参数即可：</p>
<pre><code>var s = &#39;you love me and I love you&#39;;
var pattern = /and/;
var ans = s.split(pattern, 1);
console.log(ans);
// [&quot;you love me &quot;]
</code></pre><h3 id="RegExp-字符"><a href="#RegExp-字符" class="headerlink" title="RegExp 字符"></a>RegExp 字符</h3><p><img src="https://img.funteas.com/0f972256c0d7f457495addfb48b46aec.png?imageView2/2/w/800" alt=""><img src="https://img.funteas.com/452f237aaa6135b99502df770729c0f2.png?imageView2/2/w/800" alt=""><img src="https://img.funteas.com/7002103ee3659d4c5453949a4d1b528b.png?imageView2/2/w/800" alt=""></p>
<ul>
<li>\s 任意空白字符 \S相反 空白字符可以是： 空格符 (space character) 制表符 (tab character) 回车符 (carriage return character) 换行符 (new line character) 垂直换行符 (vertical tab character) 换页符 (form feed character)</li>
<li>\b是正则表达式规定的一个特殊代码，代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。（和^ $ 以及零宽断言类似）</li>
<li>\w 匹配字母或数字或下划线   [a-z0-9A-Z_]完全等同于\w</li>
</ul>
<h3 id="贪婪匹配和懒惰匹配"><a href="#贪婪匹配和懒惰匹配" class="headerlink" title="贪婪匹配和懒惰匹配"></a>贪婪匹配和懒惰匹配</h3><p>什么是贪婪匹配？贪婪匹配就是在正则表达式的匹配过程中，默认会使得匹配长度越大越好。</p>
<pre><code>var s = &#39;hello world welcome to my world&#39;;
var pattern = /hello.*world/;
var ans = pattern.exec(s);
console.log(ans)
// [&quot;hello world welcome to my world&quot;, index: 0, input: &quot;hello world welcome to my world&quot;]
</code></pre><p>以上例子不会匹配最前面的<a href="http://link.funteas.com/?target=http%3A%2F%2Fwww.codeceo.com%2Farticle%2Fhello-world-30-years.html" target="_blank" rel="noopener">Hello World</a> (title=undefined target=undefined)，而是一直贪心的往后匹配。</p>
<p>那么我需要最短的匹配怎么办？很简单，加个‘？’即可，这就是传说中的懒惰匹配，即匹配到了，就不往后找了。</p>
<pre><code>var s = &#39;hello world welcome to my world&#39;;
var pattern = /hello.*?world/;
var ans = pattern.exec(s);
console.log(ans)
// [&quot;hello world&quot;, index: 0, input: &quot;hello world welcome to my world&quot;]
</code></pre><p><strong>懒惰限定符（？）添加的场景如下：</strong></p>
<p><img src="https://img.funteas.com/bfed54f78ebb16f531dbb785782e7a7f.png?imageView2/2/w/800" alt=""></p>
<h3 id="子表达式"><a href="#子表达式" class="headerlink" title="子表达式"></a>子表达式</h3><p>用一个小括号指定：</p>
<pre><code>var s = &#39;hello world&#39;;
var pattern = /(hello)/;
var ans = pattern.exec(s);
console.log(ans);
</code></pre><p>在exec中数组输出子表达式所匹配的值：</p>
<pre><code>var s = &#39;hello world&#39;;
var pattern = /(h(e)llo)/;
var ans = pattern.exec(s);
console.log(ans);
// [&quot;hello&quot;, &quot;hello&quot;, &quot;e&quot;, index: 0, input: &quot;hello world&quot;]
</code></pre><p>在replace中作为替换值引用：</p>
<pre><code>var s = &#39;hello world&#39;;
var pattern = /(h\w*o)\s*(w\w*d)/;
var ans = s.replace(pattern, &#39;$2 $1&#39;)
console.log(ans);
// world hello
</code></pre><p>后向引用 &amp; 零宽断言</p>
<p>简单地说：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p>
<p>复杂地说：分组0对应整个正则表达式实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号。可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．</p>
<h3 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h3><p>如果我们要找连续两个一样的字符，比如要找两个连续的c，可以这样/c{2}/，如果要找两个连续的单词hello，可以这样/(hello){2}/，但是要在一个字符串中找连续两个相同的任意单词呢，比如一个字符串hellohellochinaworldworld，我要找的是hello和world，怎么找？</p>
<p>这时候就要用后向引用。看具体例子：</p>
<pre><code>var s = &#39;hellohellochinaworldworld&#39;;
var pattern = /(\w+)\1/g;
var a = s.match(pattern);
console.log(a);
// [&quot;hellohello&quot;, &quot;worldworld&quot;]
</code></pre><p>这里的\1就表示和匹配模式中的第一个子表达式（分组）一样的内容，\2表示和第二个子表达式（如果有的话）一样的内容，\3 \4 以此类推。（也可以自己命名，详见参考文献）</p>
<p>或许你觉得数组里两个hello两个world太多了，我只要一个就够了，就又要用到子表达式了。因为match方法里是不能引用子表达式的值的，我们回顾下哪些方法是可以的？没错，exec和replace是可以的！</p>
<p><strong>exec方式：</strong></p>
<pre><code>var s = &#39;hellohellochinaworldworld&#39;;
var pattern = /(\w+)\1/g;
var ans;
do {
    ans = pattern.exec(s);
    console.log(ans);
} while (ans !== null);
// result
// [&quot;hellohello&quot;, &quot;hello&quot;, index: 0, input: &quot;hellohellochinaworldworld&quot;] index.html:69
// [&quot;worldworld&quot;, &quot;world&quot;, index: 15, input: &quot;hellohellochinaworldworld&quot;] index.html:69// null
</code></pre><p>如果输出只要hello和world，console.log(ans[1])即可。</p>
<p><strong>replace方式：</strong></p>
<pre><code>var s = &#39;hellohellochinaworldworld&#39;;
var pattern = /(\w+)\1/g;
var ans = [];
s.replace(pattern, function(a, b) {
    ans.push(b);
});
console.log(ans);
// [&quot;hello&quot;, &quot;world&quot;]
</code></pre><p>如果要找连续n个相同的串，比如说要找出一个字符串中出现最多的字符：</p>
<pre><code>String.prototype.getMost = function() {
    var a = this.split(&#39;&#39;);
    a.sort();
    var s = a.join(&#39;&#39;);
    var pattern = /(\w)\1*/g;
    var a = s.match(pattern);
    a.sort(function(a, b) { return a.length &lt; b.length; });
    var letter = a[0][0];
    var num = a[0].length;
    return letter + &#39;: &#39; + num;
}
var s = &#39;aaabbbcccaaabbbcccccc&#39;;
console.log(s.getMost());
// c: 9
</code></pre><p>如果需要引用某个子表达式（分组），请认准后向引用！</p>
<h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><p>别被名词吓坏了，其实解释很简单。</p>
<p>它们用于查找在某些内容(但并不包括这些内容)之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)</p>
<p>零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。</p>
<pre><code>// 获取字符串中以ing结尾的单词的前半部分
var s = &#39;I love dancing but he likes singing&#39;;
var pattern = /\b\w+(?=ing\b)/g;
var ans = s.match(pattern);
console.log(ans);
// [&quot;danc&quot;, &quot;sing&quot;]
</code></pre><p>零宽度负预测先行断言，断言此位置的后面不能匹配表达式exp</p>
<pre><code>// 获取第五位不是i的单词的前四位
var s = &#39;I love dancing but he likes singing&#39;;
var pattern = /\b\w{4}(?!i)/g;
var ans = s.match(pattern);
console.log(ans);
// [&quot;love&quot;, &quot;like&quot;]
</code></pre><p>javascript正则只支持前瞻，不支持后瞻（(?&lt;=exp)和(?</p>
<p>关于零宽断言的具体应用可以参考综合应用一节给字符串加千分符。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>因为某些字符已经被正则表达式用掉了，比如. * ( ) / \  []，所以需要使用它们（作为字符）时，需要用\转义</p>
<pre><code>var s = &#39;http://www.cnblogs.com/zichi/&#39;;
var pattern = /http:\/\/www\.cnblogs\.com\/zichi\//;
var ans = pattern.exec(s);
console.log(ans);
// [&quot;http://www.cnblogs.com/zichi/&quot;, index: 0, input: &quot;http://www.cnblogs.com/zichi/&quot;]
</code></pre><p>如果需要匹配abc里的任意字母，可以用[abc]，但是如果不是单个字母那么简单，就要用到分支条件。</p>
<p>分支条件很简单，就是用|表示符合其中任意一种规则。</p>
<pre><code>var s = &quot;I don&#39;t like you but I love you&quot;;
var pattern = /I.*(like|love).*you/g;
var ans = s.match(pattern);
console.log(ans);
// [&quot;I don&#39;t like you but I love you&quot;]
</code></pre><p>答案执行了贪婪匹配，如果需要懒惰匹配，则：</p>
<pre><code>var s = &quot;I don&#39;t like you but I love you&quot;;
var pattern = /I.*?(like|love).*?you/g;
var ans = s.match(pattern);
console.log(ans);
// [&quot;I don&#39;t like you&quot;, &quot;I love you&quot;]
</code></pre><h3 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h3><pre><code>String.prototype.trim = function() {
returnthis.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
};
var s = &#39;    hello  world     &#39;;
var ans = s.trim();
console.log(ans.length);
// 12
</code></pre><pre><code>String.prototype.getAns = function() { var pattern = /(?=((?!\b)\d{3})+$)/g;
    returnthis.replace(pattern, &#39;,&#39;); }
var s = &#39;123456789&#39;;
console.log(s.getAns());
// 123,456,789
</code></pre><pre><code>String.prototype.getMost = function() {
    var a = this.split(&#39;&#39;);
    a.sort();
    var s = a.join(&#39;&#39;);
    var pattern = /(\w)\1*/g;
    var a = s.match(pattern);
    a.sort(function(a, b) { return a.length &lt; b.length; });
    var letter = a[0][0];
    var num = a[0].length;
    return letter + &#39;: &#39; + num;
}
var s = &#39;aaabbbcccaaabbbcccccc&#39;;
console.log(s.getMost());
// c: 9
</code></pre><h3 id="常用匹配模式（持续更新）"><a href="#常用匹配模式（持续更新）" class="headerlink" title="常用匹配模式（持续更新）"></a>常用匹配模式（持续更新）</h3><ol>
<li>只能输入汉字：/^[\u4e00-\u9fa5]{0,}$/</li>
</ol>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ol>
<li><strong>test</strong>：检查指定字符串中有没有某子串（或某匹配模式），返回true或者false；如有必要可以进行全局模式搜索。</li>
<li><strong>exec</strong>：检查指定字符串中有没有某子串（或者匹配模式），如有返回数组（数组信息丰富，可参考上文介绍），如没有返回null；如有必要可以进行全局搜索找出所有子串（或者匹配模式）的信息，<strong>信息中含有匹配模式中子表达式所对应的字符串</strong>。</li>
<li><strong>compile</strong>：修改正则表达式中的pattern</li>
<li><strong>search</strong>：检查指定字符串中有没有某子串（或者匹配模式），如有返回子串（或者匹配模式）在原串中的开始位置，如没有返回-1。不能进行全局搜索。</li>
<li><strong>match</strong>：检查指定字符串中有没有某子串（或者匹配模式），非全局模式下返回信息和exec一致；如进行全局搜索，直接返回字符串数组。（如不需要关于每个匹配的更多信息，推荐用match而不是exec）</li>
<li><strong>replace</strong>：检查指定字符串中有没有某子串（或者匹配模式），并用另一个子串代替（该子串可以跟原字符串或者搜索到的子串有关）；如启动g，则全局替换，否则只替换第一个。<strong>replace方法可以引用子表达式所对应的值</strong>。</li>
<li><strong>split</strong>：用特定模式分割字符串，返回一个字符串数组；与Array的join方法正好相反。</li>
<li><strong>子表达式</strong>：用括号括起来的正则匹配表达式，用后向引用可以对其进行引用；也可以和exec或者replace搭配获取其真实匹配值。</li>
<li><strong>后向引用</strong> ：对子表达式所在分组进行引用。</li>
<li><strong>零宽断言</strong>：和\b ^ 以及$类似的某个位置概念。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[10大使用Node.js的理由]]></title>
      <url>/10%E5%A4%A7%E4%BD%BF%E7%94%A8Node-js%E7%9A%84%E7%90%86%E7%94%B1.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无论你的经验是否丰富，都有许多理由使用Node.js。我们来看看使用Node的几个主要的理由，以及为什么你会爱上他。</p>
<p>啊！我懂了。你不是一个跟随潮流的开发者。因为大家都不用，所以你也不使用一些很酷的与时俱进的平台。这就是为什么你还没有认真看待 <a href="http://link.funteas.com/?target=http%3A%2F%2Fnodejs.org%2F" target="_blank" rel="noopener">Node.js</a> （或者你的boss还没有让你捣鼓这些）。好嘞，是时候重新审视Node.js了。使用Nodejs，有许多理由，这里是其中的10条。</p>
<p><img src="https://img.funteas.com/ad24552f92178045c20fc8bf10f6c036.png?imageView2/2/w/800" alt=""></p>
<h2 id="10大使用Node-js的理由"><a href="#10大使用Node-js的理由" class="headerlink" title="10大使用Node.js的理由"></a>10大使用Node.js的理由</h2><h3 id="1-你已经熟悉了JavaScript"><a href="#1-你已经熟悉了JavaScript" class="headerlink" title="1. 你已经熟悉了JavaScript"></a>1. 你已经熟悉了JavaScript</h3><p>让我猜猜。你正在使用一个功能强大的客户端框架(<a href="http://link.funteas.com/?target=https%3A%2F%2Fangularjs.org%2F" target="_blank" rel="noopener">Angular</a> ，<a href="http://link.funteas.com/?target=http%3A%2F%2Femberjs.com%2F" target="_blank" rel="noopener">Ember</a> , <a href="http://link.funteas.com/?target=http%3A%2F%2Fbackbonejs.org%2F" target="_blank" rel="noopener">Backbone</a> )以及REST-ful服务器端的API，使用JSON这种数据格式来传输和接受数据。即使你没有使用其中的任一种框架，你也用jQuery写过自己的框架。因此如果你不在服务器端使用Node.js，那么你就不断地做转译吧。你在转译两件事：1）来自你脑中JavaScript的逻辑转换为服务器端框架的逻辑。以及2）来自JSON的HTTP数据转换为你的服务器端的对象。</p>
<p>JavaScript贯穿着你的应用，你不但智力上涨，你也获得了实践经验。通过模型和模板的复用，你可以减少应用的大小，同时减少了复杂度和出现bug的可能性。</p>
<p>JavaScript作为一种语言正在占领全世界！过不了多久，全球的每台电脑上都会有一个JavaScript运行环境，并且这看上去会持续一段时间。</p>
<h3 id="2-它很快"><a href="#2-它很快" class="headerlink" title="2. 它很快"></a>2. 它很快</h3><p>Node.js是JavaScript运行环境，使用了Google用在Chrome中的V8引擎。V8以闪电般的速度编译和执行JavaScript是因为V8将JavaScript编译成本地机器代码。</p>
<p><img src="https://img.funteas.com/5dccdfd3d100fc36c58553a2afd90c0a.jpg?imageView2/2/w/800" alt=""></p>
<p>除了让JavaScript运行有闪电般的速度，Node.js真正的魔法是event loop。event loop 在所有的I/O异步操作中都是单线程实现的。传统上，I/O操作可以同步运行（阻塞），也可以是异步的，通过并行线程来执行工作。这种传统的方法消耗许多内存并且是臭名昭著地难编程。相比较之下，当一个Node应用需要执行一个I/O操作，他传递一个异步任务到event loop，加上一个回调函数，然后继续执行剩下的程序。当异步操作完成，event loop 返回任务去执行他的回调函数。</p>
<p>换句话说，网络连接的读写，文件系统的读写，以及数据库的读写——所有的在网页应用中的日常任务——在Node中执行地非常非常快。Node能让你创建快速，大规模的网络应用，能够处理高吞吐量的大量的实时连接。</p>
<h3 id="3-工具"><a href="#3-工具" class="headerlink" title="3. 工具"></a>3. 工具</h3><p><img src="https://img.funteas.com/b4272c749019b1891df708f29722b0cd.png?imageView2/2/w/800" alt=""></p>
<p><a href="http://link.funteas.com/?target=https%3A%2F%2Fwww.npmjs.org%2F" target="_blank" rel="noopener">npm</a> 是Node.js的包管理器并且它棒呆了。这确实很棒，当然，这类似于其他生态系统的包管理器，但是npm很快很稳很一致。他在寻找和安装项目依赖做的非常好。他让包和其他的项目隔离开来，防止版本混淆。但是，他也处理全局shell命令安装和平台依赖的二进制。一时间，我不记得我在npm中安装的包，在这里我要问自己，“为什么会混淆这些模块？模块安装在哪里？为什么选这个版本而不是另一个？”</p>
<p><a href="http://link.funteas.com/?target=http%3A%2F%2Fgruntjs.com%2F" target="_blank" rel="noopener">grunt</a>  是较早的任务管理器，但是也有新生代的工具，如<a href="http://link.funteas.com/?target=http%3A%2F%2Fgulpjs.com%2F" target="_blank" rel="noopener">gulp</a> , <a href="http://link.funteas.com/?target=http%3A%2F%2Fbrunch.io%2F" target="_blank" rel="noopener">brunch</a> , 和 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fbroccolijs%2Fbroccoli" target="_blank" rel="noopener">broccoli</a> ，他们专注于创建编译你的文件，利用了JavaScript强大的文件流能力。</p>
<h3 id="4-你又一次刷新了对JavaScript的认识"><a href="#4-你又一次刷新了对JavaScript的认识" class="headerlink" title="4. 你又一次刷新了对JavaScript的认识"></a>4. 你又一次刷新了对JavaScript的认识</h3><p><img src="https://img.funteas.com/df836ec47f9c5433d83e4b60579aa141.png?imageView2/2/w/800" alt=""></p>
<p>那么你决定在你的服务器上用JavaScript了，并且你为你的决定感到庆幸，避免了所有的从客户端数据到服务器端数据的编译。但是数据到数据库需要甚至更多的编译！</p>
<p>There’s good news. If you’re using an object database like <a href="http://link.funteas.com/?target=http%3A%2F%2Fwww.mongodb.org%2F" target="_blank" rel="noopener">Mongo</a> , then you can extend JavaScript to the persistence layer as well. 这是一个好消息。如果你在用对象数据库，如 <a href="http://link.funteas.com/?target=http%3A%2F%2Fwww.mongodb.org%2F" target="_blank" rel="noopener">Mongo</a> ，然后你可以扩展JavaScript让持久层更好。</p>
<p>使用node.js允许你在客户端，在服务器端和在数据库中用相同的语言。从浏览器到磁盘，你可以用他的原生JSON格式保存你的数据。</p>
<h3 id="5-实时变得简单"><a href="#5-实时变得简单" class="headerlink" title="5. 实时变得简单"></a>5. 实时变得简单</h3><p>如果Node.js很擅长多并发连接，那么他也擅长多用户的，实时的网页程序，例如聊天室和游戏。Node的 event loop 能够满足多用户需求。实时能力使用websocket协议。Websocket是在客户端和服务器端的简单的双向沟通渠道。因此服务器能够推送数据到客户端就像客户端推送一样。websocket运行在TCP，避免了HTTP的消耗。</p>
<p><a href="http://link.funteas.com/?target=http%3A%2F%2Fsocket.io%2F" target="_blank" rel="noopener">Socket.io</a> 是在websoket库中的一个非常受欢迎的库，这让杀掉协同的web应用变得简单。这里是一个简单的使用 socket.io的服务器：</p>
<pre><code>var app = require(&#39;http&#39;).createServer(handler) var io = require(&#39;socket.io&#39;)(app);

app.listen(8080);

io.on(&#39;connection&#39;, function(socket) {
    // Send a message to the client
    socket.emit(&#39;event to client&#39;, { hello: &#39;world&#39; });
    // Handle a message from the client
    socket.on(&#39;event from client&#39;, function (data) {
        console.log(data);
    });
});
</code></pre><h3 id="6-流数据"><a href="#6-流数据" class="headerlink" title="6. 流数据"></a>6. 流数据</h3><p>传统意义上来说，web框架将HTTP请求和响应当做一个整体的数据对象。实际上，他们是I/O流，你可以想象，如果你把文件从文件系统中以流的形式取出。既然Node.js非常擅长处理I/O，我们能够利用这个特点创建一些很酷的东西。比如，它能够当视频或音频文件上传的时候，就<a href="http://link.funteas.com/?target=http%3A%2F%2Ftransloadit.com%2Fblog%2F2010%2F12%2Frealtime-encoding-over-150x-faster%2F" target="_blank" rel="noopener">转码音频或视频文件</a> ，减少了整体处理的时间。</p>
<p>Node能够读写流到websocket，就像他可以读写流到HTTP。比如，我们能够从服务器中运行的进程中通过websocket标准输出到浏览器，并且实时在网页上显示输出结果。</p>
<h3 id="7-一个代码库和免费的实时"><a href="#7-一个代码库和免费的实时" class="headerlink" title="7. 一个代码库和免费的实时"></a>7. 一个代码库和免费的实时</h3><p>如果你已经了解了这么多，你可能会问自己，“如果Node.js允许你在服务器和客户端使用JavaScript，并且让客户端和服务器端数据传输变得简单，我能不能写一个web应用，让一个代码库在客户端和服务器端运行，并且在两者之间自动异步处理数据。”</p>
<p>这个问题的答案是yes，并且对于此app的框架可以是<a href="http://link.funteas.com/?target=https%3A%2F%2Fwww.meteor.com%2F" target="_blank" rel="noopener">Meteor</a> 。Meteor是下一代基于Node的web框架。他可以在客户端和服务器端运行相同的代码库。然后，数据自动保存在服务器。其他的方式也奏效！任何服务器上的数据都自动传到客户端。未来会更好！任何展示数据的网页都会自动回应和自动更新。</p>
<pre><code>// Save the value of &#39;name&#39; upon clicking &#39;submit&#39; directly in the browser!
&#39;.click .submit&#39;: function(e, tpl) { Users.update({ _id: this._id }, { $set: { name: $(&#39;.name&#39;).val() } }); }
</code></pre><h3 id="8-企业管理者"><a href="#8-企业管理者" class="headerlink" title="8. 企业管理者"></a>8. 企业管理者</h3><p>任何开源项目的潜在风险就是被项目维护者所放弃。这不是Node.js的现况。Node现在由 <a href="http://link.funteas.com/?target=https%3A%2F%2Fwww.joyent.com%2F" target="_blank" rel="noopener">Joyent</a> 所赞助，这雇佣了项目带头人和其他的核心贡献者，因此有一家真实的公司在支持这项目的未来。更不要说有一大批大公司在每一个层级支持了此项目，其中包括 Walmart, Microsoft, Yahoo, Paypal, Voxer, 等等。</p>
<h3 id="9-托管"><a href="#9-托管" class="headerlink" title="9. 托管"></a>9. 托管</h3><p><img src="https://img.funteas.com/b857a57188ba9bdb1a01612e03b918e7.png?imageView2/2/w/800" alt=""></p>
<p>随着Node.js的快速普及，世界级规模的Node.js托管也在增长着。特别是，平台即服务（PaaS）供应者，比如<a href="http://link.funteas.com/?target=https%3A%2F%2Fmodulus.io%2F" target="_blank" rel="noopener">Modulus</a>  和其他减少为一个指令的部署。PaaS的鼻祖，Heroku，现在正式地支持Node部署。</p>
<h3 id="10-每个开发者都知道（一些）JavaScript"><a href="#10-每个开发者都知道（一些）JavaScript" class="headerlink" title="10. 每个开发者都知道（一些）JavaScript"></a>10. 每个开发者都知道（一些）JavaScript</h3><p>这是给你boss的理由。</p>
<p>随着web的兴起，已经存在的JavaScript的点击和鼠标滑过事件。每个web开发者都编写过一点JavaScript，即使是使用jQuery插件开发的JavaScript。寻找web开发擦能的人现在非常困难，因此当选择一个web平台，为什么不选择在这个世界上每个web开发者都熟悉的语言？</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如果想看<code>node.js</code>的教程，可以看我的这篇博客。<a href="http://pancakeawesome.ink/nodejs%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B.html">传送门</a></p>
]]></content>
      
        <categories>
            
            <category> node.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node.js </tag>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript => TypeScript 入门]]></title>
      <url>/JavaScript-TypeScript-%E5%85%A5%E9%97%A8.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ES6 是 ES5 转向主流语规格的一个重要升级，顺着这个角度看，TypeScript 让这门语言披上一层类型的外衣，直接演变成一种强类型的语言；从相反角度看，TypeScript 将编程语言们一些主流的特性引入到了 JS 的世界。</p>
<h2 id="JavaScript-gt-TypeScript-入门"><a href="#JavaScript-gt-TypeScript-入门" class="headerlink" title="JavaScript =&gt; TypeScript 入门"></a>JavaScript =&gt; TypeScript 入门</h2><p>几个月前把 ES6 的特性都过了一遍，收获颇丰。现在继续来看看 TypesScript（下文简称为 “TS”）。限于经验，本文一些总结如有不当，欢迎指正。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>官网有这样一段描述：</p>
<blockquote>
<p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.</p>
</blockquote>
<p>说的是 TS 是 JS 的超集，并且可以编译成普通的 JS。</p>
<p>其中， <strong>超集</strong> 的定义是：</p>
<blockquote>
<p>如果一个集合 S2 中的每一个元素都在集合 S1 中，且集合 S1 中可能包含 S2 中没有的元素，则集合 S1 就是 S2 的一个超集，反过来，S2 是 S1 的子集。</p>
</blockquote>
<p>而实际上，“超出” 的部分主要就是 “类型系统”。因此可以这样归纳：</p>
<blockquote>
<p>TS ≈ ES6 + 类型系统</p>
</blockquote>
<p>ES6 是 ES5 转向主流语规格的一个重要升级，顺着这个角度看，TS 让这门语言披上一层类型的外衣，直接演变成一种强类型的语言；从相反角度看，TS 将编程语言们一些主流的特性引入到了 JS 的世界。</p>
<h3 id="平稳过渡"><a href="#平稳过渡" class="headerlink" title="平稳过渡"></a>平稳过渡</h3><p>TypeScript 设计巧妙，兼具微软工业化的水准。首先，它仅靠一行命令，就融入到了广大前端人的世界：</p>
<pre><code>npm install -g typescript
</code></pre><p>然后由你随便挑一个曾编写的 <code>.js</code> 脚本文件（不妨叫做<code>hello.js</code>），不用对内容做任何修改，直接将文件后缀改成 <code>.ts</code>。这样，你就已经完成了一份 TypeScript 脚本的编写！</p>
<p>然后编译它：</p>
<pre><code>tsc hello.ts
</code></pre><p>OK，你已经平滑过渡到了 TS 的世界。就是这么简单！</p>
<p>当然这只是“一小步”，似乎后边还有无数的坑要填。不用担心，TS 已经填平了大部分的坑！</p>
<p>比如，时下最流行的 gulp，webpake 工具，只需做一些简单的配置，就能接引入TypeScript 进行编译；同时为了能与 React 完美融合，TS 引入了与 JSX 类似的 TSX 语法。当然，TS 在 Angular、Vue.js 以及 Node.js 中也是畅通的…</p>
<p>坑都填平了，大家过渡起来自然顺心顺手。</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>与 ES6 一脉相承的，同时也接轨大部分强类型语言，TS 的类型大概有这些：<br>1），<code>Number</code>、<code>Boolean</code>、<code>String</code>、<code>Null</code> 、<code>undefined</code>、<code>Symbol</code><br>2）， <code>Array</code>、<code>Function</code>、<code>Object</code><br>3），<code>Tuple</code>、<code>enum</code>、<code>Void</code>、 <code>Never</code>、<code>Any</code><br>TS 作为 JS 的一个超集，在 JS 的基础上扩展了一些非常有用的类型。第 3）中的类型就是从一些强类型语言引入的类型。</p>
<p>为了由简入繁，不妨将这些类型划分为：<strong>基本类型</strong>、<strong>复合类型</strong>。<strong>复合类型</strong> 一般由 <strong>基本类型</strong> 构成。以下将渐进式的对 TS 的这些类型进行了解。</p>
<h3 id="如何做类型声明？"><a href="#如何做类型声明？" class="headerlink" title="如何做类型声明？"></a>如何做类型声明？</h3><p>强类型语言都有一套类型声明的语法规则，TS 也不例外。TS 采用类型注释的写法，像这样<strong>将一个带冒号的注释，置于声明变量名之后，就构成了 TS 类型声明的语法</strong>。</p>
<pre><code>let str :string=&#39;hello typescript&#39;;
</code></pre><p>JAVA 的写法是相反的，但无实质差别：</p>
<pre><code>String str =&#39;hello java&#39;;
</code></pre><p>这样的注释如同一种补充说明，后文将简称它为 “冒号注释”，熟悉书写规则，有利于快速进入到 TS 的代码世界。</p>
<p>实际上，ES6 有一种属性描述对象，是通过<code>Object.getOwnPropertyDescriptor(obj, key)</code> 获取的。</p>
<pre><code>let obj = {
    set name(val) {}
}
Object.getOwnPropertyDescriptor(obj, &#39;name&#39;);
// {
//      configurable: true
//   enumerable: true
//   get: undefined
//   set: ƒ a(val)
// }
</code></pre><p>如果将 <code>setter</code> 类型的 <code>name</code> 方法适当改写，我们甚至可以实现 <code>obj.name</code> 赋值的类型检查功能，也非常有意思。</p>
<p>同样的，冒号注释 <code>: string</code> 也可以理解为对一个 <code>str</code> 变量的描述。凭借这个注释的描述，TS 的类型编译器就能进行类型检查了。</p>
<p>建立了类型的认知后，继续跑马圈地，巩固认知。其中，<code>Function</code>、 <code>Never</code>、<code>Any</code> 规则稍显复杂，但也没有什么特别的，留后细说。</p>
<h4 id="简单的基本类型"><a href="#简单的基本类型" class="headerlink" title="简单的基本类型"></a>简单的基本类型</h4><pre><code>// boolean 类型
let isBool: boolean = 1 &lt; 5; 
// string 类型
let str: string = &#39;hello world&#39;; 
// number 类型
let num: number = 123; 
// void 类型
let unusable: void = undefined; 
// undefined 类型
let u: undefined = undefined; 
// null 类型
let n: null = null; 
//Symbol 类型
// 类型 symbol 小写也能编译通过
let sym: Symbol = Symbol(&#39;hello&#39;);
</code></pre><h4 id="简单的复合类型。"><a href="#简单的复合类型。" class="headerlink" title="简单的复合类型。"></a>简单的复合类型。</h4><pre><code>// object 类型
let obj: object = {};
let arrObj: object = [];
let funcObj: object = () =&gt; {};
// array 类型
let arrNum: number[] = [1, 2, 3]
let arrStr: string[] = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
let arrObj: object[] = [{}];
// 元组 类型
let tup: [number, string] = [1, &#39;hello&#39;];
// 枚举类型
enumDays { Sun, Mon, Tue, Wed, Thu, Fri, Sat };
</code></pre><p>可谓一览无余，类型的语法就是冒号注释，仅凭这一条，60~70% 的情况你都无需担心自己的类型书写有误。</p>
<h4 id="一个灵活的子类型"><a href="#一个灵活的子类型" class="headerlink" title="一个灵活的子类型"></a>一个灵活的子类型</h4><p>但 JS 的动态类型太灵活了，<code>null</code> 和 <code>undefined</code> 的相似性, <code>Array</code>、<code>Function</code> 和 <code>Object</code>的纠缠不清的关系，仅凭一招恐怕还很难驾驭的住 JS 的 “多动症” 般的类型。比如：</p>
<pre><code>// boolean 类型接收这样的赋值
let isBool_n: boolean = null;
let isBool_u: boolean = undefined;
// void 类型接收这样的赋值
let unusable: void = undefined;
unusable = null;
// Symbol 类型接收这样的赋值
let sym: Symbol = Symbol(&#39;hello&#39;);
sym = null;
sym = undefined;
// object 类型接收这样的赋值
let obj: object = {};
obj = null;
obj = undefined;
</code></pre><p>它们都能编译通过。但是 <code>null</code> 不属于 <code>boolean</code> 类型，<code>undefined</code>也并不属于<code>object</code> 类型，为什么能通过类型检查？</p>
<p>事实上，<code>undefined</code> 和 <code>null</code> 是所有类型的子类型。也就是说，它们俩可以作为值赋给任何类型的变量。甚至，它们俩可以互相赋值给对方。</p>
<pre><code>// undefined 类型
let u:undefined=null;
// null 类型
let n:null=undefined;
</code></pre><p>有了这一条规则，就能解释一些 “复合类型” 中遇到的问题：</p>
<pre><code>let arrNum: number[]=[];
let arrStr:string[]=[];
// undefined 也属于 number 类型
let arrNum: number[]=[undefined];
// undefined 也属于 object 类型
let obj :object=undefined;
</code></pre><p>有了这条规则，我们可以大胆的写 TS 的类型声明了。</p>
<p>但太过放开的规则——本文姑且称之为 “混杂模式”，又似乎一下子让 TS 退回到了 JS 的动态类型的原始状态了，让习惯了强类型的同学容易懵掉，也让从 JS 转 TS 的同学体会不到强类型的好处。</p>
<h4 id="画条界限"><a href="#画条界限" class="headerlink" title="画条界限"></a>画条界限</h4><p>好在，TS 设计了一套巧妙的类型系统，犹如给 JS 披上 了一层强大的盔甲。</p>
<p>TS 在 “混杂模式” 下，可能存在这样的风险，就是：编译正确，运行出错。比如：</p>
<pre><code>// 无意获得一个 undefined 作为初始值
let init_name =undefined;
let nameList:string[]=[init_name];
console.log(nameList[0].split(&#39;_&#39;));
// 运行报错
</code></pre><p>在非 “严格模式” 下，上述 TS 代码编译无误，但是真正拿到页面去运行编译结果时，出现错误。</p>
<p>那怎么办呢？要相信 TS 强大的类型系统，只需一项配置，就能将编译切换成 “严格模式”：</p>
<pre><code>// 在配置文件 tsconfig.json 中增加一项
&quot;compilerOptions&quot;: {
    // ...
    &quot;strictNullChecks&quot;: true
},
</code></pre><p>再次执行编译，就会出现错误提示信息：</p>
<pre><code>error TS2322: Type &#39;undefined[]&#39;
isnot assignable to type &#39;string[]&#39;.
</code></pre><p>TypeScript 官方教程鼓励尽可能地使用 <code>--strictNullChecks</code>，因此这里也强烈建议配置该属性再进行编译，这样能很好的发挥 TS 类型检查的作用。</p>
<h4 id="网开一面和漏网之鱼"><a href="#网开一面和漏网之鱼" class="headerlink" title="网开一面和漏网之鱼"></a>网开一面和漏网之鱼</h4><p>TS 编译通过指的是类型检查符合类型系统的规则，运行 OK 则是编译后的 JS 本身执行无误。编译通过，不等于运行OK，即使在 “严格模式” 下也是这样的，所以千万别以为编译通过了就完事了。</p>
<p>以 <code>Any</code> 类型为例，在 <code>--strictNullChecks</code> 模式下：</p>
<pre><code>// TS 代码
let anyThing: any = &#39;hello&#39;;
console.log(anyThing.myName);
// 编译后的 ES6
let anyThing = &#39;hello&#39;;
console.log(anyThing.setName(&#39;world&#39;));
</code></pre><p>很显然，编译后的 <code>anyThing.setName(&#39;world&#39;)</code> 会运行报错。</p>
<p>当然， <code>Any</code> 类型略有点特殊，因为它可以当做是 TS 平滑退化到 JS 的一个类型，官网教程也有这样解说：</p>
<p><em>在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。</em></p>
<p>那问题又回来了，是否除了 <code>Any</code> 类型，其他编译OK，代码就运行无错呢？鉴于笔者正在入门，经验有限，不敢给这个结论。但无论如何，类型检查是可以排除大部分错误的。</p>
<p>最后，编译的时候，尽量选择编译成 ES6 （前提是项目是用 ES6 写的）。配置是：</p>
<pre><code>&quot;compilerOptions&quot;:{&quot;target&quot;:&quot;es6&quot;// &quot;es5&quot;}
</code></pre><h4 id="只有一条规则"><a href="#只有一条规则" class="headerlink" title="只有一条规则"></a>只有一条规则</h4><p>TS “冒号注释” ——就这一条规则，贯穿始终。在函数的类型声明中，继续来巩固这条规则的写法。</p>
<p>类型声明只对变量负责，对于函数，需考察输入——函数参数（也是变量）、输出——函数返回值两个要素。</p>
<p>因为函数的特殊结构，所有 “冒号注释” 规则的写法要特别了解下：</p>
<pre><code>// 声明函数
function add(x: number, y: number): number { return x + y; }
// 函数直接量
let myAdd = function(x: number, y: number): number { return x + y; };
</code></pre><p>可以看到，参数的 “冒号注释” 和一般变量没有任何差别。倒是函数输出类型注释有点特别——试想，<code>: number</code> 紧随函数名之后或者 <code>function</code> 关键字之后，是不是容易被误解为函数名的一部分？是不是对编译引擎不太友好？从这个角度看，注释置于<code>)</code> 之后最为合理。</p>
<p>对了，一个疑问一直从头保留到现在：要是一个变量是 <code>function</code> 类型，那类型注释怎么写，又不能拿 <code>function</code> 关键字去做类型注释？</p>
<pre><code>let myAdd: (x: number, y: number) =&gt; number = function(x: number, y: number): number { return x + y; };
</code></pre><p>其中等号前边的 <code>: (x: number, y: number) =&gt; number</code> 就代表了函数类型。它仍然在结构上符合 “冒号注释” 的规则，只不过冒号后边是一串表达式。这样的结构有点像 Python 中的推导式的概念。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>好了，补上这一块重要的缺漏，本文就完成了所有基本类型的类型声明的解释。凭借一条规则，希望在 TS 学习上畅通无阻的敲代码~</p>
]]></content>
      
        <categories>
            
            <category> typescript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 内存管理及 V8 优化]]></title>
      <url>/JavaScript-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8F%8A-V8-%E4%BC%98%E5%8C%96.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 具有垃圾自动回收机制（Garbage Collection）简称 GC。垃圾回收机制会中断整个代码执行，释放不可能再被使用的变量，释放内存，这个工作机制是周期性的，我们会在下文详细探讨。</p>
<h2 id="JavaScript-内存管理及-V8-优化"><a href="#JavaScript-内存管理及-V8-优化" class="headerlink" title="JavaScript 内存管理及 V8 优化"></a>JavaScript 内存管理及 V8 优化</h2><h3 id="可释放对象"><a href="#可释放对象" class="headerlink" title="可释放对象"></a>可释放对象</h3><pre><code>function fn1() { var obj1 = { name: &#39;xiaomuchen&#39;, age: &#39;20&#39; } }

function fn2() {
    var obj2 = { name: &#39;xiaomuchen&#39;, age: &#39;20&#39; }
    return obj2
}
var a = fn1() var b = fn2()
console.log(a, b)
// undefined, {name: &quot;xiaomuchen&quot;, age: &quot;20&quot;}
</code></pre><p>我们对比上面两个函数，fn1 在函数内声明变量 obj1 并且赋值，在函数执行后这个变量<code>便不可再访问了</code>，fn2 在最后把函数内的变量 obj2 返回到全局变量 b，所以 <code>{ name: &#39;xiaomuchen&#39;, age: &#39;20&#39; }</code> 这个对象（或者说 obj2）<code>依然可被访问</code>。</p>
<p>JavaScript 回收机制通过判断变量是否可被访问，来决定回收哪些变量。</p>
<h3 id="标记清除和引用计数"><a href="#标记清除和引用计数" class="headerlink" title="标记清除和引用计数"></a>标记清除和引用计数</h3><p>那么 JavaScript 是如何判断变量是否可被访问？这就要提到标记清除和引用计数。</p>
<p>标记清除：标记清除是目前大部分 JavaScript 引擎使用的判断方式，通过标记变量的状态来确定是否可被回收。当变量在环境中被声明时标记<code>进入环境</code>，理论上永远不要释放进入环境的变量，因为它可以在环境中的任何位置、任何时刻被访问。当环境被销毁（如函数执行完），则变量被标记<code>离开环境</code>等待回收。</p>
<pre><code>function fn() {
    var a = { count: 10 }
    // 被标记，进入环境 
    var b = { count: 20 }
    // 被标记，进入环境
}
fn();
// 执行完毕之后 b 被标记，离开环境
</code></pre><p>引用计数：JavaScript 引擎维护一张<code>引用表</code>，保存内存中所有的资源的引用次数。资源被引用一次则引用 +1，资源被去掉引用或者退出变量的函数作用域时，则引用 -1，当资源的引用次数为<code>0</code>时，说明无法访问这个值，则等待回收。<br>（注：引用计数从 1 到 0 这个过程可能不执行，而是直接标记<code>可被回收</code>，不再进行加减运算节约开销）</p>
<pre><code>function fn() {
    var a = { count: 10 }
    // 资源 { count: 10 } 被引用次数为 1
    a = { count: 20 }
    // 资源 { count: 20 } 被引用次数为 1，资源 { count: 10 } 被引用次数为 0，等待回收
    do someThing
}
fn();
// 资源 { count: 20 } 被释放
</code></pre><p>但是引用计数存在一种<code>循环引用</code>的情况，如下例子，两个对象之间相互引用，在离开环境后对象不可访问，但由于对象的引用次数为 1，则导致不会被回收。这个例子来自《JavaScript 高级程序设计》，但我思考良久，如果引用计数把 a.param 也作为一个变量来计数，那么就没有这个问题了，引用计数实现的方式不同，产生的结果也不一样。</p>
<pre><code>function fn() {
    var a = { count: 10 }
    var b = { count: 20 }
    a.param = b
    // b 的引用次数为 2
    b.param = a
    // a 的引用次数为 2
}
fn();
// a、b 的引用次数为 1
</code></pre><h4 id="GC-的缺陷、分代回收和增量-GC"><a href="#GC-的缺陷、分代回收和增量-GC" class="headerlink" title="GC 的缺陷、分代回收和增量 GC"></a>GC 的缺陷、分代回收和增量 GC</h4><p>和其他语言一样 GC 会中断代码执行，停止其他操作。因为要遍历所有对象，回收所有不可访问对象，这个操作的耗时可能有 100ms 以上。在 V8 引擎新版本中引入了两种优化方法：1. 分代回收（Generation GC），2. 增量 GC（increment GC）</p>
<p>分代回收：目的是通过对象的使用频率、存在时长区分新生代与老生代对象。多回收新生代区（young generation），少回收老生代区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时</p>
<p>增量 GC：把需要长耗时的遍历、回收操作<code>拆分运行</code>，减少中断时间，但是会增大上下文切换开销</p>
<h4 id="Node-js-中的-GC-表现"><a href="#Node-js-中的-GC-表现" class="headerlink" title="Node.js 中的 GC 表现"></a>Node.js 中的 GC 表现</h4><p>当我们用 Node.js 搭建一个稳定的服务时，就需要考虑服务器内存的开销，下面一个 Node.js 内存回收执行的例子：</p>
<p>执行代码<code>node --trace_gc --trace_gc_verbose test.js</code>跟踪一个网络服务的 GC。</p>
<pre><code>[41204: 0x102001c00] Memory reducer: call rate 0.056, low alloc, foreground[41204: 0x102001c00] Memory reducer: started GC #1
[41204:0x102001c00]Heap growing factor 1.1 based on mu= 0.970, speed_ratio = 42956(gc = 675253, mutator = 16)
[41204: 0x102001c00] Grow: old size: 21382 KB, new limit: 33604 KB(1.1)
[41204: 0x102001c00] Memory reducer: finished GC #1 (will do more)
[41204:0x102001c00]156410 ms:Mark-sweep 27.7(50.0)-&gt;21.0(30.0) MB,12.4/0.0 ms (+20.4 ms in7 steps since start of marking, biggest step 4.8 ms)[Incremental marking task: finalize incremental marking][GC in old space requested].
[41204:0x102001c00]Memory allocator,   used:30756 KB, available:1435612 KB
[41204:0x102001c00]New space,          used:169 KB, available:838 KB, committed:1024 KB
[41204:0x102001c00]Old space,          used:16662 KB, available:2417 KB, committed:19412 KB
[41204:0x102001c00]Code space,         used:4078 KB, available:178 KB, committed:5120 KB
[41204:0x102001c00]Map space,          used:642 KB, available:0 KB, committed:2128 KB
[41204:0x102001c00]Largeobject space, used:0 KB, available:1434571 KB, committed:0 KB
[41204:0x102001c00]All spaces,         used:21552 KB, available:1438005 KB, committed:27684 KB
[41204:0x102001c00]External memory reported:1026 KB
[41204:0x102001c00]Total time spent in GC  :158.6 ms
[41204:0x102001c00]Memory reducer: call rate 0.003, low alloc, foreground
</code></pre><p>首先我们可以看到 Node.js 区分 <code>New space</code>、<code>Old space</code> 等来划分检索空间。而提示<code>(+ 20.4 ms in 7 steps since start of marking, biggest step 4.8 ms)</code> 告诉我们这个标记的步骤分 7 步进行，耗时最长的一次时 4.8ms。这使 JavaScript 可以很好的支持开发高实时应。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>因为篇幅有限，留下一些小问题供大家思考：</p>
<ol>
<li>闭包一定会导致内存不可被回收？</li>
<li>如何监控一个 Node.js 服务的内存开销，如何处理不可预知的内存泄漏？</li>
</ol>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅析网站工作原理]]></title>
      <url>/%E6%B5%85%E6%9E%90%E7%BD%91%E7%AB%99%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果您刚接触Web开发，您认为自己知道网络的工作原理 - 至少在基本层面上。</p>
<p>…但是，当您尝试解释一个网站为什么出现空白。 什么是IP地址？ “客户 - 服务”模型是如何工作的？</p>
<p>最近开发框架功能很强大。强大到让我们这些新码农忽视了网站工作的基本原理。</p>
<p>我确实是这样， 没什么不好意思承认的：网络很复杂，只有当您开式编程时，您才意识到这些基础知识有多重要。 （如果您想让你的web app正常工作）</p>
<p>所以我写了一个关于这些基础知识的四部分的指南，这些基础每个人都需要掌握，无论你是编程菜鸟还是只是对编程感兴趣。</p>
<p><strong>Part 1:</strong> 网站工作原理</p>
<p><strong>第2部分：</strong> Web应用程序的结构</p>
<p><strong>第3部分：</strong> HTTP和REST</p>
<p><strong>第4部分：</strong>客户端 - 服务器交互的代码示例</p>
<h2 id="网站的工作原理：网络开发新手（或任何人-入门"><a href="#网站的工作原理：网络开发新手（或任何人-入门" class="headerlink" title="网站的工作原理：网络开发新手（或任何人)入门"></a>网站的工作原理：网络开发新手（或任何人)入门</h2><h3 id="一个基本的网页搜索"><a href="#一个基本的网页搜索" class="headerlink" title="一个基本的网页搜索"></a>一个基本的网页搜索</h3><p>让我们像之前那样开始，在浏览器的地址栏中输入“www.github.com” ，我们会看到页面开始加载。</p>
<p>看起来似乎很简单，幕后却隐藏着一大堆魔法。 让我们来深入学习吧。</p>
<h3 id="定义网络的部分"><a href="#定义网络的部分" class="headerlink" title="定义网络的部分"></a>定义网络的部分</h3><p>了解网络是非常麻烦的，因为有很多术语。不幸的是，有些术语对于理解这篇文章的其余部分至关重要。</p>
<p>如果您想了解万维网的秘密，以下是最重要的术语：</p>
<p><strong>客户端：</strong>在计算机上运行并连接到互联网的应用程序，如Chrome或Firefox。其主要作用是进行用户交互，并将其转换为对另一台称为Web服务器的计算机的请求。虽然我们通常使用浏览器访问网络，但您可以将整个计算机视为客户端 - 服务器模型的“客户端”。每个客户端计算机都有一个唯一的地址，称为IP地址，其他计算机可以用来识别它。</p>
<p><strong>服务器：</strong>连接到互联网且具有IP地址的机器。服务器等待来自其他机器（例如客户机）的请求并对其进行响应。不同于您的计算机（即客户端），服务器也具有IP地址并安装运行特殊的服务器软件，确定如何响应来自浏览器的请求。 Web服务器的主要功能是将网页存储，处理和传送给客户端。有许多类型的服务器，包括Web服务器，数据库服务器，文件服务器，应用程序服务器等。 （在这篇文章中，我们在谈论Web服务器。）</p>
<p><strong> IP地址：</strong>互联网协议地址。 TCP / IP网络上的设备（计算机，服务器，打印机，路由器等）的数字标识符。互联网上的每台计算机都有一个IP地址，用于识别和与其他计算机通信。 IP地址有四组数字，以小数点分隔（例如244.155.65.2）。这被称为“逻辑地址”。为了在网络中定位设备，通过TCP / IP协议软件将逻辑IP地址转换为物理地址。这个物理地址（即MAC地址）内置在您的硬件中。<br><strong> ISP：</strong>互联网服务提供商。 ISP是客户端和服务器之间的中间人。典型的ISP通常是“有线电视公司”。当您的浏览器收请求<a href="http://www.github.com," target="_blank" rel="noopener">www.github.com,</a>  时，它不会知道在哪里寻找<a href="http://www.github.com," target="_blank" rel="noopener">www.github.com,</a>  因此，ISP的工作是进行DNS（域名系统）查找，以询问查找的网站的IP地址。</p>
<p><strong> DNS：</strong>域名系统。跟踪计算机的域名及其在互联网上相应IP地址的分布式数据库。不要担心“分布式数据库”如何工作：只需要知道输入<a href="http://www.github.com," target="_blank" rel="noopener">www.github.com,</a> 而不是IP地址就行了。</p>
<p><strong>域名：</strong>用于标识一个或多个IP地址。用户使用域名（例如<a href="http://www.github.com," target="_blank" rel="noopener">www.github.com,</a> ）访问互联网上的网站。当您在浏览器中键入域名时，DNS使用它来查找该给定网站的IP地址。</p>
<p><strong> TCP / IP：</strong>传输控制协议/互联网协议。最广泛使用的通信协议。 “协议”是一些标准的规则。TCP / IP被用作通过网络传输数据的标准。</p>
<p><strong>端口号：</strong>一个16位整数，用于标识服务器上的特定端口，并始终与IP地址相关联。它可以用来识别服务器上可以转发网络请求的特定进程。</p>
<p><strong>主机：</strong>连接到网络的计算机 - 它可以是客户端，服务器或任何其他类型的设备。每个主机都有唯一的IP地址。对于<a href="http://www.google.com," target="_blank" rel="noopener">www.google.com,</a> 等网站，主机可以是为该网站的网页提供服务的网络服务器。主机和服务器概念经常混合，但是它们是两个不同的东西。服务器是一种主机 - 它们是一个特定的机器。另一方面，提供托管服务来维护多个Web服务器的机器可以称作主机。在这个意义上，您可以从主机运行服务器。</p>
<p><strong> HTTP：</strong>超文本传输协议。 Web浏览器和Web服务器用于通过互联网进行通信的协议。</p>
<p><strong> URL：</strong>统一资源定位符。 URL识别特定的Web资源。一个简单的例子是<a href="https://github.com/someone." target="_blank" rel="noopener">https://github.com/someone.</a> URL指定协议（“https”），主机名（github.com）和文件名（某人的个人资料页面）。用户可以从域名为github.com的网络主机通过HTTP获取该URL所标识的Web资源。（很绕口吗？）</p>
<h3 id="从代码到网页的旅程"><a href="#从代码到网页的旅程" class="headerlink" title="从代码到网页的旅程"></a>从代码到网页的旅程</h3><p>好的，现在我们有了必要的定义，让我们尝试Github的搜索，看看从地址栏输入一个网址到获取到网页经历了什么：</p>
<p>1）您在浏览器中输入URL<br><img src="http://p0.qhimg.com/t0176b1ef05e841e079.png" alt=""></p>
<p>2）浏览器解析URL中包含的信息。包括协议（“https”），域名（“github.com”）和资源（“/”）。 在这种情况下，“.com”之后没有指示特定的资源，所以浏览器知道检索主（索引）页面<br><img src="http://p0.qhimg.com/t01c869ebeabdd534c1.png" alt=""></p>
<p>3)浏览器与ISP进行通信，对主机的Web服务器的IP地址进行DNS查找<a href="http://www.github.com." target="_blank" rel="noopener">www.github.com.</a> DNS服务首先联系根服务器, 查询 <a href="https://www.github.com" target="_blank" rel="noopener">https://www.github.com</a>  顶级域服务器的IP地址。<br>该地址被发送回您的DNS服务。 DNS服务与“.com”名称服务器进行另外的沟通，并请求 <a href="https://www.github.com." target="_blank" rel="noopener">https://www.github.com.</a> 的地址。</p>
<p><img src="http://p0.qhimg.com/t0131e28807f376490e.gif" alt=""></p>
<p><em>source:</em><a href="https://technet.microsoft.com/en-us/library/bb962069.aspx" target="_blank" rel="noopener"><em>https://technet.microsoft.com/en-us/library/bb962069.aspx</em></a></p>
<p>4)一旦ISP收到目标服务器的IP地址，它会将其发送到您的Web浏览器<br><a href="http://preethikasireddy.me/wp-content/uploads/2015/12/Screen-Shot-2015-12-06-at-6.32.27-PM1.png" target="_blank" rel="noopener">http://preethikasireddy.me/wp-content/uploads/2015/12/Screen-Shot-2015-12-06-at-6.32.27-PM1.png</a></p>
<p><img src="http://p0.qhimg.com/t01f981a5ba2985f958.png" alt=""></p>
<p>5)您的浏览器从URL中获取IP地址和给定的端口号（HTTP协议默认为端口80，HTTPS默认为端口443），并打开TCP套接字连接。 此时，您的Web浏览器和Web服务器终于连接了。<br>6) 您的网络浏览器向网页服务器发送HTTP请求，请求 <a href="http://www.github.com." target="_blank" rel="noopener">www.github.com.</a> 的主页面</p>
<p><img src="http://p0.qhimg.com/t011fb50edbb274e338.png" alt=""><br>来自客户端的GET请求</p>
<p>7）Web服务器接收请求并查找该HTML页面。 如果页面存在，则Web服务器准备响应并将其发送回您的浏览器。 如果服务器找不到请求的页面，它将发送一个HTTP 404错误消息，代表“找不到页面”。</p>
<p><img src="http://p0.qhimg.com/t0101a1197df9353e5d.png" alt=""></p>
<p>服务端响应</p>
<p>8）您的Web浏览器将接收到HTML页面，然后通过它从上到按下解析寻找列出的其他资源，如图像，CSS文件，JavaScript文件等。</p>
<p><img src="http://p0.qhimg.com/t019c7165f57be8a468.png" alt=""></p>
<p>index.html 页面</p>
<p>9）对于列出的每个资源，浏览器重复上述整个过程，向服务器发送HTTP请求。</p>
<p>10）浏览器完成加载HTML页面中列出的所有其他资源后，页面将最终加载到浏览器窗口中，并且连接将被关闭<br><img src="http://p0.qhimg.com/t01557152f4e5fdf4c2.png" alt=""></p>
<p>Github</p>
<h3 id="穿越互联网深渊"><a href="#穿越互联网深渊" class="headerlink" title="穿越互联网深渊"></a>穿越互联网深渊</h3><p>值得注意的一件事是当您提出信息请求时，如何传输信息。当您发出请求时，该信息被分解成许多称为数据包的小块。每个数据包都标有一个包括源和目标端口号的TCP报头，以及包含源IP地址和目标IP地址作为身份标识的IP报头。然后，数据包通过以太网，WiFi或蜂窝网络传输，并允许在任何路由上经过多次跳转，直到到达目的地。</p>
<p>（我们实际上并不关心数据包到达那里 - 重要的是它们到达目的地安全无恙！）一旦数据包到达目的地，它们将被重新组合。</p>
<p>那么所有的数据包怎么知道如何到达目的地而不会迷路？</p>
<p>答案是TCP / IP。</p>
<p>TCP / IP是一个两部分系统，作为互联网的基本“控制系统”。IP代表互联网协议;其作用是使用每个数据包上的IP头（即IP地址）将数据包发送到其他计算机。传输控制协议（TCP）负责将消息或文件分解成较小的数据包，使用TCP头将数据包路由到目的地计算机上的正确应用程序，如果丢包，则重新发送数据包;一旦到达另一端，重新组装数据包。</p>
<h3 id="绘制最后的图片"><a href="#绘制最后的图片" class="headerlink" title="绘制最后的图片"></a>绘制最后的图片</h3><p>等等 - 工作还没有完成！ 现在，您的浏览器具有构成网站（HTML，CSS，JavaScript，图像等）的资源，必须通过几个步骤将资源呈现为可读的网页。</p>
<p>您的浏览器有一个渲染引擎，负责显示内容。 渲染引擎以小块形式接收资源的内容。 然后有一个HTML解析算法告诉浏览器如何解析资源。</p>
<p><img src="http://p0.qhimg.com/t01580da28230348db3.jpg" alt=""><br>一个DOM树</p>
<p>构建DOM树后，将分析样式表以了解如何对每个节点进行样式化。 使用此信息，浏览器遍历DOM节点并计算每个节点的CSS样式，位置，坐标等。</p>
<p>一旦浏览器具有DOM节点及其样式，那么<em>最终</em>就可以将页面绘制到屏幕上了。 结果是：你在互联网上看过的一切。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="网络很复杂，但你刚刚完成了很多的工作"><a href="#网络很复杂，但你刚刚完成了很多的工作" class="headerlink" title="网络很复杂，但你刚刚完成了很多的工作"></a>网络很复杂，但你刚刚完成了很多的工作</h3><p>所以这就是网络。迷惑吗？ 我们都是，但是如果你已经读到这里，你已经完成了最艰难的部分。 我跳过了一些细节，以便在这里向大家展示这个大图; 但是如果你能记起上面列出事件的基本顺序，填写细节将是小菜一碟。</p>
<p>查看<a href="https://medium.com/@preethikasireddy/how-the-web-works-part-ii-client-server-model-the-structure-of-a-web-application-735b4b6d76e3#.e6tmj8112" target="_blank" rel="noopener">Part 2</a>, 在那里我们将讲解一个基本的Web应用程序的结构)</p>
]]></content>
      
        <categories>
            
            <category> 网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> http协议 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[重温ES6核心概念和基本用法]]></title>
      <url>/%E9%87%8D%E6%B8%A9ES6%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 中其实并不存在真正的类，ES6 的类其实是基于原型链模拟面向对象的一种语法糖。其本质上可以看做是构造函数的另一种写法。</p>
<h2 id="重温ES6核心概念和基本用法"><a href="#重温ES6核心概念和基本用法" class="headerlink" title="重温ES6核心概念和基本用法"></a>重温ES6核心概念和基本用法</h2><h3 id="ES6新特性列表"><a href="#ES6新特性列表" class="headerlink" title="ES6新特性列表"></a>ES6新特性列表</h3><p>相比ES5，ES6提供了太多的更新，简单说来，主要为以下方面（大家可以依据自己不算清晰的点选择性查看本文）：</p>
<ul>
<li><p>Arrows,箭头函数，</p>
</li>
<li><p>Classes，类</p>
</li>
<li><p>Enhanced object literals，增强的对象字面值</p>
</li>
<li><p>Template strings：模板字符串</p>
</li>
<li><p>Destructuring：解构</p>
</li>
<li><p>Default + rest + spread：参数默认值，rest参数,扩展运算符</p>
</li>
<li><p>Let + const:命名声明的新方式</p>
</li>
<li><p>Iterators + for…of：遍历器</p>
</li>
<li><p>Generators：生成器</p>
</li>
<li><p>Unicode：更广泛的编码支持</p>
</li>
<li><p>Modules：语言层面上支持的模块机制</p>
</li>
<li><p>Module loaders：模块加载器</p>
</li>
<li><p>Map + set + weakmap + weakset：新的数据结构</p>
</li>
<li><p>Proxies：代理器</p>
</li>
<li><p>Symbols：新的基本类型，独一无二的值</p>
</li>
<li><p>Subclassable built-ins：类的继承</p>
</li>
<li><p>Promises：</p>
</li>
<li><p>Math + number + string + array + object apis：拓展了一些内置对象的方法</p>
</li>
<li><p>Binary and octal literals：二进制八进制字面量</p>
</li>
<li><p>Reflect api：操作对象的新api</p>
</li>
<li><p>Tail calls:尾调用</p>
</li>
</ul>
<h3 id="Arrows箭头函数"><a href="#Arrows箭头函数" class="headerlink" title="Arrows箭头函数"></a>Arrows箭头函数</h3><p>箭头函数使用类似于<code>=&gt;</code>这样的语法定义函数，支持表达式模式和语句模式，不过其最大特点在于和父作用域具有一样的<code>this</code>。我们知道普通函数的<code>this</code> 既不指向函数自身也不指向函数的词法作用域，this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。使用箭头函数时再也不用担心<code>this</code>跳来跳去了。<br>此外如果箭头函数如果定义在另一个函数里面，箭头函数会共享它父函数的arguments变量。</p>
<pre><code>// 表达式模式箭头函数
var odds = evens.map(v =&gt; v + 1);
var nums = evens.map((v, i) =&gt; v + i);
var pairs = evens.map(v =&gt; ({ even: v, odd: v + 1 })); // 语句模式箭头函数
nums.forEach(v =&gt; {
    if (v % 5 === 0)
        fives.push(v);
}); // 和父作用域具有相同的thisvar bob ={
_name: &quot;Bob&quot;,
    _friends: [],
    printFriends() {
        this._friends.forEach(f =&gt;
            console.log(this._name + &quot; knows &quot; + f));
    }
}

function square() {
    let example = () =&gt; {
        let numbers = [];
        for (let number of arguments) {
            numbers.push(number * number);
        }
        return numbers;
    };
    return example();
}

square(2, 4, 7.5, 8, 11.5, 21);
// returns: [4, 16, 56.25, 64, 132.25, 441]
</code></pre><h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>JavaScript中其实并不存在真正的类，ES6的类其实是基于原型链模拟面向对象的一种语法糖。其本质上可以看做是构造函数的另一种写法。<br>与真的类一样，它支持<code>super</code>继承，实例，静态方法和<code>constructor</code>方法。<br>如果你也使用React，工作中定义模块时一定没少写过<code>class A extends React.Component{}</code>吧。</p>
<pre><code>// 定义类
classPoint {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    toString() { return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;; }
}
// 通过extends关键字实现继承
class SkinnedMeshextends THREE.Mesh {
    //constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。
    //一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。
    constructor(geometry, materials) {
        // super表示父类的构造函数，用来新建父类的this对象,
        // 子类必须在constructor方法中调用super方法，否则新建实例时会报错。如果不调用super方法，子类就得不到this对象。
        super(geometry, materials);
        //在构造方法中绑定this,可以防止实例找不到this
        this.idMatrix = SkinnedMesh.defaultMatrix();
        this.bones = [];
        this.boneMatrices = [];
        //...
    }
    // 非定义在this上的方法都会被直接定义在原型链上
    update(camera) {
        //...// super在此处作为对象，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
        super.update();
    }
    // 可以使用get和set关键字，对某个属性设置存值函数和取值函数
    get boneCount() { // 类的方法内部如果含有this，它默认指向类的实例
        return this.bones.length;
    }
    set matrixType(matrixType) { this.idMatrix = SkinnedMesh[matrixType](); } // 加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用
    static defaultMatrix() { returnnew THREE.Matrix4(); }
}
// 类的所有实例共享一个原型对象
let skin = newSkinnedMesh(); // 静态方法需要直接通过类调用
SkinnedMesh.defaultMatrix()
</code></pre><h3 id="对象的拓展"><a href="#对象的拓展" class="headerlink" title="对象的拓展"></a>对象的拓展</h3><p>ES6中对象的使用方法得以拓展，主要包括以下几点：</p>
<ul>
<li><p>属性和方法可以简洁表示；</p>
</li>
<li><p>允许以表达式的模式定义属性名；</p>
</li>
<li><p>可以通过<code>__proto__</code>读取或设置当前对象的prototype对象;</p>
</li>
<li><p>使用<code>Object.is({},{})</code>判断两个对象是否完全相对，类似于<code>===</code>;</p>
</li>
<li><p><code>Object.assign(target, source1, source2)</code>合并对象；（浅拷贝）</p>
</li>
</ul>
<pre><code>var obj = {
    // __proto__用以设置当前对象的prototype对象，不推荐使用，推荐使用
    Object.setPrototypeOf()
    __proto__: theProtoObj,
    //‘handler:handler’可简写为handler（只需要写变量名就可以实现变量名为变量名，变量值为属性值）
    handler,
    // 简写在定义方法的时候同样有效
    toString() { // Super call
        sreturn &quot;d &quot; + super.toString();
    },
    // 方括号内的表达式用以计算属性名
    [&#39;prop_&#39; + (() =&gt; 42)()]: 42
};
</code></pre><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串是一种组合字符串的语法糖，其使用类似于<code>Perl</code>,<code>Python</code>等语言的字符串修改方法类似，它的出现让我们拼合字符串时方便多了。目前相互中几乎所有字符串的拼接都用这个了，异常方便。</p>
<ul>
<li><p>模板字符串定义在两个反撇号中；</p>
</li>
<li><p>在模板字符串中可以直接换行，格式会得以保留；</p>
</li>
<li><p>通过<code>${}</code>可以很方便的在模板字符串中添加变量；</p>
</li>
</ul>
<pre><code>// 把字符串放在``(注意不是引号)中就可以使用
`In JavaScript &#39;\n&#39; is a line-feed.`
// 模板字符串保留了换行
`In JavaScript this is
 not legal.`
// 在字符串中添加变量的方法，变量直接放在${}中即可
var name = &quot;Bob&quot;,
    time = &quot;today&quot;;
`Hello ${name}, how are you ${time}?`
// 拼合请求时异常方便了
POST `http://foo.org/bar?a=${a}&amp;b=${b}
     Content-Type: application/json
     X-Credentials: ${credentials}
     { &quot;foo&quot;: ${foo},
       &quot;bar&quot;: ${bar}}` (myOnReadyStateChangeHandler);
</code></pre><h3 id="Destructuring-解构"><a href="#Destructuring-解构" class="headerlink" title="Destructuring 解构"></a>Destructuring 解构</h3><p>解构使用模式匹配的方法绑定变量和值，数组和对象都可使用。解构在绑定失败的时会实现软绑定，即没有匹配值时，返回<code>undefined</code>。使用方法可见示例：</p>
<pre><code>// 数组解构
var [a, , b] = [1, 2, 3];
// a = 1,b = 3
// React中常见以下用法
var { a, b, c } = this.props;
// 对象解构也能用在函数的参数中
function g({ name: x }) {
    console.log(x);
}
g({ name: 5 })
// 绑定失败时返回undefined
var [a] = [];
a === undefined;
// 解构时也可以绑定默认值
var [a = 1] = [];
a === 1;
// 配合默认参数使用结构
function r({ x, y, w = 10, h = 10 }) { return x + y + w + h; }
r({ x: 1, y: 2 }) === 23
</code></pre><h3 id="默认值，剩余值和拓展值"><a href="#默认值，剩余值和拓展值" class="headerlink" title="默认值，剩余值和拓展值"></a>默认值，剩余值和拓展值</h3><ul>
<li><p>ES6允许我们在给变量添加默认值</p>
</li>
<li><p>使用拓展值使得函数调用时可传入数组作为连续的参数</p>
</li>
<li><p>利用剩余值特性我们可以把函数尾部的参数转换为一个数组，现在使用<code>rest</code>就可以替换以前的<code>arguments</code>对象了。</p>
</li>
</ul>
<pre><code>// 给函数的参数添加默认值
function f(x, y = 12) {
    // y is 12 if not passed (or passed as undefined)
    return x + y;
}
// 可以只传参数x的值了
f(3) == 15
// 使用rest
function f(x, ...y) {
    // y is an Array
    return x * y.length;
}
f(3, &quot;hello&quot;, true) == 6
// 传入数组作为参数
function f(x, y, z) { return x + y + z; }
// 直接传入数组当作上面函数的参数
f(...[1, 2, 3]) == 6
</code></pre><h3 id="Let-和-Const"><a href="#Let-和-Const" class="headerlink" title="Let 和 Const"></a>Let 和 Const</h3><p>ES6新增了块作用域，新增了两种定义变量的方法，定义变量时推荐使用<code>let</code>替代<code>var</code>，<code>let</code>定义的变量在块作用域内有效，<code>const</code>用以指定固定值，这两类新定义的变量不允许在定义前使用，也不允许重复定义。</p>
<pre><code>function f() {
    {
        let x; {
            const x = &quot;sneaky&quot;;
            // 改变const
            x = &quot;foo&quot;;
        }
        // 重复定义会出错
        let x = &quot;inner&quot;;
    }
}
// 在这里想到一个使用var时新手特别容易犯的问题
for (var i = 0; i &lt; 10; ++i) {
    setTimeout(function() {
        console.log(i);
    }, i * 1000);
}
// 使用var 所有的结果都是10
// 使用let 结果就是预想要的结果
for (let i = 0; i &lt; 10; ++i) {
    setTimeout(function() {
        console.log(i);
    }, i * 1000);
}
</code></pre><h3 id="Iterators-For…Of"><a href="#Iterators-For…Of" class="headerlink" title="Iterators + For…Of"></a>Iterators + For…Of</h3><p>ES6为部署了Iterator接口的各种不同的数据结构提供了统一的访问机制。其本质是一个指针对象。每次调用<code>next</code>方法，可以把指针指向数据结构的下一个成员。具体说来，每一次调用next方法，都会返回数据结构的当前成员的信息（一个包含value和done两个属性的对象，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束）。</p>
<p>凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p>
<pre><code>let fibonacci = {
    // 一个数据结构只要具有Symbol.iterator属性，就可被认为是可遍历的，`Symbol.iterator`是一个表达式，返回Symbol对象的iterator属性，所以需要放在[]中，本质上它是当前数据结构的遍历器生成函数。
    [Symbol.iterator]() {
        let pre = 0,
            cur = 1;
        return { next() {
                [pre, cur] = [cur, pre + cur]; return { done: false, value: cur } } }
    }
}
// fibonacci部署了Symbol.iterator属性，只要done不为true就会一直遍历
for (var n of fibonacci) {
    // 调用1000以内的值做遍历
    if (n &gt; 1000) break;
    console.log(n);
}
</code></pre><blockquote>
<p>原生具备<code>Iterator</code>接口的数据结构有以下几种:数组、某些类似数组的对象（字符串、DOM NodeList 对象、arguments对象）、Set和Map结构。</p>
</blockquote>
<p>对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p>
<blockquote>
<p>实际使用时需引入<a href="http://link.funteas.com/?target=http%3A%2F%2Fbabeljs.io%2Fdocs%2Fusage%2Fpolyfill%2F" target="_blank" rel="noopener">polyfill</a> </p>
</blockquote>
<h3 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h3><p>可以从两个角度理解<code>Generators</code>，它既是状态机也是一个遍历器对象生成函数。执行该函数可以理解为启动了遍历器，之后每次执行<code>next()</code>函数则每次执行到<code>yield</code>处。</p>
<p>值得注意的是执行<code>next()</code>时可添加参数，这实现了在函数运行的不同阶段，可以从外部向内部注入不同的值，</p>
<p>生成器使用<code>function*</code>和<code>yield</code>简化了迭代过程，使用<code>function*</code>定义的函数返回了一个生成器实例。<br>生成器是迭代器的子类，但是包含<code>next</code>和<code>throw</code>。这使得值可以回流到生成器，<code>yield</code>是一个可以返回值的表达式。</p>
<p><code>for...of</code>循环可以自动遍历 <code>Generator</code> 函数时生成的<code>Iterator</code>对象，此时不再需要调用<code>next</code>方法。</p>
<p><code>Generator</code>的<code>return</code>方法会返回固定的值，终结遍历Generator函数。返回值的value属性就是return方法的参数，返回值的done属性为true。</p>
<p>结合<code>co</code>模块可以实现比Promise更加优雅的异步调用方式</p>
<pre><code>// 使用generator函数实现上述遍历器对象
var fibonacci = {
    [Symbol.iterator]: function*() {
        var pre = 0,
            cur = 1;
        for (;;) {
            var temp = pre;
            pre = cur;
            cur += temp;
            yield cur;
        }
    }
}
for (var n of fibonacci) {
    // truncate the sequence at 1000
    if (n &gt; 1000) break;
    console.log(n);
}
// 使用co模块（基于 Promise 对象的自动执行器），可以实现异步函数的自动执行
var gen = function*() { var f1 = yield somethingAsync(); var f2 = yield anotherThingAsync(); };
var co = require(&#39;co&#39;);
co(gen);
</code></pre><blockquote>
<p>实际使用时需引入<a href="http://link.funteas.com/?target=http%3A%2F%2Fbabeljs.io%2Fdocs%2Fusage%2Fpolyfill%2F" target="_blank" rel="noopener">polyfill</a> </p>
</blockquote>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>ES6完整支持所有的Unicode,包括新的<code>Unicode</code>字面量和<code>u</code>模式正则，提供了新的API来处理<code>21bit</code>级别的字符串。这些新加特性使得我们的JavaScript应用有能力支持各种语言。</p>
<pre><code>// same as ES5.1
&quot;𠮷&quot;.length == 2
// 新的正则匹配模式
&quot;𠮷&quot;.match(/./u)[0].length == 2
// 新形式
&quot;\u{20BB7}&quot; == &quot;𠮷&quot; == &quot;\uD842\uDFB7&quot;
// codePointAt()能够正确处理4个字节储存的字符，返回一个字符的码点
&quot;𠮷&quot;.codePointAt(0) == 0x20BB7
// for-of 遍历字符，以整体输出
for (var c of &quot;𠮷&quot;) {
    console.log(c);
}
// 𠮷
</code></pre><p>我们也可以在JS中写出Emoji了，很有趣，对不对：</p>
<p><img src="https://img.funteas.com/f63286ff9702745ddb6f58c8ab5ce837?imageView2/2/w/800" alt=""></p>
<h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>现代JS应用的开发离不开模块了，ES6对模块的定义提供了语言层面的支持。规范化了各种JavaScript模块加载器，支持运行时动态加载模块，支持异步加载模块。</p>
<p>ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，效率要比 CommonJS 模块的加载方式高。</p>
<pre><code>// lib/math.js 模块的定义
exportfunction sum(x, y) { return x + y; } exportvar pi = 3.141593;
// app.js 模块的全部引用
import * as math from &quot;lib/math&quot;;
alert(&quot;2π = &quot; + math.sum(math.pi, math.pi));
// otherApp.js 模块的部分引用
import { sum, pi } from &quot;lib/math&quot;;
alert(&quot;2π = &quot; + sum(pi, pi));
// 模块导出方法
// lib/mathplusplus.js
export * from &quot;lib/math&quot;;
exportvar e = 2.71828182846;
exportdefaultfunction(x) { returnMath.log(x); }
// 混合引入方法
import ln, { pi, e } from &quot;lib/mathplusplus&quot;;
alert(&quot;2π = &quot; + ln(e) * pi * 2);
</code></pre><h3 id="Module-Loaders（其实并非ES6标准的一部分，只是草案）"><a href="#Module-Loaders（其实并非ES6标准的一部分，只是草案）" class="headerlink" title="Module Loaders（其实并非ES6标准的一部分，只是草案）"></a>Module Loaders（其实并非ES6标准的一部分，只是草案）</h3><p>模块加载器支持以下功能：</p>
<ul>
<li><p>动态加载</p>
</li>
<li><p>状态隔离</p>
</li>
<li><p>全局命名空间隔离</p>
</li>
<li><p>编写钩子</p>
</li>
<li><p>嵌套</p>
</li>
</ul>
<p>默认的模块加载器可以被配置，新的加载器可以被配置来评估加载独立上下文中的内容。</p>
<pre><code>// 动态加载 – ‘System’ 是默认的加载器
System.import(&#39;lib/math&#39;).then(function(m) {
    alert(&quot;2π = &quot; + m.sum(m.pi, m.pi));
});
// 新的加载器创建了执行沙盒
var loader = newLoader({
    global: fixup(window) // replace ‘console.log’
});
loader.eval(&quot;console.log(&#39;hello world!&#39;);&quot;);
// 可以直接修改模块的缓存
System.get(&#39;jquery&#39;);
System.set(&#39;jquery&#39;, Module({ $: $ }));
// WARNING: not yet finalized
</code></pre><h3 id="Map-Set-WeakMap-WeakSet"><a href="#Map-Set-WeakMap-WeakSet" class="headerlink" title="Map Set WeakMap WeakSet"></a>Map Set WeakMap WeakSet</h3><p>ES6为算法提供了新的高效的数据结构，<code>WeakMaps</code>提供了防泄漏的键值对表。</p>
<pre><code>// Set类似于数组，但是成员的值都是唯一的，没有重复的值。
var s = newSet();
s.add(&quot;hello&quot;).add(&quot;goodbye&quot;).add(&quot;hello&quot;);
s.size === 2;
s.has(&quot;hello&quot;) === true;
// Map 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
var m = newMap();
m.set(&quot;hello&quot;, 42);
m.set(s, 34);
m.get(s) == 34;
// WeakMap结构与Map结构类似，也是用于生成键值对的集合，但是WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名，此外WeakMap的键名所指向的对象，不计入垃圾回收机制。
var wm = newWeakMap();
wm.set(s, { extra: 42 });
wm.size === undefined
// WeakSet 结构与 Set 类似，也是不重复的值的集合,但是WeakSet 的成员只能是对象，而不能是其他类型的值，此外WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用
var ws = newWeakSet();
ws.add({ data: 42 });
// Because the added object has no other references, it will not be held in the set
</code></pre><blockquote>
<p>实际使用时需引入<a href="http://link.funteas.com/?target=http%3A%2F%2Fbabeljs.io%2Fdocs%2Fusage%2Fpolyfill%2F" target="_blank" rel="noopener">polyfill</a> </p>
</blockquote>
<h3 id="Proxies"><a href="#Proxies" class="headerlink" title="Proxies"></a>Proxies</h3><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<blockquote>
<p>需要注意的是目前未被Babel支持，使用时需谨慎</p>
</blockquote>
<pre><code>// target参数表示所要拦截的目标对象;
var target = {};
// handler参数也是一个对象，用来定制拦截行为;
var handler = { get: function(receiver, name) { return `Hello, ${name}!`; } };
// 生成一个Proxy实例
var p = newProxy(target, handler);
p.world === &#39;Hello, world!&#39;;
// 对函数同样可以使用代理
var target = function() { return &#39;I am the target&#39;; };
var handler = {
    apply: function(receiver, ...args) { return &#39;I am the proxy&#39;; }
};
var p = newProxy(target, handler);
p() === &#39;I am the proxy&#39;;
</code></pre><p>// Proxy支持的拦截操作如下</p>
<pre><code>var handler = {
    get: ...,
    set: ...,
    has: ...,
    deleteProperty: ...,
    apply: ...,
    construct: ...,
    getOwnPropertyDescriptor: ...,
    defineProperty: ...,
    getPrototypeOf: ...,
    setPrototypeOf: ...,
    enumerate: ...,
    ownKeys: ...,
    preventExtensions: ...,
    isExtensible: ...
}
</code></pre><blockquote>
<p>Babel 不支持，使用时应注意</p>
</blockquote>
<h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p><code>Symbol</code>保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名的冲突；<br>它是一种类似于字符串的数据类型,Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述；<br>Symbols是唯一的，单并非私有的，通过<code>Object.getOwnPropertySymbols</code>可以获取对应的值；<br>Symbol 值作为对象属性名时，不能用点运算符。</p>
<pre><code>varMyClass = (function() {
    // module scoped symbol
    var key = Symbol(&quot;key&quot;);
    functionMyClass(privateData) { this[key] = privateData; } MyClass.prototype = {
        doStuff: function() { ...this[key]... }
    };
    returnMyClass;
})();
var c = newMyClass(&quot;hello&quot;)
c[&quot;key&quot;] === undefined
</code></pre><blockquote>
<p>由于语言限制，Babel只提供部分支持，使用时需要注意</p>
</blockquote>
<h3 id="内置类的继承"><a href="#内置类的继承" class="headerlink" title="内置类的继承"></a>内置类的继承</h3><p>在ES6中，内置的<code>Array</code>,<code>Date</code>,<code>DOM Element</code>可以被继承以拓展了。</p>
<pre><code>// User code of Array subclass
classMyArrayextendsArray {
    constructor(...args) { super(...args); }
}
var arr = newMyArray();
arr[1] = 12;
arr.length == 2
</code></pre><blockquote>
<p>babel 部分支持，由于ES5引擎的限制<code>Date</code>,<code>Array</code>,<code>Error</code>不被支持，但是<code>HTMLElement</code>是被支持的</p>
</blockquote>
<h3 id="Math-Number-String-Array-Object-APIs"><a href="#Math-Number-String-Array-Object-APIs" class="headerlink" title="Math + Number + String + Array + Object APIs"></a>Math + Number + String + Array + Object APIs</h3><p>ES6 为很多旧有对象添加了新的API，这些对象包括<code>Math</code>,<code>Array器</code>，<code>String</code>,<code>Object</code>，如下：</p>
<pre><code>Number.EPSILON
Number.isInteger(Infinity)
// false
Number.isNaN(&quot;NaN&quot;)
// false
Math.acosh(3)
// 1.762747174039086
Math.hypot(3, 4)
// 5
Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2)
// 2
&quot;abcde&quot;.includes(&quot;cd&quot;)
// true
&quot;abc&quot;.repeat(3)
// &quot;abcabcabc&quot;
Array.from(document.querySelectorAll(&#39;*&#39;))
// Returns a real Array
Array.of(1, 2, 3)
// Similar to new Array(...), but without special one-arg behavior
[0, 0, 0].fill(7, 1)
// [0,7,7]
[1, 2, 3].find(x =&gt; x == 3)
// 3
[1, 2, 3].findIndex(x =&gt; x == 2)
// 1
[1, 2, 3, 4, 5].copyWithin(3, 0)
// [1, 2, 3, 1, 2]
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries()
// iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;]
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys()
// iterator 0, 1, 2
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values()
// iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;
Object.assign(Point, { origin: newPoint(0, 0) })
</code></pre><blockquote>
<p>babel 通过 polyfill 提供部分支持</p>
</blockquote>
<h3 id="二进制和八进制字面量"><a href="#二进制和八进制字面量" class="headerlink" title="二进制和八进制字面量"></a>二进制和八进制字面量</h3><p>ES6添加了二进制和八进制数值的字面量定义方法：</p>
<pre><code>0b111110111===503
// true
0o767===503
// true
</code></pre><blockquote>
<p>babel 只支持字面量形式，不支持 Number(“0o767”)形式</p>
</blockquote>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise为异步编程提供了一种新的方式，Promise把未来将用到的值当做一等对象，Promise在很多前端库中已经有所支持了。这个平时用得最多了，还没使用的推荐试试。</p>
<pre><code>function timeout(duration = 0) {
    returnnewPromise((resolve, reject) =&gt; {
        setTimeout(resolve, duration);
    })
}
var p = timeout(1000).then(() =&gt; { return timeout(2000); }).then(() =&gt; { thrownewError(&quot;hmm&quot;); }).catch(err =&gt; { returnPromise.all([timeout(100), timeout(200)]); })
</code></pre><blockquote>
<p>实际使用时需引入<a href="http://link.funteas.com/?target=http%3A%2F%2Fbabeljs.io%2Fdocs%2Fusage%2Fpolyfill%2F" target="_blank" rel="noopener">polyfill</a> </p>
</blockquote>
<h3 id="Reflect-API"><a href="#Reflect-API" class="headerlink" title="Reflect API"></a>Reflect API</h3><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API，作用如下：</p>
<ul>
<li><p>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上；</p>
</li>
<li><p>修改某些Object方法的返回结果，让其变得更合理；</p>
</li>
<li><p>让Object操作都变成函数行为，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</p>
</li>
<li><p>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法；</p>
</li>
</ul>
<pre><code>var O = { a: 1 };
Object.defineProperty(O, &#39;b&#39;, { value: 2 });
O[Symbol(&#39;c&#39;)] = 3;
Reflect.ownKeys(O);
// [&#39;a&#39;, &#39;b&#39;, Symbol(c)]
function C(a, b) { this.c = a + b; }
var instance = Reflect.construct(C, [20, 22]);
instance.c;
// 42
</code></pre><blockquote>
<p>实际使用时需引入<a href="http://link.funteas.com/?target=http%3A%2F%2Fbabeljs.io%2Fdocs%2Fusage%2Fpolyfill%2F" target="_blank" rel="noopener">polyfill</a> </p>
</blockquote>
<h3 id="Tail-Calls"><a href="#Tail-Calls" class="headerlink" title="Tail Calls"></a>Tail Calls</h3><p>尾部调用被保证不能无限拓展栈，这让有无限制输入时的递归算法更加安全。</p>
<pre><code>function factorial(n, acc = 1) { &#39;use strict&#39;; if (n &lt;= 1) return acc; return factorial(n - 1, n * acc); }
// 堆栈越来越常用，在ES6中其使用更加安全了
factorial(100000)
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>上文对ES6的新特性都做了简单的描述，但是关于<code>Reflect API</code>和<code>Proxies</code>,由于本人对他们的理解还不够透彻，说得可能有些不清不楚。希望阅读本文让你有收获，有任何疑问，大家也可以一起讨论。</p>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> es6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ajax 的全面总结]]></title>
      <url>/Ajax-%E7%9A%84%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Ajax在前端开发中有着举足轻重的地位，关于Ajax的使用和注意事项一直是一个重要的话题，借此机会，本文希望对Ajax做一个全面的总结，彻底揭开Ajax的神秘面纱。</p>
<h2 id="Ajax-的全面总结"><a href="#Ajax-的全面总结" class="headerlink" title="Ajax 的全面总结"></a>Ajax 的全面总结</h2><h2 id="一-什么是Ajax"><a href="#一-什么是Ajax" class="headerlink" title="一.什么是Ajax"></a>一.什么是Ajax</h2><p>Ajax(Asynchronous JavaScript and XML),可以理解为JavaScript执行异步网络请求。通俗的理解的话就是，如果没有Ajax技术，改变网页的一小部分（哪怕是一行文字、一张图片）都需要重新加载一次整个页面，<strong>而有了Ajax之后，就可以实现在网页不跳转不刷新的情况下，在网页后台提交数据，部分更新页面内容。</strong></p>
<h2 id="二-Ajax的原生写法"><a href="#二-Ajax的原生写法" class="headerlink" title="二.Ajax的原生写法"></a>二.Ajax的原生写法</h2><h3 id="1-XMLHttpRequest对象"><a href="#1-XMLHttpRequest对象" class="headerlink" title="1.XMLHttpRequest对象"></a>1.XMLHttpRequest对象</h3><p>XMLHttpRequest 对象用于在后台与服务器交换数据，能够在不重新加载页面的情况下更新网页，在页面已加载后从服务器请求数据，在页面已加载后从服务器接收数据，在后台向服务器发送数据。所以<strong>XMLHttpRequest对象是Ajax技术的核心所在。</strong></p>
<h3 id="2-实现流程"><a href="#2-实现流程" class="headerlink" title="2.实现流程"></a>2.实现流程</h3><p>创建 XMLHttpRequest对象——&gt;打开请求地址，初始化数据——&gt;发送请求数据——&gt;监听回调函数状态——&gt;收到服务器返回的应答结果。</p>
<p>下面用具体的代码进行解释：</p>
<pre><code>var xmlhttp;

function loadXMLDoc(url) {

    xmlhttp = null;


    if (window.XMLHttpRequest)


    { // code for all new browsers


        xmlhttp = newXMLHttpRequest(); //在这里创建 XMLHttpRequest对象


    }


    elseif(window.ActiveXObject)


    { // code for IE5 and IE6


        xmlhttp = newActiveXObject(&quot;Microsoft.XMLHTTP&quot;);


    }


    if (xmlhttp != null)


    {


        xmlhttp.open(&quot;GET&quot;, url, true); //请求的方式和请求地址


        xmlhttp.send(null); //发送请求


        xmlhttp.onreadystatechange = state_Change; //监听回调函数


    } else


    {


        alert(&quot;Your browser does not support XMLHTTP.&quot;);


    }


}


function state_Change() //这里是回调函数


{


    if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200)


    //当满足这两个条件时表示请求成功,完成响应 4 = &quot;loaded&quot;, 200 = OK  


    {


        var data = xmlhttp.responseText; //拿到服务器返回的数据


        // ...our code here...在这里进行数据返回后的操作


    } else


    {


        alert(&quot;Problem retrieving XML data&quot;);


    }


}
</code></pre><h3 id="3-原生写法中的注意点"><a href="#3-原生写法中的注意点" class="headerlink" title="3.原生写法中的注意点"></a>3.原生写法中的注意点</h3><p>(1).open() 的第三个参数中使用了 “true”,该参数规定请求是否异步处理，默认是异步。True 表示脚本会在 send() 方法之后继续执行，而不等待来自服务器的响应。</p>
<p>(2).关于readyState<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fllfps9jy7j30mc05mmxi.jpg" alt=""></p>
<p>(3).关于status 由服务器返回的 HTTP 状态代码，200 表示成功，而 404 表示 “Not Found” 错误。当 readyState 小于 3 的时候读取这一属性会导致一个异常。(后面会有http状态码的详细解读)</p>
<h2 id="三-JQuery中的Ajax"><a href="#三-JQuery中的Ajax" class="headerlink" title="三.JQuery中的Ajax"></a>三.JQuery中的Ajax</h2><p>JQuery对原生Ajax做了很好的封装，使用起来非常简单方便,具体的很多方法如 $.ajax，$.post， $.get， $.getJSON等能根据不同需要进行调用，写法更加简洁，但是为了兼顾各个方法在这里我以一个通用的方法 $.ajax为例做一个简单的解析,按照下面的模式写好各个参数,就能成功进行Ajax的请求了,可能在实际中使用 $.post， $.get 这两个方法使用比较多，但是<strong>理**</strong>解$.ajax 这个通用的方法能对封装原理有很好的认识。**</p>
<pre><code> $.ajax({


     type: //数据的提交方式：get和post


         url: //请求地址


         async: //是否支持异步刷新，默认是true


         data: //需要提交的数据


         dataType: //服务器返回数据的类型，例如xml,String,Json等


         success: function(data) {


         } //请求成功后的回调函数,参数data就是服务器返回的数据


     error: function(data) {


     } //请求失败后的回调函数，根据需要可以不写，一般只写上面的success回调函数


 })
</code></pre><h2 id="四-GET-or-POST？"><a href="#四-GET-or-POST？" class="headerlink" title="四.GET or POST？"></a>四.GET or POST？</h2><p>作为Ajax最常用的两种数据提交方式，GET和POST有着自己的特点和适用场景，<strong>正确区分GET和POST的不同并根据实际需要进行选用在开发中十分重要，简单但是关键</strong>！</p>
<p>先上一张GET 和 POST的比较图，从这张图中可以看出两者之间的差别：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fllfq8vt89j30m40d3gmt.jpg" alt=""></p>
<p><strong>从表格中拎出关键点：</strong> 1.传递数据的方式不同：get是直接把请求数据放在url的后面，是可见的，post的请求数据不会显示在url中，是不可见的。 2.数据长度和数据类型的差异：get有数据长度的的限制，且数据类型只允许ASCII字符，post在这两方面都没有限制。 3.安全性的差异：get不安全，post更安全。</p>
<p><strong>由此得出的两者的使用场景</strong>：get使用较方便，适用于页面之间非敏感数据的简单传值，post使用较为安全，适用于向服务器发送密码、token等敏感数据。</p>
<h2 id="五-success和complete的区别"><a href="#五-success和complete的区别" class="headerlink" title="五.success和complete的区别"></a>五.success和complete的区别</h2><p>JQuery封装的Ajax回调函数中，success、error、complete是最常用的三个，其中，success和error很好区别，一个是请求成功调用的，另一个是请求失败调用的，从字面上就可以理解。但是success和complete容易混淆，在这里特别做一个说明：</p>
<p>success:请求成功后回调函数。</p>
<p>complete:请求完成后回调函数 (请求成功或失败时均调用)。</p>
<p>注意到括号里面了吗，没错，<strong>区别就在于complete只要请求完成，不论是成功还是失败均会调用</strong>。也就是说如果调用了success，一定会调用complete；反过来调用了complete，不一定会调用success。(状态码404、403、301、302…都会进入complete，只要不出错就会调用)</p>
<h2 id="六-XML-gt-JSON"><a href="#六-XML-gt-JSON" class="headerlink" title="六.XML -&gt; JSON"></a>六.XML -&gt; JSON</h2><p>Ajax中的是 “x” 指的就是XML。</p>
<p>xml:可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言。</p>
<p>xml作为一种数据交互格式，广泛用在计算机领域，然而，随着json的发展，json以其明显的优势已经渐渐取代了xml成为现在数据交互格式的标准，所以在这里，想强调的是，<strong>json现在是主流的数据交互格式</strong>，前后端的交互标准，无论是前端提交给后台的数据，还是后台返回给前端的数据，都最好统一为json格式，各自接收到数据后再解析数据即可供后续使用。所以 “Ajax” 实际上已经发展为 “Ajaj”</p>
<h2 id="七-JSON和JSONP"><a href="#七-JSON和JSONP" class="headerlink" title="七.JSON和JSONP"></a>七.JSON和JSONP</h2><p>json 和 jsonp 看起来只相差了一个 “p” ，然而实际上根本不是一个东西，千万别以为是差不多的两个概念。</p>
<p>json：(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。</p>
<p>jsonp：一种借助 <code>&lt;script&gt;</code> 元素解决主流浏览器的跨域数据访问问题的方式。</p>
<h2 id="八-Ajax跨域访问"><a href="#八-Ajax跨域访问" class="headerlink" title="八.Ajax跨域访问"></a>八.Ajax跨域访问</h2><p>ajax很好，但不是万能的，<strong>ajax的请求与访问同样会受到浏览器同源策略的限制</strong>，不能访问不同主域中的地址。所以，为了解决这一问题，实现跨域访问，有很多种方式，上述提到的jsonp就是一种流行的方式，还有其他一些方式，我在这里就不展开说了，只是想说明ajax的使用也是有条件的，任何技术的实现都不会是没有限制的。跨域访问时一个很重要的知识点，之前专门写过一篇关于跨域访问的总结，还挺详细的，可以移步查看： javascript中实现跨域的方式总结</p>
<h2 id="九-再议HTTP状态码"><a href="#九-再议HTTP状态码" class="headerlink" title="九.再议HTTP状态码"></a>九.再议HTTP状态码</h2><p>前面提到的”200”、”404”只是http状态码中常见的两个，当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p>
<p>需要掌握的常见http状态码大致有以下一些：</p>
<pre><code>
1. 101：切换协议，服务器根据客户端的请求切换协议

2. **200：请求成功。一般用于GET与POST请求**

3. **301：永久重定向**

4. **302：临时重定向**

5. 303：与301类似。使用GET和POST请求查看

6. **304：请求资源未修改，使用缓存**

7. 307：与302类似。使用GET请求重定向

8. **404：客户端请求失败**

9. 408：请求超时

10. **500：内部服务器错误，无法完成请求**

11. 505:服务器不支持请求的HTTP协议的版本，无法完成处理
</code></pre><h2 id="十-不可忽视的HTTP头文件"><a href="#十-不可忽视的HTTP头文件" class="headerlink" title="十.不可忽视的HTTP头文件"></a>十.不可忽视的HTTP头文件</h2><p>http请求中的一个重要关注点就是请求头和响应头的内容，从这两个头文件中可以看出很多东西，当我们用发送一个ajax请求的时候，如果没有达到预期的效果，那么就需要打开浏览器的调试工具，从NetWork中找到相应的ajax请求，再通过查看请求头和响应头的信息，大体会知道这次请求的结果是怎么样的，结合响应的主体内容，可以很快找到问题。所以学会看http的头文件信息是前端开发中必须掌握的一个技能，下面就来看看具体的头文件信息。</p>
<p>首先随便上一张sf中的完成一个搜索结果的http请求，可以从图中的右侧清楚看到请求头和响应头的内容，包括了很多个字段信息，这些字段信息就是我们需要掌握的知识点，下面挑出其中的重点字段进行分析。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fllfu0gundj30md0cu75k.jpg" alt=""> </p>
<h3 id="1-请求头信息："><a href="#1-请求头信息：" class="headerlink" title="1.请求头信息："></a>1.请求头信息：</h3><pre><code>
1. Accept：客户端支持的数据类型

2. Accept-Charset：客户端采用的编码

3. Accept-Encoding：客户端支持的数据压缩格式

4. Accept-Language：客户端的语言环境

5. Cookie：客服端的cookie

6. Host：请求的服务器地址

7. Connection：客户端与服务连接类型

8. If-Modified-Since:上一次请求资源的缓存时间，与Last-Modified对应

9. If-None-Match：客户段缓存数据的唯一标识，与Etag对应

10. Referer:发起请求的源地址。
</code></pre><h3 id="2-响应头信息："><a href="#2-响应头信息：" class="headerlink" title="2.响应头信息："></a>2.响应头信息：</h3><pre><code>
1. content-encoding：响应数据的压缩格式。

2. content-length：响应数据的长度。

3. content-language：语言环境。

4. content-type：响应数据的类型。

5. Date:消息发送的时间

6. Age:经过的时间

7. Etag:被请求变量的实体值,用于判断请求的资源是否发生变化

8. Expires：缓存的过期时间

9. Last-Modified：在服务器端最后被修改的时间

10. server：服务器的型号
</code></pre><h3 id="3-两者都可能出现的消息"><a href="#3-两者都可能出现的消息" class="headerlink" title="3.两者都可能出现的消息"></a>3.两者都可能出现的消息</h3><p>Pragma：是否缓存(http1.0提出) Cache-Control:是否缓存(http1.1提出)</p>
<h3 id="4-跟缓存相关的字段"><a href="#4-跟缓存相关的字段" class="headerlink" title="4.跟缓存相关的字段"></a>4.跟缓存相关的字段</h3><p>(1) 强制缓存 expire 和 cache-control</p>
<p>(2) 对比缓存 Last-Modified 和 If-Modified-Since Etag 和 If-None-Match</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h2 id="十一-Ajax的优缺点"><a href="#十一-Ajax的优缺点" class="headerlink" title="十一.Ajax的优缺点"></a>十一.Ajax的优缺点</h2><h3 id="1-优点："><a href="#1-优点：" class="headerlink" title="1.优点："></a>1.优点：</h3><ol>
<li><p>页面无刷新，在页面内与服务器通信，减少用户等待时间，增强了用户体验。</p>
</li>
<li><p>使用异步方式与服务器通信，响应速度更快。</p>
</li>
<li><p>可以把一些原本服务器的工作转接到客户端，利用客户端闲置的能力来处理，减轻了服务器和带宽的负担，节约空间和宽带租用成本。</p>
</li>
<li><p>基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。</p>
</li>
</ol>
<h3 id="2-缺点："><a href="#2-缺点：" class="headerlink" title="2.缺点："></a>2.缺点：</h3><ol>
<li><p>无法进行操作的后退，即不支持浏览器的页面后退。</p>
</li>
<li><p>对搜索引擎的支持比较弱。</p>
</li>
<li><p>可能会影响程序中的异常处理机制。</p>
</li>
<li><p>安全问题，对一些网站攻击，如csrf、xxs、sql注入等不能很好地防御。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识Pandas]]></title>
      <url>/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Python</code>有着很多强大的计算库，用来做科学计算非常方便。其中pandas库是一个很有名的库，用来做数据分析非常方便。</p>
<h2 id="pandas简介"><a href="#pandas简介" class="headerlink" title="pandas简介"></a>pandas简介</h2><p>pandas是一个专门用于数据分析的开源Python库。</p>
<h3 id="使用Anaconda安装pandas"><a href="#使用Anaconda安装pandas" class="headerlink" title="使用Anaconda安装pandas"></a>使用Anaconda安装pandas</h3><p>安装pandas库最简单和最常用的方法是先安装一个发行版。我们选用先安装Anaconda，再用Anaconda安装pandas。</p>
<blockquote>
<p>Anaconda 是一个可用于科学计算的 Python 发行版，支持 Linux、Mac、Windows系统，内置了常用的科学计算包。它解决了官方 Python 的两大痛点。</p>
<ul>
<li>第一：提供了包管理功能，Windows 平台安装第三方包经常失败的场景得以解决，</li>
<li>第二：提供环境管理的功能，功能类似 Virtualenv，解决了多版本Python并存、切换的问题。</li>
</ul>
</blockquote>
<h4 id="安装conda"><a href="#安装conda" class="headerlink" title="安装conda"></a>安装conda</h4><p>conda是Anaconda的包管理器，用来管理各种依赖关系的包。可以通过它下载自己想要的包。</p>
<p>首先安装Anaconda，在<a href="https://www.anaconda.com/download/#macos" target="_blank" rel="noopener">官网下载</a>软件包（以mac系统为例），大约需要1.8G的磁盘空间。打开安装包，一路默认配置。这样，conda就会默认加到你的环境变量中。</p>
<h3 id="使用pypi安装pandas"><a href="#使用pypi安装pandas" class="headerlink" title="使用pypi安装pandas"></a>使用pypi安装pandas</h3><p>pypi是python安装之后自带的包管理器，我们也可以是用pip安装pandas。</p>
<pre><code>pip install pandas
</code></pre><h3 id="安装nose"><a href="#安装nose" class="headerlink" title="安装nose"></a>安装nose</h3><blockquote>
<p>坚持是否成功安装pandas</p>
</blockquote>
<pre><code>nosetests pandas
</code></pre><p>nose是python的测试模块，可以在开发阶段测试python代码。没有安装python发行版的或者没有nose模块的，可以安装nose模块。</p>
<blockquote>
<p>检查是否安装过nose模块。</p>
</blockquote>
<pre><code>pip list
</code></pre><blockquote>
<p>使用pip安装nose</p>
</blockquote>
<pre><code>pip install nose
</code></pre><h3 id="开始pandas之旅"><a href="#开始pandas之旅" class="headerlink" title="开始pandas之旅"></a>开始pandas之旅</h3><p>那么现在我们就可以开始学习我们的pandas了。</p>
<blockquote>
<p>命令行模式调试python代码。</p>
</blockquote>
<pre><code>python
</code></pre><p>这样就会进入python的命令行模式。</p>
<p>引入pandas模块。</p>
<pre><code>import pandas as pd
</code></pre><p><em>我们就可以使用pd这个pandas的实例，来调用pandas库一些常用的方法来处理数据。</em><br><em>exit()或者quit()命令：退出python命令行模式。</em></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> 数据分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> Python </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript异步编程（二）]]></title>
      <url>/%E4%BD%BF%E7%94%A8-await-%E5%87%8F%E5%B0%91%E5%9B%9E%E8%B0%83%E5%B5%8C%E5%A5%97.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发的时候，有时候需要发很多请求，然后经常会面临嵌套回调的问题，即在一个回调里面又嵌了一个回调，导致代码层层缩进得很厉害</p>
<h2 id="使用-await-减少回调嵌套"><a href="#使用-await-减少回调嵌套" class="headerlink" title="使用 await 减少回调嵌套"></a>使用 await 减少回调嵌套</h2><p>在开发的时候，有时候需要发很多请求，然后经常会面临嵌套回调的问题，即在一个回调里面又嵌了一个回调，导致代码层层缩进得很厉害，如下代码所示：</p>
<pre><code>ajax({
    url: &quot;/list&quot;,
    type: &quot;GET&quot;,
    success: function(data) {
        appendToDOM(data);
        ajax({
                url: &quot;/update&quot;,
                type: &quot;POST&quot;,
                success: function(data) {
                    util.toast(&quot;Success!&quot;);
                })
        });
}
});
</code></pre><p>这样的代码看起来有点吃力，这种异步回调通常可以用Promise优化一下，可以把上面代码改成：</p>
<pre><code>newPromise(resolve =&gt; {
ajax({
    url: &quot;/list&quot;,
    type: &quot;GET&quot;,
    success: data =&gt; resolve(data);
})
}).then(data =&gt; {
    appendToDOM(data);
    ajax({
            url: &quot;/update&quot;,
            type: &quot;POST&quot;,
            success: function(data) {
                util.toast(&quot;Successfully!&quot;);
            })
    });
});
</code></pre><p>Promise提供了一个resolve，方便通知什么时候异步结束了，不过本质还是一样的，还是使用回调，只是这个回调放在了then里面。</p>
<p>当需要获取多次异步数据的时候，可以使用Promise.all解决：</p>
<pre><code>let orderPromise = newPromise(resolve =&gt; {
    ajax(&quot;/order&quot;, &quot;GET&quot;, data =&gt; resolve(data));
});
let userPromise = newPromise(resolve =&gt; {
    ajax(&quot;/user&quot;, &quot;GET&quot;, data =&gt; resolve(data));
});
Promise.all([orderPromise, userPromise]).then(values =&gt; {
    let order = values[0],
        user = values[1];
});
</code></pre><p>但是这里也是使用了回调，有没有比较优雅的解决方式呢？</p>
<p>ES7的await/async可以让异步回调的写法跟写同步代码一样。第一个嵌套回调的例子可以用await改成下面的代码：</p>
<pre><code>let leadList = await newPromise(resolve =&gt; {
    ajax({
        url: &quot;/list&quot;,
        type: &quot;GET&quot;,
        success: data =&gt; resolve(data);
    });
});

appendToDom(leadList);
ajax({
    url: &quot;/update&quot;,
    type: &quot;POST&quot;,
    success: () =&gt; util.toast(&quot;Successfully&quot;);
});
</code></pre><p>Await让代码可以像瀑布流一样很自然地写下来。</p>
<p>第二个例子：获取多次异步数据，可以改成这样：</p>
<pre><code>let order = await newPromise(
        resolve =&gt; ajax(&quot;/order&quot;, data =&gt; resovle(data))),

    user = await newPromise(
        resolve =&gt; ajax(&quot;/user&quot;, data =&gt; resolve(data)));
</code></pre><p>这种写法就好像从本地获取数据一样，就不用套回调函数了。</p>
<p>Await除了用在发请求之外，还适用于其它异步场景，例如我在创建订单前先弹一个小框询问用户是要创建哪种类型的订单，然后再弹具体的设置订单的框，所以按正常思路这里需要传递一个按钮回调的点击函数，如下图所示：</p>
<p><img src="https://img.funteas.com/7ed628dbfa69b90eb33b6a77ef5efc56?imageView2/2/w/800" alt=""></p>
<p>但其实可以使用await解决，如下代码所示：</p>
<pre><code>let quoteHandler =require(&quot;./quote&quot;);

let createType = await quoteHandler.confirmCreate();
</code></pre><p>quote里面返回一个Promise，监听点击事件，并传递createType：</p>
<pre><code>let quoteHandler = {
    confirmCreate: function() {
        dialog.showDialog({
            contentTpl: tpl,
            className: &quot;confirm-create-quote&quot;
        });
        let $quoteDialog = $(&quot;.confirm-create-quote form&quot;)[0];
        returnnewPromise(resolve =&gt; {
            $(form.submit).on(&quot;click&quot;, function(event) {
                resolve(form.createType.value);
            });
        });
    }
}
</code></pre><p>这样外部调用者就可以使用await，而不用传递一个点击事件的回调函数了。</p>
<p>但是需要注意的是await的一次性执行特点。相对于回调函数来说，await的执行是一次性的，例如监听点击事件，然后使用await，那么点击事件只会执行一次，因为代码从上往下执行完了，所以当希望点击之后出错了还能继续修改和提交就不能使用await，另外使用await获取异步数据，如果出错了，那么成功的resolve就不会执行，后续的代码也不会执行，所以请求出错的时候基本逻辑不会有问题。</p>
<p>要在babel里面使用await，需要：</p>
<p>（1）安装一个Node包</p>
<p>npm install –save-dev babel-plugin-transform-async-to-generator</p>
<p>（2）在工程的根目录添加一个.babelrc文件，内容为：</p>
<pre><code>{&quot;plugins&quot;:[&quot;transform-async-to-generator&quot;]}
</code></pre><p>（3）使用的时候先引入一个模块</p>
<pre><code>require(&quot;babel-polyfill&quot;);
</code></pre><p>然后就可以愉快地使用ES7的await了。</p>
<p>使用await的函数前面需要加上async关键字，如下代码：</p>
<pre><code>async showOrderDialog() {

    let createType = await quoteHandler.confirmCreate();

    let orderInfo = await orderHandler.getOrderData();
}
</code></pre><p>我们再举一个例子：使用await实现JS版的sleep函数，因为原生是没有提供线程休眠函数的，如下代码所示：</p>
<pre><code>function sleep(time) {
    returnnewPromise(resolve =&gt; setTimeout(() =&gt; resolve(), time));
}

async function start() {
    await sleep(1000);
}

start();
</code></pre><p>babel的await实现是转成了ES6的generator，如下关键代码：</p>
<pre><code>while (1) {
    switch (_context.prev = _context.next) {
        case0: _context.next = 2;
        return sleep(1000);case2:
            case &quot;end&quot;:
            return _context.stop();
    }
}
</code></pre><p>而babel的generator也是要用ES5实现的，什么是generator呢？如下图所示：</p>
<p><img src="https://img.funteas.com/acefdf462f920886e55556cce745e124?imageView2/2/w/800" alt=""></p>
<p>生成器用function*定义，每次执行生成器的next函数的时候会返回当前生成器里用yield返回的值，然后生成器的迭代器往后走一步，直到所有yield完了。</p>
<p>有兴趣的可以继续研究babel是如何把ES7转成ES5的，据说原生的实现还是直接基于Promise.</p>
<p>使用await还有一个好处，可以直接try-catch捕获异步过程抛出的异常，因为我们是不能直接捕获异步回调里面的异常的，如下代码：</p>
<pre><code>let quoteHandler = {
    confirmCreate: function() {
        $(form.submit).on(&quot;click&quot;, function(event) {

            callback(form.notFoundInput.value);
        });
    }
}
try {

    quoteHandler.confirmCreate();
} catch (e) {}
</code></pre><p>上面的try-catch是没有办法捕获到异常的，因为try里的代码已经执行完了，在它执行的过程中并没有异常，因此无法在这里捕获，如果使用Promise的话一般是使用Promise链的catch：</p>
<pre><code>let quoteHandler = {
    confirmCreate: function() {
        returnnewPromise(resolve =&gt; {
            $(form.submit).on(&quot;click&quot;, function(event) {

                resolve(form.notFoundInput.value);
            });
        });
    }
}

quoteHandler.confirmCreate().then(createType =&gt; {
}).catch(e =&gt; {
});
</code></pre><p>而使用await，我们可以直接用同步的catch，就好像它真的变成同步执行了：</p>
<pre><code>try {
    createType = await quoteHandler.confirmCreate(&quot;order&quot;);
} catch (e) {
    console.log(e);
    return;
}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>总之使用await让代码少写了很多嵌套，很方便的逻辑处理，纵享丝滑。</p>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> es6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript异步编程（一）]]></title>
      <url>/%E6%88%91%E4%BA%86%E8%A7%A3%E5%88%B0%E7%9A%84JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="我了解到的JavaScript异步编程"><a href="#我了解到的JavaScript异步编程" class="headerlink" title="我了解到的JavaScript异步编程"></a>我了解到的JavaScript异步编程</h2><p>浏览器的内核是多线程的，他们在内核的控制下互相配合以保持同步，一个浏览器至少实现三个常驻的线程：javascript 引擎线程，GUI 渲染线程，浏览器事件触发线程</p>
<h2 id="一、-一道面试题"><a href="#一、-一道面试题" class="headerlink" title="一、 一道面试题"></a>一、 一道面试题</h2><p>前段时间面试，考察比较多的是js异步编程方面的相关知识点，如今，正好轮到自己分享技术，所以想把js异步编程学习下，做个总结。<br>下面这个demo 概括了大多数面试过程中遇到的问题：</p>
<pre><code>for (var i = 0; i &lt; 3; i++) {
    setTimeout(function() {
        console.log(&#39;timeout&#39; + i);
    })
}
newPromise(function(resolve) {
    console.log(&#39;promise1&#39;);
    for (var i = 0; i &lt; 1000; i++) {
        i == 99 &amp;&amp; resolve();
    }
    console.log(&#39;promise2&#39;);
}).then(function() {
    console.log(&#39;then1&#39;);
})

console.log(&#39;global1&#39;);
</code></pre><p>通过验证可以得知这个demo的结果为：</p>
<p><img src="https://img.funteas.com/d5db7a51ac511fabe4cd13ee7b1774c3.png?imageView2/2/w/800" alt="1.png"></p>
<p>可是为什么会是这样的结果，我们可能需要先了解下下面两个知识点</p>
<h2 id="二、-二个前提知识点"><a href="#二、-二个前提知识点" class="headerlink" title="二、 二个前提知识点"></a>二、 二个前提知识点</h2><h3 id="2-1-浏览器内核的多线程"><a href="#2-1-浏览器内核的多线程" class="headerlink" title="2.1 浏览器内核的多线程"></a>2.1 浏览器内核的多线程</h3><p><img src="https://img.funteas.com/7820dc3a5b1b443bf902c2d3165ae786.png?imageView2/2/w/800" alt="2.png"></p>
<p>浏览器的内核是多线程的，他们在内核的控制下互相配合以保持同步，一个浏览器至少实现三个常驻的线程：javascript引擎线程，GUI渲染线程，浏览器事件触发线程。</p>
<p>1)js引擎，基于事件驱动单线程执行的，js引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。<br>2）GUI线程，当界面需要重绘或由于某种操作引发回流时，该线程就会执行。它和JS引擎是互斥的。<br>3）浏览器事件触发线程，当一个事件被触发时，该线程会把事件添加到待处理队列的队尾，等待js引擎的处理，这些事件可来自JavaScript引擎当前执行的代码块如，setTimeOut, 也可以来自浏览器内核的其他线程如鼠标点击，AJAX异步请求等，但由于JS的单线程关系，所有这些事件都得排队等待JS引擎处理。</p>
<h3 id="2-2-事件循环机制"><a href="#2-2-事件循环机制" class="headerlink" title="2.2 事件循环机制"></a>2.2 事件循环机制</h3><p><img src="https://img.funteas.com/811d82c0a84fe03d1000352c5e83a3b4.png?imageView2/2/w/800" alt="3.png"></p>
<p>1）任务队列又分为macro-task（宏任务）与micro-task（微任务），<br>在最新标准中，它们被分别称为task与jobs。</p>
<p>2）macro-task大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。</p>
<p>3）micro-task【先执行】大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)</p>
<p>setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。</p>
<p>事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的macro-task，这样一直循环下去。</p>
<p>通过这个事件循环的顺序，我们就知道，为什么上面提到的面试题为什么是这样的输出结果了。<br>接下来我们看下三类异步编程的实现。</p>
<h2 id="三、三类异步编程实现"><a href="#三、三类异步编程实现" class="headerlink" title="三、三类异步编程实现"></a>三、三类异步编程实现</h2><h3 id="3-1-回调函数"><a href="#3-1-回调函数" class="headerlink" title="3.1 回调函数"></a>3.1 回调函数</h3><p>demo1:</p>
<pre><code>// 一个简单的封装
function want() {
    console.log(&#39;这是你想要执行的代码&#39;);
}
function fn(want) {
    console.log(&#39;这里表示执行了一大堆各种代码&#39;); // 其他代码执行完毕，最后执行回调函数
    want &amp;&amp; want();
}

fn(want);
</code></pre><p>demo2:</p>
<pre><code>//callback hell

doSomethingAsync1(function() {
    doSomethingAsync2(function() {
        doSomethingAsync3(function() {
            doSomethingAsync4(function() {
                doSomethingAsync5(function() { // code...
                });
            });
        });
    });
});
</code></pre><p>可以发现一个问题，在回调函数嵌套层数不深的情况下，代码还算容易理解和维护，一旦嵌套层数加深，就会出现“回调金字塔”的问题，就像demo2那样，如果这里面的每个回调函数中又包含了很多业务逻辑的话，整个代码块就会变得非常复杂。从逻辑正确性的角度来说，上面这几种回调函数的写法没有任何问题，但是随着业务逻辑的增加和趋于复杂，这种写法的缺点马上就会暴露出来，想要维护它们实在是太痛苦了，这就是“回调地狱(callback hell)”。</p>
<p>回调函数还有一个问题就是我们在回调函数之外无法捕获到回调函数中的异常，一般我们用try catch来捕捉异常，我们尝试下捕捉回调中的异常</p>
<p><img src="https://img.funteas.com/3ba320fc1acdbda04fdef90394e67e6e.png?imageView2/2/w/800" alt="4.png"><br>可以看到，不能捕捉到callback中的异常。</p>
<h3 id="3-2-事件监听-事件发布-订阅"><a href="#3-2-事件监听-事件发布-订阅" class="headerlink" title="3.2 事件监听(事件发布/订阅)"></a>3.2 事件监听(事件发布/订阅)</h3><p>事件监听是一种非常常见的异步编程模式，它是一种典型的逻辑分离方式，对代码解耦很有用处。通常情况下，我们需要考虑哪些部分是不变的，哪些是容易变化的，把不变的部分封装在组件内部，供外部调用，需要自定义的部分暴露在外部处理。从某种意义上说，事件的设计就是组件的接口设计。<br>1）jQuery事件监听</p>
<pre><code>    $(&#39;#btn&#39;).on(&#39;myEvent&#39;, function(e) {
    console.log(&#39;There is my Event&#39;);
});
$(&#39;#btn&#39;).trigger(&#39;myEvent&#39;);
</code></pre><p>2）发布/订阅模式</p>
<pre><code>varPubSub = function() { this.handlers = {}; };
PubSub.prototype.subscribe = function(eventType, handler) {
    if (!(eventType inthis.handlers)) { this.handlers[eventType] = []; } this.handlers[eventType].push(handler);
    //添加事件监听器
    return this;
    //返回上下文环境以实现链式调用
};
PubSub.prototype.publish = function(eventType) {
    var _args = Array.prototype.slice.call(arguments, 1);
    for (var i = 0, _handlers = this.handlers[eventType]; i &lt; _handlers.length; i++) {
        _handlers[i].apply(this, _args); //遍历事件监听器
    }
    return this;
};
varevent = newPubSub; //构造PubSub实例
event.subscribe(&#39;list&#39;, function(msg) {
    console.log(msg);
});
event.publish(&#39;list&#39;, { data: [&#39;one,&#39;, &#39;two&#39;] });
//Object {data: Array[2]}
</code></pre><p>这种模式实现的异步编程，本质上还是通过回调函数实现的，所以3.1中提到的回调嵌套和无法捕捉异常的问题还是存在的，接下来我们看ES6提供的Promise对象，是否解决这两个问题。</p>
<h3 id="3-3-Promise对象"><a href="#3-3-Promise对象" class="headerlink" title="3.3 Promise对象"></a>3.3 Promise对象</h3><p>ES 6中原生提供了Promise对象，Promise对象代表了某个未来才会知道结果的事件(一般是一个异步操作)，并且这个事件对外提供了统一的API，可供进一步处理。<br>使用Promise对象可以用同步操作的流程写法来表达异步操作，避免了层层嵌套的异步回调，代码也更加清晰易懂，方便维护，也可以捕捉异常。</p>
<p>一个简单例子：</p>
<pre><code>function fn(num) {
    returnnewPromise(function(resolve, reject) {
        if (typeof num == &#39;number&#39;) {
            resolve();
        } else {
            reject();
        }
    }).then(function() {
        console.log(&#39;参数是一个number值&#39;);
    }).then(null, function() {
        console.log(&#39;参数不是一个number值&#39;);
    })
}
fn(&#39;haha&#39;);
fn(1234);
</code></pre><p>为什么Promise 可以这样实现异步编程，在这我们简单分析下Promise实现过程：<br>1）极简Promise雏形</p>
<pre><code>// 极简promise雏形
functionPromise(fn) {
    var value = null,
        callbacks = []; //callbacks为数组，因为可能同时有很多个回调
    this.then = function(onFulfilled) {
        callbacks.push(onFulfilled);
    };

    function resolve(value) {
        callbacks.forEach(function(callback) {
            callback(value);
        });
    }

    fn(resolve);
}
</code></pre><ul>
<li>如果promise内部的函数是同步函数，我们要加入一些处理，保证在resolve执行之前，then方法已经注册完所有的回调；</li>
<li>通过setTimeout机制，将resolve中执行回调的逻辑放置到JS任务队列末尾，以保证在resolve执行时，then方法的回调函数已经注册完成.</li>
</ul>
<p>2）加入延时处理</p>
<pre><code>// 极简promise雏形，加入延时处理
functionPromise(fn) {
    var value = null,
        callbacks = []; //callbacks为数组，因为可能同时有很多个回调
    this.then = function(onFulfilled) {
        callbacks.push(onFulfilled);
    };

    function resolve(value) {
        setTimeout(function() {
            callbacks.forEach(function(callback) {
                callback(value);
            });
        }, 0)
    }

    fn(resolve);
}
</code></pre><ul>
<li>如果Promise异步操作已经成功，这时，在异步操作成功之前注册的回调都会执行，但是在Promise异步操作成功这之后调用的then注册的回调就再也不会执行了，这显然不是我们想要的</li>
</ul>
<p>3）加入状态判断</p>
<pre><code>// 极简promise雏形，加状态判断
functionPromise(fn) {
    var state = &#39;pending&#39;,
        value = null,
        callbacks = [];
    this.then = function(onFulfilled) {
        if (state === &#39;pending&#39;) {
            callbacks.push(onFulfilled);
            returnthis;
        }
        onFulfilled(value);
        returnthis;
    };

    function resolve(newValue) {
        value = newValue;
        state = &#39;fulfilled&#39;;
        setTimeout(function() {
            callbacks.forEach(function(callback) {
                callback(value);
            });
        }, 0);
    }

    fn(resolve);
}
</code></pre><p>4）链式promise</p>
<pre><code>// 极简promise雏形，链式promise
functionPromise(fn) {
    var state = &#39;pending&#39;,
        value = null,
        callbacks = [];
    this.then = function(onFulfilled) {
        returnnewPromise(function(resolve) {
            handle({
                onFulfilled: onFulfilled || null,
                resolve: resolve
            });
        });
    };

    function handle(callback) {
        if (state === &#39;pending&#39;) {
            callbacks.push(callback);
            return;
        } //如果then中没有传递任何东西
        if (!callback.onResolved) {
            callback.resolve(value);
            return;
        }
        var ret = callback.onFulfilled(value);
        callback.resolve(ret);
    }

    function resolve(newValue) {
        if (newValue &amp;&amp; (typeof newValue === &#39;object&#39; || typeof newValue === &#39;function&#39;)) { varthen = newValue.then; if (typeofthen === &#39;function&#39;) { then.call(newValue, resolve); return; } }
        state = &#39;fulfilled&#39;;
        value = newValue;
        setTimeout(function() {
            callbacks.forEach(function(callback) {
                handle(callback);
            });
        }, 0);
    }

    fn(resolve);
}
</code></pre><h2 id="四、四个扩展点"><a href="#四、四个扩展点" class="headerlink" title="四、四个扩展点"></a>四、四个扩展点</h2><h3 id="4-1-Promise常用的应用场景：ajax"><a href="#4-1-Promise常用的应用场景：ajax" class="headerlink" title="4.1 Promise常用的应用场景：ajax"></a>4.1 Promise常用的应用场景：ajax</h3><p>利用Promise的知识，对ajax进行一个简单的封装。看看会是什么样子：</p>
<pre><code>//demo3 promise封装ajax
var url =&#39;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10&#39;;
function getJSON(url) {
    returnnewPromise(function(resolve, reject) {
        var XHR = newXMLHttpRequest();
        XHR.open(&#39;GET&#39;, url, true);
        XHR.send();

        XHR.onreadystatechange = function() {
            if (XHR.readyState == 4) {
                if (XHR.status == 200) {
                    try {
                        var response = JSON.parse(XHR.responseText);
                        resolve(response);
                    } catch ( e ) {
                        reject(e);
                    }
                } else {
                    reject(newError(XHR.statusText));
                }
            }
        }
    })
}
getJSON(url).then(resp =&gt; console.log(resp));
</code></pre><p>除了串行执行若干异步任务外，Promise还可以并行执行异步任务。</p>
<p>当有一个ajax请求，它的参数需要另外2个甚至更多请求都有返回结果之后才能确定，那么这个时候，就需要用到Promise.all来帮助我们应对这个场景。</p>
<h3 id="4-2-Promise-all"><a href="#4-2-Promise-all" class="headerlink" title="4.2 Promise.all"></a>4.2 Promise.all</h3><p>Promise.all接收一个Promise对象组成的数组作为参数，当这个数组所有的Promise对象状态都变成resolved或者rejected的时候，它才会去调用then方法。</p>
<pre><code>// demo4 promise.all
var url = &#39;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10&#39;;
var url1 = &#39;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-03-26/2017-06-10&#39;;

function renderAll() { returnPromise.all([getJSON(url), getJSON(url1)]); }

renderAll().then(function(value) {
            console.log(value); //将得到一个数组，里面是两个接口返回的值})
</code></pre><p>结果：</p>
<p><img src="https://img.funteas.com/dc947fc1c210056b601d495a739b3590.png?imageView2/2/w/800" alt="5.png"></p>
<p>有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现。</p>
<h3 id="4-3-Promise-race"><a href="#4-3-Promise-race" class="headerlink" title="4.3 Promise.race"></a>4.3 Promise.race</h3><p>与Promise.all相似的是，Promise.race都是以一个Promise对象组成的数组作为参数，不同的是，只要当数组中的其中一个Promsie状态变成resolved或者rejected时，就可以调用.then方法了</p>
<pre><code>// demo5 promise.race
function renderRace() {
    returnPromise.race([getJSON(url), getJSON(url1)]);
}

renderRace().then(function(value) {
    console.log(value);
})
</code></pre><p>这里then()传的value值将是接口返回比较快的接口数据，另外一个接口仍在继续执行，但执行结果将被丢弃。</p>
<p>结果：</p>
<p><img src="https://img.funteas.com/61de25f0a2f0a8ba9216fb4189c1978b.png?imageView2/2/w/800" alt="6.png"></p>
<h3 id="4-4-Generator-函数"><a href="#4-4-Generator-函数" class="headerlink" title="4.4 Generator 函数"></a>4.4 Generator 函数</h3><p>Generator函数是协程在ES 6中的实现，最大特点就是可以交出函数的执行权（暂停执行）。<br>注意：在node中需要开启–harmony选项来启用Generator函数。<br>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。</p>
<p>看个简单的例子：</p>
<pre><code>function* gen(x) {
    var y = yieldx + 2;
    return y;
}
var g = gen(1);
var r1 = g.next(); // { value: 3, done: false }
console.log(r1);
var r2 = g.next() // { value: undefined, done: true }
console.log(r2);
</code></pre><p>需要注意的是Generator函数的函数名前面有一个”*”。<br>上述代码中，调用Generator函数，会返回一个内部指针(即遍历器)g，这是Generator函数和一般函数不同的地方，调用它不会返回结果，而是一个指针对象。调用指针g的next方法，会移动内部指针，指向第一个遇到的yield语句，上例就是执行到x+2为止。<br>换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一个阶段。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>对Generator函数，只有一个感性认知，没有实践过，所以就先介绍到这了，后面还有ES7新的知识点async await，看了下网上的资料，理解得还不够，希望后面自己接触得更多再来这里补上，未完待续…</p>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[__proto__与prototype]]></title>
      <url>/%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E7%9A%84-proto-%E4%B8%8Eprototype.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当创建函数时，JavaScript 会为这个函数自动添加 prototype 属性，这个属性指向的是一个原型对象 Functionname.prototype。我们可以向这个原型对象添加属性或对象，甚至可以指向一个现有的对象</p>
<h2 id="傻傻分不清的proto与prototype"><a href="#傻傻分不清的proto与prototype" class="headerlink" title="傻傻分不清的proto与prototype"></a>傻傻分不清的<strong>proto</strong>与prototype</h2><p>今天小英童鞋问了我一个问题：</p>
<pre><code>functionFoo(firstName, lastName) { this.firstName = firstName;
    this.lastName = lastName; } Foo.prototype.logName = function() {
    Foo.combineName();
    console.log(this.fullName);
}
Foo.prototype.combineName = function() { this.fullName = `${this.firstName} ${this.lastName}` }
var foo = newFoo(&#39;Sanfeng&#39;, &#39;Zhang&#39;);
foo.logName(); // Uncaught TypeError: Foo.combineName is not a function
</code></pre><p>小英童鞋认为<code>Foo</code>的原型对象是<code>Foo.prototype</code>，所以<code>Foo</code>会继承<code>Foo.prototype</code>的属性，调用<code>Foo.combineName()</code>相当于调用<code>Foo.prototype.combineName()</code>，但结果<code>Foo.combineName()</code>不是一个方法。</p>
<p>会造成这个问题的原因一定是因为小英童鞋弄混了原型和继承的一些原理，下面我们来整理一下原型和继承的相关原理，找出问题的根本原因。</p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><code>prototype</code></h2><p><code>prototype</code>是一个只有函数才有的属性。</p>
<p>当创建函数时，<strong>JavaScript</strong> 会为这个函数自动添加<code>prototype</code>属性，这个属性指向的是一个原型对象<code>Functionname.prototype</code>。我们可以向这个原型对象添加属性或对象，甚至可以指向一个现有的对象。</p>
<h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h2><p>接下来我们说说继承，每个对象都有一个<code>__proto__</code>属性，这个属性是用来标识自己所继承的原型。</p>
<p>注意： <strong>JavaScript</strong> 中任意对象都有一个内置属性 <strong>[[Prototype]]</strong> ，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过<code>__proto__</code>来访问。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><strong>JavaScript</strong> 可以通过<code>prototype</code>和<code>__proto__</code>在两个对象之间创建一个关联，使得一个对象就可以通过委托访问另一个对象的属性和函数。</p>
<p>这样的一个关联就是原型链，一个由对象组成的有限对象链，用于实现继承和共享属性。</p>
<h2 id="构造函数创建对象实例"><a href="#构造函数创建对象实例" class="headerlink" title="构造函数创建对象实例"></a>构造函数创建对象实例</h2><p><strong>JavaScript</strong> 函数有两个不同的内部方法：<strong>[[Call]]</strong> 和 <strong>[[Construct]]</strong> 。</p>
<p>如果不通过<code>new</code>关键字调用函数，则执行 <strong>[[Call]]</strong> 函数，从而直接执行代码中的函数体。</p>
<p>当通过<code>new</code>关键字调用函数时，执行的是 <strong>[[Construct]]</strong> 函数，它负责创建一个实例对象，把实例对象的<code>__proto__</code>属性指向构造函数的<code>prototype</code>来实现继承构造函数<code>prototype</code>的所有属性和方法，将<code>this</code>绑定到实例上，然后再执行函数体。</p>
<p>模拟一个构造函数：</p>
<pre><code>functionFoo(firstName, lastName) { this.firstName = firstName;
    this.lastName = lastName; } Foo.prototype.logName = function() {
    Foo.combineName();
    console.log(this.fullName);
}
Foo.prototype.combineName = function() { this.fullName = `${this.firstName} ${this.lastName}` }
var foo = newFoo(&#39;Sanfeng&#39;, &#39;Zhang&#39;);
foo.logName(); // Uncaught TypeError: Foo.combineName is not a function
</code></pre><p>至此我们了解了<code>prototype</code>和<code>__proto__</code>的作用，也了解使用构造函数创建对象实例时这两个属性的指向，以下使用一张图来总结一下如何通过<code>prototype</code>和<code>__proto__</code>实现原型链。</p>
<p><img src="https://img.funteas.com/12d6bb072d101ff6e1966a63329cf806?imageView2/2/w/800" alt=""></p>
<p>从上图我们可以找出<code>foo</code>对象和<code>Foo</code>函数的原型链：</p>
<pre><code>foo.__proto__ = Foo.prototype;
foo.__proto__.__proto__ = Foo.prototype.__proto__ = Object.prototype;
foo.__proto__.__proto__.__proto__ = Foo.prototype.__proto__.__proto__ = Object.prototype.__proto__ = null;
</code></pre><p><img src="https://img.funteas.com/73c4353afa8b74a63baedfc94c583539?imageView2/2/w/800" alt=""></p>
<pre><code>Foo.__proto__ = Function.prototype;
Foo.__proto__.__proto__ = Function.prototype.__proto__;
Foo.__proto__.__proto__.__proto__ = Function.prototype.__proto__.__proto__ = Object.prototype.__proto__ = null;
</code></pre><p><img src="https://img.funteas.com/aa3de68a5dd2e76120d836d22adeb969?imageView2/2/w/800" alt=""></p>
<p>构造函数<code>Foo</code>的原型链上没有<code>Foo.prototype</code>，因此无法继承<code>Foo.prototype</code>上的属性和方法。而实例<code>foo</code>的原型链上有<code>Foo.prototype</code>，因此<code>foo</code>可以继承<code>Foo.prototype</code>上的属性和方法。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>到这里，我们可以很简单的解答小英童鞋的问题了，在<code>Foo</code>的原型链上没有<code>Foo.prototype</code>，无法继承<code>Foo.prototype</code>上的<code>combineName</code>方法，因此会抛出<code>Foo.combineName is not a function</code>的异常。要想使用<code>combineName</code>方法，可以这样<code>Foo.prototype.combineName</code>，或者这样<code>this.combineName</code>（<code>this</code>指向实例对象）。</p>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用合适的设计模式一步步优化前端代码]]></title>
      <url>/%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E6%AD%A5%E6%AD%A5%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>常见的设计模式有 23 种，如果单纯的按照模式名称 + 名词解释的方式来写这篇文章，可能太枯燥了或者很难理解记忆，所以我打算换一种方式。下面我们以一个例子开始我们今天的文章。</p>
<h2 id="使用合适的设计模式一步步优化前端代码"><a href="#使用合适的设计模式一步步优化前端代码" class="headerlink" title="使用合适的设计模式一步步优化前端代码"></a>使用合适的设计模式一步步优化前端代码</h2><blockquote>
<p>在后端语言中，设计模式应用的较为广泛。如Spring中常见的工厂模式、装饰者模式、单例模式、迭代器模式。但是在日常的前端开发中，设计模式使用的较少，或者大家的代码已经遵循了某某设计模式但是我们并不知道。常见的设计模式有23种，如果单纯的按照模式名称+名词解释的方式来写这篇文章，可能太枯燥了或者很难理解记忆，所以我打算换一种方式。下面我们以一个例子开始我们今天的文章。</p>
</blockquote>
<h5 id="假设我们有一个这样的需求："><a href="#假设我们有一个这样的需求：" class="headerlink" title="假设我们有一个这样的需求："></a>假设我们有一个这样的需求：</h5><pre><code>let page = {
    init: () =&gt; { //此处(placeA)有很多业务代码或者调用了很多page中的其他初始化函数
    },
    ....
};
</code></pre><p>现在业务迭代，需要我们在page.init()初始化代码块的最后增加一些功能，同时不影响原先的功能。按照正常的写法，我们可能会像下面这样写：</p>
<pre><code>let page = {
    init: () =&gt; { //placeA
        page.newFunction();
    },
    newFunction: () =&gt; { ... }
};
</code></pre><p>这样写是可以解决我们的需求，但是这样的代码是具有侵略性的，我们不得不在原先的代码的合适位置新增我们需要的代码。但我们思考一个问题，如果我们用了某个插件或者某个被ungly、minify之后的代码呢，我们怎么在找到合适的位置添加我们需要的功能呢？大家可以先自己思考一下，再看下面的内容。</p>
<h5 id="首先我们先看解决方案，再思考其背后的东西。"><a href="#首先我们先看解决方案，再思考其背后的东西。" class="headerlink" title="首先我们先看解决方案，再思考其背后的东西。"></a>首先我们先看解决方案，再思考其背后的东西。</h5><pre><code>//我们可以在Function的原型链上定义一个扩展函数，以实现我们的需求。
Function.prototype.fnAfter = function(fn) {
    var _self = this;
    returnfunction() {
        _self.apply(this, arguments);
        fn.apply(this, arguments);
    }
};

page.init = (page.init || function() {}).fnAfter(function() {
    console.log(&#39;我们要追加的功能成功啦~&#39;);
});

page.init();
</code></pre><p>上面的代码已经能够实现我们的需要了，但是其实还是不够好或者可以写的更灵活一些。因为我希望可以可以做到像jquery的链式调用那样，可以一直往后面追加新的功能。那么我们在上面代码的基础上再扩展下，其实很简单，我们只要再Function.prototype.fnAfter中再返回自身就好了。</p>
<pre><code>Function.prototype.fnAfter = function(fn) {
    var _self = this;
    returnfunction() {
        var fnOrigin = _self.apply(this, arguments);
        fn.apply(this, arguments);
        return fnOrigin;
    }
};
</code></pre><p>其实上面的代码写法还是可以优化的。比如：</p>
<pre><code>//每次扩展的时候我们都需要这么写
page.init = (page.init || function() {}).fnAfter(function() { //
    ...
}); //我们能不能再优化下，比如容错代码 || function(){} 在一个地方统一处理  
//或者我们新建一个工厂函数来帮我们统一做这样的事情，这里我们就不展开了，文章篇幅有限。
</code></pre><h5 id="我们上面的扩展其实就是遵循的是面向对象程序设计中的开放-封闭原则（OCP）。官方对OCP的解释是：软件实体（类、模块、函数…）应该是可以扩展的，但是不可修改。设计模式中有很多模式都遵循了开发-封闭原则，比如：发布-订阅者模式、模板方法模式、策略模式、代理模式。"><a href="#我们上面的扩展其实就是遵循的是面向对象程序设计中的开放-封闭原则（OCP）。官方对OCP的解释是：软件实体（类、模块、函数…）应该是可以扩展的，但是不可修改。设计模式中有很多模式都遵循了开发-封闭原则，比如：发布-订阅者模式、模板方法模式、策略模式、代理模式。" class="headerlink" title="我们上面的扩展其实就是遵循的是面向对象程序设计中的开放-封闭原则（OCP）。官方对OCP的解释是：软件实体（类、模块、函数…）应该是可以扩展的，但是不可修改。设计模式中有很多模式都遵循了开发-封闭原则，比如：发布-订阅者模式、模板方法模式、策略模式、代理模式。"></a>我们上面的扩展其实就是遵循的是面向对象程序设计中的开放-封闭原则（OCP）。官方对OCP的解释是：软件实体（类、模块、函数…）应该是可以扩展的，但是不可修改。设计模式中有很多模式都遵循了开发-封闭原则，比如：发布-订阅者模式、模板方法模式、策略模式、代理模式。</h5><p>有的时候我们通过扩展来提高代码的灵活性并不能解决所有的场景需要，在不可避免发生修改的时候，我们可以通过增加配置文件，让用户修改配置文件以实现个性化需求也是合理的。修改配置远比修改源代码要简单的多。</p>
<h5 id="有了上面的引入，我们来看几个前端开发中常见的设计模式。"><a href="#有了上面的引入，我们来看几个前端开发中常见的设计模式。" class="headerlink" title="有了上面的引入，我们来看几个前端开发中常见的设计模式。"></a>有了上面的引入，我们来看几个前端开发中常见的设计模式。</h5><ul>
<li>单例模式</li>
</ul>
<blockquote>
<p>单例模式顾名思义：保证一个类仅有一个实例，并且对外暴露一个能够访问到它的访问点。</p>
</blockquote>
<p>实现单例模式的核心就是保证一个类仅有一个实例，那么意思就是当创建一个对象时，我们需要判断下之前有没有创建过该实例，如果创建过则返回之前创建的实例，否则新建。</p>
<pre><code>var fn = function() { this.instance = null; };
fn.getInstance = function() { //写法1
    if (!this.instance) { this.instance = new fn(); }
    return this.instance; //写法2
    return this.instance || (this.instance = new fn());
};
var fnA = fn.getInstance();
var fnB = fn.getInstance();
console.log(fnA === fnB); //true
</code></pre><p>日常的业务场景中，单例模式也比较常见，比如：一个页面中的模态框只有一个，每次打开与关闭的都应该是同一个，而不是重复新建。而且为了性能优化，我们应该在需要时再创建，而不是页面初始化时就已经存在于dom中，这个就是_惰性单例模式_。</p>
<pre><code>//假设我们需要点击某个按钮时就显示出模态框，那么我们可以像下面这么
var createModal = (function() {
    var modal = null;
    returnfunction() {
        if (!modal) {
            modal = document.createElement(&#39;div&#39;); //...
            modal.style.display = &#39;none&#39;;
            document.getElementById(&#39;container&#39;).append(modal);
        }
        return modal;
    }
})();

document.getElementById(&#39;showModal&#39;).click(function() {
    var modal = createModal();
    modal.style.display = &#39;block&#39;;
});
</code></pre><p>上面的代码中，我们将创建对象和管理实例的逻辑都放在一个地方，违反了单一职责原则，我们应该单独新建一个用于创建单例的方法，这样我们不仅能创建唯一的modal实例，也能创建其他的，职责分开。</p>
<pre><code>var createSingleInstance = function(fn) {
    var instance = null;
    returnfunction() {
        if (!instance) {
            instance = fn.apply(this, arguments);
        }
        return instance;
    }
};
var createModal = function() {
    var modal = docuemnt.createElement(&#39;div&#39;); //...
    modal.style.display = &#39;none&#39;;
    document.getElementById(&#39;container&#39;).append(modal);
    return modal;
};
var modal = createSingleInstance(createModal);
</code></pre><ul>
<li>观察者模式</li>
</ul>
<blockquote>
<p>定义了对象与其他对象之间的依赖关系，当某个对象发生改变的时候，所有依赖到这个对象的地方都会被通知。</p>
<p>像knockout.js中的ko.compute以及vue中的computed函数其实就是这个模式的实践。实现观察者模式的核心就是我们需要有一个变量来保存所有的依赖，一个listen函数用于向变量中添加依赖，一个trigger函数用于触发通知。</p>
</blockquote>
<pre><code>var observal = {
    eventObj: {},
    listen: function(key, fn) { this.eventObj[key] = this.eventObj[key] || [];
        this.eventObj[key].push(fn); },
    trigger: function(key) { var eventList = this.eventObj[key]; if (!eventList || eventList.length &lt; 1) { return; } var length = eventList.length; for (var i = 0; i &lt; length; i++) { varevent = eventList[i];
            event.apply(this, arguments); } }
}; //定义要监听的事件
observal.listen(&#39;command1&#39;, function() {
    console.log(&#39;黑夜给了我夜色的眼睛~&#39;);
});
observal.listen(&#39;command1&#39;, function() {
    console.log(&#39;我却用它寻找光明~&#39;);
});
observal.listen(&#39;command2&#39;, function() {
    console.log(&#39;一花一世界~&#39;);
});
observal.listen(&#39;command2&#39;, function() {
    console.log(&#39;一码一人生~&#39;);
}); //触发某个监听的事件
observal.trigger(&#39;command1&#39;); //黑夜给了我夜色的眼睛~ 我却用它寻找光明~
observal.trigger(&#39;command2&#39;); //一花一世界~ 一码一人生~
</code></pre><p>使用观察者模式（发布-订阅模式）我们可以使得代码更灵活、健壮性更高。订阅者不需要了解消息来自哪一个发布者，发布者也不需要知道消息会发送给哪些订阅者。</p>
<p>同样的我们可以创建一个公用的函数库，里面存放创建observal的工具方法，需要用到的地方我们就用这个方法创建一个发布订阅对象。</p>
<ul>
<li>其他设计模式及设计原则</li>
</ul>
<p>设计模式有很多，这里篇幅有限就不再展开。GoF在1995年提出了23种设计模式。诸如策略者模式优化表单验证、代理模式、组合模式、装饰者模式、适配器模式…这些后期可以再简单探讨或者大家后面自己了解。常用的设计模式及设计原则可以参考下面的思维导图。<img src="https://user-gold-cdn.xitu.io/2017/10/27/f7ab0664b5fd4e34dbb16eaab5813c9d" alt="常用设计模式"><img src="https://user-gold-cdn.xitu.io/2017/10/27/038d561c77aba1ff095fa0c3cfc8c113" alt="六大设计原则"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>设计模式都是经过了大量的代码、软件实践而总结出来的优秀的组织实践方案。每种设计模式都有它的适应场景，有的场景也会使用多种设计模式。只有了解了更多的设计模式，掌握各个设计模式自己的适应场景，才能更好的为我们所用。</p>
<p>但是过早的优化不一定是好事或者不是必须的，有时候我们可以一开始并不去优化，等到某个应用场景下出现了代码组织混乱、需要额外扩展等问题，我们再优化重构，以防过早优化导致的不必要性或者只是增加了代码不必要的复杂性。就像redux，如果一个页面组件与组件之间有数据共享、需要在任意组件内部拿到某个数据、任意一个组件中某个行为导致的数据变化需要通知到所有用到的地方，那么这个时候可以使用redux，一些简单的表单页面或者展示页完全可以不用redux。</p>
]]></content>
      
        <categories>
            
            <category> javascript设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS3 transform特性教程]]></title>
      <url>/CSS3-transform%E7%89%B9%E6%80%A7%E6%95%99%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍的是css3新属性变形transform。</p>
<h2 id="CSS3-transform教程"><a href="#CSS3-transform教程" class="headerlink" title="CSS3 transform教程"></a>CSS3 transform教程</h2><p><a href="http://www.w3.org/TR/css3-2d-transforms/" target="_blank" rel="noopener">Transform</a> 字面上就是变形，改变的意思。在<a href="http://www.w3.org/TR/css3-roadmap/" target="_blank" rel="noopener">CSS3</a> 中<a href="http://www.w3.org/TR/css3-2d-transforms/" target="_blank" rel="noopener">transform</a> 主要包括以下几种：<strong>旋转rotate</strong>、<strong>扭曲skew</strong>、<strong>缩放scale</strong>和<strong>移动translate</strong>以及<strong>矩阵变形matrix</strong>。下面我们一起来看看CSS3中transform的旋转rotate、扭曲skew、缩放scale和移动translate具体如何实现，老样子，我们就从<a href="http://www.w3.org/TR/css3-2d-transforms/" target="_blank" rel="noopener">transform</a> 的语法开始吧。</p>
<p><strong>语法：</strong></p>
<pre><code>   transform ： none | &lt;transform-function&gt; [ &lt;transform-function&gt; ]* 
   也就是：
   transform: rotate | scale | skew | translate |matrix;
</code></pre><p>none:表示不进么变换；<transform-function>表示一个或多个变换函数，以空格分开；换句话说就是我们同时对一个元素进行transform的多种属性操作，例如rotate、scale、translate三种，但这里需要提醒大家的，以往我们叠加效果都是用逗号（“，”）隔开，但transform中使用多个属性时却需要有空格隔开。大家记住了是空格隔开。</transform-function></p>
<p>取值：</p>
<p>transform属性实现了一些可用SVG实现的同样的功能。它可用于内联(inline)元素和块级(block)元素。它允许我们旋转、缩放和移动元素 ，他有几个属性值参数：rotate;translate;scale;skew;matrix。下面我们分别来介绍这几个属性值参数的具体使用方法：</p>
<h3 id="一、旋转rotate"><a href="#一、旋转rotate" class="headerlink" title="一、旋转rotate"></a><strong>一、旋转rotate</strong></h3><p>rotate(<angle>) ：通过指定的角度参数对原元素指定一个<a href="http://www.w3.org/TR/SVG/coords.html#RotationDefined" target="_blank" rel="noopener">2D rotation</a> （2D 旋转），需先有transform-origin属性的定义。transform-origin定义的是旋转的基点，其中angle是指旋转角度，如果设置的值为正数表示顺时针旋转，如果设置的值为负数，则表示逆时针旋转。如：transform:rotate(30deg):</angle></p>
<p><img src="http://www.w3cplus.com/sites/default/files/rotate.png" alt=""> </p>
<h3 id="二、移动translate"><a href="#二、移动translate" class="headerlink" title="二、移动translate"></a><strong>二、移动translate</strong></h3><p>移动translate我们分为三种情况：translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）；translateX(x)仅水平方向移动（X轴移动）；translateY(Y)仅垂直方向移动（Y轴移动），具体使用方法如下：</p>
<p>1、translate(<translation-value>[, <translation-value>]) ：通过矢量[tx, ty]指定一个<a href="http://www.w3.org/TR/SVG/coords.html#TranslationDefined" target="_blank" rel="noopener">2D translation</a> ，tx 是第一个过渡值参数，ty 是第二个过渡值参数选项。如果 未被提供，则ty以 0 作为其值。也就是translate(x,y),它表示对象进行平移，按照设定的x,y参数值,当值为负数时，反方向移动物体，其基点默认为元素 中心点，也可以根据transform-origin进行改变基点。如transform:translate(100px,20px):</translation-value></translation-value></p>
<p><img src="http://www.w3cplus.com/sites/default/files/translate-x-y.png" alt=""> </p>
<p>2、translateX(<translation-value>) ： 通过给定一个X方向上的数目指定一个<a href="http://www.w3.org/TR/SVG/coords.html#TranslationDefined" target="_blank" rel="noopener">translation</a> 。只向x轴进行移动元素，同样其基点是元素中心点，也可以根据transform-origin改变基点位置。如：transform:translateX(100px):</translation-value></p>
<p><img src="http://www.w3cplus.com/sites/default/files/translate-x.png" alt=""> </p>
<p>3、translateY(<translation-value>) ：通过给定Y方向的数目指定一个<a href="http://www.w3.org/TR/SVG/coords.html#TranslationDefined" target="_blank" rel="noopener">translation</a> 。只向Y轴进行移动，基点在元素心点，可以通过transform-origin改变基点位置。如：transform:translateY(20px):</translation-value></p>
<p><img src="http://www.w3cplus.com/sites/default/files/translate-y.png" alt=""> </p>
<p><strong>三、缩放scale</strong></p>
<p>缩放scale和移动translate是极其相似，他也具有三种情况：scale(x,y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）；scaleX(x)元素仅水平方向缩放（X轴缩放）；scaleY(y)元素仅垂直方向缩放（Y轴缩放），但它们具有相同的缩放中心点和基数，其中心点就是元素的中心位置，缩放基数为1，如果其值大于1元素就放大，反之其值小于1，元素缩小。下面我们具体来看看这三种情况具体使用方法：</p>
<p>1、scale(<number>[, <number>])：提供执行[sx,sy]缩放矢量的两个参数指定一个<a href="http://www.w3.org/TR/SVG/coords.html#ScalingDefined" target="_blank" rel="noopener">2D scale</a> （2D缩放）。如果第二个参数未提供，则取与第一个参数一样的值。scale(X,Y)是用于对元素进行缩放，可以通过transform-origin对元素的基点进行设置，同样基点在元素中心位置；基中X表示水平方向缩放的倍数，Y表示垂直方向的缩放倍数，而Y是一个可选参数，如果没有设置Y值，则表示X，Y两个方向的缩放倍数是一样的。并以X为准。如：transform:scale(2,1.5):</number></number></p>
<p><img src="http://www.w3cplus.com/sites/default/files/scale-x-y.png" alt=""> </p>
<p>2、scaleX(<number>) ： 使用 [sx,1] 缩放矢量执行缩放操作，sx为所需参数。scaleX表示元素只在X轴(水平方向)缩放元素，他的默认值是(1,1)，其基点一样是在元素的中心位置，我们同样是通过transform-origin来改变元素的基点。如：transform:scaleX(2):</number></p>
<p><img src="http://www.w3cplus.com/sites/default/files/scale-x.png" alt=""> </p>
<p>3、scaleY(<number>) ： 使用 [1,sy] 缩放矢量执行缩放操作，sy为所需参数。scaleY表示元素只在Y轴（垂直方向）缩放元素，其基点同样是在元素中心位置，可以通过transform-origin来改变元素的基点。如transform:scaleY(2):</number></p>
<p><img src="http://www.w3cplus.com/sites/default/files/scale-y.png" alt=""> </p>
<p><strong>四、扭曲skew</strong></p>
<p>扭曲skew和translate、scale一样同样具有三种情况：skew(x,y)使元素在水平和垂直方向同时扭曲（X轴和Y轴同时按一定的角度值进行扭曲变形）；skewX(x)仅使元素在水平方向扭曲变形（X轴扭曲变形）；skewY(y)仅使元素在垂直方向扭曲变形（Y轴扭曲变形），具体使用如下：</p>
<p>1、skew(<angle> [, <angle>]) ：X轴Y轴上的<a href="http://www.w3.org/TR/SVG/coords.html#SkewXDefined" target="_blank" rel="noopener">skew transformation</a> （斜切变换）。第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则值为0，也就是Y轴方向上无斜切。skew是用来对元素进行扭曲变行，第一个参数是水平方向扭曲角度，第二个参数是垂直方向扭曲角度。其中第二个参数是可选参数，如果没有设置第二个参数，那么Y轴为0deg。同样是以元素中心为基点，我们也可以通过transform-origin来改变元素的基点位置。如：transform:skew(30deg,10deg):</angle></angle></p>
<p><img src="http://www.w3cplus.com/sites/default/files/skew-x-y.png" alt=""> </p>
<p>2、skewX(<angle>) ： 按给定的角度沿X轴指定一个<a href="http://www.w3.org/TR/SVG/coords.html#SkewXDefined" target="_blank" rel="noopener">skew transformation</a> （斜切变换）。skewX是使元素以其中心为基点，并在水平方向（X轴）进行扭曲变行，同样可以通过transform-origin来改变元素的基点。如：transform:skewX(30deg)</angle></p>
<p><img src="http://www.w3cplus.com/sites/default/files/skew-x.png" alt=""> </p>
<p>3、skewY(<angle>) ： 按给定的角度沿Y轴指定一个<a href="http://www.w3.org/TR/SVG/coords.html#SkewYDefined" target="_blank" rel="noopener">skew transformation</a> （斜切变换）。skewY是用来设置元素以其中心为基点并按给定的角度在垂直方向（Y轴）扭曲变形。同样我们可以通过transform-origin来改变元素的基点。如：transform:skewY（10deg）</angle></p>
<p><img src="http://www.w3cplus.com/sites/default/files/skew-y.png" alt=""> </p>
<p><strong>五、矩阵matrix</strong></p>
<p>matrix(<number>, <number>, <number>, <number>, <number>, <number>) ： 以一个含六值的(a,b,c,d,e,f)<a href="http://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined" target="_blank" rel="noopener">变换矩阵</a> 的形式指定一个2D变换，相当于直接应用一个[a b c d e f]变换矩阵。就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素,此属性值使用涉及到数学中的矩阵，我在这里只是简单的说一下CSS3中的transform有这么一个属性值，如果有感兴趣的朋友可以去了解更深层次的martix使用方法，这里就不多说了。</number></number></number></number></number></number></p>
<p><strong>改变元素基点transform-origin</strong></p>
<p>前面我们多次提到transform-origin这个东东，他的主要作用就是让我们在进行transform动作之前可以改变元素的基点位置，因为我们元素默认基点就是其中心位置，换句话说我们没有使用transform-origin改变元素基点位置的情况下，transform进行的rotate,translate,scale,skew,matrix等操作都是以元素自己中心位置进行变化的。但有时候我们需要在不同的位置对元素进行这些操作，那么我们就可以使用transform-origin来对元素进行基点位置改变，使元素基点不在是中心位置，以达到你需要的基点位置。下面我们主要来看看其使用规则：</p>
<p>transform-origin(X,Y):用来设置元素的运动的基点（参照点）。默认点是元素的中心点。其中X和Y的值可以是百分值,em,px，其中X也可以是字符参数值left,center,right；Y和X一样除了百分值外还可以设置字符值top,center,bottom，这个看上去有点像我们background-position设置一样；下面我列出他们相对应的写法：</p>
<p>1、top left | left top 等价于 0 0 | 0% 0%</p>
<p>2、top | top center | center top 等价于 50% 0</p>
<p>3、right top | top right 等价于 100% 0</p>
<p>4、left | left center | center left 等价于 0 50% | 0% 50%</p>
<p>5、center | center center 等价于 50% 50%（默认值）</p>
<p>6、right | right center | center right 等价于 100% 50%</p>
<p>7、bottom left | left bottom 等价于 0 100% | 0% 100%</p>
<p>8、bottom | bottom center | center bottom 等价于 50% 100%</p>
<p>9、bottom right | right bottom 等价于 100% 100%</p>
<p>其中 left,center right是水平方向取值，对应的百分值为left=0%;center=50%;right=100%而top center bottom是垂直方向的取值，其中top=0%;center=50%;bottom=100%;如果只取一个值，表示垂直方向值不变，我们分别来看看以下几个实例</p>
<p>(1)transform-origin:(left,top):</p>
<p><img src="http://www.w3cplus.com/sites/default/files/origin-x-y.png" alt=""> </p>
<p>(2)transform-origin:right</p>
<p><img src="http://www.w3cplus.com/sites/default/files/origin-x.png" alt=""> </p>
<p>(3)transform-origin(25%,75%)</p>
<p><img src="http://www.w3cplus.com/sites/default/files/origin-per.png" alt=""> </p>
<p>更多的改变中心基点办法，大家可以在本地多测试一下，多体会一下，这里还要提醒大家一点的是，transform-origin并不是transform中的属性值，他具有自己的语法，前面我也说过了，说简单一点就是类似于我们的background-position的用法，但又有其不一样，因为我们background-position不需要区别浏览器内核不同的写法，但transform-origin跟其他的css3属性一样，我们需要在不同的浏览内核中加上相应的前缀，下面列出各种浏览器内核下的语法规则：</p>
<pre><code>//Mozilla内核浏览器：firefox3.5+
  -moz-transform-origin: x y;
  //Webkit内核浏览器：Safari and Chrome
  -webkit-transform-origin: x y;
  //Opera
  -o-transform-origin: x y ;
  //IE9
  -ms-transform-origin: x y;
  //W3C标准
  transform-origin: x y ;
</code></pre><p><strong>transform在不同浏览器内核下的书写规则</strong></p>
<pre><code>//Mozilla内核浏览器：firefox3.5+
  -moz-transform: rotate | scale | skew | translate ;
 //Webkit内核浏览器：Safari and Chrome
  -webkit-transform: rotate | scale | skew | translate ;
 //Opera
  -o-transform: rotate | scale | skew | translate ;
 //IE9
  -ms-transform: rotate | scale | skew | translate ;
 //W3C标准
  transform: rotate | scale | skew | translate ;
</code></pre><p>上面列出是不同浏览内核transform的书写规则，如果需要兼容各浏览器的话，以上写法都需要调用。</p>
<p><strong>支持transform浏览器</strong></p>
<p><img src="http://www.w3cplus.com/sites/default/files/transform-browers.png" alt=""> </p>
<p>同样的transform在IE9下版本是无法兼容的，之所以有好多朋友说，IE用不了，搞这个做什么？个人认为，CSS3推出来了，他是一门相对前沿的技术，做为Web前端的开发者或者爱好者都有必要了解和掌握的一门新技术，如果要等到所有浏览器兼容，那我们只能对css3说NO，我用不你。因为IE老大是跟不上了，，，，纯属个人观点，不代表任何。还是那句话，感兴趣的朋友跟我一样，不去理会IE，我们继续看下去。</p>
<p>在上面我们详细介绍了CSS3中transform的各种属性值的设置以及其各自的参数，下面我们通过一个实例来看看每一种属性值的使用，为了节约空间和大家的时间，我们后面的实例都是在这个html基础上实现，主要是我们在下面的菜单中的a:hover中分别使用不同的transform的设置，换句话说，当你移动到链接上时，相应的每一个菜单项有不同的变化，因为我们在每个菜单中使用了transform。具体每一步我们可以看下面的实例：</p>
<p><strong>HTML Code:</strong></p>
<pre><code>&lt;divclass=&quot;menu&quot;&gt;
    &lt;ulclass=&quot;clearfix&quot;&gt;
        &lt;liclass=&quot;item translate&quot;&gt;
            &lt;ahref=&quot;#&quot;&gt;Translate&lt;/a&gt;
                &lt;/li&gt;
                &lt;liclass=&quot;item translate-x&quot;&gt;
                    &lt;ahref=&quot;#&quot;&gt;TranslateX&lt;/a&gt;
                        &lt;/li&gt;
                        &lt;liclass=&quot;item translate-y&quot;&gt;
                            &lt;ahref=&quot;#&quot;&gt;TranslateY&lt;/a&gt;
                                &lt;/li&gt;
                                &lt;liclass=&quot;item rotate&quot;&gt;
                                    &lt;ahref=&quot;#&quot;&gt;Rotate&lt;/a&gt;
                                        &lt;/li&gt;
                                        &lt;liclass=&quot;item scale&quot;&gt;
                                            &lt;ahref=&quot;#&quot;&gt;Scale&lt;/a&gt;
                                                &lt;/li&gt;
                                                &lt;liclass=&quot;item scale-x&quot;&gt;
                                                    &lt;ahref=&quot;#&quot;&gt;ScaleX&lt;/a&gt;
                                                        &lt;/li&gt;
                                                        &lt;liclass=&quot;item scale-y&quot;&gt;
                                                            &lt;ahref=&quot;#&quot;&gt;ScaleY&lt;/a&gt;
                                                                &lt;/li&gt;
                                                                &lt;liclass=&quot;item skew&quot;&gt;
                                                                    &lt;ahref=&quot;#&quot;&gt;Skew&lt;/a&gt;
                                                                        &lt;/li&gt;
                                                                        &lt;liclass=&quot;item skew-x&quot;&gt;
                                                                            &lt;ahref=&quot;#&quot;&gt;SkewX&lt;/a&gt;
                                                                                &lt;/li&gt;
                                                                                &lt;liclass=&quot;item skew-y&quot;&gt;
                                                                                    &lt;ahref=&quot;#&quot;&gt;SkewY&lt;/a&gt;
                                                                                        &lt;/li&gt;
                                                                                        &lt;liclass=&quot;item matrix&quot;&gt;
                                                                                            &lt;ahref=&quot;#&quot;&gt;Matrix&lt;/a&gt;
                                                                                                &lt;/li&gt;
                                                                                                &lt;/ul&gt;
                                                                                                &lt;/div&gt;
</code></pre><p>为了效果更好一点，我们给上面的导航菜单加上一点CSS样式：</p>
<pre><code>.menuul {
    border-top: 15px solid black;
    padding: 010px;
}

.menuullia {
    color: #fff;
    float: left;
    margin: 05px;
    font-size: 14px;
    height: 50px;
    line-height: 50px;
    text-align: center;
    width: 65px;
    padding: 10px 5px;
    background: #151515;
    -moz-border-radius: 005px 5px;
    -webkit-border-radius: 005px 5px;
    border-radius: 005px 5px;
    -moz-box-shadow: 001px #ccc, inset 002px #fff;
    -webkit-box-shadow: 001px #ccc, inset 002px #fff;
    box-shadow: 001px #ccc, inset 002px #fff;
    text-shadow: 01px 1px #686868;
    text-decoration: none;
}

.menuulli.translatea {
    background: #2EC7D2;
}

.menuulli.translate-xa {
    background: #8FDD21;
}

.menuulli.translate-ya {
    background: #F45917;
}

.menuulli.rotatea {
    background: #D50E19;
}

.menuulli.scalea {
    background: #cdddf2;
}

.menuulli.scale-xa {
    background: #0fDD21;
}

.menuulli.scale-ya {
    background: #cd5917;
}

.menuulli.skewa {
    background: #519;
}

.menuulli.skew-xa {
    background: #D50;
}

.menuulli.skew-ya {
    background: #E19;
}

.menuulli.matrixa {
    background: #919;
}
</code></pre><p>在这里我们使用了一些前面所进的CSS3的属性制作出来的导航，如果你跟着做的话，在你本地一定能看到一个非常靓丽的导航菜单，这里由于无法链接demo原页面，只好贴上缩略图，让大家有一个初步效果视觉初步的效果如下：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/transform-menu-dome.png" alt=""> (style=undefined)</p>
<p>从效果图上我们可以清楚的看到菜单上我们分别对应的是transform中的Translate、TranslateX、TranslateY、Rotate、Scale、ScaleX、ScaleY、Skew、SkewX、SkewY和Matrix，下面我们就在相应的a:hover加上各自的效果：</p>
<p><strong>1、transform:translate(x,y):</strong></p>
<pre><code>.menuulli.translatea:hover {
    -moz-transform: translate(-10px, -10px);
    -webkit-transform: translate(-10px, -10px);
    -o-transform: translate(-10px, -10px);
    -ms-transform: translate(-10px, -10px);
    transform: translate(-10px, -10px);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-translate-xy.png" alt=""></p>
<p><strong>2、transform:translateX(x)</strong></p>
<pre><code>.menuulli.translate-xa:hover {
    -moz-transform: translateX(-10px);
    -webkit-transform: translateX(-10px);
    -o-transform: translateX(-10px);
    -ms-transform: translateX(-10px);
    transform: translateX(-10px);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-translatex.png" alt=""></p>
<p><strong>3、transform:translateY(y)</strong></p>
<pre><code>.menuulli.translate-ya:hover {
    -moz-transform: translateY(-10px);
    -webkit-transform: translateY(-10px);
    -o-transform: translateY(-10px);
    -ms-transform: translateY(-10px);
    transform: translateY(-10px);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-translatey.png" alt=""></p>
<p><strong>4、transform:rotate(角度值)</strong></p>
<pre><code>.menuulli.rotatea:hover {
    -moz-transform: rotate(45deg);
    -webkit-transform: rotate(45deg);
    -o-transform: rotate(45deg);
    -ms-transform: rotate(45deg);
    transform: rotate(45deg);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-rotate.png" alt=""> </p>
<p><strong>5、transform:scale(x,y)</strong></p>
<pre><code>.menuulli.scalea:hover {
    -moz-transform: scale(0.8, 0.8);
    -webkit-transform: scale(0.8, 0.8);
    -o-transform: scale(0.8, 0.8);
    -ms-transform: scale(0.8, 0.8);
    transform: scale(0.8, 0.8);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-scalexy.png" alt=""> (style=undefined)</p>
<p><strong>6、transform:scaleX(x)</strong></p>
<pre><code>.menuulli.scale-xa:hover {
    -moz-transform: scaleX(0.8);
    -webkit-transform: scaleX(0.8);
    -o-transform: scaleX(0.8);
    -ms-transform: scaleX(0.8);
    transform: scaleX(0.8);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-scalex.png" alt=""></p>
<p><strong>7、transform:scaleY(y)</strong></p>
<pre><code>.menuulli.scale-ya:hover {
    -moz-transform: scaleY(1.2);
    -webkit-transform: scaleY(1.2);
    -o-transform: scaleY(1.2);
    -ms-transform: scaleY(1.2);
    transform: scaleY(1.2);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-scaley.png" alt=""></p>
<p><strong>8、transform:skew(x,y)</strong></p>
<pre><code>.menuulli.skewa:hover {
    -moz-transform: skew(45deg, 15deg);
    -webkit-transform: skew(45deg, 15deg);
    -o-transform: skew(45deg, 15deg);
    -ms-transform: skew(45deg, 15deg);
    transform: skew(45deg, 15deg);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-skewxy.png" alt=""> </p>
<p><strong>9、transform:skewX(x)</strong></p>
<pre><code>.menuulli.skew-xa:hover {
    -moz-transform: skewX(-30deg);
    -webkit-transform: skewX(-30deg);
    -o-transform: skewX(-30deg);
    -ms-transform: skewX(-30deg);
    transform: skewX(-30deg);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-skewx.png" alt=""> </p>
<p><strong>10、transform:skewY(y)</strong></p>
<pre><code>.menuulli.skew-ya:hover {
    -moz-transform: skewY(30deg);
    -webkit-transform: skewY(30deg);
    -o-transform: skewY(30deg);
    -ms-transform: skewY(30deg);
    transform: skewY(30deg);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-skewy.png" alt=""></p>
<p><strong>11、transform:matrix(a,b,c,d,e,f)</strong></p>
<pre><code>.menuulli.matrixa:hover {
    -moz-transform: matrix(1, 1, -1, 0, 0, 0);
    -webkit-transform: matrix(1, 1, -1, 0, 0, 0);
    -o-transform: matrix(1, 1, -1, 0, 0, 0);
    -ms-transform: matrix(1, 1, -1, 0, 0, 0);
    transform: matrix(1, 1, -1, 0, 0, 0);
}
</code></pre><p>效果：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-matrix.png" alt=""> </p>
<p>transform中的matrix是相对的复杂，如果感兴趣的朋友可以点<a href="http://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined" target="_blank" rel="noopener">这里</a> 进去学民更多有关于Matrix的用法，我在这里就不多说了，说了也讲不清楚。</p>
<p>下面我们来看看最终的效果图，如果你在本地跟着这个实例做了的话，那么你就能看到非常好的效果了。</p>
<p><img src="http://www.w3cplus.com/sites/default/files/transform-demo-hover.png" alt=""> </p>
<p>上面的实例效果展示了有关于transform中各种风格效果，这里需要提醒大家，我们上面的效果都是以元素自身的中心点为基点的，下面我们来看一个改变元素基点的实例</p>
<p>我们在前面的实例基础改变一下所有a标签基点位置为left top（前面默认是center center）</p>
<pre><code>.menuulli.transform-origina {
    -moz-transform-origin: left top;
    -webkit-transform-origin: left top;
    -o-transform-origin: left top;
    -ms-transform-origin: left top;
    transform-origin: left top;
}
</code></pre><p>大家一起看看改变了a标签基点后transform下各种效果有什么样的变化：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/Transform-origin-demo-hover.png" alt=""> </p>
<p>从效果图中大家可以明显的看出，改变元素的基点后。元素进行transform任何属性值的设置都会有影响，换句话说，我们transform进行任何动作变化都是以元素的中心为基点，同时我们可以通过transform-origin来改变任何元素的基点，从而达到不同的效果。感兴趣的朋友可以去了解更多有关这方面的知识。</p>
<p>最后我们再来看一个transform运用多个属性值的效果实例</p>
<pre><code>.demoa {
    width: 100px;
    padding: 5px;
    background: red;
    display: block;
}

.demoa:hover {
    -moz-transform: rotate(45deg)scale(0.8, 1.2)skew(60deg, -30deg);
    -webkit-transform: rotate(45deg)scale(0.8, 1.2)skew(60deg, -30deg);
    -o-transform: rotate(45deg)scale(0.8, 1.2)skew(60deg, -30deg);
    -ms-transform: rotate(45deg)scale(0.8, 1.2)skew(60deg, -30deg);
    transform: rotate(45deg)scale(0.8, 1.2)skew(60deg, -30deg);
}
</code></pre><p>这里需要注意的是使用多个属性值时，其之间不能用逗号（“，”）分隔，必须使用空格分隔，记住了是空格分隔，如上面代码所示。</p>
<p>那么到这有关于CSS3的transform就介绍完了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> css3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack简易配置入门]]></title>
      <url>/webpack%E7%AE%80%E6%98%93%E9%85%8D%E7%BD%AE%E5%85%A5%E9%97%A8.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>WebPack 可以看做是模块打包机：它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript 等），并将其转换和打包为合适的格式供浏览器使用</p>
<h2 id="webpack-简易配置入门教程"><a href="#webpack-简易配置入门教程" class="headerlink" title="webpack 简易配置入门教程"></a>webpack 简易配置入门教程</h2><p><img src="https://img.funteas.com/e54cfd22c67adc465dff62272b905fc7?imageView2/2/w/800" alt=""></p>
<p><code>webpack</code>是现在一款非常流行的<strong>模块化管理工具🔧</strong>，<strong><code>react+webpack+es6</code></strong>是很火的项目构建组合</p>
<blockquote>
<p><code>webpack</code>会将有依赖关系的文件都视为一个模块，比如<code>scss</code>,<code>sass</code>,<code>less</code>,<code>css</code>结尾的文件，这样会产生一个模块群，<code>webpack</code>处理过后会产生可以被浏览器识别的一些文件，比如<code>Js</code>,<code>css</code>,<code>html</code>等。</p>
<p><a href="https://webpack.github.io/" target="_blank" rel="noopener">Webpack</a>在面对大型工程项目时，非常有优势，它最大的特点是很轻，不会加载打包冗余的文件，只会打包项目中用的到的模块。这是<code>webpack</code>的<strong>代码分割</strong>特性～</p>
<p><code>webpack</code>的<strong>模块热更新</strong>特性：当项目文件发生变化时，不需要开发人员手动刷新浏览器，<code>webpack</code>会自动刷新页面，极大地提高了开发效率，是不是很神奇！</p>
</blockquote>
<p><strong>注意：本文的webpack环境是<code>3.5.5</code>由于webpack的更新很快，每次更新都会更新新的语法，所以学习webpack的本质就可以</strong>，具体语法可以看webpack官网：<strong><a href="https://webpack.github.io/" target="_blank" rel="noopener">https://webpack.github.io/</a></strong></p>
<p>那么让我们快速以一个webpack demo的形式开始我们的webpack的学习吧～</p>
<h3 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h3><p>在前端的项目开发中，总有大量的页面和样式需要处理，而维护这些文件也成了头疼的问题。</p>
<p>为了简化开发，于是就有很多好的开发方式，如：</p>
<ul>
<li><p>模块化开发。每个功能模块都分开成一个个独立的组件，需要的时候再引入。</p>
</li>
<li><p>scss等预处理器。</p>
</li>
<li><p>使用pug, jade 更快编写HTML。</p>
</li>
<li><p>…</p>
</li>
</ul>
<p>这些方式确实可以大大提高开发效率，但是每种方式都有自己的打包方式，还有兼容性处理，如果纯手动处理，必然会增加工作量。</p>
<p>但是，现在有了webpack，上述问题基本解决了，一个webpack就可以处理各种繁琐的过程，给你一个清爽，快速的开发环境。</p>
<blockquote>
<p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。</p>
</blockquote>
<p>简单的来说，在项目开发中，</p>
<ul>
<li><p>你可以使用js，es6/7，甚至ts开发。</p>
</li>
<li><p>es6/es7, .ts =&gt; .js</p>
</li>
<li><p>使用stylus, scss, less 等预处理器编写css</p>
</li>
<li><p>.scss/.less =&gt; .css</p>
</li>
</ul>
<p>webpack可以将你项目中的所有文件，处理成浏览器能识别的文件。</p>
<h3 id="开始使用webpack"><a href="#开始使用webpack" class="headerlink" title="开始使用webpack"></a>开始使用webpack</h3><p>先新建一个练手用的空文件夹 <code>$ mkdir webpack-demo</code> ，并进入该文件夹。</p>
<ol>
<li>新建 <code>package.json</code>.</li>
</ol>
<pre><code>$ npm init
</code></pre><ol>
<li>安装webpack及其基本插件。</li>
</ol>
<pre><code>$ npm i -D webpack extract-text-webpack-plugin html-webpack-plugin css-loader file-loader style-loader url-loader
</code></pre><p>其中：</p>
<ol>
<li>配置webpack。</li>
</ol>
<p>新建一个配置文件： <code>$ touch webpack.config.js</code></p>
<pre><code>var webpack = require(&#39;webpack&#39;);
var path = require(&#39;path&#39;);
varExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);
var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
var webpackConfig = { // 设置入口文件。
    entry: &#39;./src/js/index.js&#39;,
    output: { // 设置输出文件夹
        path: path.join(__dirname, &#39;dist&#39;), // 设置公用文件夹路径
        publicPath: &#39;/&#39;, // 设置输出的js文件的名字规则。// [name] 为chunk中的名称// [hash] 为webpack生成的哈希值
        filename: &quot;js/[name].[hash].bundle.js&quot;
    },
    module: {
        rules: [{ // 处理css文件
            test: /\.css$/,
            loader: &quot;style-loader!css-loader&quot;
        }, { // 处理html文件，并处理img 中 src 和 data-src 的引入路径
            test: /\.html$/,
            loader: &quot;html-loader?attrs=img:src img:data-src&quot;
        }, { // 处理字体文件
            test: /\.(woff|woff2|ttf|eot|svg)(\?v=[0-9]\.[0-9]\.[0-9])?$/,
            loader: &#39;file-loader?name=./fonts/[name].[ext]&#39;
        }, { // 处理图片，并将8k以下的图片转为base64编码
            test: /\.(png|jpg|gif)$/,
            loader: &#39;url-loader?limit=8192&amp;name=./img/[hash].[ext]&#39;
        }]
    },
    plugins: [ // 公共js提取
        new webpack.optimize.CommonsChunkPlugin({
            name: &#39;vendors&#39;, // 将公共模块提取，生成名为`vendors`的chunk 
            minChunks: 3 // 提取至少3个模块共有的部分
        }),
        // 提取公共css样式
        newExtractTextPlugin(&#39;./css/[name].css&#39;),
        // 处理html文件。
        newHtmlWebpackPlugin({
            filename: &#39;./view/index.html&#39;, //生成的html存放路径，相对于path
            template: &#39;./src/view/index.html&#39;, //html模板路径
            inject: &#39;body&#39;, //js插入的位置，true/&#39;head&#39;/&#39;body&#39;/false
            hash: true, //为静态资源生成hash值// 
            chunks: [&#39;vendors&#39;, allDirs[i] + &#39;/&#39; + matches[1]], //需要引入的chunk，不配置就会引入所有页面的资源
            minify: { //压缩HTML文件
                removeComments: true, //移除HTML中的注释
                collapseWhitespace: false //删除空白符与换行符
            }
        })
    ], // 设置开发服务器
    devServer: {
        contentBase: path.join(__dirname, &quot;dist/&quot;),
        host: &#39;localhost&#39;,
        port: 9090,
        inline: true
    }
}
module.exports = webpackConfig
</code></pre><ol>
<li>测试配置文件：<br>先设置开发文件夹目录：</li>
</ol>
<ul>
<li>webpack-demo<ul>
<li>node_modules</li>
</ul>
<ul>
<li>src<ul>
<li>js      // 存放js文件</li>
<li>css     // 存放css样式</li>
<li>view    // 存放模板文件</li>
</ul>
<ul>
<li>webpack.config.js</li>
<li>package.json</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>新建一个 html 文件：<br><code>$ touch ./src/view/index.html</code>。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

    &lt;head&gt;
        &lt;metacharset=&quot;UTF-8&quot;&gt;
            &lt;metaname=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
                &lt;metahttp-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
                    &lt;title&gt;Hello World&lt;/title&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;h2&gt;Hello World&lt;/h2&gt;
        &lt;p&gt;This is from webpack-demo&lt;/p&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p>新建css文件： <code>$ touch ./src/css/index.css</code>。</p>
<pre><code>h2 {
    color: red;
    opacity: 0.5;
    transform: rotateZ(-10 deg);
}
p {
    color: green;
}
</code></pre><p>新建js文件： <code>$ touch ./src/js/index.js</code>。</p>
<pre><code>// 引入css文件。
require(&#39;../css/index.css&#39;)

console.log(&#39;hello world&#39;);
</code></pre><p>测试打包： <code>$ webpack</code><br>OK!基本的配置就完成了。<br><img src="https://img.funteas.com/cdd0c8a3c4779a076a4af3de8a38cc86?imageView2/2/w/800" alt=""></p>
<p>我们可以看到，在项目中多了一个dist文件夹，里面存放的就是刚刚打包好的文件。打开index.html（需要在服务器中打开，并且服务器根目录为dist）可以看到，生成的html文件，征程显示我们写的内容，css样式则直接写入了style标签当中，而且自动引入了两个js文件，其中，vendors是带有公共部分的js文件，index则是我们一开始写的js逻辑文件。<br><img src="https://img.funteas.com/6b1a1edb6f9d049014899131b37a02b8?imageView2/2/w/800" alt=""></p>
<h3 id="处理scss文件。"><a href="#处理scss文件。" class="headerlink" title="处理scss文件。"></a>处理scss文件。</h3><p>既然都用到了webpack自动打包了，那也顺便使用webpack去处理scss文件（个人爱好是scss，less的处理同理），顺便也处理完css中的其他兼容性问题和浏览器前缀问题吧（程序员的思维就是，懒）。</p>
<p>现在css中需要处理的有：</p>
<ol>
<li><p>浏览器前缀和大部分兼容性问题： <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fpostcss%2Fautoprefixer" target="_blank" rel="noopener">autoprefixer</a> </p>
</li>
<li><p>flex 的兼容性问题： <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2F7rulnik%2Fpostcss-flexibility" target="_blank" rel="noopener">postcss-flexibility</a> </p>
</li>
<li><p>opacity 兼容IE： <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fiamvdo%2Fpostcss-opacity" target="_blank" rel="noopener">postcss-opacity</a> </p>
</li>
<li><p>颜色兼容性问题： <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fpostcss%2Fpostcss-color-rgba-fallback" target="_blank" rel="noopener">postcss-color-rgba-fallback</a> </p>
</li>
<li><p>scss文件处理： <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fsass-loader" target="_blank" rel="noopener">sass-loader</a>  同时需要依赖 <code>node-sass</code></p>
</li>
<li><p>压缩css文件： <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fben-eb%2Fcssnano" target="_blank" rel="noopener">cssnano</a> </p>
</li>
</ol>
<p>安装上书postcss-loader的插件： <code>$ npm i -D autoprefixer postcss-flexibility postcss-opacity postcss-color-rgba-fallback sass-loader node-sass</code></p>
<p>现在在webpack中处理css的问题，基本都是通过一个 <code>postcss-loader</code> 去完成所有的处理问题。</p>
<p>先新建一个文件夹，用于存放所有的scss文件： <code>$ mkdir ./src/scss</code></p>
<p>再新建一个index.scss, <code>$ touch ./src/scss/index.scss</code></p>
<pre><code>body {
    background: black;
    color: white;
    h2 {
        transform: translateX(10 px) rotateZ(-10 deg);
        color: red;
        opacity: 0.5;
    }
}
</code></pre><p>将postcss的加载器中需要的单独提取出来放在一个配置文件中： <code>$ touch postcss.config.js</code></p>
<pre><code>module.exports = {
    plugins: [ // minify css
        require(&#39;cssnano&#39;)({
            preset: &#39;default&#39;
        }), // 处理css前缀
        require(&#39;autoprefixer&#39;)({
            browserslist: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;Edge&quot;, &quot;ie &gt;= 9&quot;]
        }), // 处理flex浏览器兼容性
        require(&#39;postcss-flexibility&#39;), // 处理css中rgba颜色代码
        require(&#39;postcss-color-rgba-fallback&#39;), // 处理css中opacity的IE兼容性。
        require(&#39;postcss-opacity&#39;)
    ]
}
</code></pre><p>修改 webpack.config.js:</p>
<pre><code>var webpackConfig = { ...module: {
        rules: [{ // 处理css文件
            test: /\.(scss|sass|css)$/, // 
            loader: &quot;css-loader?importLoaders=1!postcss-loader!sass-loader&quot;, // loader执行顺序是从右到左：sass-loader -&gt; postcss-loader -&gt; css-loader
            use: [&quot;style-loader&quot;, {
                loader: &quot;css-loader&quot;,
                options: { // // 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader
                    importLoaders: 2
                }
            }, &#39;postcss-loader&#39;, &#39;sass-loader&#39;]
        }, ...]
    }...
}
module.exports = webpackConfig
</code></pre><p>修改一下入口文件中的样式引入： <code>$ vim ./src/js/index.js</code></p>
<pre><code>require(&#39;../scss/index.scss&#39;)

console.log(&#39;hello world&#39;);
</code></pre><p>打包测试：<br><img src="https://img.funteas.com/7161926ef76bbc56cd95b4e8fa3b3043?imageView2/2/w/800" alt=""><img src="https://img.funteas.com/b2ef241cadd633d504099ebfffbe9c57?imageView2/2/w/800" alt=""></p>
<p>完美通过。</p>
<h3 id="处理pug-jade文件"><a href="#处理pug-jade文件" class="headerlink" title="处理pug/jade文件"></a>处理pug/jade文件</h3><p>项目有很多的页面，而且页面之间也有很多相同的页面，之前写惯了vue的组件，所以注册我们也引入了pug作为前端模板引擎。 pug 的前身就是 jade ，所以语法什么都得基本都是一致的。具体的看 <a href="http://link.funteas.com/?target=https%3A%2F%2Fpugjs.org%2Fapi%2Fgetting-started.html" target="_blank" rel="noopener">官网</a>  。</p>
<p>和处理css的一样，先要安装加载器。<br><code>$ npm i -D pug pug-loader</code></p>
<p>新建一个简单的页面：<br><code>$ touch ./src/view/index.pug</code></p>
<pre><code>html
    title   Test.html
body
    h2  Welcome to pug.
    p   Thisisfrom index.pug
</code></pre><p>修改一下配置文件中的html模板入口：</p>
<pre><code>var webpackConfig = { ...
    plugins: [ // 公共js提取
        new webpack.optimize.CommonsChunkPlugin({
            name: &#39;vendors&#39;, // 将公共模块提取，生成名为`vendors`的chunk
        }), // 提取公共css样式
        newExtractTextPlugin(&#39;./css/[name].css&#39;), // 处理html文件。
        newHtmlWebpackPlugin({
            filename: &#39;./view/index.html&#39;, //生成的html存放路径，相对于pathtemplate:&#39;./src/view/index.pug&#39;,//html模板路径
            inject: &#39;body&#39;, //js插入的位置，true/&#39;head&#39;/&#39;body&#39;/false
            hash: true, //为静态资源生成hash值
            chunks: [&#39;vendors&#39;, &#39;index&#39;], //需要引入的chunk，不配置就会引入所有页面的资源
            minify: { //压缩HTML文件
                removeComments: true, //移除HTML中的注释
                collapseWhitespace: false //删除空白符与换行符
            }
        })
    ],
    ...
}
module.exports = webpackConfig
</code></pre><p>重新编译打包：<br><img src="https://img.funteas.com/f50d2630c41fc3722fb1e8c594b17df8?imageView2/2/w/800" alt=""><img src="https://img.funteas.com/b9a66e946d63f63b8afe51355f848299?imageView2/2/w/800" alt=""></p>
<h3 id="使用-babel-来“编译”你的js"><a href="#使用-babel-来“编译”你的js" class="headerlink" title="使用 babel 来“编译”你的js"></a>使用 babel 来“编译”你的js</h3><p>在项目开发中，难免会遇到使用 es6 ，甚至 es7 去编写js。但是大部分浏览器却不支持这些语法，这时候，就需要 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel-loader" target="_blank" rel="noopener">babel-loader</a>  来处理js，并将其转换为浏览器能识别的 es5 语法。</p>
<p>还是要安装依赖： <code>$ npm i -D babel-loader babel-core babel-preset-es2015</code></p>
<p>如果用上了es7 的语法，就要根据不同阶段语法提案的转码规则（共有4个阶段），选装一个：</p>
<pre><code>$ npm i -D babel-preset-stage-0
$ npm i -D babel-preset-stage-1
$ npm i -D babel-preset-stage-2
$ npm i -D babel-preset-stage-3
</code></pre><p>新建一个 <code>.babelrc</code> babel配置文件： <code>$ touch .babelrc</code></p>
<pre><code>{&quot;presets&quot;:[&quot;es2015&quot;],&quot;plugins&quot;:[]}
</code></pre><p>修改 webpack 配置文件：</p>
<pre><code>var webpackConfig = { ...module: {
        rules: [{
            test: /\.js$/, // 不编译 node_modules 下的文件
            exclude: /node_modules/,
            loader: &quot;babel-loader&quot;
        }]
    }...
}
module.exports = webpackConfig
</code></pre><p>在 index.js 中写个 es6 的语法：</p>
<pre><code>require(&#39;../scss/index.scss&#39;)

console.log(&#39;hello world&#39;);
((message) =&gt; {
    console.log(message);
})(&#39;message from es6&#39;)

let step = 2;
var add = number =&gt; number *= step

console.log(add(2));
</code></pre><p>来，打包看看：<br><img src="https://img.funteas.com/17f943bb3337dc33beee2c13805be376?imageView2/2/w/800" alt=""><img src="https://img.funteas.com/dcdad593279f1b2192a9f4ba9d5f28ff?imageView2/2/w/800" alt=""><br>完美。</p>
<h3 id="配置多文件入口"><a href="#配置多文件入口" class="headerlink" title="配置多文件入口"></a>配置多文件入口</h3><p>项目有多个页面，每个页面都对应着一个js入口和一个页面，但是，入口 entry 和 html-webpack-plugin 每次只能配置一个具体的入口文件，如果每增加一个页面就要去配置，那么这无形之中增加了工作量，因此，我们需要一个通用的入口文件。</p>
<p>既然在node中可以访问文件夹并读取其中的文件名，那么我们可以使用node来去循环读取文件夹下的js文件，并自动添加至入口配置中：</p>
<p>新建一个config 文件夹，以存放webpack可变的配置，方便以后修改： <code>$ mkdir config</code></p>
<p>因为遍历入口文件都是一样的操作流程，所以先写一个工具包：<code>$ touch config/utils.js</code></p>
<pre><code>var fs = require(&#39;fs&#39;); // 递归遍历文件夹，获取入口文件
function getAllFiles(dirRoot, type) {
    var filterReg = newRegExp(&#39;.&#39; + type + &#39;/div&gt;&#39;);
        function getAllFileFromDir(root) {
            var res = [],
                files = fs.readdirSync(root)
            files.forEach((file) =&gt; {
                var pathname = root + &#39;/&#39; + file,
                    state = fs.lstatSync(pathname)
                if (!state.isDirectory()) {
                    // 过滤相对应的文件
                    filterReg.test(pathname) &amp;&amp; res.push(pathname)
                    // res.push(pathname.replace(dir_root+&#39;/&#39;, &#39;&#39;))
                } else {
                    res = res.concat(getAllFileFromDir(pathname))
                }
            })
            return res
        }
        return getAllFileFromDir(dirRoot)
    }

    function getEntry(files, replaces) {
        var entry = {}
        for (var i = 0; i &lt; files.length; i++) {
            var filename = files[i]
            replaces.map((replace) =&gt; {
                filename = filename.replace(replace, &#39;&#39;)
            })
            entry[filename] = files[i]
        }
        return entry
    }

    module.exports = {
        getAllFiles,
        getEntry
    }
</code></pre><p>再新建一个 js 入口文件配置：<br><code>$ touch config/webpack.entry.js</code></p>
<pre><code>var path = require(&#39;path&#39;);
var utils = require(&#39;./utils.js&#39;) var dir_root = path.resolve(__dirname, &#39;../src/js&#39;); 
// console.log(getAllFiles(dir_root));
var allFiles = utils.getAllFiles(dir_root, &#39;js&#39;) var entry = utils.getEntry(allFiles, [&#39;js&#39;, dir_root + &#39;/&#39;])
console.log(entry);
module.exports = entry
</code></pre><p>同样的，页面入口文件也添加一个：<br> <code>$ touch config/webpack.plugins.js</code></p>
<pre><code>var webpack = require(&#39;webpack&#39;) var path = require(&#39;path&#39;);
var utils = require(&#39;./utils.js&#39;) varExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);
var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
var entry = require(&#39;./webpack.entry.js&#39;);
var plugins = [ // 公共js提取
    new webpack.optimize.CommonsChunkPlugin({
        name: &#39;vendors&#39;, // 将公共模块提取，生成名为`vendors`的chunk
        minChunks: 3 // 提取至少3个模块共有的部分
    }), // 提取公共css样式
    newExtractTextPlugin(&#39;./css/[name].css&#39;),
]
let dir_root = path.resolve(__dirname, &#39;../src/view&#39;);
var pugFiles = utils.getAllFiles(dir_root, &#39;pug&#39;)

pugFiles = utils.getEntry(pugFiles, [&#39;.pug&#39;, dir_root + &#39;/&#39;]) for (var key in pugFiles) {
    if (pugFiles.hasOwnProperty(key)) {
        let opt = {
            filename: &#39;./view/&#39; + key + &#39;.html&#39;,
            template: pugFiles[key],
            hash: true,
            minify: { //压缩HTML文件
                removeComments: true, //移除HTML中的注释
                collapseWhitespace: false //删除空白符与换行符
            }
        }
        if (entry.hasOwnProperty(key)) {
            opt[&#39;chunks&#39;] = [&#39;vendors&#39;, key]
            opt[&#39;inject&#39;] = &#39;body&#39;
        }
        console.log(opt);
        plugins.push(newHtmlWebpackPlugin(opt))
    }
}
module.exports = plugins
</code></pre><p>再次修改webpack的配置：</p>
<pre><code>var entry = require(&#39;./config/webpack.entry.js&#39;) var plugins = require(&#39;./config/webpack.plugins.js&#39;) var webpackConfig = {
    entry,
    plugins,
    ...
}
module.exports = webpackConfig
</code></pre><p><img src="https://img.funteas.com/281e607088b144d2c458949393222b8c?imageView2/2/w/800" alt=""><img src="https://img.funteas.com/40af51e0f7c22c574ec37d04126dec94?imageView2/2/w/800" alt=""><br>可以看到，dist文件夹下，多了几个html文件和js文件。</p>
<h3 id="其他处理"><a href="#其他处理" class="headerlink" title="其他处理"></a>其他处理</h3><ul>
<li>提取css到外部link，而非style标签<br>这个解决办法比较简单，只需要用 <code>extract-text-webpack-plugin</code> 插件将css提取出来即可：</li>
</ul>
<pre><code>{
    test: /\.(scss|sass|css)$/,
    use: ExtractTextPlugin.extract(
    {
        fallback: &quot;style-loader&quot;,
        use: [
        {
            loader: &quot;css-loader&quot;,
            options:
            { // // 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader
                importLoaders: 2
            }
        }, &#39;postcss-loader&#39;, &#39;sass-loader&#39;]
    })
}
</code></pre><p>再次打包的结果：<br><img src="https://img.funteas.com/c0d501d1dba2745f1a88a74039e29176?imageView2/2/w/800" alt=""></p>
<p>列出dis文件夹的目录树可以发现，多了一个css的文件夹。打开页面可以发现，页面中的style标签已经被link替代了。<br><img src="https://img.funteas.com/9b3e582b1d7799c98891be7786f8b751?imageView2/2/w/800" alt=""><img src="https://img.funteas.com/e9c1a1d5a71d0175912b4ad5b53bcd0a?imageView2/2/w/800" alt=""></p>
<ul>
<li>每次打包旧的文件依旧存在<br>每次执行webpack打包（当然在实际开发中应该使用热更新服务器，不需要频繁打包）都会产生一堆新的js文件。</li>
</ul>
<p>解决办法：</p>
<p>一是将打包的js文件的hash值去掉，这样就会新的打包js文件，将旧的覆盖。</p>
<p>二是使用 <a href="http://link.funteas.com/?target=https%3A%2F%2Fgithub.com%2Fjohnagan%2Fclean-webpack-plugin" target="_blank" rel="noopener">clean-webpack-plugin</a> </p>
<pre><code>var CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;);
var plugins = [ // 每次打包前都清空dist文件
    newCleanWebpackPlugin([&#39;dist&#39;], {
        root: path.resolve(__dirname, &#39;../&#39;)
    }), // 公共js提取
    new webpack.optimize.CommonsChunkPlugin({
        name: &#39;vendors&#39;,
        // 将公共模块提取，生成名为`vendors`的chunk//
        minChunks: 3 // 提取至少3个模块共有的部分
    }), // 提取公共css样式
    newExtractTextPlugin(&#39;./css/[name].css&#39;),
]
</code></pre><ul>
<li>批量新建文件<br>因为每个页面基本都有3个文件：<code>page.pug</code>, <code>page.js</code>, <code>page.scss</code>，如果每次新加一个页面都要手动新建3个文件的话，效率太低下，能用命令行解决的，当然要用命令行解决啦。</li>
</ul>
<p>先写个小脚本 <code>newpage.sh</code>:</p>
<pre><code>#!/bin/shif[[ $1 ]];then
    filename=$1
    touch ./src/js/$filename.js
    touch ./src/view/$filename.pug
    touch ./src/scss/$filename.scss
fi
</code></pre><p>使用方式就是： <code>$ ./newpage.sh filename</code>，要运行该脚本，就需要先将脚本设置为可执行： <code>$ sudo chmod +x ./newpage.sh</code>。</p>
<p>还可以将它写进 npm 的 <code>package.json</code> 的命令中，则命令可以变为：<code>npm run new -- filename</code></p>
<pre><code>{&quot;script&quot;:{&quot;new&quot;:&quot;./newpage.sh&quot;}}
</code></pre><ul>
<li>定义路径常量<br>在编写js时，因为有可能js文件是在很多级的目录当中，如果每次都使用 <code>..</code> 来定位上一层目录的话，那么这个定位就会十分繁琐。这时可以使用 webpack 提供的 <a href="http://link.funteas.com/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fresolve%2F%23resolve-alias" target="_blank" rel="noopener">resolve.alias</a>  配置来使引入文件的时候变得更加方便简单。</li>
</ul>
<pre><code>resolve: {
    alias: {
        scss: path.resolve(__dirname, &#39;src/scss&#39;),
        js: path.resolve(__dirname, &#39;src/js&#39;),
        view: path.resolve(__dirname, &#39;src/view&#39;),
        assets: path.resolve(__dirname, &#39;src/assets&#39;)
    }
}
</code></pre><p>这样，在 <code>other.js</code> 中，就可以直接使用 <code>require(&#39;scss/about.scss&#39;)</code> 而不需要写繁琐的 <code>require(&#39;../../scss/about.scss&#39;)</code>。这样就方便多了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>看完这篇文章相信你对<code>webpack</code>的配置已经基本了解了，接下来如果你想了解<code>webpack</code>的更多基础知识，请看我的这篇<a href="http://pancakeawesome.ink/%E5%85%A5%E9%97%A8Webpack%EF%BC%8C%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.html">文章</a>，并且想实践中使用<code>webpack</code>，请看我的这篇<a href="http://pancakeawesome.ink/react%E5%AE%9E%E6%88%98-%E6%89%93%E9%80%A0%E7%94%BB%E5%BB%8A%E9%A1%B9%E7%9B%AE.html">文章</a></p>
]]></content>
      
        <categories>
            
            <category> 前端工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端工具 </tag>
            
            <tag> webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[react实战--打造画廊项目（二）]]></title>
      <url>/react%E5%AE%9E%E6%88%98-%E6%89%93%E9%80%A0%E7%94%BB%E5%BB%8A%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇博客中，我们把画廊应用的静态框架搭建好了，现在我们为舞台添加动态旋转和移动的效果。</p>
<h2 id="构建动态图片组件"><a href="#构建动态图片组件" class="headerlink" title="构建动态图片组件"></a>构建动态图片组件</h2><p>继续控制单个图片组件<code>ImgFigure</code>，为它加上动态效果。</p>
<h3 id="图片旋转"><a href="#图片旋转" class="headerlink" title="图片旋转"></a>图片旋转</h3><p>给图片加上旋转角度的效果样式。</p>
<ul>
<li>首先给存储所有图片样式信息的全局变量<code>imageDatasArr</code>加上<code>rotate</code>属性，用来存储每张图片的旋转信息。<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fl1qdd8kd2j30w50afaac.jpg" alt=""></li>
<li>添加<code>get30DegRandom</code>方法用来随机图片旋转的角度：<pre><code>function get30DegRandom() {
  return (Math.random() &gt; 0.5 ? &#39;&#39; : &#39;-&#39;) + Math.ceil(Math.random() * 30);
}
</code></pre><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fl1qhwj5r9j30ox08xmxf.jpg" alt=""></li>
<li>给每张图片设置随机过后旋转角度样式：<pre><code>// 如果图片的旋转角度有值且不为0则添加旋转角度
      if (this.props.arrange.rotate) {
          // 兼容低版本浏览器
          [&#39;MozTransform&#39;, &#39;msTransform&#39;, &#39;WebkitTransform&#39;, &#39;transform&#39;].forEach(function(value) {
            styleObj[value] = &#39;rotate(&#39; + this.props.arrange.rotate + &#39;deg)&#39;;
          }.bind(this));
      }
</code></pre><strong>注意：<code>transform: rotate(旋转角度deg)</code>可以旋转标签的角度。</strong><br><strong>添加浏览器前缀可以实现低版本浏览器样式兼容的效果。</strong></li>
</ul>
<h3 id="旋转控制"><a href="#旋转控制" class="headerlink" title="旋转控制"></a>旋转控制</h3><p>给图片加上点击图片，反转的效果。</p>
<ul>
<li>为<code>imgsArrangeArr</code>添加表示图片翻转信息的属性<code>isInvers</code>,<code>false</code>表示图片没有翻转。</li>
<li>添加翻转的样式。</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fl2u0yjtf3j30m906mwei.jpg" alt="给`ImgFigure`添加翻转样式"></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl2u209tkfj30w405ct91.jpg" alt="给图片背面添加样式"></p>
<blockquote>
<p><code>&amp;.className</code>:是<code>sass</code>的语法，意思是给父元素添加一个<code>class</code><br><code>transform</code>属性是Css3的新特性，它能够实现一些动态效果，比如rotate（旋转）、scale（缩放）、translate（平移）等。</p>
</blockquote>
<p><strong>具体<code>transform</code>属性如何使用呢？请看我的这篇文章<a href="http://pancakeawesome.ink/CSS3-transform%E7%89%B9%E6%80%A7%E6%95%99%E7%A8%8B.html">CSS3-transform特性教程</a></strong></p>
<ul>
<li>添加点击图片的处理函数<br>我们在<code>AppComponent</code>组件中添加<code>inverse</code>函数,用来将选定的图片在图片数组中对应的图片信息中的表示图片翻转的属性<code>isInverse</code>改为相应样式。</li>
</ul>
<pre><code>/**
     * 翻转图片
     * @param {int} index 输入当前被执行inverse操作的图片对应的图片信息数组的index值
     * @return {Function} 这是一个闭包函数，其内return一个真正待被执行的函数
     */
    inverse(index) {
        return function() {
            let imgsArrangeArr = this.state.imgsArrangeArr;
            imgsArrangeArr[index].isInverse = !imgsArrangeArr[index].isInverse;

            this.setState({
                imgsArrangeArr: imgsArrangeArr
            });
        }.bind(this);
    }
</code></pre><blockquote>
<p><strong>重要：为什么使用闭包函数</strong>，因为调用这个函数所在的作用域(<code>ImgFigure</code>)中没有权限去调用<code>AppComponent</code>里的<code>index</code>变量，这个变量是<code>AppComponent</code>初始化<code>render</code>的时候就固定好的，如果想要调用<code>index</code>这个变量而不是当前<code>ImgFigure</code>组件中的<code>index</code><strong>值</strong>，就必须使用闭包函数作为桥梁连接两个函数作用域，这样<code>ImgFigure</code>就可以使用另外一个作用域中的变量。</p>
<ul>
<li>给图片信息数组添加表示图片居中的属性，并在<code>AppComponent</code>组件中添加居中函数，处理图片居中效果。</li>
</ul>
</blockquote>
<pre><code>/**
     * 利用rearrange函数，居中对应index的图片
     * @param {int} index 输入当前被执行inverse操作的图片对应的图片信息数组的index值
     * @return {Function} 这是一个闭包函数，其内return一个真正待被执行的函数
     */
     center(index) {
         return function() {
             this.rearrange(index);
         }.bind(this);
     }
</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fl2usbzpg4j30kn0bs0sv.jpg" alt="`AppComponent`组件中"></p>
<ul>
<li><p>在<code>ImgFigure</code>组件中添加点击处理函数，<code>handleClick</code>。用来处理所有图片的点击事件，加上处理逻辑，实现点击周围图片，将图片居中，点击居中图片，实现图片翻转的效果。</p>
<pre><code>constructor(props) {
    super(props);

    this.handleClick = this.handleClick.bind(this);
    this.center = this.center.bind(this);
  }

  /**
   * imgFigure的点击事件
   */
  handleClick(e) {
      if (this.props.arrange.isCenter) {
          this.props.inverse();
      }else {
          this.props.center();
      }

      e.stopPropagation();
      e.preventDefault();
  }

  // 控制反转样式
  let imgFigureClassName = &#39;img-figure&#39;;
      imgFigureClassName += this.props.arrange.isInverse ? &#39; is-inverse&#39; : &#39;&#39;;
</code></pre></li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fl2upt0b7sj30wm0bj74v.jpg" alt="给`ImgFigure`组件加上事件监听器"></p>
<blockquote>
<p><strong>注意⚠️：</strong><code>React ES6</code>的写法中，组件的函数不是自动绑定<code>this</code>的，需要在<code>constructor</code>中手动给所有的成员方法绑定<code>this</code>。</p>
</blockquote>
<ul>
<li>给居中图片添加<code>z-index</code>样式，使其在页面的最顶层：<pre><code>// 如果图片居中，则给居中图片添加z-index样式，使其在整个页面的最顶层
      if (this.props.arrange.isCenter) {
          styleObj.zIndex = &#39;11&#39;;
      }
</code></pre></li>
</ul>
<h3 id="给图片加上切换动画"><a href="#给图片加上切换动画" class="headerlink" title="给图片加上切换动画"></a>给图片加上切换动画</h3><p>我们可以使用<code>css3</code>相关的<code>transform</code>样式。</p>
<ul>
<li><code>transition</code>:定义了一个元素在两种状态下切换时，显示的过渡动画效果。<br>值：<ul>
<li><code>transform</code>: 表示在发生<code>transform</code>变化时，发生的动画效果。</li>
<li><code>left</code>:表示在<code>left</code>值发生变化的时候发生的动画效果。</li>
<li><code>.6s</code>:动画的时长。</li>
<li><code>easy-in-out</code>:动画的速度曲线。三次的倍塞尔函数。  </li>
</ul>
</li>
<li><p><code>perspective</code>：景深样式，表示perspective-origin，3D观察点与z轴平面的距离，默认是无限大，类似我们平常2D的效果。值越小，我们能感受到的3D效果越深刻。<br><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fl2vorp47uj30hn0brmxy.jpg" alt="3D景深效果"></p>
</li>
<li><p><code>transform-origin</code>:表示<code>transform</code>变化的基点，默认是元素的中心点。这个属性很重要，通过这个属性和<code>translate</code>,<code>rotateY</code>结合，我们可以实现元素翻转的真实效果。</p>
<ul>
<li><code>rotateY(deg)</code>:表示以Y轴为纬轴旋转元素。</li>
<li><code>translate(px)</code>:表示以x轴平移元素。</li>
<li><code>translateZ(px)</code>:表示平移Z轴上的元素。</li>
</ul>
</li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl2wg3wc33j30c80cjwet.jpg" alt=""></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl2w5lpavxj30lr03k746.jpg" alt=""></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fl2w541kobj30j3018jr8.jpg" alt=""></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl2w32yg5ng30m60aywsx.gif" alt=""></p>
<h3 id="控制组件的构建"><a href="#控制组件的构建" class="headerlink" title="控制组件的构建"></a>控制组件的构建</h3><p>现在我们开始构建显示在画廊页面下方的控制条组件。</p>
<ul>
<li><p>创建控制条组件。</p>
<pre><code>// 构建控制组件
class ControllerUnit extends React.Component {
  constructor(props) {
    super(props);

    this.handleClick = this.handleClick.bind(this);
  }

  handleClick(e) {
      e.preventDefault();
      e.stopPropagation();
  }

  render() {
      return (
          &lt;span className=&quot;controller-unit&quot; onClick={this.handleClick}&gt;&lt;/span&gt;    
      );
  }
}
</code></pre></li>
<li>修饰控制组件<br>在css文件中，修饰控制组件在不同状态下的样式。</li>
</ul>
<pre><code>/* controller --- start */
.controller-nav {
  position: absolute;
  left: 0;
  bottom: 30px;
  z-index: 101;

  width: 100%;

  text-align: center;

  @at-root {
    .controller-unit {
      display: inline-block;
      margin: 0 5px;
      width: 30px;
      height: 30px;

      text-align: center;

      cursor: pointer;
      background-color: #aaa;
      border-radius: 50%;

      transform: scale(.5);

      &amp;.is-center {
        background-color: #888;

        transform: scale(1);

        // 使用伪元素添加字体文件
        &amp;::before {
          color: #fff;
          font-family: &quot;icons-turn-arrow&quot;;

            // 指定为元素的内容
          content: &quot;\e900&quot;;
        }
      }
    }
  }
}
/* controller --- end */
</code></pre><ul>
<li>构造按钮居中时的样式：</li>
</ul>
<pre><code>@font-face {
  font-family: &quot;icons-turn-arrow&quot;;
  src: url(&quot;../fonts/icons/turn-arrow.eot&quot;);
  src: url(&quot;../fonts/icons/turn-arrow.eot&quot;) format(&quot;embedded-opentype&quot;),
    url(&quot;../fonts/icons/turn-arrow.woff&quot;) format(&quot;woff&quot;),
    url(&quot;../fonts/icons/turn-arrow.ttf&quot;) format(&quot;truetype&quot;), 
    url(&quot;../fonts/icons/turn-arrow.svg&quot;) format(&quot;svg&quot;);
}
</code></pre><blockquote>
<p>引用字体文件来表示箭头</p>
</blockquote>
<pre><code>// 使用after伪元素添加字体文件
        &amp;::after {
          color: #fff;
          font-family: &quot;icons-turn-arrow&quot;;
          line-height: 30px;

            // 通过文件的unicode码，指定为元素的内容
          content: &quot;\e900&quot;;

          /* 开启chrome字体渲染的灰阶平滑 */
          -webkit-font-smoothing: antialiased;
          /* 开启Firefox在mac上的灰阶平滑 */
          -moz-osx-font-smoothing: grayscale;
        }
</code></pre><blockquote>
<p>css3新规范规定css伪元素修饰需要使用<strong>两个“:”</strong>来修饰，而<code>hover</code>伪类则用一<strong>个”:”</strong>修饰。<br>icon font的体积比图片小；icon font 是矢量图形，拉伸不变形，支持css对字体的样式修饰。<br>不同格式的字体文件是为了兼容不同浏览器对不同字体文件的支持。</p>
<pre><code>- `embedded-opentype`:ie
- `woff`:chrome,firefox
- `truetype`:chrome,firefox,safari,ios,android4.2以及之后的版本。
- `svg`:android4.1以及之前的版本
</code></pre><p>如果字体和背景都是浅色调，使用字体文件来代替图片渲染，会造成边缘呈现锯齿状的不平滑，为了解决这个问题，可以设置字体渲染引擎通过灰阶渲染和亚像素渲染来平滑字体文件的渲染。</p>
</blockquote>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl43x2xxqkj30gh03vjrh.jpg" alt=""></p>
<ul>
<li>构造按钮翻转时的样式：</li>
</ul>
<pre><code>&amp;.is-inverse {
        background-color: #555;

        transform: rotateY(180deg) translateZ(1px);
      }
</code></pre><ul>
<li>给控制按钮加上变化（transform, background-color）时的过渡动画效果：</li>
</ul>
<pre><code>transform: scale(.5);
      transition: transform .6s ease-in-out, background-color .3s;
</code></pre><ul>
<li>关联控制组件和图片组件，给不同状态下的控制组件添加相应的样式</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fl8mtfymcnj30yc0fst9f.jpg" alt="ControllerUnit"></p>
<ul>
<li>给控制组件添加点击事件，实现控制组件和绑定的图片的动画效果</li>
</ul>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fl8mx349tcj30nw0a1aa9.jpg" alt="ControllerUnit"></p>
<h3 id="收尾项目"><a href="#收尾项目" class="headerlink" title="收尾项目"></a>收尾项目</h3><p>到这里，画廊项目基本已经完成，我们可以检查一下项目的展现效果，找到错误的地方，然后逐一debug。</p>
<h4 id="测试代码的兼容性"><a href="#测试代码的兼容性" class="headerlink" title="测试代码的兼容性"></a>测试代码的兼容性</h4><p>首先测试代码在firefox下的兼容性（我在firefox15版本下，测试成功）。</p>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><blockquote>
<p>react渲染页面的核心思想是<code>virtual dom</code>:当react将组件插入到html dom文档树前，react会先将代码中的react组件插入到virtual dom中，然后react会检查virtual dom和html文档树中结构是否有不同的地方，如果发现不同，才会去插入virtual dom中的文档树节点，这样会极大地减少浏览器引擎渲染dom节点的速度。</p>
</blockquote>
<p>所以，我们在将图片组件和控制组件插入到AppComponent组件中时，可以给每个图片组件和控制组件都加上一个唯一表示的key，这样可以帮助react更好地区分每个<code>virtual dom</code>节点，这样比较两个文档树节点时，会消耗更少的时间。</p>
<h3 id="部署代码"><a href="#部署代码" class="headerlink" title="部署代码"></a>部署代码</h3><p>dist目录时项目部署到正是环境下的代码，我们在即将把我们代码部署到线上的时候，可以运行Webpack dist环境，将我们的代码以dist环境的参数运行打包，这样所有的代码都会在dist目录下，然后打开8000端口，在浏览器环境下调试dist环境下的代码。</p>
<p>在<code>package.json</code>配置文件中配置命令，可以在命令行中执行不同的环境的代码。</p>
<ul>
<li>执行本地调试(<code>src</code>目录下的代码)命令：</li>
</ul>
<pre><code>npm start
</code></pre><ul>
<li>执行dist打包，并执行<code>dist</code>环境下的代码：</li>
</ul>
<pre><code>// 将dist目录清空
npm run clean
</code></pre><pre><code>// 将静态资源文件复制到Dist目录下，并执行webpack打包命令（参数是dist环境）
npm run dist
</code></pre><ul>
<li>部署项目到gitpages上：<ul>
<li>在<code>cfg/default.js</code>中更改<code>publicPath</code>为相对路径（因为gitpages下的项目url路径是二级目录）</li>
</ul>
</li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl8qrgnltzj30kk069mx6.jpg" alt=""></p>
<pre><code>- 将`src/index.html`中的`js`引用地址改为相对路径
</code></pre><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;assets/app.js&quot;&gt;&lt;/script&gt;
</code></pre><pre><code>- 将`dist`目录上传到`gitpages`(git提供的html页面部署服务)
</code></pre><pre><code>git subtree push --prefix=dist origin gh-pages
</code></pre><pre><code>- 在浏览器中地址栏中输入`https://&lt;你的github账户名称&gt;.github.io/&lt;你的项目名称&gt;`
</code></pre><p>就可以看到你的画廊应用部署到线上了！激动么～</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl8r55fj7nj30d007xdg0.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> react </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> react </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于ES6语法的React重构]]></title>
      <url>/%E5%9F%BA%E4%BA%8EES6%E8%AF%AD%E6%B3%95%E7%9A%84React%E9%87%8D%E6%9E%84.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ES6</code>语法规范已经日渐被大家所接受，而且在开发过程中，这些新的语法特性，都很方便，一些开源框架和项目都已经使用了最新的<code>ES6</code>语法，比如<code>react</code>，一些老的语法已经逐渐被淘汰，为了跟上时代潮流，我们应该努力接受新的知识。</p>
<h2 id="React-js中常用的ES6写法总结"><a href="#React-js中常用的ES6写法总结" class="headerlink" title="React.js中常用的ES6写法总结"></a><code>React.js</code>中常用的<code>ES6</code>写法总结</h2><h3 id="一-模块"><a href="#一-模块" class="headerlink" title="一 模块"></a>一 模块</h3><h4 id="1-引入模块以便使用"><a href="#1-引入模块以便使用" class="headerlink" title="1 引入模块以便使用"></a>1 引入模块以便使用</h4><p>用import实现：</p>
<pre><code>import &#39;模块文件地址&#39;
import 组件 from &#39;模块文件地址&#39;
</code></pre><h4 id="2-导出模块"><a href="#2-导出模块" class="headerlink" title="2 导出模块"></a>2 导出模块</h4><p>用export default实现：</p>
<pre><code>export defaultclass MyComponent extends Component{
    ...
}
</code></pre><p>引用：</p>
<pre><code>import MyComponent from &#39;./MyComponent&#39;;
</code></pre><h3 id="二-组件"><a href="#二-组件" class="headerlink" title="二 组件"></a>二 组件</h3><h4 id="1-定义组件"><a href="#1-定义组件" class="headerlink" title="1 定义组件"></a>1 定义组件</h4><p>通过定义一个继承自React.Component的class来定义一个组件类：</p>
<pre><code>class Photo extends React.Component {
    render() {
       ...
    }
}
</code></pre><h4 id="2-定义组件方法"><a href="#2-定义组件方法" class="headerlink" title="2 定义组件方法"></a>2 定义组件方法</h4><p>直接用名字(){},很像java定义类方法的写法：</p>
<pre><code>class Photo extends React.Component {
    componentWillMount() {

    }
    render() {
        return (
            &lt;Imagesource={this.props.source} /&gt;
        );
    }
}
</code></pre><h4 id="3-定义组件的属性类型和默认属性"><a href="#3-定义组件的属性类型和默认属性" class="headerlink" title="3 定义组件的属性类型和默认属性"></a>3 定义组件的属性类型和默认属性</h4><p>统一使用static成员来实现：</p>
<pre><code>class Video extends React.Component {
    static defaultProps = {
        autoPlay: false,
        maxLoops: 10,
    };  // 注意这里有分号
    static propTypes = {
        autoPlay: React.PropTypes.bool.isRequired,
        maxLoops: React.PropTypes.number.isRequired,
        posterFrameSrc: React.PropTypes.string.isRequired,
        videoSrc: React.PropTypes.string.isRequired,
    };  // 注意这里有分号
    render() {
        return (
            &lt;View /&gt;
        );
    } // 注意这里既没有分号也没有逗号
}
</code></pre><p><strong>注意: 对React而言，static成员在IE10及之前版本不能被继承，而在IE11和其它浏览器上可以，有时会带来一些问题。React Native则不用担心这个问题。</strong></p>
<h4 id="4-初始化STATE"><a href="#4-初始化STATE" class="headerlink" title="4 初始化STATE"></a>4 初始化STATE</h4><p>在构造函数中初始化（这样可以根据需要做一些计算）：</p>
<pre><code>class Video extends React.Component {
    constructor(props){
        super(props);
        this.state = {
            loopsRemaining: this.props.maxLoops,
        };
    }
}
</code></pre><h4 id="5-把方法作为回调提供并使用"><a href="#5-把方法作为回调提供并使用" class="headerlink" title="5 把方法作为回调提供并使用"></a>5 把方法作为回调提供并使用</h4><p>ES5下可以这么做：</p>
<pre><code>//ES5var PostInfo = React.createClass({
    handleOptionsButtonClick: function(e) {// Here, &#39;this&#39; refers to the component instance.this.setState({showOptionsModal: true});
    },
    render: function(){return (
            &lt;TouchableHighlightonPress={this.handleOptionsButtonClick}&gt;&lt;Text&gt;{this.props.label}&lt;/Text&gt;&lt;/TouchableHighlight&gt;
        )
    },
});
</code></pre><p>在ES5下，<code>React.createClass</code>会把所有的方法都bind一遍，这样可以提交到任意的地方作为回调函数，而this不会变化。但官方现在认为这是不标准、不易理解的。</p>
<p>ES6下，需要通过bind来绑定this引用，或者使用箭头函数（它会绑定当前scope的this引用）来调用：</p>
<pre><code>//ES6class PostInfo extends React.Component
{
    handleOptionsButtonClick(e){
        this.setState({showOptionsModal: true});
    }
    render(){
        return (
            &lt;TouchableHighlightonPress={this.handleOptionsButtonClick.bind(this)}onPress={e=&gt;this.handleOptionsButtonClick(e)}
                &gt;
                &lt;Text&gt;{this.props.label}&lt;/Text&gt;&lt;/TouchableHighlight&gt;
        )
    },
}
</code></pre><p><em>箭头函数是在这里定义了一个临时的函数，箭头函数的箭头=&gt;之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。</em></p>
<p>即：箭头函数箭头前是参数，箭头后是函数体或返回值。</p>
<p>注意：</p>
<p><strong>不论是bind还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么必须自己保存这个引用：</strong></p>
<pre><code>// 错误的做法
class PauseMenu extends React.Component{
    componentWillMount(){
        AppStateIOS.addEventListener(&#39;change&#39;, this.onAppPaused.bind(this));
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener(&#39;change&#39;, this.onAppPaused.bind(this));
    }
    onAppPaused(event){
    }
}
</code></pre><pre><code>// 正确的做法
class PauseMenu extends React.Component{
    constructor(props){
        super(props);
        this._onAppPaused = this.onAppPaused.bind(this);//注意这里
    }
    componentWillMount(){
        AppStateIOS.addEventListener(&#39;change&#39;, this._onAppPaused); //还有这里
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener(&#39;change&#39;, this._onAppPaused);
    }
    onAppPaused(event){
    }
}
</code></pre><h3 id="三-Mixins"><a href="#三-Mixins" class="headerlink" title="三 Mixins"></a>三 Mixins</h3><p>ES5下，经常使用<code>mixin</code>来为类添加一些新的方法，如<code>PureRenderMixin</code>:</p>
<pre><code>var PureRenderMixin = require(&#39;react-addons-pure-render-mixin&#39;);
React.createClass({
  mixins: [PureRenderMixin],

  render: function() {return&lt;divclassName={this.props.className}&gt;foo&lt;/div&gt;;
  }
});
</code></pre><p>但React官方已经不再打算在ES6里继续推行Mixin,官方推荐，对于库编写者而言，应尽快放弃Mixin的编写方式，推荐一种新的编码方式：</p>
<pre><code>//Enhance.js
import { Component } from &quot;React&quot;;

export var Enhance = ComposedComponent =&gt; class extends Component {
    constructor() {
        this.state = { data: null };
    }
    componentDidMount() {
        this.setState({ data: &#39;Hello&#39; });
    }
    render() {
        return&lt;ComposedComponent {...this.props} data={this.state.data} /&gt;;
    }
};
//HigherOrderComponent.js
import { Enhance } from &quot;./Enhance&quot;;

class MyComponent {
    render() {
        if (!this.data) return&lt;div&gt;Waiting...&lt;/div&gt;;return&lt;div&gt;{this.data}&lt;/div&gt;;
    }
}

export default Enhance(MyComponent); // Enhanced component
</code></pre><p>用一个“增强函数”，来为某个类增加一些方法，并且返回一个新类，这无疑能实现mixin所实现的大部分需求。</p>
<h3 id="四-解构与属性延展"><a href="#四-解构与属性延展" class="headerlink" title="四 解构与属性延展"></a>四 解构与属性延展</h3><p>结合使用ES6+的解构和属性延展，在给子组件传递一批属性更为方便了。下面的例子把className以外的所有属性传递给div标签：</p>
<pre><code>class AutoloadingPostsGrid extends React.Component {
    render() {
        var {
            className,
            ...others,  // contains all properties of this.props except for className
        } = this.props;
        return (
            &lt;divclassName={className}&gt;&lt;PostsGrid {...others} /&gt;&lt;buttononClick={this.handleLoadMoreClick}&gt;Load more&lt;/button&gt;&lt;/div&gt;
        );
    }
}
</code></pre><p>下面这种写法，则是传递所有属性的同时，用新的<code>className</code>值进行覆盖（<code>{…this.props}</code>写在前边）：</p>
<pre><code>&lt;div {...this.props} className=&quot;override&quot;&gt;
    …
&lt;/div&gt;
</code></pre><p>这个例子则相反，如果属性中没有包含<code>className</code>，则提供默认的值，而如果属性中已经包含了，则使用属性中的值（<code>{…this.props}</code>写在后边）</p>
<pre><code>&lt;div className=&quot;base&quot; {...this.props}&gt;
    …
&lt;/div&gt;
</code></pre><p>更多ES6的细节可以参考阮一峰前辈的《ECMAScript 6入门》： <a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>ES6是大势所趋，建议大家日常使用js的时候逐渐的转到ES6上，适应ES6的新特性，这样才不会落伍哈。</p>
]]></content>
      
        <categories>
            
            <category> 前端框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react </tag>
            
            <tag> es6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[scrum敏捷开发]]></title>
      <url>/scrum%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>scrum是一种灵活的敏捷软件开发管理过程。这个名词来源于英式橄榄球。Scrum方法由Ken Schwaber和 Jeff Sutherland 提出，它将软件开发团队比作橄榄球队，全队有明确的最高目标：发布产品的重要性高于一切。团队高度自治，队员们熟悉开发过程中涉及到的各种技术，紧密合作，确保每个迭代都朝着最高目标推进。而且每隔2至6周，每个人都能看到能实际工作的软件，并且据此决定是发布这个版本还是继续开发以加强它的功能。</p>
<p>对于功能需求可能经常发生变化的项目来说，Scrum是它们最为理想的选择之一。在一个采用Scrum的项目中，首先要将所有需要完成的工作列在一个产品待开发项(Product Backlog)中，项目开发过程中需求的改变也要写进去。在每个迭代(Sprint)开始之前，要开一个迭代计划会议(Sprint Planning Meetting)。在会上，产品责任人(Product Owner)为 Product Backlog中的各功能需求确定优先级(或者是在会前完成)，随后Scrum开发团队按照优先级，从Product Backlog中挑选出他们认为能在本次迭代中完成的任务，把它们从Product Backlog中挪到Sprint Backlog中来。在Sprint进行过程中，Scrum团队每一天都要举行一个简短的每日立会(Daily Stand-up Meeting)，以便团队成员了解开发进度。Sprint结束之后，需要开评审会(Review Meeting)和反思会(Restrospective Meeting)。开发团队在评审会上把这个Sprint的开发成果展示给大家看；而在反思会上，团队成员们会回顾过去的这个Sprint，从中总结经验和教训。</p>
<h2 id="entries-of-backlog"><a href="#entries-of-backlog" class="headerlink" title="entries of backlog"></a>entries of backlog</h2><p>Product Backlog：根据初始需求分解出的任务列表，包括功能性的和非功能性的所有功能； 由Product Owner为Product Backlog中的任务确定优先级别；当开发团队开始做某个任务的时候，再精确定义和分解这个任务。<br><strong>Product Backlog是产品所要具备的所有功能的总纲。</strong></p>
<p>具体项目的任务分类：</p>
<ul>
<li>epic<ul>
<li>user story(jira)产品某一功能完整的需求<ul>
<li>condition<ul>
<li>themes(group user stories) for each developer in group<br>subtasks(可以为每个组员分配更加详细的子任务)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Scrum敏捷开发的简要步骤："><a href="#Scrum敏捷开发的简要步骤：" class="headerlink" title="Scrum敏捷开发的简要步骤："></a>Scrum敏捷开发的简要步骤：</h2><ul>
<li>need a vision:<br>项目开始，所有的成员包括开发和po一起去做一个产品的vision，也就是产品的愿景，我们需要将产品做成什么样，然后大家一起朝着这个目标进发。</li>
<li>维护backlog：<br>po根据产品的需求去第一次划分任务，是所有的任务。然后根据任务的重要程度<strong>去排列优先级</strong>，只有po有这个权限去维护backlog！。</li>
<li>拆分sprint：<br>把scrum拆分成一个一个的sprint也就是我们常说的迭代。并把上一步列出来的所有项目分到sprint中去。这就形成了一个简单的plan。</li>
<li>运行sprint plan<br>整个团队一起去开始sprint。通过backlog从优先级最高的item开始挑选，po开始讲解item的具体要求。然后大家将item细分成各个task。开发人员开始领task。</li>
<li>sprint planning meeting（迭代计划会）<br>在每个Sprint开始之前，需要召开Sprint计划会议，一般为4至8个小时。参加人员有产品责任人、Scrum Master、Scrum团队和其他感兴趣的人，比如管理层人员和客户代表。Product Owner从产品Backlog中挑选优先度高的任务，并与Scrum团队一起决定在这个Sprint中需要完成多少功能；Scrum团队将这些任务分解成小的功能模块； Scrum团队成员详细讨论如何能按需求完成这些功能模块，并估计完成每个功能模块所需的大概时间。</li>
<li>Daily Stand-up Meeting（每日立会）<br>即团队每日例会，条件允许的话，每天都应该在同样的时间和地点，所有成员站立着举行。由于是站立的状态开会，因此时间比较短，一般为15分钟左右。这个会议最好是在每天的早晨开，有利于团队成员们安排好当天的工作计划。只有团队成员可以在每日Scrum会议上发言，其他人员如果对项目进度有兴趣也可以参加，但只能旁听而不能发言。<br>  会议由Scrum Master（backlog owner）主持，Scrum团队的所有成员轮流回答上图中的三个问题，即：<ul>
<li>昨天我完成了什么工作；</li>
<li>今天我打算做什么；</li>
<li>我遇到了什么障碍。</li>
</ul>
</li>
<li>Review Meeting（Sprint评审会）<br>Sprint结束时召开；由开发团队展示这个Sprint中完成的功能；长度为两个小时左右；不需要PPT；一般是已完成的功能的Demo； 谁都可以参加：客户、管理层、Product Owner、其他开发人员等等。</li>
<li>Sprint Retrospective（sprint回顾会）<br>也就是一个sprint做完了，大家坐在一起聊一聊，总结一下这个迭代过程中有什么问题，有什么可以值得后续开发借鉴的啊。blabla～</li>
</ul>
<h2 id="backlog具体分析"><a href="#backlog具体分析" class="headerlink" title="backlog具体分析"></a>backlog具体分析</h2><h3 id="user-story-format"><a href="#user-story-format" class="headerlink" title="user story     format"></a>user story     format</h3><p>name and summary text format:</p>
<pre><code>as a/an &lt;type of user&gt;
i want &lt;some goal&gt;
so that &lt;some reason&gt;
</code></pre><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>jira:<br><strong>epic:</strong></p>
<ul>
<li>project:项目</li>
<li>type:任务类型：epic</li>
<li>epic name: epic name format</li>
<li>summary: same as above</li>
<li>描述：</li>
<li>优先级：任务的优先级</li>
<li>labels：标签</li>
<li>links：可以将文档或者其他epic，tasks，story关联到此任务上。</li>
</ul>
<h3 id="sprint中任务的各个状态"><a href="#sprint中任务的各个状态" class="headerlink" title="sprint中任务的各个状态"></a>sprint中任务的各个状态</h3><ul>
<li>todo:即将要做的任务</li>
<li>in progress： 正在做的任务</li>
<li>test in progress: 正在测试的任务</li>
<li>done: 已经完成测试的任务</li>
</ul>
<h3 id="scrum的三大神器"><a href="#scrum的三大神器" class="headerlink" title="scrum的三大神器"></a>scrum的三大神器</h3><p>production backlog, sprint backlog and burn down chart。</p>
<ul>
<li>production backlog:(产品代办事项)<br>是量化的用户需求，条目化地表达实际需要开发的需求。由po分化产品的backlog，比较详细。</li>
<li>sprint backlog:<br>是一次迭代中需要完成的任务，也是开发过程用得最多的Backlog，非常细化。将上面所生成的backlog，由开发人员再次细分，生成一个比较详细的backlog。</li>
<li>burn down chart:<br>用来统计每个sprint过程中，每天统计所有item的剩余时间，可以生成两种曲线，一种是现实的消耗，一种是项目预计的消耗，形成一个数据表格的形式。</li>
</ul>
<h3 id="scrum的四个计划会议"><a href="#scrum的四个计划会议" class="headerlink" title="scrum的四个计划会议"></a>scrum的四个计划会议</h3><ul>
<li>sprint planning meeting（迭代计划会）<br>在每个Sprint开始之前，需要召开Sprint计划会议，一般为4至8个小时。参加人员有产品责任人、Scrum Master、Scrum团队和其他感兴趣的人，比如管理层人员和客户代表。Product Owner从产品Backlog中挑选优先度高的任务，并与Scrum团队一起决定在这个Sprint中需要完成多少功能；Scrum团队将这些任务分解成小的功能模块； Scrum团队成员详细讨论如何能按需求完成这些功能模块，并估计完成每个功能模块所需的大概时间。</li>
<li>Daily Stand-up Meeting（每日立会）<br>即团队每日例会，条件允许的话，每天都应该在同样的时间和地点，所有成员站立着举行。由于是站立的状态开会，因此时间比较短，一般为15分钟左右。这个会议最好是在每天的早晨开，有利于团队成员们安排好当天的工作计划。只有团队成员可以在每日Scrum会议上发言，其他人员如果对项目进度有兴趣也可以参加，但只能旁听而不能发言。<br>  会议由Scrum Master（backlog owner）主持，Scrum团队的所有成员轮流回答上图中的三个问题，即：<ul>
<li>昨天我完成了什么工作；</li>
<li>今天我打算做什么；</li>
<li>我遇到了什么障碍。</li>
</ul>
</li>
<li>Review Meeting（Sprint评审会）<br>Sprint结束时召开；由开发团队展示这个Sprint中完成的功能；长度为两个小时左右；不需要PPT；一般是已完成的功能的Demo； 谁都可以参加：客户、管理层、Product Owner、其他开发人员等等。</li>
<li>Sprint Retrospective（sprint回顾会）<br>也就是一个sprint做完了，大家坐在一起聊一聊，总结一下这个迭代过程中有什么问题，有什么可以值得后续开发借鉴的啊。blabla～</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> 软件开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅析react]]></title>
      <url>/%E6%B5%85%E6%9E%90react.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> 前端框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端框架 </tag>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据可视化研究笔记]]></title>
      <url>/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="视觉感知与认知"><a href="#视觉感知与认知" class="headerlink" title="视觉感知与认知"></a>视觉感知与认知</h2><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p><strong>数据是符号的集合</strong>，是表达客观事物的未加工过的原始素材。<strong>数据模型是用来描述数据表达的底层模型</strong>：包含数据的定义和类型，以及对不同数据类型的操作功能。<br><strong>概念模型是对目标事物的状态和行为惊醒抽象的语义描述，并提供构建、推理支持等操作。</strong></p>
<h3 id="数据基础"><a href="#数据基础" class="headerlink" title="数据基础"></a>数据基础</h3><h4 id="数据分类"><a href="#数据分类" class="headerlink" title="数据分类"></a>数据分类</h4><p>从关系模型的角度来说，数据可以被分为实体和关系两部分。</p>
<ul>
<li>实体：被可视化的对象。</li>
<li>关系：定义了实体与其他实体之间的关系的结构和模型。</li>
</ul>
<h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><p>数据集是数据的实例。常见的数据集的表达方式有三类。</p>
<h5 id="数据记录集"><a href="#数据记录集" class="headerlink" title="数据记录集"></a>数据记录集</h5><p>数据记录由一组包含固定属性值的数据元素组成。有三种形式：数据矩阵，文档向量表示和事务处理数据。</p>
<ul>
<li>数据矩阵：数据对象可视为高维空间的点集，每个维度对应单个属性。这种数据集可以表达为一个mxn的矩阵。其中矩阵的每行对应一个数据对象，每列代表单个属性在数据集中的分布。数据矩阵类似于数据库中表对数据的存储方式。</li>
<li>文档向量表示：如果统计文档中所有单词出现的频率，则一个文档可以表示为一个向量，其长度是单词集的个数，每个分量记录单词集中每个单词在该文档中的频率。</li>
<li>事务处理数据：每个记录包含一组数据项。事务处理数据与数据矩阵的差别在于，事务处理数据的每个记录包含的个数和属性不固定，所以不能用矩阵这种大小确定的方式进行表达。</li>
</ul>
<h5 id="图数据集"><a href="#图数据集" class="headerlink" title="图数据集"></a>图数据集</h5><p>通常由图和树这种非结构化的数据结构来表示。后文将会详细介绍这种数据集。</p>
<h5 id="有序数据集"><a href="#有序数据集" class="headerlink" title="有序数据集"></a>有序数据集</h5><p>有序数据集是具有某种顺序的数据集。常见的有空间数据，时间数据，时空数据，顺序数据和基因测序数据。</p>
<p>数据集的另一种分类是考察数据模型的结构。可以用二维表结构逻辑表达实现的数据称为结构化数据。反之，如果不能用二维表结构逻辑表达实现的数据称为非结构化数据。</p>
<h4 id="数据相似度与密度"><a href="#数据相似度与密度" class="headerlink" title="数据相似度与密度"></a>数据相似度与密度</h4><p><strong>相似度</strong>是描述多个数据之间的相似程度的数值，通常位于0-1之间。与之对应的是相异度，其下限是0，上限和数据集有关，有可能会超过1.</p>
<p>计算相似度的方法：</p>
<ul>
<li>欧几里德距离。</li>
<li>明可夫斯基距离</li>
<li>余铉距离</li>
<li>jacccard相似度</li>
</ul>
<p>计算密度：</p>
<ul>
<li>欧几里得密度</li>
<li>概率密度</li>
<li>基于图结构的密度</li>
</ul>
<h3 id="数据获取和预处理"><a href="#数据获取和预处理" class="headerlink" title="数据获取和预处理"></a>数据获取和预处理</h3><h4 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h4><p>移动互联网时代，<strong>基于网络的多源数据交换占据主流</strong>。数据获取的挑战主要有<strong>数据格式变换</strong>和<strong>异构异质数据的获取协议</strong>两部分。</p>
<p>数据获取协议（DAP）作为一种通用的数据获取标准，在科研领域应用比较广泛。通过定义基于网络的数据获取句法，以完善数据交换机制，维护，发展和提升数据获取效率。它和网格ftp，http，srb、开放地理空间联盟（如wcs，wms，wfs）、天文学（siap，ssap，stap）等协议兼容。</p>
<h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><p>常见的数据元操作有：</p>
<ul>
<li>合并</li>
<li>采样</li>
<li>降维</li>
<li>特征子集选择</li>
<li>特征生成</li>
<li>离散化与二值化</li>
<li>属性变换</li>
</ul>
<h5 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h5><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> 数据可视化 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 数据可视化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nodejs初级教程]]></title>
      <url>/nodejs%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><del>~待更新</del></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      
        <categories>
            
            <category> node.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RESTful API设计最佳实践]]></title>
      <url>/RESTful-API%E8%AE%BE%E8%AE%A1%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="RESTful-API-设计最佳实践"><a href="#RESTful-API-设计最佳实践" class="headerlink" title="RESTful API 设计最佳实践"></a>RESTful API 设计最佳实践</h2><p>项目资源的URL应该如何设计？用名词复数还是用名词单数？一个资源需要多少个URL？用哪种HTTP方法来创建一个新的资源？可选参数应该放在哪里？那些不涉及资源操作的URL呢？实现分页和版本控制的最好方法是什么？因为有太多的疑问，设计RESTful API变得很棘手。</p>
<h3 id="每个资源使用两个URL"><a href="#每个资源使用两个URL" class="headerlink" title="每个资源使用两个URL"></a>每个资源使用两个URL</h3><p>资源集合用一个URL，具体某个资源用一个URL：</p>
<pre><code>
/employees         #资源集合的URL

/employees/56      #具体某个资源的URL
</code></pre><h3 id="用名词代替动词表示资源"><a href="#用名词代替动词表示资源" class="headerlink" title="用名词代替动词表示资源"></a>用名词代替动词表示资源</h3><p>这让你的API更简洁，URL数目更少。不要这么设计：</p>
<pre><code>
/getAllEmployees

/getAllExternalEmployees

/createEmployee

/updateEmployee
</code></pre><p>更好的设计：</p>
<pre><code>
GET /employees

GET /employees?state=external

POST /employees

PUT /employees/56
</code></pre><h3 id="用HTTP方法操作资源"><a href="#用HTTP方法操作资源" class="headerlink" title="用HTTP方法操作资源"></a>用HTTP方法操作资源</h3><p>使用URL指定你要用的资源。使用HTTP方法来指定怎么处理这个资源。使用四种HTTP方法POST，GET，PUT，DELETE可以提供CRUD功能（创建，获取，更新，删除）。</p>
<ul>
<li><p>获取：使用GET方法获取资源。GET请求从不改变资源的状态。无副作用。GET方法是幂等的。GET方法具有只读的含义。因此，你可以完美的使用缓存。</p>
</li>
<li><p>创建：使用POST创建新的资源。</p>
</li>
<li><p>更新：使用PUT更新现有资源。</p>
</li>
<li><p>删除：使用DELETE删除现有资源。</p>
</li>
</ul>
<p>2个URL乘以4个HTTP方法就是一组很好的功能。看看这个表格：<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fkkbpxeexvj30j803cdfw.jpg" alt=""></p>
<h3 id="对资源集合的URL使用POST方法，创建新资源"><a href="#对资源集合的URL使用POST方法，创建新资源" class="headerlink" title="对资源集合的URL使用POST方法，创建新资源"></a>对资源集合的URL使用POST方法，创建新资源</h3><p>创建一个新资源的时，客户端与服务器是怎么交互的呢？</p>
<p>在资源集合URL上使用POST来创建新的资源过程： </p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkkbsd2qs5j30gh0akt90.jpg" alt=""></p>
<ol>
<li><p>客户端向资源集合URL<code>/employees</code>发送POST请求。HTTP body 包含新资源的属性 “Albert Stark”。</p>
</li>
<li><p>RESTful Web服务器为新员工生成ID，在其内部模型中创建员工，并向客户端发送响应。这个响应的HTTP头部包含一个Location字段，指示创建资源可访问的URL。</p>
</li>
</ol>
<h3 id="对具体资源的URL使用PUT方法，来更新资源"><a href="#对具体资源的URL使用PUT方法，来更新资源" class="headerlink" title="对具体资源的URL使用PUT方法，来更新资源"></a>对具体资源的URL使用PUT方法，来更新资源</h3><p>使用PUT更新已有资源： </p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkkbt00kzkj30gp0ao74j.jpg" alt=""></p>
<ol>
<li><p>客户端向具体资源的URL发送PUT请求<code>/employee/21</code>。请求的HTTP body中包含要更新的属性值（21号员工的新名称“Bruce Wayne”）。</p>
</li>
<li><p>REST服务器更新ID为21的员工名称，并使用HTTP状态码200表示更改成功。</p>
</li>
</ol>
<h3 id="推荐用复数名词"><a href="#推荐用复数名词" class="headerlink" title="推荐用复数名词"></a>推荐用复数名词</h3><p>推荐：</p>
<pre><code>
/employees

/employees/21
</code></pre><p>不推荐：</p>
<pre><code>
/employee

/employee/21
</code></pre><p>事实上，这是个人爱好问题，但复数形式更为常见。此外，在资源集合URL上用GET方法，它更直观，特别是<code>GET /employees?state=external</code>、<code>POST /employees</code>、<code>PUT /employees/56</code>。但最重要的是：避免复数和单数名词混合使用，这显得非常混乱且容易出错。</p>
<p>对可选的、复杂的参数，使用查询字符串（？）。</p>
<p>不推荐做法：</p>
<pre><code>
GET /employees

GET /externalEmployees

GET /internalEmployees

GET /internalAndSeniorEmployees
</code></pre><p>为了让你的URL更小、更简洁。为资源设置一个基本URL，将可选的、复杂的参数用查询字符串表示。</p>
<pre><code>
GET /employees?state=internal&amp;maturity=senior
</code></pre><h3 id="使用HTTP状态码"><a href="#使用HTTP状态码" class="headerlink" title="使用HTTP状态码"></a>使用HTTP状态码</h3><p>RESTful Web服务应使用合适的HTTP状态码来响应客户端请求</p>
<ul>
<li><p>2xx - 成功 - 一切都很好</p>
</li>
<li><p>4xx - 客户端错误 - 如果客户端发生错误（例如客户端发送无效请求或未被授权）</p>
</li>
<li><p>5xx – 服务器错误 - 如果服务器发生错误（例如，尝试处理请求时出错）<br>参考维基百科上的HTTP状态代码。但是，其中的大部分HTTP状态码都不会被用到，只会用其中的一小部分。通常会用到一下几个：</p>
</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkkbtr8ez8j30ir0503ym.jpg" alt=""></p>
<p>除了合适的状态码之外，还应该在HTTP响应正文中提供有用的错误提示和详细的描述。这是一个例子。<br>请求：</p>
<pre><code>
GET /employees?state=super
</code></pre><p>响应：</p>
<pre><code>
// 400 Bad Request

{

    &quot;message&quot;: &quot;You submitted an invalid state. Valid state values are &#39;internal&#39; or &#39;external&#39;&quot;,

    &quot;errorCode&quot;: 352,

    &quot;additionalInformation&quot; : 

    &quot;http://www.domain.com/rest/errorcode/352&quot;

}
</code></pre><h3 id="使用小驼峰命名法"><a href="#使用小驼峰命名法" class="headerlink" title="使用小驼峰命名法"></a>使用小驼峰命名法</h3><p>使用小驼峰命名法作为属性标识符。</p>
<pre><code>
{&quot;yearOfBirth&quot;:1982}
</code></pre><p>不要使用下划线（<code>year_of_birth</code>）或大驼峰命名法（<code>YearOfBirth</code>）。通常，RESTful Web服务将被JavaScript编写的客户端使用。客户端会将JSON响应转换为JavaScript对象（通过调用<code>var person = JSON.parse(response)</code>），然后调用其属性。因此，最好遵循JavaScript代码通用规范。<br>对比：</p>
<pre><code>
person.year_of_birth // 不推荐，违反JavaScript代码通用规范

person.YearOfBirth // 不推荐，JavaScript构造方法命名

person.yearOfBirth // 推荐
</code></pre><h3 id="在URL中强制加入版本号"><a href="#在URL中强制加入版本号" class="headerlink" title="在URL中强制加入版本号"></a>在URL中强制加入版本号</h3><p>从始至终，都使用版本号发布您的RESTful API。将版本号放在URL中以是必需的。如果您有不兼容和破坏性的更改，版本号将让你能更容易的发布API。发布新API时，只需在增加版本号中的数字。这样的话，客户端可以自如的迁移到新API，不会因调用完全不同的新API而陷入困境。<br>使用直观的 “v” 前缀来表示后面的数字是版本号。</p>
<pre><code>
/v1/employees
</code></pre><p>你不需要使用次级版本号（“v1.2”），因为你不应该频繁的去发布API版本。</p>
<p>提供分页信息</p>
<p>一次性返回数据库所有资源不是一个好主意。因此，需要提供分页机制。通常使用数据库中众所周知的参数offset和limit。</p>
<pre><code>
/employees?offset=30&amp;limit=15       #返回30 到 45的员工
</code></pre><p>如果客户端没有传这些参数，则应使用默认值。通常默认值是<code>offset = 0</code>和<code>limit = 10</code>。如果数据库检索很慢，应当减小<code>limit</code>值。</p>
<pre><code>
/employees       #返回0 到 10的员工
</code></pre><p>此外，如果您使用分页，客户端需要知道资源总数。例：<br>请求：</p>
<pre><code>
GET /employees
</code></pre><p>响应：</p>
<pre><code>
{

  &quot;offset&quot;:0,

  &quot;limit&quot;:10,

  &quot;total&quot;:3465,

  &quot;employees&quot;:[

    //...

  ]

}
</code></pre><h3 id="非资源请求用动词"><a href="#非资源请求用动词" class="headerlink" title="非资源请求用动词"></a>非资源请求用动词</h3><p>有时API调用并不涉及资源（如计算，翻译或转换）。例：</p>
<pre><code>
GET /translate?from=de_DE&amp;to=en_US&amp;text=Hallo

GET/calculate?para2=23&amp;para2=432
</code></pre><p>在这种情况下，API响应不会返回任何资源。而是执行一个操作并将结果返回给客户端。因此，您应该在URL中使用动词而不是名词，来清楚的区分资源请求和非资源请求。</p>
<h3 id="考虑特定资源搜索和跨资源搜索"><a href="#考虑特定资源搜索和跨资源搜索" class="headerlink" title="考虑特定资源搜索和跨资源搜索"></a>考虑特定资源搜索和跨资源搜索</h3><p>提供对特定资源的搜索很容易。只需使用相应的资源集合URL，并将搜索字符串附加到查询参数中即可。</p>
<pre><code>
GET /employees?query=Paul
</code></pre><p>如果要对所有资源提供全局搜索，则需要用其他方法。前文提到，对于非资源请求URL，使用动词而不是名词。因此，您的搜索网址可能如下所示：</p>
<pre><code>
GET /search?query=Paul   //返回 employees, customers, suppliers 等等.
</code></pre><h3 id="在响应参数中添加浏览其它API的链接"><a href="#在响应参数中添加浏览其它API的链接" class="headerlink" title="在响应参数中添加浏览其它API的链接"></a>在响应参数中添加浏览其它API的链接</h3><p>理想情况下，不会让客户端自己构造使用REST API的URL。让我们思考一个例子。<br>客户端想要访问员工的薪酬表。为此，他必须知道他可以通过在员工URL（例如<code>/employees/21/salaryStatements</code>）中附加字符串“salaryStatements”来访问薪酬表。这个字符串连接很容易出错，且难以维护。如果你更改了访问薪水表的REST API的方式（例如变成了<code>/employees/21/salary-statement</code>或<code>/employees/21/paySlips</code>），所有客户端都将中断。<br>更好的方案是在响应参数中添加一个<code>links</code>字段，让客户端可以自动变更。<br>请求：</p>
<pre><code>
GET /employees/
</code></pre><p>响应：</p>
<pre><code>
//...

   {

      &quot;id&quot;:1,

      &quot;name&quot;:&quot;Paul&quot;,

      &quot;links&quot;: [

         {

            &quot;rel&quot;: &quot;salary&quot;,

            &quot;href&quot;: &quot;/employees/1/salaryStatements&quot;

         }

      ]

   },

//...
</code></pre><p>如果客户端完全依靠<code>links</code>中的字段获得薪资表，你更改了API，客户端将始终获得一个有效的URL（只要你更改了<code>link</code>字段，请求的URL会自动更改），不会中断。另一个好处是，你的API变得可以自我描述，需要写的文档更少。<br>在分页时，您还可以添加获取下一页或上一页的链接示例。只需提供适当的偏移和限制的链接示例。</p>
<pre><code>
GET /employees?offset=20&amp;limit=10
</code></pre><pre><code>
{

  &quot;offset&quot;:20,

  &quot;limit&quot;:10,

  &quot;total&quot;:3465,

  &quot;employees&quot;:[

    //...

  ],

  &quot;links&quot;: [

     {

        &quot;rel&quot;: &quot;nextPage&quot;,

        &quot;href&quot;: &quot;/employees?offset=30&amp;limit=10&quot;

     },

     {

        &quot;rel&quot;: &quot;previousPage&quot;,

        &quot;href&quot;: &quot;/employees?offset=10&amp;limit=10&quot;

     }

  ]

}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>RESTful api设计可以极大地提高项目管理效率，提高开发</p>
]]></content>
      
        <categories>
            
            <category> 前端架构设计 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 前端架构设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[三种web会话管理的方式]]></title>
      <url>/%E4%B8%89%E7%A7%8Dweb%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="3-种-web-会话管理的方式"><a href="#3-种-web-会话管理的方式" class="headerlink" title="3 种 web 会话管理的方式"></a>3 种 web 会话管理的方式</h2><p>http是无状态的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。当然它知道是哪个客户端地址发过来的，但是对于我们的应用来说，我们是靠用户来管理，而不是靠客户端。所以对我们的应用而言，它是需要有状态管理的，以便服务端能够准确的知道http请求是哪个用户发起的，从而判断他是否有权限继续这个请求。这个过程就是常说的会话管理。它也可以简单理解为一个用户从登录到退出应用的一段期间。本文总结了3种常见的实现web应用会话管理的方式：</p>
<ol>
<li><p>基于server端session的管理方式</p>
</li>
<li><p>cookie-base的管理方式</p>
</li>
<li><p>token-base的管理方式</p>
</li>
</ol>
<p>这些内容可以帮助加深对web中用户登录机制的理解，对实际项目开发也有参考价值，欢迎阅读与指正。</p>
<h3 id="基于server端session的管理"><a href="#基于server端session的管理" class="headerlink" title="基于server端session的管理"></a>基于server端session的管理</h3><p>在早期web应用中，通常使用服务端session来管理用户的会话。快速了解服务端session:</p>
<ol>
<li><p>服务端session是用户第一次访问应用时，服务器就会创建的对象，代表用户的一次会话过程，可以用来存放数据。服务器为每一个session都分配一个唯一的sessionid，以保证每个用户都有一个不同的session对象。</p>
</li>
<li><p>服务器在创建完session后，会把sessionid通过cookie返回给用户所在的浏览器，这样当用户第二次及以后向服务器发送请求的时候，就会通过cookie把sessionid传回给服务器，以便服务器能够根据sessionid找到与该用户对应的session对象。</p>
</li>
<li><p>session通常有失效时间的设定，比如2个小时。当失效时间到，服务器会销毁之前的session，并创建新的session返回给用户。但是只要用户在失效时间内，有发送新的请求给服务器，通常服务器都会把他对应的session的失效时间根据当前的请求时间再延长2个小时。</p>
</li>
<li><p>session在一开始并不具备会话管理的作用。它只有在用户登录认证成功之后，并且往sesssion对象里面放入了用户登录成功的凭证，才能用来管理会话。管理会话的逻辑也很简单，只要拿到用户的session对象，看它里面有没有登录成功的凭证，就能判断这个用户是否已经登录。当用户主动退出的时候，会把它的session对象里的登录凭证清掉。所以在用户登录前或退出后或者session对象失效时，肯定都是拿不到需要的登录凭证的。</p>
</li>
</ol>
<p>以上过程可简单使用流程图描述如下：<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fkk5mboalij30e2087t8y.jpg" alt=""></p>
<p>主流的web开发平台（java,.net,php）都原生支持这种会话管理的方式，而且开发起来很简单，相信大部分后端开发人员在入门的时候都了解并使用过它。它还有一个比较大的优点就是安全性好，因为在浏览器端与服务器端保持会话状态的媒介始终只是一个sessionid串，只要这个串够随机，攻击者就不能轻易冒充他人的sessionid进行操作；除非通过CSRF或http劫持的方式，才有可能冒充别人进行操作；即使冒充成功，也必须被冒充的用户session里面包含有效的登录凭证才行。但是在真正决定用它管理会话之前，也得根据自己的应用情况考虑以下几个问题：</p>
<ol>
<li><p>这种方式将会话信息存储在web服务器里面，所以在用户同时在线量比较多时，这些会话信息会占据比较多的内存；</p>
</li>
<li><p>当应用采用集群部署的时候，会遇到多台web服务器之间如何做session共享的问题。因为session是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建session的服务器，这样他就拿不到之前已经放入到session中的登录凭证之类的信息了；</p>
</li>
<li><p>多个应用要共享session时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好cookie跨域的处理。</p>
</li>
</ol>
<p>针对问题1和问题2，我见过的解决方案是采用redis这种中间服务器来管理session的增删改查，一来减轻web服务器的负担，二来解决不同web服务器共享session的问题。针对问题3，由于服务端的session依赖cookie来传递sessionid，所以在实际项目中，只要解决各个项目里面如何实现sessionid的cookie跨域访问即可，这个是可以实现的，就是比较麻烦，前后端有可能都要做处理。</p>
<p>如果不考虑以上三个问题，这种管理方式比较值得使用，尤其是一些小型的web应用。但是一旦应用将来有扩展的必要，那就得谨慎对待前面的三个问题。如果真要在项目中使用这种方式，推荐结合单点登录框架如CAS一起用，这样会使应用的扩展性更强。</p>
<h3 id="cookie-based的管理方式"><a href="#cookie-based的管理方式" class="headerlink" title="cookie-based的管理方式"></a>cookie-based的管理方式</h3><p>由于前一种方式会增加服务器的负担和架构的复杂性，所以后来就有人想出直接把用户的登录凭证直接存到客户端的方案，当用户登录成功之后，把登录凭证写到cookie里面，并给cookie设置有效期，后续请求直接验证存有登录凭证的cookie是否存在以及凭证是否有效，即可判断用户的登录状态。使用它来实现会话管理的整体流程如下：</p>
<ol>
<li><p>用户发起登录请求，服务端根据传入的用户密码之类的身份信息，验证用户是否满足登录条件，如果满足，就根据用户信息创建一个登录凭证，这个登录凭证简单来说就是一个对象，最简单的形式可以只包含用户id，凭证创建时间和过期时间三个值。</p>
</li>
<li><p>服务端把上一步创建好的登录凭证，先对它做数字签名，然后再用对称加密算法做加密处理，将签名、加密后的字串，写入cookie。cookie的名字必须固定（如ticket），因为后面再获取的时候，还得根据这个名字来获取cookie值。这一步添加数字签名的目的是防止登录凭证里的信息被篡改，因为一旦信息被篡改，那么下一步做签名验证的时候肯定会失败。做加密的目的，是防止cookie被别人截取的时候，无法轻易读到其中的用户信息。</p>
</li>
<li><p>用户登录后发起后续请求，服务端根据上一步存登录凭证的cookie名字，获取到相关的cookie值。然后先做解密处理，再做数字签名的认证，如果这两步都失败，说明这个登录凭证非法；如果这两步成功，接着就可以拿到原始存入的登录凭证了。然后用这个凭证的过期时间和当前时间做对比，判断凭证是否过期，如果过期，就需要用户再重新登录；如果未过期，则允许请求继续。</p>
</li>
</ol>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fkk5n047egj30e108fglt.jpg" alt=""></p>
<p>这种方式最大的优点就是实现了服务端的无状态化，彻底移除了服务端对会话的管理的逻辑，服务端只需要负责创建和验证登录cookie即可，无需保持用户的状态信息。对于第一种方式的第二个问题，用户会话信息共享的问题，它也能很好解决：因为如果只是同一个应用做集群部署，由于验证登录凭证的代码都是一样的，所以不管是哪个服务器处理用户请求，总能拿到cookie中的登录凭证来进行验证；如果是不同的应用，只要每个应用都包含相同的登录逻辑，那么他们也是能轻易实现会话共享的，不过这种情况下，登录逻辑里面数字签名以及加密解密要用到的密钥文件或者密钥串，需要在不同的应用里面共享，总而言之，就是需要算法完全保持一致。</p>
<p>这种方式由于把登录凭证直接存放客户端，并且需要cookie传来传去，所以它的缺点也比较明显：</p>
<ol>
<li><p>cookie有大小限制，存储不了太多数据，所以要是登录凭证存的消息过多，导致加密签名后的串太长，就会引发别的问题，比如其它业务场景需要cookie的时候，就有可能没那么多空间可用了；所以用的时候得谨慎，得观察实际的登录cookie的大小；比如太长，就要考虑是非是数字签名的算法太严格，导致签名后的串太长，那就适当调整签名逻辑；比如如果一开始用4096位的RSA算法做数字签名，可以考虑换成1024、2048位；</p>
</li>
<li><p>每次传送cookie，增加了请求的数量，对访问性能也有影响；</p>
</li>
<li><p>也有跨域问题，毕竟还是要用cookie。</p>
</li>
</ol>
<p>相比起第一种方式，cookie-based方案明显还是要好一些，目前好多web开发平台或框架都默认使用这种方式来做会话管理，比如php里面yii框架，这是我们团队后端目前用的，它用的就是这个方案，以上提到的那些登录逻辑，框架也都已经封装好了，实际用起来也很简单；asp.net里面forms身份认证，也是这个思路，这里有一篇好文章把它的实现细节都说的很清楚：</p>
<p><a href="http://www.cnblogs.com/fish-li/archive/2012/04/15/2450571.html" target="_blank" rel="noopener">http://www.cnblogs.com/fish-li/archive/2012/04/15/2450571.html</a></p>
<p>前面两种会话管理方式因为都用到cookie，不适合用在native app里面：native app不好管理cookie，毕竟它不是浏览器。这两种方案都不适合用来做纯api服务的登录认证。要实现api服务的登录认证，就要考虑下面要介绍的第三种会话管理方式。</p>
<h3 id="token-based的管理方式"><a href="#token-based的管理方式" class="headerlink" title="token-based的管理方式"></a>token-based的管理方式</h3><p>这种方式从流程和实现上来说，跟cookie-based的方式没有太多区别，只不过cookie-based里面写到cookie里面的ticket在这种方式下称为token，这个token在返回给客户端之后，后续请求都必须通过url参数或者是http header的形式，主动带上token，这样服务端接收到请求之后就能直接从http header或者url里面取到token进行验证：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkk5o3um32j30ef07bq34.jpg" alt=""></p>
<p>这种方式不通过cookie进行token的传递，而是每次请求的时候，主动把token加到http header里面或者url后面，所以即使在native app里面也能使用它来调用我们通过web发布的api接口。app里面还要做两件事情：</p>
<ol>
<li><p>有效存储token，得保证每次调接口的时候都能从同一个位置拿到同一个token；</p>
</li>
<li><p>每次调接口的的代码里都得把token加到header或者接口地址里面。</p>
</li>
</ol>
<p>看起来麻烦，其实也不麻烦，这两件事情，对于app来说，很容易做到，只要对接口调用的模块稍加封装即可。</p>
<p>这种方式同样适用于网页应用，token可以存于localStorage或者sessionStorage里面，然后每发ajax请求的时候，都把token拿出来放到ajax请求的header里即可。不过如果是非接口的请求，比如直接通过点击链接请求一个页面这种，是无法自动带上token的。所以这种方式也仅限于走纯接口的web应用。</p>
<p>这种方式用在web应用里也有跨域的问题，比如应用如果部署在a.com，api服务部署在b.com，从a.com里面发出ajax请求到b.com，默认情况下是会报跨域错误的，这种问题可以用CORS（跨域资源共享）的方式来快速解决，相关细节可去阅读前面给出的CORS文章详细了解。</p>
<p>这种方式跟cookie-based的方式同样都还有的一个问题就是ticket或者token刷新的问题。有的产品里面，你肯定不希望用户登录后，操作了半个小时，结果ticket或者token到了过期时间，然后用户又得去重新登录的情况出现。这个时候就得考虑ticket或token的自动刷新的问题，简单来说，可以在验证ticket或token有效之后，自动把ticket或token的失效时间延长，然后把它再返回给客户端；客户端如果检测到服务器有返回新的ticket或token，就替换原来的ticket或token。</p>
<h3 id="安全问题在web应用里面，会话管理的安全性始终是最重要的安全问题，这个对用户的影响极大。"><a href="#安全问题在web应用里面，会话管理的安全性始终是最重要的安全问题，这个对用户的影响极大。" class="headerlink" title="安全问题在web应用里面，会话管理的安全性始终是最重要的安全问题，这个对用户的影响极大。"></a>安全问题在web应用里面，会话管理的安全性始终是最重要的安全问题，这个对用户的影响极大。</h3><p>首先从会话管理凭证来说，第一种方式的会话凭证仅仅是一个session id，所以只要这个session id足够随机，而不是一个自增的数字id值，那么其它人就不可能轻易地冒充别人的session id进行操作；第二种方式的凭证（ticket）以及第三种方式的凭证（token）都是一个在服务端做了数字签名，和加密处理的串，所以只要密钥不泄露，别人也无法轻易地拿到这个串中的有效信息并对它进行篡改。总之，这三种会话管理方式的凭证本身是比较安全的。</p>
<p>然后从客户端和服务端的http过程来说，当别人截获到客户端请求中的会话凭证，就能拿这个凭证冒充原用户，做一些非法操作，而服务器也认不出来。这种安全问题，可以简单采用https来解决，虽然可能还有http劫持这种更高程度的威胁存在，但是我们从代码能做的防范，确实也就是这个层次了。</p>
<p>最后的安全问题就是CSRF（跨站请求伪造）。这个跟代码有很大关系，本质上它就是代码的漏洞，只不过一般情况下这些漏洞，作为开发人员都不容易发现，只有那些一门心思想搞些事情的人才会专门去找这些漏洞，所以这种问题的防范更多地还是依赖于开发人员对这种攻击方式的了解，包括常见的攻击形式和应对方法。不管凭证信息本身多么安全，别人利用CSRF，就能拿到别人的凭证，然后用它冒充别人进行非法操作，所以有时间还真得多去了解下它的相关资料才行。举例来说，假如我们把凭证直接放到url后面进行传递，就有可能成为一个CSRF的漏洞：当恶意用户在我们的应用内上传了1张引用了他自己网站的图片，当正常的用户登录之后访问的页面里面包含这个图片的时候，由于这个图片加载的时候会向恶意网站发送get请求；当恶意网站收到请求的时候，就会从这个请求的Reffer header里面看到包含这个图片的页面地址，而这个地址正好包含了正常用户的会话凭证；于是恶意用户就拿到了正常用户的凭证；只要这个凭证还没失效，他就能用它冒充用户进行非法操作。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>总结前面这三种方式，各自有各自的优点及使用场景，我觉得没有哪个是最好的，做项目的时候，根据项目将来的扩展情况和架构情况，才能决定用哪个是最合适的。本文的目的也就是想介绍这几种方式的原理，以便掌握web应用中登录验证的关键因素。</p>
<p>作为一个前端开发人员，本文虽然介绍了3种会话管理的方式，但是与前端关系最紧密的还是第三种方式，毕竟现在前端开发SPA应用以及hybrid应用已经非常流行了，所以掌握好这个方式的认证过程和使用方式，对前端来说，显然是很有帮助的。好在这个方式的技术其实早就有很多实现了，而且还有现成的标准可用，这个标准就是JWT(json-web-token)。</p>
<p>JWT本身并没有做任何技术实现，它只是定义了token-based的管理方式该如何实现，它规定了token的应该包含的标准内容以及token的生成过程和方法。目前实现了这个标准的技术已经有非常多。</p>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[react实战--打造画廊项目（一）]]></title>
      <url>/react%E5%AE%9E%E6%88%98-%E6%89%93%E9%80%A0%E7%94%BB%E5%BB%8A%E9%A1%B9%E7%9B%AE.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用<code>yeoman+bower+gulp+webpack</code>等前端自动化解决方案来构建<code>react+sass</code>的前端画廊应用。<br><em>这是画廊项目的效果图，点击相应的图片，图片会居中显示</em></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fl0o41biu3g30ze0ic4r6.gif" alt=""></p>
<p><strong>注意：此项目的react语法是基于es6的最新语法，如果看到不会的，亲子行REACT官网查看<a href="https://reactjs.org/docs/react-without-es6.html#setting-the-initial-state" target="_blank" rel="noopener">doc</a></strong></p>
<h2 id="yeoman脚手架生成项目初始的代码结构"><a href="#yeoman脚手架生成项目初始的代码结构" class="headerlink" title="yeoman脚手架生成项目初始的代码结构"></a>yeoman脚手架生成项目初始的代码结构</h2><ul>
<li>首先安装nodejs环境，不会的请自行百度～ </li>
<li>安装yeoman<pre><code>npm install yo -g
</code></pre>如果有童鞋对yeoman不是很了解，请看我以前的博客<a href="http://pancakeawesome.ink/yeoman+bower+gulp-grunt%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE.html">yeoman+bower+gulp-grunt构建现代化前端项目</a></li>
<li>去yeoman官网去搜寻基于<code>webpack</code>的react的项目生成器（generator）<br>安装generator:<pre><code>npm install -g generator-react-webpack
</code></pre><strong>TIPS：如何查看全局环境下npm安装的模块</strong><pre><code>npm ls -g --depth=1 2&gt;/dev/null | grep generator-
</code></pre><em>depth=1：因为npm中各个模块都是有依赖关系的，所以npm会以树状图的形式显示所有模块</em><br><em>2&gt;/dev/null:表示将执行bash命令过程中的错误输出到null设备中，<strong>注意：npm经常会报错。</strong>这里的设备是null，也就是空设备，意思是错误将不会展现出来。</em><br><em>grep generator：表示输出的内容仅显示generator开头的内容</em></li>
<li>在github等代码托管平台中生成一个仓库，将项目down下来。</li>
</ul>
<pre><code>git clone &lt;你的远程代码仓库的地址&gt;
</code></pre><ul>
<li>进入项目的文件夹，用yeoman生成react的初始项目结构：</li>
</ul>
<pre><code>yo react-webpack &lt;项目名称&gt;
</code></pre><p><em>国内使用npm下载包实在太慢，建议使用淘宝源下载软件：<strong>使用cnpm替换npm下载包：</strong></em></p>
<pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fkkfh53akkj31340k3jt2.jpg" alt=""></p>
<p><strong>通常生成项目初始结构很慢，耐心等待</strong></p>
<h3 id="项目根目录结构："><a href="#项目根目录结构：" class="headerlink" title="项目根目录结构："></a>项目根目录结构：</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkkfz14akcj30460anjre.jpg" alt=""></p>
<ul>
<li>babelrc: es6相关的配置。</li>
<li>node_modules:项目编译所需的node组件所在的目录。</li>
<li>cfg:<strong>类比于webpack.config文件中的webpack配置信息：</strong></li>
</ul>
<pre><code>/**
 * Build the webpack configuration
 * @param  {String} wantedEnv The wanted environment
 * @return {Object} Webpack config
 */
function buildConfig(wantedEnv) {
  let isValid = wantedEnv &amp;&amp; wantedEnv.length &gt; 0 &amp;&amp; allowedEnvs.indexOf(wantedEnv) !== -1;
  let validEnv = isValid ? wantedEnv : &#39;dev&#39;;
  let config = require(path.join(__dirname, &#39;cfg/&#39; + validEnv));
  return config;
}

module.exports = buildConfig(env);
</code></pre><p><em>这段webpack.config.js文件中的代码表明用cfg文件夹中相应环境的代码去完成webpack的配置</em></p>
<ul>
<li><code>dist</code>: dist环境的目录。</li>
<li><code>src</code>：源代码所在目录。</li>
<li><code>test</code>：测试代码所在目录。</li>
<li><code>editorconfig</code>：用来统一不同编辑器，ide的代码编辑风格。写代码的同时，自动将你的代码格式统一为editorconfig支持的编辑器的格式。<em>支持很多编辑器和ide，<a href="http://editorconfig.org/" target="_blank" rel="noopener">官网</a></em></li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fkkgqbin8cj30lr0hdgme.jpg" alt=""></p>
<ul>
<li><code>gitignore</code>:git仓库相关的配置文件。</li>
<li><code>eslintrc/jshintrc</code>:代码风格检测工具🔧，eslint比jshint多支持jsx语法。</li>
<li><code>yo-rc.json</code>：yeoman的配置文件，用来记录当前项目的信息。</li>
<li><code>karma.conf.js</code>:karma测试框架的配置文件。</li>
<li><code>package.json</code>:node项目的配置文件，声明当前的项目的信息，依赖了哪些npm包等等。</li>
<li><code>webpack.config.js</code>：webpack的配置文件。</li>
</ul>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>在<code>pacakge.json</code>文件中已经配置好了：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fkkh9uo9w3j30ka03bt8u.jpg" alt=""></p>
<pre><code>npm start 或者
npm run serve
</code></pre><p><strong>源代码结构</strong></p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkkhfhh7c7j304506nt8l.jpg" alt=""></p>
<ul>
<li><code>favicon.ico</code>:项目首页的图标，通常放在项目根目录。</li>
<li><code>index.html</code>:项目的入口文件。<br>在index页面中有这么一个脚本，这个脚本和chrome的扩展插件 react developer tools有关。<br><em>react developer tools：是chrome浏览器的一款扩展插件，可以很方便地用来调试react代码。下载地址：chrome应用商店搜索<strong>react developer tools</strong></em></li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fkmho8iwabj30ol07cq36.jpg" alt=""></p>
<p><strong>而<code>react developer tools</code>的工作原理是页面加载的时候，通过<code>__REACT_DEVTOOLS_GLOBAL_HOOK__</code>这个全局变量和页面通信。而我们项目的真实代码其实是写在一个yeoman自带的框架页面之中，也就是一个iframe，这个<code>__REACT_DEVTOOLS_GLOBAL_HOOK__</code>变量其实是存在顶层的框架页面中，如果我们需要在我们的iframe页面中使用这个这个插件，就得重新取得这个全局变量，以供插件来通信。</strong></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fkmhtkh4kuj30mc07bglx.jpg" alt=""></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fkkhieotwnj30mh01zt8p.jpg" alt="这里的parent代表的顶层页面window变量"></p>
<h2 id="webpack配置详解"><a href="#webpack配置详解" class="headerlink" title="webpack配置详解"></a><code>webpack</code>配置详解</h2><p><code>webpack</code>配置代码在<code>cfg/default.js</code>中。</p>
<p><em>目录结构：</em></p>
<ul>
<li><code>default.js</code>:相关<code>loader</code>配置</li>
<li><code>base.js</code>:<code>webpack</code>基本配置。</li>
<li><code>dev.js</code>:本地环境<code>webpack</code>配置。</li>
<li><code>dist.js</code>:正式环境<code>webpack</code>配置。</li>
<li><code>test.js</code>:测试环境<code>webpack</code>配置。</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fkukr0hwrkj307p04da9w.jpg" alt=""></p>
<h3 id="dev环境配置"><a href="#dev环境配置" class="headerlink" title="dev环境配置"></a>dev环境配置</h3><p>dev环境是项目本地调试所需的代码目录。在cfg/dev.js文件中配置相关webpack配置。</p>
<h4 id="plugins参数"><a href="#plugins参数" class="headerlink" title="plugins参数"></a>plugins参数</h4><ul>
<li>webpack.HotModuleReplacementPlugin：用来实现在本地调试项目时的模块热更新的功能</li>
<li>webpack.NoErrorsPlugin：保证编译过程不能出错。</li>
</ul>
<h3 id="dist环境配置"><a href="#dist环境配置" class="headerlink" title="dist环境配置"></a>dist环境配置</h3><p>dist环境是项目正式上线所需的代码目录。在cfg/dist.js文件中配置相关webpack配置。</p>
<h4 id="plugins参数-1"><a href="#plugins参数-1" class="headerlink" title="plugins参数"></a>plugins参数</h4><ul>
<li><code>webpack.optimize.DedupePlugin</code>：用来检测相似的文件，去除输出的<code>js</code>文件中冗余的代码。</li>
<li><code>webpack.optimize.UglifyJsPlugin</code>：压缩输出的<code>js</code>代码。</li>
<li><code>webpack.optimize.OccurenceOrderPlugin</code>：按照引用频度来排序各个模块bundle的id，引用频度越高，id值越短，达到见效文件大小的效果。</li>
<li><code>webpack.optimize.AggressiveMergingPlugin</code>：合并相似的chunk，提取公共部分。</li>
<li><code>webpack.NoErrorsPlugin</code>：保证编译过程不能出错。</li>
</ul>
<h2 id="舞台构建"><a href="#舞台构建" class="headerlink" title="舞台构建"></a>舞台构建</h2><p>开始基于脚手架项目骨架快速搭建项目环境。</p>
<h3 id="autoprefixer-loader"><a href="#autoprefixer-loader" class="headerlink" title="autoprefixer-loader"></a><code>autoprefixer-loader</code></h3><p><code>autoprefixer-loader</code>可以为css表达式自动添加一些浏览器前缀，来达到浏览器兼容的效果。</p>
<ul>
<li>安装loader,并将包写入到项目<code>package.json</code>中的本地依赖中（devDependencies）<ul>
<li>安装<code>autoprefixer-loader</code><pre><code>npm install autoprefixer-loader --save-dev
</code></pre></li>
<li>安装<code>sass-loader</code><br>由于yeoman并没有为我们自动安装处理sass文件相关的loader，我们得手动安装依赖包。<pre><code>npm install sass-loader node-sass webpack --save-dev
</code></pre></li>
</ul>
</li>
<li>修改loader配置<pre><code>{
      test: /\.scss/,
      loader: &#39;style-loader!css-loader!autoprefixer-loader?{browsers:[\&quot;last 2 version\&quot;]}!sass-loader?outputStyle=expanded&#39;
    },
</code></pre></li>
</ul>
<h3 id="引入图片资源"><a href="#引入图片资源" class="headerlink" title="引入图片资源"></a>引入图片资源</h3><ul>
<li>根据<code>VCD</code>原则（<code>V:view, C:controller, D:data</code>），在项目跟目录新建一个data目录存放项目所需的数据文件。<br>新建<code>imageDatas.json</code>文件存放图片文件的信息。<pre><code>[
  {
      &quot;fileName&quot;: &quot;1.jpg&quot;,
      &quot;title&quot;: &quot;heaven of time&quot;,
      &quot;desc&quot;: &quot;here is the heaven of time&quot;
  }
]
</code></pre></li>
<li>入口文件中处理图片信息。<br><strong>构建出的工作环境<code>webpack</code>默认版本为1.x，不包含<code>json-loader</code>.</strong><br><strong>解析<code>.json</code>文件一种解决办法是安装<code>json-loader</code>，并在<code>default.js</code>中配置。<code>json-loader</code></strong><br><strong>另一种解决办法是全局安装webpack2.x及以上版本，自带有<code>json-loader</code></strong><pre><code>npm install -g webpack@2.x
</code></pre><ul>
<li><code>json-loader</code>处理<code>json</code>文件。<ul>
<li>安装<code>json-loader</code><pre><code>npm install --save-dev json-loader
</code></pre></li>
<li>配置<code>json-loader</code><pre><code>  {
test: /\.json$/,
loader: &#39;json-loader&#39;
},
</code></pre>注：require时都必须加上json!前缀</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>let imageDatas = require(&#39;json!../data/imageDatas.json&#39;);
// 利用自执行函数，将图片名信息转成图片URL路径信息
imageDatas = (function genImageURL(imageDatasArr) {
    for (var i = imageDatasArr.length - 1; i &gt;= 0; i--) {
        let singleImageData = imageDatasArr[i];

        singleImageData.imageURL = require(&#39;../images/&#39; + singleImageData.fileName);

        imageDatasArr[i] = singleImageData;
    }
    return imageDatasArr;
})(imageDatas);
</code></pre><ul>
<li>构建页面框架（<code>html</code>， <code>css</code>）<br><em>入口文件</em><pre><code>class AppComponent extends React.Component {
render() {
  return (
    &lt;section className=&quot;stage&quot;&gt;
        &lt;section className=&quot;image-sec&quot;&gt;&lt;/section&gt;
        &lt;nav className=&quot;controller-nav&quot;&gt;&lt;/nav&gt;
    &lt;/section&gt;
  );
}
}
</code></pre><strong>这里创建组件的方式是react最新的语法，支持了es6的class和extend语法。</strong></li>
</ul>
<h2 id="构建图片组件"><a href="#构建图片组件" class="headerlink" title="构建图片组件"></a>构建图片组件</h2><h3 id="构建单个图片组件"><a href="#构建单个图片组件" class="headerlink" title="构建单个图片组件"></a>构建单个图片组件</h3><p>可以看出我们的画廊应用是由一些重复的单个图片组件形成，所以我们可以单独建立单个图片的组件，然后复用这个组件，形成多张图片的样式。</p>
<ul>
<li>创建单个图片组件<pre><code>// 构建单幅画的组件
class ImgFigure extends React.Component {
  render() {
      return (
          &lt;figure className=&#39;img-figure&#39;&gt;
            &lt;img src={this.props.data.imageURL} alt={this.props.data.title} /&gt;
            &lt;figcaption&gt;
              &lt;h2 className=&quot;img-title&quot;&gt;{this.props.data.title}&lt;/h2&gt;
              &lt;div className=&quot;img-back&quot;&gt;
                &lt;p&gt;&lt;/p&gt;
              &lt;/div&gt;
            &lt;/figcaption&gt;
          &lt;/figure&gt;
      );
  }
}
</code></pre><strong><code>figure</code>是h5语义化标签，标签内建议存放<code>自包含</code>（单独拿出也能有意义）的内容，而且其中<code>firgcaptiopn</code>标签可以描述<code>figure</code>内容的标题，很适合现在的场景。</strong></li>
<li><p>通过管理者<code>APPComponent</code>管理数据和数据交换，将组件插入到<code>APPComponent</code>中。</p>
<pre><code>// “大管家”：掌握一切的数据和数据之间的切换
class AppComponent extends React.Component {
render() {
    let controllerUnits = [],
            imgFigures = [];

    imageDatas.forEach( function(value, index) {
        // 用图片数据填充imageFigure组件
        imgFigures.push(&lt;ImgFigure data={value} key={index} ref={&#39;imgFigure&#39; + index}&gt;&lt;/ImgFigure&gt;);
    });

  return (
    &lt;section className=&quot;stage&quot;&gt;
        &lt;section className=&quot;image-sec&quot;&gt;
            {imgFigures}
        &lt;/section&gt;
        &lt;nav className=&quot;controller-nav&quot;&gt;&lt;/nav&gt;
    &lt;/section&gt;
  );
}
}
</code></pre><p><strong>注意：⚠️通过<code>require json</code>文件得到的<code>imageDatas</code>是一个数组对象，react需更新组件时是通过DOM与virtual DOM的对比来实现，如果有变化就重新渲染，因此在每次forEach循环添加节点都应给组件添加一个key，<code>&lt;ImgFigure data={value} key={index} ref={&#39;imgFigure&#39; + index}&gt;&lt;/ImgFigure&gt;)</code>以优化对比</strong><br><strong>REACTC自定义的组件命名必须是大写字母开头，笔者当初被坑了好久。怪我粗心了～</strong></p>
</li>
<li><p>定义组件的样式：</p>
<pre><code>/* image --- start */
.image-sec {
position: relative;
width: 100%;
height: 100%;
overflow: hidden;
background-color: #ddd;
@at-root {
  // at-root 系统mixin会在编译css文件时将内部的选择器放到最外层
  .img-figure {
    position: absolute;

    width: 320px;
    height: 360px;
    margin: 0;
    padding: 40px;

    background-color: #fff;

    box-sizing: border-box;
  }

  figcaption {
    text-align: center;

    .img-title {
      margin-top: 20px;

      color: #a7a0a7;

      font-size: 16px;
    }
  }
}
}
/* image --- end */
</code></pre><p><strong><code>at-root 系统mixin</code>会在编译css文件时将内部的选择器放到最外层,以防止选择器嵌套过深。</strong></p>
</li>
</ul>
<h3 id="划分舞台区域"><a href="#划分舞台区域" class="headerlink" title="划分舞台区域"></a>划分舞台区域</h3><p>将舞台粗略划分为五个区域，左侧区域，右侧区域，上侧区域，下侧区域，中心区域。为了不影响控制组件，图片只显示在左中右三个区域。</p>
<ul>
<li>计算各个区域的范围。</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fkvzl8mgh0j30pq0dtq50.jpg" alt="左分区和右分区位置排布"></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fkvzm1t2m3j30pm0dogn5.jpg" alt="上分区位置排布"></p>
<ul>
<li><p>为组件田间表示范围的常量：    </p>
<pre><code>constructor(props) {
      super(props);

      // 存储排布的可取范围
      this.Constant = {
          // 中心图片的位置点
          centerPos: {
              left: 0,
              right: 0
          },
          // 水平方向的取值范围
          hPosRange: {
              leftSecX: [0, 0],
              rightSecX: [0, 0],
              y: [0, 0]
          },
          // 垂直方向的取值范围
          vPosRange: {
              x: [0, 0],
              topY: [0, 0]
          }
      };
  }
</code></pre><p><strong>注意：这里给组件添加自定义属性使用了es6 class的新语法。</strong></p>
</li>
<li>当组件被渲染进页面时，为每张图片计算其范围：</li>
</ul>
<pre><code>var stageDOM = ReactDOM.findDOMNode(this.refs.stage),
      stageW = stageDOM.scrollWidth,
      stageH = stageDOM.scrollHeight,
      halfStageW = Math.ceil(stageW / 2),
      halfStageH = Math.ceil(stageH / 2);

    // 取得ImgFigure大小
    var imgFigureDOM = ReactDOM.findDOMNode(this.refs.imgFigure0),
      imgW = imgFigureDOM.scrollWidth,
      imgH = imgFigureDOM.scrollHeight,
      halfImgW = Math.ceil(imgW / 2),
      halfImgH = Math.ceil(imgH / 2);

    // 计算中间区域图片排布的位置
    this.Constant.centerPos = {
      left: halfStageW - halfImgW,
      top: halfStageH - halfImgH
    };

    // 计算左、右侧图片排布区域的位置
    this.Constant.hPosRange = {
      leftSecX: [-halfImgW, halfStageW - halfImgW * 3],
      rightSecX: [halfStageW + halfImgW, stageW - halfImgW],
      y: [-halfImgH, stageH - halfImgH]
    };

    // 计算上侧区域图片排布的位置
    this.Constant.vPosRange = {
      topY: [-halfImgH, halfStageH - halfImgH * 3],
      x: [halfStageW - imgW, halfStageW]
    };

    this.rearrange(0);
</code></pre><p><strong>注意：<code>ReactDOM.findDOMNode</code>是<code>REACT</code>顶层结构的全局变量<code>ReactDOM</code>的一个辅助方法，需要单独引入。</strong></p>
<pre><code>- es5写法：
</code></pre><pre><code>var ReactDOM = require(&#39;react-dom&#39;);
</code></pre><pre><code>- es6写法：
</code></pre><pre><code>import ReactDOM from &#39;react-dom&#39;;
</code></pre><ul>
<li><p>给imagdatas的毁掉函数绑定组件到<code>this</code>上，并且给每张图片初始化位置信息。</p>
<pre><code>imageDatas.forEach(function(value, index) {
          // 判断当前图片的位置信息是否已经初始化，如果没有初始化，则初始化图片的位置信息
          if (!this.state.imgsArrangeArr[index]) {
              this.state.imgsArrangeArr[index] = {
                  pos: {
                      left: 0,
                      top: 0
                  }
              }
          }

          // 用图片数据填充imageFigure组件
          imgFigures.push(
              &lt;ImgFigure data={value} key={index} ref={&#39;imgFigure&#39; + index}&gt;&lt;/ImgFigure&gt;
          );
      }.bind(this));
</code></pre></li>
<li><p>创建重新布局的方法：</p>
<pre><code>rearrange(centerIndex) {
      let imgsArrangeArr = this.state.imgsArrangeArr,
          Constant = this.Constant,
          centerPos = Constant.centerPos,
          hPosRange = Constant.hPosRange,
          vPosRange = Constant.vPosRange,
          hPosRangeLeftSecx = hPosRange.leftSecX,
          hPosRangeRightSecx = hPosRange.rightSecX,
          hPosRangeY = hPosRange.y,
          vPosRangeTopY = vPosRange.topY,
          vPosRangex = vPosRange.x,
          // 存储显示在上侧区域的图片信息
          imgsArrangeTopArr = [],
          // 取一个或者不取
          topImgNum = Math.ceil(Math.random() * 2),
          topImgSpliceIndex = 0,
          imgsArrangeCenterArr = imgsArrangeArr.splice(centerIndex, 1);

      // 首先居中centerIndex的图片
      imgsArrangeCenterArr[0].pos = centerPos;

      // 取出要布局上侧的图片的状态信息
      topImgSpliceIndex = Math.ceil(Math.random() * (imgsArrangeArr.length - topImgNum));
      imgsArrangeTopArr = imgsArrangeArr.splice(topImgSpliceIndex, 1);

      // 布局位于上侧的图片
      imgsArrangeTopArr.forEach(function(value, index) {
          imgsArrangeTopArr[index].pos = {
              top: getRangeRandom(vPosRangeTopY[0], vPosRangeTopY[1]),
              left: getRangeRandom(vPosRangex[0], vPosRangex[1])
          }
      });

      // 布局两侧图片
      for (let i = 0, j = imgsArrangeArr.length, k = j / 2; i &lt; j; i++) {
          let hPosRangeLORX = null;

          // 前半部分布局左边，右半部分布局右边
          if (i &lt; k) {
              hPosRangeLORX = hPosRangeLeftSecx;
          } else {
              hPosRangeLORX = hPosRangeRightSecx;
          }

          imgsArrangeArr[i].pos = {
              top: getRangeRandom(hPosRangeY[0], hPosRangeY[1]),
              left: getRangeRandom(hPosRangeLORX[0], hPosRangeLORX[1])
          }
      }

      // 将之前取出来的上侧图片再放回去
      if (imgsArrangeTopArr &amp;&amp; imgsArrangeTopArr[0]) {
          imgsArrangeArr.splice(topImgSpliceIndex, 0, imgsArrangeTopArr[0]);
      }
      // 将之前取出来的中心图片再放回去
      imgsArrangeArr.splice(centerIndex, 0, imgsArrangeCenterArr[0]);

      // 设置state，触发组件的重新渲染
      this.setState({
          imgsArrangeArr: imgsArrangeArr
      });
  }
</code></pre></li>
<li><p>从<code>imgsArrangeArr</code>中取出每张图片新的位置信息，并设置每张图片的新的位置样式，重新渲染组件：</p>
<pre><code>// 构建单幅画的组件
class ImgFigure extends React.Component {
  render() {
      let styleObj = {};

      // 如果props属性中指定了这张图片的位置，则使用
      if (this.props.arrange.pos) {
          styleObj = this.props.arrange.pos;
      }

      return (
          &lt;figure className=&#39;img-figure&#39; style={styleObj}&gt;
                &lt;img src={this.props.data.imageURL} alt={this.props.data.title} /&gt;
                &lt;figcaption&gt;
                      &lt;h2 className=&quot;img-title&quot;&gt;{this.props.data.title}&lt;/h2&gt;
                      &lt;div className=&quot;img-back&quot;&gt;
                        &lt;p&gt;&lt;/p&gt;
                  &lt;/div&gt;
                &lt;/figcaption&gt;
          &lt;/figure&gt;
      );
  }
}
</code></pre></li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这样我们的画廊舞台的基本框架就搭好了，接下来就是给我们的画廊加上动态效果，请移步我的另一片博客。<br><img src="http://ww4.sinaimg.cn/mw690/e75a115bgw1f3rrbzv1m8g209v0diqv7.gif" alt=""></p>
]]></content>
      
        <categories>
            
            <category> react </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> react </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[compass重要功能之精灵图合图]]></title>
      <url>/compass%E9%87%8D%E8%A6%81%E5%8A%9F%E8%83%BD%E4%B9%8B%E7%B2%BE%E7%81%B5%E5%9B%BE%E5%90%88%E5%9B%BE.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>精灵图合图相关功能集合。可以说是compass在日常工程中的最佳实践，非常实用也非常重要。<br><strong>想象一下设计人员（通常是漂亮的小姐姐们～不好意思责怪人家呀=。=）将sprites图中的一个图标，并且很有可能影响到了其他的图标，开发人员就要吐血地在项目中修改所有被影响的样式代码，这真的是巨痛苦无比呀</strong><br><strong>而有了compass的精灵图合图功能，我们只需要将项目中用想要合图的图片文件（现在只支持png格式的文件）放到一个相应的目录下，compass将会自动帮我们把图片文件生成为一个雪碧图，无论这些文件怎么变化，我们都不需要再去更改代码中的内容！</strong><br>精灵图合图可以说是compass的最重要的功能模块，我这里说下我的理解。<br>compass相关的知识请进<a href="http://pancakeawesome.ink/2017/09/28/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E4%B9%8Bcompass/">传送门</a></p>
<h2 id="在compass项目中使用精灵合图功能"><a href="#在compass项目中使用精灵合图功能" class="headerlink" title="在compass项目中使用精灵合图功能"></a>在compass项目中使用精灵合图功能</h2><h3 id="在项目中引入sprites模块"><a href="#在项目中引入sprites模块" class="headerlink" title="在项目中引入sprites模块"></a>在项目中引入sprites模块</h3><ul>
<li>在scss目录下新建一个_icons.scss文件来专门处理项目的雪碧图（个人习惯，也可以写在screen.scss中）</li>
<li>在screen.scss文件中引入_icons.scss，不知道screen.scss文件作用的同学请看我的上一篇<a href="http://pancakeawesome.ink/2017/09/28/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E4%B9%8Bcompass/">博客</a><br>引入sprites模块<pre><code>_icons.scss文件中：
@import &#39;compass/utilities/sprites&#39;;
</code></pre></li>
<li>将一些logo文件放入images文件夹下的logo文件夹，用来作为合图的资源。并在_icons.scss文件中引入。<br><strong>compass会在合图文件夹下生成一个不被写入硬盘的隐藏SCss文件</strong>引这种入方式在compass中被称为<strong>compass import</strong><pre><code>@import &quot;logo/*.png&quot;;
</code></pre><em>意思是引入logo文件夹下的所有格式是png的图片文件，后面字符是compass为合图文件添加的cache-buster</em><br>编译项目，可以看见images文件夹下生成了一张合图文件。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fkfqhk9vakj306w04zmx5.jpg" alt=""></li>
<li>调用all-<code>合图文件的最后一级目录名</code>-sprites这个mixin<pre><code>@include all-logo-sprites()
</code></pre>编译之后，我们会发现相应的css文件中会自动根据合图文件生成一个一个对应的样式类。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fkfqmypiezj30nh0hzaat.jpg" alt=""><br><strong>那么这个mixin是从哪来的呢？</strong><br>其实就是在上面那句<strong>magic import生成的隐藏scss文件中</strong><h3 id="使用合图"><a href="#使用合图" class="headerlink" title="使用合图"></a>使用合图</h3>在index文件中给元素添加生成的相应的css样式即可。<h4 id="其他样式类的元素应用特定的图片样式？"><a href="#其他样式类的元素应用特定的图片样式？" class="headerlink" title="其他样式类的元素应用特定的图片样式？"></a>其他样式类的元素应用特定的图片样式？</h4>只需给相应的样式引入logo-sprite(<code>$图片名</code>)<pre><code>/*
  其余类想使用某张图片，可以不使用这个类名，直接引入图片类即可
*/
.main-logo {
  @include logo-sprite(&#39;btn&#39;);
}
</code></pre><h4 id="元素不同状态下显示不同的图片？"><a href="#元素不同状态下显示不同的图片？" class="headerlink" title="元素不同状态下显示不同的图片？"></a>元素不同状态下显示不同的图片？</h4>只要将合图资源文件命名为<code>文件名_hover</code>的格式（或者<code>active</code>），compass就会自动生成图片设置为<code>文件名</code>样式的不同状态的css。<br><strong><code>-</code>也可以</strong><br><strong>以下代码可以消除以上伪类形容不同状态样式的功能</strong><pre><code>/*
  是否关闭精灵图合图模块默认的伪类样式
*/
$disable-magic-sprite-selectors: true;
</code></pre><h4 id="设置精灵合的排列布局"><a href="#设置精灵合的排列布局" class="headerlink" title="设置精灵合的排列布局"></a>设置精灵合的排列布局</h4>设置<code>logo-layout</code>变量</li>
<li>vertical(垂直（默认布局方式）)</li>
<li>horizontal(水平)</li>
<li>diagonal(斜对角线)</li>
<li>smart(最节省空间的布局方式)<pre><code>/*
  精灵合图的默认排列方式
*/
$logo-layout: smart;
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>compass的精灵图合图功能在实际项目过程中时非常有用的功能，希望大家都能掌握这种技能～谢谢🙏观看～</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端技术 </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[yeoman+bower+gulp/grunt构建现代化前端项目]]></title>
      <url>/yeoman+bower+gulp-grunt%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE.html</url>
      <content type="html"><![CDATA[<p><del>待更新</del></p>
]]></content>
      
        <categories>
            
            <category> 前端工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端必备技能之compass]]></title>
      <url>/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E4%B9%8Bcompass.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先介绍下<a href="http://compass-style.org/" target="_blank" rel="noopener">compass</a>，compass是一款优秀的开源的<strong>css书写框架</strong>，什么叫书写框架呢？众所周知，<code>sass</code>中有很多便捷的语法特性，比如<code>mixin</code>,<code>function</code>等，<code>compass</code>正是一个强大的函数仓库，compass封装了很多在平常工程过程中能用到的css效果的函数，比如清楚浮动，设置表格样式等等。<br><em>至于sass和css之间的关系请看我的上篇<a href="http://pancakeawesome.ink/2017/09/18/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8sass/">博客</a></em>，讲的很详细。<br><strong>这里是我写的一个compass的demo，可以对照着看</strong><br><strong>如果把<code>sass</code>必做钉子，那么<code>compass</code>就是一个锤子🔨，可以方便快捷地构建你的<code>css</code>工程化代码</strong></p>
<h2 id="compass的安装-amp-amp-项目的构建"><a href="#compass的安装-amp-amp-项目的构建" class="headerlink" title="compass的安装&amp;&amp;项目的构建"></a>compass的安装&amp;&amp;项目的构建</h2><h3 id="compass的安装"><a href="#compass的安装" class="headerlink" title="compass的安装"></a>compass的安装</h3><p>如果你是<code>Mac os</code>系统，那么你的电脑预装了ruby的环境，那么就会有<code>gem</code>这个ruby的包管理器。如果你的电脑是windows的，那么请先安装<code>ruby</code>，具体安装方法我就不赘述了，请大家自行谷歌。</p>
<pre><code>gem install compass
</code></pre><p><em>如果大家在gem install过程中发现速度很慢，甚至卡住了</em>，请谷歌：<strong>gem源</strong>，具体原因我就不说了=,=</p>
<h3 id="compass项目的运行"><a href="#compass项目的运行" class="headerlink" title="compass项目的运行"></a>compass项目的运行</h3><ul>
<li>正式编译，<strong>会将项目目录下的<code>scss</code>文件编译成<code>css</code>文件并执行scss文件中的函数在</strong>命令行环境下：<pre><code>compass compile
</code></pre><em>加上<code>--force</code>会强制编译</em></li>
<li>自动编译，会自动监听文件的更改而随之编译文件。<pre><code>compass watch
</code></pre><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3>下面通过compass搭建你的项目：<pre><code>compass create &lt;project name&gt;
</code></pre>成功之后你会在命令行中查看到compass项目成功搭建的提示：<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fk0rttcy1sj30z70k4ack.jpg" alt=""><br>看一下项目的目录:<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fk0rv00m1dj308b04t0sk.jpg" alt=""><br>这就是compass构建的项目初始目录<h2 id="compass的各大模块"><a href="#compass的各大模块" class="headerlink" title="compass的各大模块"></a>compass的各大模块</h2>compass中有各个功能不一的模块，每个模块都封装了大量的minxin和function。<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fk0s3r3nlpj30ry0dfjrx.jpg" alt=""><br><strong>其中reset模块和layout模块是特殊的核心模块，需要单独制定引入</strong>，<strong>而其他五大模块则只需要引入compass，就自动引入了</strong><pre><code>@import &#39;compass&#39;;
</code></pre><em>下面就分别介绍一下各个核心模块，但是由于精力有限，每个模块我只会介绍一些项目开发过程中常见的功能函数，其他的函数，请直接移步compass的 api <a href="http://compass-style.org/reference/compass/css3/" target="_blank" rel="noopener">doc</a></em><h2 id="reset模块"><a href="#reset模块" class="headerlink" title="reset模块"></a>reset模块</h2>reset模块是负责将浏览器默认样式统一，以减少浏览器之间差异性。<h3 id="reset模块引入"><a href="#reset模块引入" class="headerlink" title="reset模块引入"></a>reset模块引入</h3>/sass/screen.ccss文件中：<br><strong>screen.scss文件负责站点主体的样式</strong><pre><code>@import &quot;compass/reset&quot;;
</code></pre><h3 id="css样式效果展示"><a href="#css样式效果展示" class="headerlink" title="css样式效果展示"></a>css样式效果展示</h3><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fk0sic433gj30vb0izwg9.jpg" alt=""><h3 id="normalize模块"><a href="#normalize模块" class="headerlink" title="normalize模块"></a>normalize模块</h3><strong>用normalize模块来代替compass默认的reset模块</strong><br>其实可以看出reset模块很粗暴，它会把所有浏览器默认属性重置，这样在实际工程中回造成很多麻烦，我们可以很方便的normalize模块来替代reset,normalize模块会将大多数常用到的标签属性重置。<h4 id="normalize模块-1"><a href="#normalize模块-1" class="headerlink" title="normalize模块"></a>normalize模块</h4>normalize常用的子模块有：</li>
<li>html5模块：用来统一html5属性</li>
<li>base：用来统一一般的html属性</li>
<li>links:用来统一<code>&lt;a&gt;</code>标签相关的属性<h4 id="normalize的安装"><a href="#normalize的安装" class="headerlink" title="normalize的安装"></a>normalize的安装</h4><pre><code>gem install normalize
</code></pre><em>用homebrew，npm也可以安装</em></li>
</ul>
<h4 id="normalize的引入"><a href="#normalize的引入" class="headerlink" title="normalize的引入"></a>normalize的引入</h4><ul>
<li>在工程目录下的<code>config.rb</code>下将normalize通过require语法引入<pre><code>require &#39;compass-normalize&#39;
</code></pre></li>
<li>在screen.scss文件中将normalize模块引入<pre><code>/*
  引入normalize模块
*/
@import &quot;normalize&quot;;
</code></pre><strong>screen.css文件中的生成效果</strong><br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fk0t5ugeiaj30us0gqaat.jpg" alt=""><br>你也可以根据需求分别引入normalize的各个子模块:<br><strong>注意：如果要引入子模块，必须要先引入normalize-version模块</strong><pre><code>/*
  引入normalize子模块之前需要引入normalize-version
*/
@import &quot;normalize-version&quot;;
/*
  normalize子模块一
*/
@import &quot;normalize/html5&quot;;
/*
  normalize子模块二
*/
@import &quot;normalize/base&quot;;
/*
  normalize子模块三
*/
@import &quot;normalize/links&quot;;
</code></pre>具体这些子模块的作用可以去去normalize的官网去查看<a href="https://necolas.github.io/normalize.css/" target="_blank" rel="noopener">doc</a><br><code>screen.css</code>文件的显示效果:(以html5模块举例)<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fk0tb4jv4lj30vi0ie0tp.jpg" alt=""><h2 id="layout模块"><a href="#layout模块" class="headerlink" title="layout模块"></a>layout模块</h2>如果说reset模块事使用起来最简单的模块（因为只需引进来即可，不需要多余操作），那么layout模块就是使用率最低的模块。layout模块提供页面的布局控制能力。<br><strong>layout模块不属于compass自带的模块，需要在scss文件中单独引入</strong><br>layout模块又分为三个子模块：</li>
<li>grid-background</li>
<li>sticky-footer</li>
<li>stretching<h3 id="grid-background模块："><a href="#grid-background模块：" class="headerlink" title="grid-background模块："></a>grid-background模块：</h3>提供为元素提供定宽定高或者自适应格式宽高的背景的功能。<br><strong>这个功能不常用，在webapp电子书在线阅读等场景需求下可以用到，有需要的去doc仔细看看</strong></li>
<li>引入：<pre><code>@import &#39;compass/layout/grid-background&#39;;
</code></pre></li>
<li>相关mixin：<ul>
<li><strong>grid-background($total, $column, $gutter, $baseline, $offset, $column-color, $gutter-color, $baseline-color, $force-fluid)</strong><ul>
<li>功能：提供为元素提供定宽定高或者自适应格式宽高的背景的功能</li>
<li>参数：</li>
<li>示例：<pre><code>screen.scss文件:
/*
grid-background模块
*/
#root {
@include grid-background();
}
</code></pre>screen.css文件中:<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fk5dydolwaj30tu0gugoy.jpg" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="stretching模块："><a href="#stretching模块：" class="headerlink" title="stretching模块："></a>stretching模块：</h3><p>提供子元素拉伸填满整个父元素的能力。</p>
<ul>
<li>引入：<pre><code>@import &#39;compass/layout/stetching&#39;;
</code></pre></li>
<li>相关mixin：<ul>
<li><strong>stretch($offset-top, $offset-right, $offset-bottom, $offset-left)</strong><ul>
<li>功能：将子元素填满父元素</li>
<li>参数：绝对定位上右下左的位置</li>
<li>示例：<pre><code>screen.scss文件:
/*
stretching模块
*/
.stretch-full {
@include stretch();
}
screen.css文件中:
/* line 119, ../sass/screen.scss */
.stretch-full {
position: absolute;
top: 0;
bottom: 0;
left: 0;
right: 0;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="sticky-footer模块"><a href="#sticky-footer模块" class="headerlink" title="sticky-footer模块"></a>sticky-footer模块</h3><p>提供页面中的页脚始终在页面最底部的功能：<br>提供子元素拉伸填满整个父元素的能力。</p>
<ul>
<li>引入：<ul>
<li>在html文件中引入以下标签：<pre><code>&lt;body&gt;
&lt;div id=&quot;root&quot;&gt;
&lt;div id=&quot;root_footer&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;footer&quot;&gt;
Footer content goes here.
&lt;/div&gt;
&lt;/body&gt;
</code></pre></li>
<li>在screen.scss文件中引入footer模块<pre><code>@import &#39;compass/layout/sticky-footer&#39;;
</code></pre></li>
</ul>
</li>
<li>相关mixin：<ul>
<li><strong>sticky-footer($footer-height, $root-selector, $root-footer-selector, $footer-selector)</strong><ul>
<li>功能：当主体内容不超过浏览器窗口大小时，页脚始终在窗口底部；当主体内容超过浏览器窗口大小时，页脚将随浏览器内容在页面底部</li>
<li>参数：footer的高度</li>
<li>示例：<pre><code>screen.scss文件:
/*
sticky-footer模块
*/
@include sticky-footer(30px);
screen.css文件中:
html, body {
height: 100%;
}
#root {
clear: both;
min-height: 100%;
height: auto !important;
height: 100%;
margin-bottom: -30px;
}
#root #root_footer {
height: 30px;
}
#footer {
clear: both;
position: relative;
height: 30px;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="css3-amp-amp-browser-support模块"><a href="#css3-amp-amp-browser-support模块" class="headerlink" title="css3&amp;&amp;browser support模块"></a>css3&amp;&amp;browser support模块</h2><p>css3模块:提供css3特性的一些功能函数，support模块提供规定compass支持哪些浏览器的功能。如果说layout模块使用率最低，那么css3一定是主动使用率最高的模块，因为我们在使用css特性时，都会用到browser support模块来做浏览器的兼容,配置compass模块默认支持哪些浏览器。<br>引入css3模块：</p>
<pre><code>@import &quot;compass/css3&quot;;
</code></pre><p>引入browser support模块：<br><em>其实可以不用引入，因为css3模块自动引入support模块</em></p>
<pre><code>@import &quot;compass/support&quot;;
</code></pre><h3 id="常用的browser-support子功能："><a href="#常用的browser-support子功能：" class="headerlink" title="常用的browser support子功能："></a>常用的browser support子功能：</h3><p><strong>介绍一些常用的，其他的请看官网的doc</strong></p>
<ul>
<li><strong>browsers()</strong><ul>
<li>返回值是compass目前版本支持的浏览器list</li>
</ul>
</li>
<li><strong>$supported-browsers: chrome,ie</strong><ul>
<li>功能：声明compass支持的浏览器list</li>
<li>参数：浏览器的list（逗号分隔）</li>
</ul>
</li>
<li><strong>$browser-minimum-versions: (“ie”: “8”);</strong><ul>
<li>功能：声明compass支持的最低浏览器版本</li>
<li>参数：浏览器和版本号对应的键值对（map形式）</li>
</ul>
</li>
</ul>
<h3 id="常用的css3子功能："><a href="#常用的css3子功能：" class="headerlink" title="常用的css3子功能："></a>常用的css3子功能：</h3><p><strong>介绍一些常用的，其他的请看官网的doc</strong><br><strong>所有的css属性的编译结果（css文件中）都是依照support模块设置的浏览器版本</strong><br><em>我的实例结果都是在没有设置support中的功能前提下而得出的</em></p>
<ul>
<li><p><strong>box-shadow</strong></p>
<ul>
<li>box-shadow()<ul>
<li>功能：添加元素的box-shadow样式，并自动根据browsersupport中的浏览器，添加浏览器前缀</li>
<li>参数：上右下左边框阴影样式的高度和颜色</li>
<li>示例：<pre><code>screen.scss文件:
.webdemo-sec {
@include box-shadow(1px 2px 3px 4px #cfcecf);
}
screen.css文件中:
.webdemo-sec {
-moz-box-shadow: 1px 2px 3px 4px #cfcecf;
-webkit-box-shadow: 1px 2px 3px 4px #cfcecf;
box-shadow: 1px 2px 3px 4px #cfcecf;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>opacity</strong></p>
<ul>
<li>opacity($opacity)<ul>
<li>功能：提供元素透明度样式的功能</li>
<li>参数：透明度</li>
<li>示例：<pre><code>screen.scss文件:
.opacity-test {
@include opacity(.5);
}
screen.css文件中:
.opacity-test {
filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=50);
opacity: 0.5;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>inline-block</strong></p>
<ul>
<li>inline-block($alignment, $ie-alignment)<ul>
<li>功能：提供元素display是inline-block的功能（兼容）</li>
<li>参数：</li>
<li>示例：<pre><code>screen.scss文件:
.inlineblock-test {
@include inline-block();
}
screen.css文件中:
.inlineblock-test {
display: inline-block;
vertical-align: middle;
*vertical-align: auto;
*zoom: 1;
*display: inline;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>flex</strong><br><strong>提供相关flexbox布局特性的功能并做浏览器兼容，这个我经常用到很好用</strong></p>
<ul>
<li>相关mixin<ul>
<li>display-flex($display)</li>
<li>flex-direction($direction)</li>
<li>justify-content($justify-content)</li>
<li>align-items($align-items)</li>
<li>功能：提供相关flexbox布局特性的功能并做浏览器兼容</li>
<li>参数：</li>
<li>示例：<pre><code>screen.scss文件:
.flex-test {
@include display-flex();
@include flex-direction(row);
@include justify-content(center);
@include align-items(center);
}
screen.css文件中:
.flex-test {
display: -webkit-flex;
display: flex;
-webkit-flex-direction: row;
flex-direction: row;
-webkit-justify-content: center;
justify-content: center;
-webkit-align-items: center;
align-items: center;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="typography模块"><a href="#typography模块" class="headerlink" title="typography模块"></a>typography模块</h2><p>typography模块主要用来修饰文本样式，垂直韵律等。<br>typography又分为四个子模块：</p>
<ul>
<li>links</li>
<li>list</li>
<li>text</li>
<li>vertical rhythm</li>
</ul>
<p>引入typography模块：</p>
<pre><code>@import &quot;compass/typography&quot;;
</code></pre><h3 id="links子模块："><a href="#links子模块：" class="headerlink" title="links子模块："></a>links子模块：</h3><p>修饰<code>&lt;a&gt;</code>标签超链接的样式。<br>我们对<code>&lt;a&gt;</code>标签通常有两种场景修饰它的样式：</p>
<ul>
<li><p><strong>hover-link()</strong></p>
<ul>
<li>功能：正常状态下掉下划线，hover和focus状态下才显示a标签的下划线<ul>
<li>参数：</li>
<li>示例：<pre><code>screen.scss文件:
a {
@include hover-link(); 
}
screen.css文件中:
a {
text-decoration: none;
}
a:hover, a:focus {
text-decoration: underline;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>不同状态下改变a标签的颜色</p>
<ul>
<li><strong>link-colors($normal, $hover, $active, $visited, $focus)</strong><ul>
<li>功能：修改不同状态下超链接的颜色</li>
<li>参数：不同状态下超链接的颜色，只有第一个参数是必须的</li>
<li>示例：<pre><code>screen.scss文件:
a {
@include link-colors(#cc0, #c0c, #0cc, #00c, #c00);
}
screen.css文件中:
a {
color: #cc0;
}
a:visited {
color: #00c;
}
a:focus {
color: #c00;
}
a:hover {
color: #c0c;
}
a:active {
color: #0cc;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>unstyled-link()</strong></p>
<pre><code>  -     功能：消除超链接原来的样式，让其在非正常状态的样式和其所在文本一样
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
a {
  @include unstyled-link();
}
screen.css文件中:
a {
color: inherit;
text-decoration: inherit;
cursor: inherit;
}
a:active, a:focus {
outline: none;
}
</code></pre></li>
</ul>
<h3 id="list子模块"><a href="#list子模块" class="headerlink" title="list子模块"></a>list子模块</h3><p>修饰<code>ul</code>和<code>ol</code>列表的样式。</p>
<ul>
<li><p><strong>no-bullets()</strong></p>
<pre><code>  -     功能：消除`ul`和`ol`元素之前所有`li`的默认点的样式。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.list-unstyled {
  @include no-bullets();
}
screen.css文件中:
.list-unstyled {
list-style: none;
}
.list-unstyled li {
list-style-image: none;
list-style-type: none;
margin-left: 0;
}
</code></pre></li>
<li><p><strong>no-bullet()</strong></p>
<pre><code>  -     功能：消除`ul`和`ol`元素之前单个`li`的默认点的样式。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.list-unstyled-list {
  @include no-bullet();
}
screen.css文件中:
.list-unstyled-list {
list-style-image: none;
list-style-type: none;
margin-left: 0;
}
</code></pre></li>
<li><p><strong>inline-list()</strong></p>
<pre><code>  -     功能：通过设置`li`元素的display值为inline,实现横向`ul`或`ol`列表的样式。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.list-inline {
  @include inline-list();
}
screen.css文件中:
.list-inline {
list-style-type: none;
}
.list-inline, .list-inline li {
margin: 0;
padding: 0;
display: inline;
}
</code></pre></li>
<li><p><strong>horizontal-list(0, right)</strong></p>
<pre><code>  -     功能：相比于上例，我们要实现横向list时，由于上例的li都是inline的样式，所有没有高度，这样我们想给li设置一些必须有高度的样式修饰时，就会出现麻烦，horizontal-list()这个mixin可以通过浮动的方式实现横向list且每个li都有高度。
  -     参数：第一个参数时li元素padding的值，第二个元素浮动的方向，设置成false，不设置padding值以兼容ie
  -     示例：
</code></pre><pre><code>screen.scss文件:
.list-horizontal {
  @include horizontal-list(0, right);
}
screen.css文件中:
.list-horizontal {
margin: 0;
padding: 0;
border: 0;
overflow: hidden;
*zoom: 1;
}
.list-horizontal li {
list-style-image: none;
list-style-type: none;
margin-left: 0;
white-space: nowrap;
float: right;
display: inline;
padding-left: 0;
padding-right: 0;
}
.list-horizontal li:first-child, .list-horizontal li.first {
padding-right: 0;
}
.list-horizontal li:last-child {
padding-left: 0;
}
.list-horizontal li.last {
padding-left: 0;
}
</code></pre></li>
<li><p><strong>horizontal-list(0, right)</strong></p>
<pre><code>  -     功能：通过设置li元素为的display属性为inline-block来实现横向list。
  -     参数：li的padding值
  -     示例：
</code></pre><pre><code>screen.scss文件:
.list-inline-block {
  @include inline-block(7px);
}
screen.css文件中:
.list-inline-block {
display: inline-block;
vertical-align: 7px;
*vertical-align: auto;
*zoom: 1;
*display: inline;
}
</code></pre></li>
</ul>
<h3 id="text子模块"><a href="#text子模块" class="headerlink" title="text子模块"></a>text子模块</h3><p>文本操作，操作过长文本的样式。</p>
<ul>
<li><p><strong>force-wrap()</strong></p>
<pre><code>  -     功能：强行使长文本换行。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.wrap-text {
  @include force-wrap();
}
screen.css文件中:
.wrap-text {
white-space: pre;
white-space: pre-wrap;
white-space: pre-line;
white-space: -pre-wrap;
white-space: -o-pre-wrap;
white-space: -moz-pre-wrap;
white-space: -hp-pre-wrap;
word-wrap: break-word;
}
</code></pre></li>
<li><p><strong>nowrap()</strong></p>
<pre><code>  -     功能：无论何时都不换行。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.nowrap-text {
  @include nowrap();
}
screen.css文件中:
.nowrap-text {
white-space: nowrap;
}
</code></pre></li>
<li><p><strong>ellipsis()</strong></p>
<pre><code>  -     功能：不换行的时候文本超出容器的宽度，出现省略号。
</code></pre><ul>
<li>引入： firefox不能很好的支持text-overflow属性，所以需要相关的xml文件来hack，compass已经封装好了，直接引用就好</li>
</ul>
</li>
</ul>
<pre><code>compass install compass/ellipsis
</code></pre><pre><code>    -     参数：
    -     示例：
</code></pre><pre><code>screen.scss文件:
$use-mozilla-ellipsis-binding: true;
.text-ellipsis {
    @include ellipsis();
}
screen.css文件中:
.text-ellipsis {
  white-space: nowrap;
  overflow: hidden;
  -ms-text-overflow: ellipsis;
  -o-text-overflow: ellipsis;
  text-overflow: ellipsis;
  -moz-binding: url(&#39;xml/ellipsis.xml#ellipsis&#39;);
}
</code></pre><ul>
<li><p><strong>hide-text()</strong></p>
<pre><code>  -     功能：背景图片和标签文本重复时，隐藏标签文本，用图片替换文本内容，这个mixin用来隐藏文字。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.text-hide {
  @include hide-text();
}
screen.css文件中:
.text-hide {
text-indent: -119988px;
overflow: hidden;
text-align: left;
text-transform: capitalize;
}
</code></pre></li>
<li><p><strong>squish-text()</strong></p>
<pre><code>  -     功能：功能同上，字体设置为透明，来隐藏文字。
  -     参数：
  -     示例：
</code></pre><pre><code>screen.scss文件:
.text-hide {
  @include squish-text();
}
screen.css文件中:
.text-hide {
font: 0/0 serif;
text-shadow: none;
color: transparent;
}
</code></pre></li>
<li><p><strong>replace-text()</strong></p>
<pre><code>  -     功能：隐藏文字后，添加背景图片。
  -     参数：第一个参数是图片的url地址（可以使服务器资源的地址也可以是本地图片的地址），第二个和第三个参数是图片的background-position的值。
  -     示例：
</code></pre><pre><code>screen.scss文件:
.bind-img {
  @include replace-text(&quot;http://img3.mukewang.com/5452ffeb0001b82401000100-40-40.jpg&quot;, 50%, .50%);
}
screen.css文件中:
.bind-img {
text-indent: -119988px;
overflow: hidden;
text-align: left;
text-transform: capitalize;
background-image: url(http://img3.mukewang.com/5452ffeb0001b82401000100-40-40.jpg);
background-repeat: no-repeat;
background-position: 50% 0.5%;
}
</code></pre></li>
<li><p><strong>replace-text-with-dimensions()</strong></p>
<pre><code>  -     功能：功能同上，但是会自动隐藏超出容器的多余图片的边框。
  -     参数：第一个参数是图片的url地址（可以使服务器资源的地址也可以是本地图片的地址）
  -     示例：
</code></pre><pre><code>screen.scss文件:
.bind-img {
  @include replace-text-with-dimensions(image-url(&#39;1503616769997479025.jpg&#39;));
}
screen.css文件中:
.bind-img {
text-indent: -119988px;
overflow: hidden;
text-align: left;
text-transform: capitalize;
background-image: url(http://img3.mukewang.com/5452ffeb0001b82401000100-40-40.jpg);
background-repeat: no-repeat;
background-position: 50% 0.5%;
}
</code></pre></li>
</ul>
<h3 id="vertical-rythm子模块"><a href="#vertical-rythm子模块" class="headerlink" title="vertical rythm子模块"></a>vertical rythm子模块</h3><p>修饰文本的垂直韵律。修饰文本行与行之间的样式。<br><em>这个功能不是很长用到，如果做页面大段文本布局的童鞋可以深入理解一下，请入doc <a href="http://compass-style.org/reference/compass/typography/" target="_blank" rel="noopener">api</a></em></p>
<h2 id="helpers模块"><a href="#helpers模块" class="headerlink" title="helpers模块"></a>helpers模块</h2><p>helpers模块是用来提供许多工具function的内部模块。<br><strong>helpers模块中有很多不适很常用的function，这里不多讲，如果有需要的童鞋请进入doc <a href="http://compass-style.org/reference/compass/typography/" target="_blank" rel="noopener">api</a></strong><br><strong>这里只介绍常用的功能</strong><br><strong>安装</strong>：</p>
<pre><code>compass install helpers
</code></pre><p><strong>引入</strong>：</p>
<pre><code>@import &#39;compass/helpers&#39;;
</code></pre><h3 id="inline-image"><a href="#inline-image" class="headerlink" title="inline-image()"></a>inline-image()</h3><pre><code>    -     功能：将图片base64编码压缩。
    -     参数：图片本地地址
    -     示例：
</code></pre><pre><code>screen.scss文件:
.analyze-logo {    
    background-image: inline-image(&#39;1503616769997479025.jpg&#39;);
}
</code></pre><p><em>screen.css</em>文件中:<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fkdgggqdmxj30zk0ewn0k.jpg" alt=""><br><strong>这种方法会很消耗内存，在项目中不适很常用到，compass的另一个比较常用的模块–精灵合图绘很适合这样的场景，大力推荐！</strong></p>
<h3 id="image-url"><a href="#image-url" class="headerlink" title="image-url()"></a>image-url()</h3><pre><code>    -     功能：直接使用文件的名称来代替文件的本地路径，compass会直接根据config.rb文件中配置来寻路，并且可以给生成css文件中图片地址加上cache-buster（时间戳和版本号，通常在图片路径中问号的后面。图片每次更新都会更改这个值。会造成大量的缓存垃圾。）
    -     参数：图片本地地址
    -     注意：这里的参数直接使用了图片的文件名称，相对路径图片的引用自动根据图片改变而改变,URL后面的cache会据config中的httppath配置项去自动加上http域名,config文件中的relative-assets配置项来配置是否使用相对路径来引用资源文件。
</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fkdgorxruoj30ma07eq3c.jpg" alt=""></p>
<pre><code>    -     示例：
</code></pre><pre><code>screen.scss文件:
.analyze-logo {
    background-image: image-url(&#39;1503616769997479025.jpg&#39;);
}
screen.css文件中:
.analyze-logo {
  background-image: url(&#39;../images/1503616769997479025.jpg?1506223791&#39;);
}
</code></pre><p><strong>功能类似的还有stylesheet-url和font-url用来指向css目录和font目录，可以查询doc api</strong></p>
<h3 id="font-files"><a href="#font-files" class="headerlink" title="font-files()"></a>font-files()</h3><pre><code>    -     功能：在项目目录中寻路font字体文件，并加上cache-buster
    -     参数：font字体文件的文件名列表
    -     注意：**在config.rb文件中配置font字体文件的路径。**
</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fkdh3hrs8kj309u0drjrq.jpg" alt=""></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fkdgorxruoj30ma07eq3c.jpg" alt=""></p>
<pre><code>    -     示例：
</code></pre><pre><code>screen.scss文件:
@debug font-files(&quot;fontawesome-webfont.eot&quot;, &quot;fontawesome-webfont.ttf&quot;, &quot;fontawesome-webfont.svg&quot;, &quot;fontawesome-webfont.woff&quot;, &quot;FontAwesome.otf&quot;);
</code></pre><p>命令行中：<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fkdgzlxvuaj313h046t9h.jpg" alt=""></p>
<h3 id="font-face"><a href="#font-face" class="headerlink" title="font-face()"></a>font-face()</h3><pre><code>    -     功能：相比于font-url，font-face会额外根据字体文件帮我们生成对应的format的值
    -     参数：字体文件的url，可以和font-files配合
    -     示例：
</code></pre><pre><code>screen.scss文件:
@include font-face(&quot;FontAwesome&quot;,
font-files(&quot;fontawesome-webfont.eot&quot;, &quot;fontawesome-webfont.ttf&quot;, &quot;fontawesome-webfont.svg&quot;, &quot;fontawesome-webfont.woff&quot;, &quot;FontAwesome.otf&quot;));
screen.css文件中:
@font-face {
  font-family: &quot;FontAwesome&quot;;
  src: url(&#39;../fonts/fontawesome-webfont.eot?1478142484&#39;) format(&#39;embedded-opentype&#39;), url(&#39;../fonts/fontawesome-webfont.ttf?1478142484&#39;) format(&#39;truetype&#39;), url(&#39;../fonts/fontawesome-webfont.svg?1478142484&#39;) format(&#39;svg&#39;), url(&#39;../fonts/fontawesome-webfont.woff?1478142484&#39;) format(&#39;woff&#39;), url(&#39;../fonts/FontAwesome.otf?1478142484&#39;) format(&#39;opentype&#39;);
}
</code></pre><p>命令行中：<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fkdgzlxvuaj313h046t9h.jpg" alt="3123"></p>
<h3 id="append-selector"><a href="#append-selector" class="headerlink" title="append-selector()"></a>append-selector()</h3><pre><code>    -     功能：将选择器嵌套起来
    -     参数： 将第二个选择弃嵌套到第一个参数的选择器中
    -     注意：**在选择器里面要引用sass的变量需要加上#{}sass的变量包裹器**
    -     示例：
</code></pre><pre><code>screen.scss文件:
#{append-selector(&#39;p, span, div&#39;, &#39;.bar&#39;)} {
    color: #000;
}
screen.css文件中:
p.bar, span.bar, div.bar {
  color: #000;
}
</code></pre><h2 id="utilities模块"><a href="#utilities模块" class="headerlink" title="utilities模块"></a>utilities模块</h2><p>辅助工具类🔧的模块。与helpers模块不同的是，utilities模块都是mixin。<br><em>引入：</em></p>
<pre><code>@import &#39;compass/utilities&#39;;
</code></pre><p>utilities模块又分为以下5个子模块：</p>
<ul>
<li>color</li>
<li>generak</li>
<li>print</li>
<li>tables</li>
<li><strong>sprites</strong>（精灵图合图相关工具的集合,<strong>这个功能模块是使用compass的重中之重！</strong>详见我的另一篇博客）</li>
</ul>
<h3 id="color子模块"><a href="#color子模块" class="headerlink" title="color子模块"></a>color子模块</h3><p>颜色相关的模块。</p>
<ul>
<li><strong>brightness()</strong><pre><code>  -     功能：返回相关颜色的亮度值，计算hsl的亮度值（l）
  -     参数：色值
</code></pre></li>
</ul>
<h3 id="print子模块"><a href="#print子模块" class="headerlink" title="print子模块"></a>print子模块</h3><p>打印场景下相关功能的模块。这个场景很少见，估计是打印页面相关的样式。</p>
<ul>
<li><strong>print-utilities();</strong><pre><code>  -     功能：适配打印页面。产生打印页面才显示的样式。
  -     参数：media文件，默认print.
  -     注意：**需要print.scss中做适配**
</code></pre><ul>
<li>引入    ：</li>
</ul>
</li>
</ul>
<pre><code>index.html文件中：
&lt;link href=&quot;stylesheets/print.css&quot; media=&quot;print&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;
</code></pre><pre><code>-     示例
</code></pre><pre><code>print.scss文件中：
@import &quot;compass/utilities/print&quot;;

@include print-utilities();
screen.scss文件:
@include print-utilities(screen);
screen.css文件中:
.print-only {
  display: none;
}
</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fkdhvt5ihdj31240lemzn.jpg" alt="print.css文件"></p>
<h3 id="tables子模块"><a href="#tables子模块" class="headerlink" title="tables子模块"></a>tables子模块</h3><p>table样式的相关样式集合。<br><em>用一个实例来说明这些mixin</em><br><strong>需要在index.html文件中引入相关格式的html代码：</strong></p>
<pre><code>index.html文件中：
&lt;div class=&#39;example&#39;&gt;
    &lt;table class=&quot;good-price&quot; cellspacing=&#39;0&#39;&gt;
        &lt;thead&gt;
            &lt;tr class=&#39;odd&#39;&gt;
                &lt;th&gt;Title&lt;/th&gt;
                &lt;th&gt;One&lt;/th&gt;
                &lt;th&gt;Two&lt;/th&gt;
                &lt;th&gt;Three&lt;/th&gt;
                &lt;th&gt;Four&lt;/th&gt;
                &lt;th&gt;Row Total&lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            &lt;tr class=&#39;even&#39;&gt;
                &lt;th&gt;Single&lt;/th&gt;
                &lt;td class=&#39;numeric&#39;&gt;1.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;2.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;3.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;4.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;10.0&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr class=&#39;odd&#39;&gt;
                &lt;th&gt;Tens&lt;/th&gt;
                &lt;td class=&#39;numeric&#39;&gt;10.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;20.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;30.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;40.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;100.0&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/tbody&gt;
        &lt;tfoot&gt;
            &lt;tr class=&#39;even&#39;&gt;
                &lt;th&gt;Total&lt;/th&gt;
                &lt;td class=&#39;numeric&#39;&gt;11.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;22.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;33.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;44.0&lt;/td&gt;
                &lt;td class=&#39;numeric&#39;&gt;110.0&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/tfoot&gt;
    &lt;/table&gt;
&lt;/div&gt;
</code></pre><pre><code>screen.scss文件中：
.good-price {
    $table-color: #7a98c6;

    @include outer-table-borders();
    @include inner-table-borders(1px,darken($table-color, 40%)); 
    // th标题居中对齐，普通文本左对齐，竖直右对齐，并填充padding
    @include table-scaffolding(); 
    // 奇偶行不同色，相邻纵列不同色
    @include alternating-rows-and-columns($table-color,adjust-hue($table-color, -120deg),#222222);
}
screen.css文件中：
.good-price {
  border: 2px solid black;
}
.good-price thead th {
  border-bottom: 2px solid black;
}
.good-price tfoot th, .good-price tfoot td {
  border-top: 2px solid black;
}
.good-price th:first-child, .good-price th.first {
  border-right: 2px solid black;
}
.good-price th, .good-price td {
  border-right: 1px solid #233551;
  border-bottom: 1px solid #233551;
  border-left-width: 0;
  border-top-width: 0;
}
.good-price th:last-child, .good-price td:last-child {
  border-right-width: 0;
}
.good-price th.last, .good-price td.last {
  border-right-width: 0;
}
.good-price tbody tr:last-child th, .good-price tbody tr:last-child td, .good-price tfoot tr:last-child th, .good-price tfoot tr:last-child td {
  border-bottom-width: 0;
}
.good-price tbody tr.last th, .good-price tbody tr.last td, .good-price tfoot tr.last th, .good-price tfoot tr.last td {
  border-bottom-width: 0;
}
.good-price th {
  text-align: center;
  font-weight: bold;
}
.good-price td,
.good-price th {
  padding: 2px;
}
.good-price td.numeric,
.good-price th.numeric {
  text-align: right;
}
.good-price th {
  background-color: white;
}
.good-price th.even, .good-price th:nth-child(2n) {
  background-color: #dddddd;
}
.good-price tr.odd td, .good-price tr:nth-child(2n+1) td {
  background-color: #98c67a;
}
.good-price tr.odd td.even, .good-price tr.odd td:nth-child(2n), .good-price tr:nth-child(2n+1) td.even, .good-price tr:nth-child(2n+1) td:nth-child(2n) {
  background-color: #76a458;
}
.good-price tr.even td {
  background-color: #7a98c6;
}
.good-price tr.even td.even, .good-price tr.even td:nth-child(2n) {
  background-color: #5876a4;
}
.good-price tfoot th, .good-price tfoot td {
  background-color: white;
}
.good-price tfoot th.even, .good-price tfoot th:nth-child(2n), .good-price tfoot td.even, .good-price tfoot td:nth-child(2n) {
  background-color: #dddddd;
}
</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fkdic3j8rmj30cp04iq34.jpg" alt="table样式"></p>
<h3 id="general子模块"><a href="#general子模块" class="headerlink" title="general子模块"></a>general子模块</h3><p>一些常见的样式的相关样式集合。</p>
<ul>
<li><p><strong>clearfix()</strong></p>
<pre><code>  -     功能：overflow:hidden的方法清除浮动。
  -     示例
</code></pre><pre><code>screen.scss文件:
.clearfix {
  @include pie-clearfix();
}
screen.css文件中:
.clearfix {
  /*
      子元素超出父元素会overflow: hidden
   */
overflow: hidden;
*zoom: 1;
}
</code></pre></li>
<li><p><strong>pie-clearfix()</strong></p>
<pre><code>  -     功能：伪类的方法清除浮动。
  -     示例
</code></pre><pre><code>screen.scss文件:
.clearfix {
  @include pie-clearfix();
}
screen.css文件中:
.clearfix {
*zoom: 1;
}
.clearfix:after {
content: &quot;&quot;;
display: table;
clear: both;
}
</code></pre></li>
<li><p><strong>float()</strong></p>
<pre><code>  -     功能：根据你在browser support中配置的浏览器环境，兼容ie6浮动布局。
</code></pre><ul>
<li>注意：需要在browser support中配置</li>
</ul>
</li>
</ul>
<pre><code>$browser-minimum-versions: (&quot;ie&quot;: &quot;6&quot;);
</code></pre><pre><code>- 参数：浮动的方向
    -     示例
</code></pre><pre><code>screen.scss文件:
.pull-left {
    @include float(left);
}
screen.css文件中:
.pull-left {
  float: left;
  display: inline;
}
</code></pre><h4 id="hacks子模块"><a href="#hacks子模块" class="headerlink" title="hacks子模块"></a>hacks子模块</h4><p>很多兼容ie的hack集合。</p>
<ul>
<li><p><strong>has-layout()</strong></p>
<pre><code>  -     功能：激活兼容ie属性。
</code></pre><ul>
<li>参数：激活ie的方式，推荐zoom         <ul>
<li>示例<pre><code>screen.scss文件:
.need-has-layout {
@include has-layout();
}
screen.css文件中:
.need-has-layout {
*zoom: 1;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>underscore-hack()</strong></p>
<pre><code>  -     功能：正常情况下属性是某种值，ie下hack成另一种值。
</code></pre><ul>
<li>参数：第一个参数是属性的key，第二个是正常情况下的value，第三个是hack情况下的value        <ul>
<li>示例：<pre><code>screen.scss文件:
.underscore-hack-display {
@include underscore-hack(display,block,inline);
}
screen.css文件中:
.underscore-hack-display {
display: block;
_display: inline;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>min-height()</strong></p>
<pre><code>  -     功能：下划线的方式hack min-height和min-width属性。
</code></pre><ul>
<li>参数：相应的height或者width值<ul>
<li>示例：<pre><code>screen.scss文件:
.test-min-height {
@include min-height(10px);
}
screen.css文件中:
.test-min-height {
min-height: 10px;
height: auto;
_height: 10px;
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="标签云模块"><a href="#标签云模块" class="headerlink" title="标签云模块"></a>标签云模块</h4><p>compass封装了一个简单的标签云功能模块，以一个例子来说明：</p>
<pre><code>screen.scss文件:
.tag-cloud-container {
    @include tag-cloud(24px);
}
screen.css文件中:
.tag-cloud-container {
  font-size: 24px;
  line-height: 28.8px;
}
.tag-cloud-container .xxs, .tag-cloud-container .xs, .tag-cloud-container .s, .tag-cloud-container .l, .tag-cloud-container .xl, .tag-cloud-container .xxl {
  line-height: 28.8px;
}
.tag-cloud-container .xxs {
  font-size: 12px;
}
.tag-cloud-container .xs {
  font-size: 16px;
}
.tag-cloud-container .s {
  font-size: 18px;
}
.tag-cloud-container .l {
  font-size: 32px;
}
.tag-cloud-container .xl {
  font-size: 36px;
}
.tag-cloud-container .xxl {
  font-size: 48px;
}
</code></pre><p><strong>在index.html文件中不同的标签加上不同的类，从而实现一个简单的标签云，效果如下：</strong><br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fkdj3zidjrj316c0qp0uz.jpg" alt="index.html"></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fkdj344tjyj30lp017q2v.jpg" alt="标签云效果demo"></p>
<h2 id="sprites模块"><a href="#sprites模块" class="headerlink" title="sprites模块"></a>sprites模块</h2><p>精灵图合图相关功能集合。可以说是compass在日常工程中的最佳实践，非常实用也非常重要。<br><strong>想象一下设计人员（通常是漂亮的小姐姐们～不好意思责怪人家呀=。=）将sprites图中的一个图标，并且很有可能影响到了其他的图标，开发人员就要吐血地在项目中修改所有被影响的样式代码，这真的是巨痛苦无比呀</strong><br>由于sprites模块很重要，我将它放到了另外一个博客中，以便详细讲解～<a href="http://pancakeawesome.ink/2017/10/10/compass%E9%87%8D%E8%A6%81%E5%8A%9F%E8%83%BD%E4%B9%8B%E7%B2%BE%E7%81%B5%E5%9B%BE%E5%90%88%E5%9B%BE/">传送门</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>compass是一个很好用的前端自动化工具，它给sass插上了一双翅膀，极大地提高了我们的开发效率！<br><strong>这里是我写的一个compass的demo，可以对照着看</strong></p>
]]></content>
      
        <categories>
            
            <category> 前端工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端技术 </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo+githubio+material搭建你的个人博客网站（优化篇）]]></title>
      <url>/hexo+githubio+material%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99(%E4%BC%98%E5%8C%96%E7%AF%87).html</url>
      <content type="html"><![CDATA[<h2 id="网站-SEO-优化—如何让你的博客在搜索结果中排名第一"><a href="#网站-SEO-优化—如何让你的博客在搜索结果中排名第一" class="headerlink" title="网站 SEO 优化—如何让你的博客在搜索结果中排名第一"></a>网站 SEO 优化—如何让你的博客在搜索结果中排名第一</h2><p>关于网站 SEO 这一块我主要参考了这位小姐姐的<a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F590b451a0ce46300588c43a0" target="_blank" rel="noopener">这篇文章</a>,但是有些发现她有些地方写的不是很清楚,自己也在这一块设置时也摸索了半天,所以直接像大家分享一下我的踩坑经验.</p>
<h3 id="让百度收录你的站点"><a href="#让百度收录你的站点" class="headerlink" title="让百度收录你的站点"></a>让百度收录你的站点</h3><p>我们直接在百度中搜索<code>site:你的域名</code>就可以查看百度是否已经收录你的网站,如果没有收录的话,你就要去去登录<a href="https://link.juejin.im?target=http%3A%2F%2Fzhanzhang.baidu.com" target="_blank" rel="noopener">百度站长平台</a>在站点管理中点击添加网站,然后输入你的站点地址, 注意,这里需要输入我们自己购买的域名,不能使用<code>xxx.github.io</code>之类域名.</p>
<p>步骤如下:</p>
<ol>
<li>输入网站: 添加域名时建议是不带上<code>www</code>的前缀</li>
<li>站点属性: 选择自己网站类型</li>
<li><p>验证网站: 验证网站的所有权,这里主要有以下三种</p>
<ul>
<li>文件验证: 文件验证文件存放的位置需要放在source文件夹下,txt 格式的不会被 hexo 预编译,其他格式要在头部加上<code>layout: false</code></li>
<li>HTML 标签验证: 将他给你的代码添加到网站首页的 head 标签内</li>
<li>CNAME 验证: <strong>推荐使用</strong>,将对应的 CNAME 文件放在你的 source 文件夹中即可,只要在其中写上你的域名地址就行;除此之外还会要求你到自己的域名提供商(我的是万网)上添加 CNAME 的解析(会面在国内外分流这一块会与更详细的解析说明);</li>
</ul>
</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2017/7/12/ee30fa072724e1141dfae134f4693f86?imageView2/0/w/1280/h/960" alt=""><br><strong>你需要到你的域名管理商那里更改百度的域名解析如：(以<a href="https://netcn.console.aliyun.com/core/domain/tclist" target="_blank" rel="noopener">万网</a>举例)</strong><br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fk1jiu2w2gj30ou01umx0.jpg" alt=""></p>
<h3 id="生成网站地图-—-sitemap"><a href="#生成网站地图-—-sitemap" class="headerlink" title="生成网站地图 — sitemap"></a>生成网站地图 — sitemap</h3><p> 这里需要我们安装下面两个插件,先执行下面命令</p>
<pre><code> npm i hexo-generator-sitemap hexo-generator-baidu-sitemap -S
</code></pre><p> 再在你的站点配置文件中修改 URL 为你的站点地址<br> <img src="https://ws2.sinaimg.cn/large/006tNc79gy1fjtqfn861bj30mk0953z5.jpg" alt=""></p>
<p> 当你在 <code>hexo g</code> 时,会在<code>public</code>文件夹中生成<code>sitemap.xml</code> 和<code>baidusitemap.xml</code> 两个文件,如果你已经提前将你的 hexo 部署到网上,这是可以直接打开<code>http://yoururl/sitemap.xml</code>和<code>http://yoururl/baidusitemap.xml</code>来查看.(这两者的区别在于 <code>baidusitemap.xml</code>        是百度搜索引擎的专用文件,另一个是通用).</p>
<h3 id="向百度提交链接"><a href="#向百度提交链接" class="headerlink" title="向百度提交链接"></a>向百度提交链接</h3><p><strong>现在百度好像不能抓去github上面的数据了</strong><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fk3qrgy8egj30oy0233yi.jpg" alt=""></p>
<blockquote>
<p>如何选择链接提交方式</p>
<p>   1、主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。</p>
<p>   2、自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。</p>
<p>   3、sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。</p>
<p>  4、手动提交：一次性提交链接给百度，可以使用此种方式。</p>
</blockquote>
<p>这里我推荐大家<strong>使用主动推送</strong>,当你主动推送时,可以缩短百度爬虫发现您站点新链接的时间,使新发布的页面可以在第一时间被百度收录;对于网站的最新原创内容，使用主动推送功能可以快速通知到百度，使内容可以在转发之前被百度发现.</p>
<h4 id="使用主动推送"><a href="#使用主动推送" class="headerlink" title="使用主动推送"></a>使用主动推送</h4><ul>
<li>需要先安装插件<code>npm i hexo-baidu-url-submit -S</code></li>
<li>然后再在站点配置文件中按如下方式新增字段<pre><code>baidu_url_submit:
count: 100 # 提交最新的链接数
host: pancakeawesome.com # 在百度站长平台中注册的域名,虽然官方推荐要带有 www, 但可以不带.
token:  XXXXX # 你的秘钥,每个人都不一样,获取方法在下面
path: baidu_urls.txt # 文本文档的地址,新链接会保存在此文本文档里
</code></pre></li>
<li>然后加入新的 </li>
</ul>
<pre><code>deploydeploy:
     - type:baidu_url_submitter
</code></pre><p><strong>注意</strong>,这里多个 type 的写法应该这么写,前面那个 type 是我推送到 <code>Gitub</code> 与 <code>Coding</code> 的<code>page</code>页面的配置,后面再讲这个.</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fjtqhkscohj30qp0inmyv.jpg" alt=""></p>
<p>密钥的获取位置在<code>网页抓取</code>中的<code>链接提交</code>这一块,如下所示:<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/0995148de59688b95330f5e2c99daa58?imageView2/0/w/1280/h/960" alt=""></p>
<ul>
<li>最后当你执行<code>hexo d</code>时新的连接就会被推送上去.</li>
<li>推送成功时,会有如下终端提示,各种不同的推送反馈字段说明在<a href="https://link.juejin.im?target=http%3A%2F%2Fzhanzhang.baidu.com%2Fcollege%2Fcourseinfo%3Fid%3D267%26amp%3Bpage%3D2%23h2_article_title8" target="_blank" rel="noopener">这里</a>查看,一般来说,推送失败都是地址不相符造成的,我们只需对比<code>baidu_url_submit</code>在<code>public</code>中生成的<code>baidu_urls.txt</code>的地址,与自己填写在<code>host</code>字段中是否一样即可,这里需要注意的是,多加<code>www</code>会导致上传失败(血的教训…)</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fjttndgvr1j30uw0icmzj.jpg" alt=""></p>
<h3 id="让-Google-收录你的网站"><a href="#让-Google-收录你的网站" class="headerlink" title="让 Google 收录你的网站"></a>让 Google 收录你的网站</h3><ul>
<li><p>登录 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.google.com%2Fwebmasters%2F%23%3Fmodal_active%3Dnone" target="_blank" rel="noopener">Google 网络站长</a>,点击<code>添加属性</code>按要求添加你的网站</p>
</li>
<li><p>验证你的网站所有权,我推荐使用 HTML 文件上传的方式,将他给你的html 文件放入 <code>sources</code> 文件夹下,但 html 文件默认会被 hexo 预编译,所以这里,我们要手动设置让 hexo 不要编译该文件,在文件开始添加<code>layout:false</code>即可.<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/d08c34f269cb81e388eeef1e70a5d2bc?imageView2/0/w/1280/h/960" alt=""></p>
</li>
<li><p>添加 sitemap : 进入 Google Search Console - 抓取 - 站点地图,点击「添加/测试站点地图」,输入你的博客网址. 若无报错则站点地图提交成功<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fjtuhe4at2j30xj0c0jrn.jpg" alt="">)</p>
</li>
<li>提交 robots.txt:<blockquote>
<p>robots.txt 是一种存放于网站根目录下的 ASCII 编码的文本文件，它的作用是告诉搜索引擎此网站中哪些内容是可以被爬取的，哪些是禁止爬取的。robots.txt 放在博客目录下的 source 文件夹中，博客生成后在站点目录 /public/ 下。</p>
</blockquote>
</li>
</ul>
<p>我的 robots.txt 文件内容如下：</p>
<pre><code>    User-agent: *
    Allow: /
    Allow: /archives/
    Allow: /categories/
    Allow: /about/
    Disallow: /vendors/
    Disallow: /js/
    Disallow: /css/
    Disallow: /fonts/
    Disallow: /vendors/
    Disallow: /fancybox/
</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fjtuilil2dj30w90dc0tc.jpg" alt="">)</p>
<ul>
<li><em>提交谷歌索引</em><br>在这里我们填上我们需要抓取的url,不填这表示抓取首页，抓取方式可以选择桌面，智能手机等等，自行根据需要选择。填好url之后，点击抓取。然后可能会出现几种情况，如:完成、部分完成、重定向等，自由这三种情况是可以提交的。<br>提交完成后，提交至索引，根据提示操作就可以了，我的提交：<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fjtukpj4edj30x90bw0tg.jpg" alt="">)<h3 id="优化你的-URL"><a href="#优化你的-URL" class="headerlink" title="优化你的 URL"></a>优化你的 URL</h3></li>
</ul>
<blockquote>
<p>这段话参考自<a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F590b451a0ce46300588c43a0" target="_blank" rel="noopener">上面那个小姐姐的文章</a>,写的很好,这里我直接拿来用下<br>seo搜索引擎优化认为，网站的最佳结构是用户<strong>从首页点击三次就可以到达任何一个页面</strong>，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，所以我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下：</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2017/7/12/7f12922620fc0c865bffafd8ce4a2f97?imageView2/0/w/1280/h/960" alt=""></p>
<h2 id="将你的网站同时托管到-Github-和-Coding-上-国内外分流"><a href="#将你的网站同时托管到-Github-和-Coding-上-国内外分流" class="headerlink" title="将你的网站同时托管到 Github 和 Coding 上,国内外分流"></a>将你的网站同时托管到 Github 和 Coding 上,国内外分流</h2><p>Coding 类似于中国的 Github 一样,也提供了 Pages 服务,但对我们而言,跟 Github 不同的地方在于免费用户能拥有五个私人仓库,这个可以用来部署自己的一些私人代码,而且配合 Github 可以做到国内IP 访问 Coding 的 Pages 页面,国外访问 Github 上面的 Pages 页面.大致配置过程如下:</p>
<ul>
<li>在 Coding 上创建仓库: 这里注意要去创建一个公有的仓库,私有仓库是没有 pages 服务的.</li>
<li>将你的公钥传上去.这里网上关于自己公钥的相关教程很多,我就不多叙述了.</li>
<li><p>修改 hexo 的站点配置文件中的 deploy 选项,配置你的 Github 与 Coding 仓库,需要注意的是其中 Github 的仓库名<code>xxx.github.io</code>必须跟你的 Github 名称一样:<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/395865e456887d0a62adc65769fdb73b?imageView2/0/w/1280/h/960" alt=""><br>每次上传的时候都需要输入你的账号密码之类的信息,可以直接将你账号密码写在上传地址中,这样就不用每次更新都输入你的账号密码了例如你的账号为<span class="hljs-selector-pseudo">:crown3,密码为 BBB;<br>那你的repo填写为下面这样即可</span></p>
<pre><code>github: https://crown3:BBB@github.com/crown3/crown3.github.io.git
coding: https://crown3:BBB@git.coding.net/crown3/仓库名.git
</code></pre></li>
<li><p>设置 coding 的 pages 服务:在pages页面将部署来源选择为master分支，然后将自定义域名填写自己购买的域名就可以了</p>
</li>
<li>设置域名解析: 在你的域名提供商那里修改你的域名解析就行,例如我的是万网,按照下图所示,添加这五条解析即可做到国内外访问分流.<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/f1bbfa32ee6b74ef8d1d3e87bd25083c?imageView2/0/w/1280/h/960" alt=""></li>
</ul>
<h2 id="将自己的代码托管到私有仓库"><a href="#将自己的代码托管到私有仓库" class="headerlink" title="将自己的代码托管到私有仓库"></a>将自己的代码托管到私有仓库</h2><p>当我们将自己的代码托管到<strong>私有仓库</strong>后,就可以在任何一台电脑上将你的 hexo 部署代码下载下来进行编辑,而且可以将你的一些个人密钥什么的直接推送到你的代码仓库去,这样更便利于我们的管理维护.</p>
<p>在上文我已经说过了,国内 Coding 的免费用户可以创建五个私有仓库,这是可以直接拿来使用,但是如果你对国内的私有仓库安全性存有怀疑,也可以去使用国外专门做私有仓库托管的<a href="https://link.juejin.im?target=https%3A%2F%2Fbitbucket.org%2F" target="_blank" rel="noopener">bitbucket</a>,在这里私有仓库是可以免费使用的.具体上传之类的使用方法我就不再细述了,都是基于 git 做的代码管理,使用方法都大同小异.</p>
<h2 id="使用-Gulp-压缩你的代码"><a href="#使用-Gulp-压缩你的代码" class="headerlink" title="使用 Gulp 压缩你的代码"></a>使用 Gulp 压缩你的代码</h2><p>代码压缩可以明显减小我们的文件大小,加载速度,这里我会直接提供我使用的脚本,大家可以直接拿来使用,有需要了解相关知识的可以去<code>gulp</code>官网去做相关了解.</p>
<ul>
<li><p>先安装<code>Gulp</code>以及我们需要使用的一系列插件:</p>
<pre><code>npm i gulp gulp-clean-css gulp-htmlclean gulp-htmlmin gulp-imagemin gulp-uglify del run-sequence -S
</code></pre></li>
<li><p>接着创建<code>gulpfile.js</code>: 在你的博客根目录(跟你站点配置文件同一层)下创建<code>gulpfile.js</code>这个文件,然后在里面填入如下脚本即可,里面有相关注释,感兴趣的可以去了解一下.</p>
</li>
</ul>
<pre><code>var gulp = require(&#39;gulp&#39;);
    var minifycss = require(&#39;gulp-clean-css&#39;);
    var uglify = require(&#39;gulp-uglify&#39;);
    var htmlmin = require(&#39;gulp-htmlmin&#39;);
    var htmlclean = require(&#39;gulp-htmlclean&#39;);
    var imagemin = require(&#39;gulp-imagemin&#39;);
    var del = require(&#39;del&#39;);
    var runSequence = require(&#39;run-sequence&#39;);
    var Hexo = require(&#39;hexo&#39;);
    // 清除public文件夹
    gulp.task(&#39;clean&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return del([&#39;public/**/*&#39;]);
    });
    // 利用Hexo API 来生成博客内容， 效果和在命令行运行： hexo g 一样
    // generate html with &#39;hexo generate&#39;
    var hexo = new Hexo(process.cwd(), {});
    gulp.task(&#39;generate&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;(cb) {
        hexo.init().then(&lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
            return hexo.call(&#39;generate&#39;, {
                watch: false
            });
        }).then(&lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
            return hexo.exit();
        }).then(&lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
            return cb()
        }).catch(&lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;(err) {
            console.log(err);
            hexo.exit(err);
            return cb(err);
        })
    })
    // 压缩public目录下的所有css
    gulp.task(&#39;minify-css&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return gulp.src(&#39;./public/**/*.css&#39;)
            .pipe(minifycss({
                compatibility: &#39;ie8&#39;
            }))
            .pipe(gulp.dest(&#39;./public&#39;));
    });
    // 压缩public目录下的所有html
    gulp.task(&#39;minify-html&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return gulp.src(&#39;./public/**/*.html&#39;)
            .pipe(htmlclean())
            .pipe(htmlmin({
                removeComments: true,
                minifyJS: true,
                minifyCSS: true,
                minifyURLs: true,
            }))
            .pipe(gulp.dest(&#39;./public&#39;))
    });
    // 压缩public目录下的所有js
    gulp.task(&#39;minify-js&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return gulp.src(&#39;./public/**/*.js&#39;)
            .pipe(uglify())
            .pipe(gulp.dest(&#39;./public&#39;));
    });
    // 压缩public目录下的所有img： 这个采用默认配置
    gulp.task(&#39;minify-img&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return gulp.src(&#39;./public/images/**/*.*&#39;)
            .pipe(imagemin())
            .pipe(gulp.dest(&#39;./public/images&#39;))
    })
    // 同上，压缩图片，这里采用了： 最大化压缩效果。
    gulp.task(&#39;minify-img-aggressive&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;() {
        return gulp.src(&#39;./public/images/**/*.*&#39;)
            .pipe(imagemin(
            [imagemin.gifsicle({&#39;optimizationLevel&#39;: &lt;span class=&quot;hljs-number&quot;&gt;3}), 
            imagemin.jpegtran({&#39;progressive&#39;: true}), 
            imagemin.optipng({&#39;optimizationLevel&#39;: &lt;span class=&quot;hljs-number&quot;&gt;7}), 
            imagemin.svgo()],
            {&#39;verbose&#39;: true}))
            .pipe(gulp.dest(&#39;./public/images&#39;))
    })
    // 用run-sequence并发执行，同时处理html，css，js，img
    gulp.task(&#39;compress&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;(cb) {
        runSequence([&#39;minify-html&#39;, &#39;minify-css&#39;, &#39;minify-js&#39;, &#39;minify-img-aggressive&#39;], cb);
    });
    // 执行顺序： 清除public目录 -&amp;gt; 产生原始博客内容 -&amp;gt; 执行压缩混淆
    gulp.task(&#39;build&#39;, &lt;span class=&quot;hljs-function&quot;&gt;function&lt;span class=&quot;hljs-params&quot;&gt;(cb) {
        runSequence(&#39;clean&#39;, &#39;generate&#39;, &#39;compress&#39;, cb)
    });
    gulp.task(&#39;default&#39;, [&#39;build&#39;])
</code></pre><ul>
<li>执行<code>gulp</code>: 在命令行中输入<code>gulp build</code>即可<br>这里要说明的是,这里利用Hexo API 来生成博客内容,效果和在命令行运行： <code>hexo g</code> 一样,所以当我们在执行<code>gulp build</code>时,会根据我们的相关博文来直接生成相应的<code>public</code>文件夹中的内容,并直接进行压缩,接下来我们运行<code>hexo d</code>上传上去的代码会是已经进行相应压缩了的.</li>
</ul>
<h2 id="使用七牛图床来处理我们的图片"><a href="#使用七牛图床来处理我们的图片" class="headerlink" title="使用七牛图床来处理我们的图片"></a>使用七牛图床来处理我们的图片</h2><p><strong>推荐使用<code>智图+ipic+七牛</code>来管理博客的图床</strong></p>
<p>选中一张图片 =&gt; 用智图进行相应压缩处理 =&gt; 使用 iPic 快捷键一键上传到七牛云(cmd + u) =&gt; 在文章中直接粘贴已经复制到剪贴板的图片地址</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/7/12/1bdc660c52243514a6d7a96a5f7624ae?imageView2/0/w/1280/h/960" alt=""></p>
<p><em>选择智图来压缩是因为<code>iPic</code>这个软件自带的上传压缩效果没有智图的好</em><br><strong>具体使用七牛的方法：</strong></p>
<h3 id="增加七牛图床"><a href="#增加七牛图床" class="headerlink" title="增加七牛图床"></a>增加七牛图床</h3><p>增加七牛图床就是要将我们电脑上的图片上传至七牛，然后获得外链，在我们使用md写博客的时候直接插入外链，更方便的是可以直接获取带水印、压缩、剪裁过后的图片~</p>
<h4 id="注册七牛"><a href="#注册七牛" class="headerlink" title="注册七牛"></a>注册七牛</h4><p>万年不变的第一步，注册。官网：<a href="https://link.juejin.im?target=https%3A%2F%2Fportal.qiniu.com%2Fsignup%3Fcode%3D3lnd6wvc103f6" target="_blank" rel="noopener">七牛云</a></p>
<h4 id="上传资源"><a href="#上传资源" class="headerlink" title="上传资源"></a>上传资源</h4><p>在登录成功之后，点击对象存储</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/5/5/1c58d10d6b4022bb745c679f6e34a447?imageView2/0/w/1280/h/960" alt="上传资源至七牛"><br>上传完图片之后，关闭上传页面，可以在图片列表的最后面有一个眼睛的icon，点击之后就会在右下角找到该图片的外链，在用md写博客的时候就可以直接加入外链就好~也可以对上传的源文件进行重命名，因为大部分我上传到七牛上的图片都是相册中使用的，所以我将源文件的名字都改成统一的形式，在引用的时候只需要修改最后的数字就可以~<br><img src="https://user-gold-cdn.xitu.io/2017/5/5/e748be6d8cd158b3529748beae2082ad?imageView2/0/w/1280/h/960" alt="上传资源至七牛"></p>
<h4 id="添加水印"><a href="#添加水印" class="headerlink" title="添加水印"></a>添加水印</h4><p>使用七牛图床最棒的地方在于可以对图片进行处理，我就只拿添加水印来举例。<br>七牛可以对上传的图片添加图片样式</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/5/5/32770706a230e5f50687ce8f301a28ff?imageView2/0/w/1280/h/960" alt="增加图片样式"><br>增加图片样式就是对图片进行处理，这里的处理方式有很多，比如缩放方式、裁剪、增加图片水印、设置输出格式。<br><img src="https://user-gold-cdn.xitu.io/2017/5/5/54bd4a7d42e7179e2ced2db70325b638?imageView2/0/w/1280/h/960" alt="增加图片样式"><br>在设置了图片样式之后我们要怎么使用呢，开始我也是一脸懵逼的，不知道怎么使用，百度之后才知道，你直接访问获取的外链就是你上传的原图，在外链的后面加上连接符和你的样式名称访问的就是经过处理后的图片，有没有很赞~既可以访问到你的原图片，也可以访问到经过处理后的图片，只不过是连接不同，还可以给一个图片增加多个样式访问，就不需要我们一张一张对图片进行处理了~简直不能太赞~(～￣▽￣)～比如:我的原图地址是：<a href="https://link.juejin.im?target=http%3A%2F%2Foova2i5xh.bkt.clouddn.com%2FIMG49.jpg" target="_blank" rel="noopener">oova2i5xh.bkt.clouddn.com/IMG49.jpg</a> ，可以看到是一张很大的不带水印的图片<br><img src="https://user-gold-cdn.xitu.io/2017/5/5/7304dbe593b950f42197dbc5e364cdcb?imageView2/0/w/1280/h/960" alt="这里写图片描述"><br>然后在该地址后加上我设置的连接符,”-“和我的样式名称：<a href="https://link.juejin.im?target=http%3A%2F%2Foova2i5xh.bkt.clouddn.com%2FIMG49.jpg-cherryblogImg" target="_blank" rel="noopener">oova2i5xh.bkt.clouddn.com/IMG49.jpg-c…</a> ，就可以看到是一张带水印的小图，我进行了缩放和加水印<br><img src="https://user-gold-cdn.xitu.io/2017/5/5/0f6012ba8e1ee3bf84eb53a9f6793ffa?imageView2/0/w/1280/h/960" alt="这里写图片描述"></p>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo+githubio+material搭建你的个人博客网站（主题篇）]]></title>
      <url>/hexo+githubio+material%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99(%E4%B8%BB%E9%A2%98%E7%AF%87).html</url>
      <content type="html"><![CDATA[<h1 id="Hexo博客搭建详细教程-从搭建-SEO-国内外分流到部署"><a href="#Hexo博客搭建详细教程-从搭建-SEO-国内外分流到部署" class="headerlink" title="Hexo博客搭建详细教程 : 从搭建 , SEO , 国内外分流到部署"></a>Hexo博客搭建详细教程 : 从搭建 , SEO , 国内外分流到部署</h1><blockquote>
<p>本文主要包括以下内容:</p>
<ul>
<li>Hexo 博客搭建</li>
<li>Hexo 主题选择以及应用</li>
<li>关于 Hexo Meterial 主题的相关配置</li>
<li>网站 SEO 优化</li>
<li>将你的网站同时托管到 Github 和 Coding 上,国内外分流</li>
<li>将自己的代码托管到私有仓库</li>
<li>使用 Gulp 来压缩你的代码</li>
<li>如何简单高效地使用七牛图床</li>
</ul>
<p>主题这里我选择的是 Hexo Meterial 主题( Github Hexo 主题中 star 数排第三,前两名分别是 next 和 yilia).</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="为什么写这篇文章"><a href="#为什么写这篇文章" class="headerlink" title="为什么写这篇文章?"></a>为什么写这篇文章?</h3><p>我发现网上关于 Next 主题的相关配置比较多,但是关于这个 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fviosey%2Fhexo-theme-material" target="_blank" rel="noopener">Meterial</a> 主题的完整配置过程文档却相当难找,但这个主题在我看来,不管是颜值,还是功能来说,都明显不该被埋没在next的大海之中,所以在自己折腾了一整子后,将自己记录的相关过程整理分享给大家,毕竟这个主题颜值辣么高,功能辣么强……(除了主题不通之外,其他相关配置都是可以拿来参考的,甚至直接拿来用的,所以其他主题的童靴先不要逃…)</p>
</blockquote>
<p><a href="http://pancakeawesome.ink/">Demo演示</a></p>
<h2 id="Hexo-博客搭建"><a href="#Hexo-博客搭建" class="headerlink" title="Hexo 博客搭建"></a>Hexo 博客搭建</h2><h3 id="Hexo-安装环境"><a href="#Hexo-安装环境" class="headerlink" title="Hexo 安装环境"></a>Hexo 安装环境</h3><p>Hexo 是基于<code>Node.js</code>,所以不管是 mac 还是 win 都需要提前安装好<code>Node.js</code>以及<code>NPM</code>才能进行下一步,这里关于 Node 与 NPM 的安装我就不在这里多说了,请大家自行 Google 解决.</p>
<h3 id="Hexo-的相关安装搭建"><a href="#Hexo-的相关安装搭建" class="headerlink" title="Hexo 的相关安装搭建"></a>Hexo 的相关安装搭建</h3><h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>首先我们要在命令行里直接执行如下命令,全局安装<code>Hexo</code>.</p>
<pre><code>npm install -g hexo
</code></pre><h4 id="初始化你的-Hexo-博客"><a href="#初始化你的-Hexo-博客" class="headerlink" title="初始化你的 Hexo 博客"></a>初始化你的 Hexo 博客</h4><p>然后需要你去找到一个你想要安装的文件夹,在里面执行如下命令来进行安装初始化你的hexo博客.</p>
<pre><code>hexo init hexo_blog   //在当前目录下新建一个叫 `hexo_blog`文件夹并在其中初始化生成 `Hexo `相关代码
cd `hexo_blog`//进入到 `hexo_blog `这个文件夹中并安装相关依赖包
npm install
</code></pre><p>生成的相关目录如下:</p>
<pre><code>-- hexo_blog
    ├── node_modules//NPM安装依赖包
    ├── scaffolds
    ├── source
    |   └── _posts//新建文件存放位置
    ├── themes//相关主题存放位置
    ├── _config.yml//Hexo 博客站点配置文件
    ├── .gitignore
    ├── db.json
    └── package.json
</code></pre><p>这里需要下载速度比较慢的童鞋需要注意一下, npm 中默认使用的是国外的 npm 源,这意味着你在你执行 npm install 相关命令式会有比较高的延迟,甚至部分包下载不下来的情况,所以这里推荐国内用户用<code>nrm</code>切换成淘宝的镜像源来使用(但还是会有部分依赖包必须从国外下载,所以还是推荐自己去学会科学上网),使用方法如下:</p>
<pre><code>npm i nrm -g//全局安装 nrm 这个插件
nrm test //测试哪个镜像源跟自己的延迟比较低,我的是 taobao
nrm use taobao //切换到taobao 这个镜像源上
npm i ...//之后继续使用 npm 来安装相关依赖就行
</code></pre><p><img src="https://user-gold-cdn.xitu.io/2017/7/12/b363cb55a2f09865dcb715e2cf4e2860?imageView2/0/w/1280/h/960" alt=""></p>
<p>之后你就可以在当前文件夹下执行<code>hexo server --debug</code>来让你的博客进入<code>debug</code>模式,一般默认是在<code>4000</code>这个端口下执行,直接在浏览器输入<code>localhost:4000</code>就可以查看自己本地生成的<code>Hexo</code>博客了.</p>
<pre><code>在`debug`模式下,你可以直接对你的博客进行相关修改,刷新网页来查看效果.
</code></pre><h2 id="Hexo-主题选择以及应用"><a href="#Hexo-主题选择以及应用" class="headerlink" title="Hexo 主题选择以及应用"></a>Hexo 主题选择以及应用</h2><p>现在网上关于 <code>Hexo</code> 的主题一搜一大把,这里推荐大家在选择主题时可以去选择一些关注度比较高的主题,这种主题一般相应的配套使用插件和文档比较丰富,使用起来也比较方便,主题选择的话可以去一些<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题库</a>中查找,也可以直接去<code>Github</code>中搜索<code>hexo theme</code>等关键字来查找— <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fsearch%3Fo%3Ddesc%26amp%3Bq%3Dhexo%2Btheme%26amp%3Bs%3Dstars%26amp%3Btype%3DRepositories%26amp%3Butf8%3D%25E2%259C%2593" target="_blank" rel="noopener">点击查看搜索结果</a>.</p>
<pre><code>这里我们要注意的一点是在 Hexo 中,通常有两份配置文件,一个是站点根目录下(例如我的就是`.../hexo_blog/_config.yml`)的 `_config.yml`;另外一个是主题目录(例如我的就是`.../hexo_blog/themes/material/_config.yml`)下的 `_config.yml`.为了描述方便,在以下说明中,将前者称为 `站点配置文件`,后者称为`主题配置文件`.
</code></pre><ol>
<li>去找到你喜欢的主题,然后将其下载下来存放到你的 Themes 这个文件夹下,可以使用<code>NPM</code>,<code>Git</code>等一系列方法下载下来,一般主题的文档里面都会有其下载方法的介绍,例如我使用的 <code>Material</code> 主题的<a href="https://material.viosey.com/start/#install-material" target="_blank" rel="noopener">下载方法</a>.</li>
<li>复制完成后,修改主题文件夹名称,将其修改为 <code>AAA</code>(你的主题名称),然后打开<code>站点配置文件</code>,找到<code>theme</code>字段,并将其值更改为<code>AAA</code>.</li>
<li>运行<code>hexo s --debug</code> 并访问<code>http://localhost:4000</code>即可查看你的主题修改效果.<pre><code>文件夹名称可自由修改,并不是唯一的,只需要 `theme` 字段与之对应即可.这里有一点必须要注意,**配置项之间必须要有一个空格**,例如`theme:material`这种情况是会报错的,要向下面这样.
</code></pre><img src="https://user-gold-cdn.xitu.io/2017/7/12/536f099650be34b06798a19f8ea24cb1?imageView2/0/w/1280/h/960" alt=""></li>
</ol>
<h2 id="关于-Hexo-Material-主题的相关配置"><a href="#关于-Hexo-Material-主题的相关配置" class="headerlink" title="关于 Hexo Material 主题的相关配置"></a>关于 Hexo Material 主题的相关配置</h2><p>这里我会将分享我关于<code>Material</code>配置时的一些踩坑经验,使用其他主题的童鞋可以直接跳过这一段,去看后面的其他优化配置.</p>
<p><code>Material</code>的相关配置文档可以直接查看<a href="https://link.juejin.im?target=https%3A%2F%2Fmaterial.viosey.com%2F" target="_blank" rel="noopener">官网配置文档</a>,但是我在配置的一些过程中发现该网站中的文档部分没有跟上最新发布的版本,例如关于文章评论这一块,并没有网易云跟帖的相关说明,但是在最新的版本中,已经跟新了对网易云跟帖的支持.推荐大家直接去查看其 Github 上面的文档—<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fviosey%2Fmaterial-theme-docs" target="_blank" rel="noopener">material-theme-docs</a>,这里更新的比较及时.</p>
<ul>
<li><code>站点配置文件</code>:<code>.../hexo_blog/_config.yml</code></li>
<li><code>主题配置文件</code>: <code>.../hexo_blog/themes/material/_config.yml</code></li>
</ul>
<h3 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h3><p>这里我主要介绍一下关于博客使用语言的设置,其默认的是英语,我们可以编辑<code>站点配置文件</code>,将<code>language</code>设置成你想要的语言,常用的几种如下:</p>
<ul>
<li>英语: <code>en</code></li>
<li>简体中文: <code>zh-CN</code></li>
<li>繁体中文: <code>zh-TW</code></li>
<li>language: zh-CN</li>
</ul>
<h4 id="代码高亮设置"><a href="#代码高亮设置" class="headerlink" title="代码高亮设置"></a>代码高亮设置</h4><p>这里可以使用 <code>hexo-prism-plugin</code>这个插件来让我们文章中的代码实现高亮，具体文档官方已经写得很详细了,这里我就不再多说,大家直接去参考 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fele828%2Fhexo-prism-plugin" target="_blank" rel="noopener">Hexo-Prism-Plugin 插件文档</a>即可.</p>
<h3 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h3><p>这里我直接贴出我的配置文件,大家可以结合官方文档参考下,但我会在下面一些有可能踩坑的地方做出一些相关注释,大家可以配合着一起看下.</p>
<pre><code># .../hexo_blog/themes/material/_config.yml
---------------------------------------------------------------
# Site Information Settings
#---------------------------------------------------------------

# Head info
head:
    favicon: &quot;/img/favicon_c.png&quot;//网站的 favicon
    high_res_favicon: &quot;/img/favicon_c.png&quot;//高清 favicon
    apple_touch_icon: &quot;/img/favicon_c.png&quot;  //IOS 主屏按钮图标
    keywords: 前端,全栈,Web,自学编程,学习分享  //网站关键词,文章的关键字会结合你对文章打上的相应标签来一起显示
    site_verification:  //向搜索引擎验证你对站点的所有权,后面会专门做这方面的 SEO
        google:
        baidu:

    # Enable generate structured-data as JSON+LD for SEO or not.
    #        Set as &#39;false&#39; if it cause some wrong when `hexo g`.
    structured_data: true  //用于改善搜索引擎对你网站的 SEO, 建议开启

# Jump Links Settings
url:
    rss:  //设置生成的 rss 或 atom url
    daily_pic: &quot;#&quot; //设置 daily_pic 模块 点击时跳转的 url
    logo: &quot;#&quot; //设置 logo 点击时跳转的 url

# ---------------------------------------------------------------
# Style Settings
# ---------------------------------------------------------------

# Shemes  //主题选择设置,现在只有默认的 Paradox 和至简模式的 Isolation,去掉对应的 # 号就可使用
scheme: Paradox
#scheme: Isolation

# UI &amp;amp; UX: slogan, color, effect
uiux:
    slogan: &quot;XXXXXXXXXXX&quot;
    theme_color: &quot;#607D8B&quot;
    theme_sub_color: &quot;#00838F&quot;
    hyperlink_color: &quot;#00838F&quot;
    button_color: &quot;#757575&quot;
    android_chrome_color: &quot;#607D8B&quot;
    nprogress_color: &quot;#29d&quot;
    nprogress_buffer: &quot;800&quot;
</code></pre><h4 id="slogan-—-网站标语"><a href="#slogan-—-网站标语" class="headerlink" title="slogan — 网站标语"></a>slogan — 网站标语</h4><p><code>slogan</code>: 显示在<code>blog_info</code>模块中的标语,我们可以将其可以设置成单行或者多行,支持 HTML 标签.</p>
<ul>
<li>单行格式: <code>slogan: &quot;我爱吃土豆&quot;</code></li>
<li>多行格式:(注意缩进)</li>
</ul>
<pre><code>    slogan: 
        - &quot;我爱吃土豆&quot;
        - &quot;我爱吃番茄&quot;
</code></pre><p>我继续接上面开始说明 <code>.../hexo_blog/themes/material/_config.yml</code>中的相关代码.</p>
<pre><code># JS Effect Switches --- 用来控制 Material 主题中自带的多种 js 特性
js_effect:
    fade: true
    smoothscroll: false
# Reading experience --- 首页文章输出摘要的字符长度
reading:
    entry_excerpt: 80

# Thumbnail Settings --- 用于设置文章缩略图相关
thumbnail:
    purecolor:
    random_amount: 19

# Background Settings
# bing available parameter:
#     new | color= | type=
#         color available value: black, blue, brown, green, multi, orange, pink, purple, red, white, yellow
#         type available value: A (animal), C (culture), N (nature), S (space), T (travel)
background:
    purecolor: &quot;#F5F5F5&quot;
    #bgimg: &quot;/img/bg.png&quot;
#   开启bing随机背景
    bing:
        enable: false
        parameter:

# Images Settings
img:
    logo: &quot;/img/logo_c.png&quot;
    avatar: &quot;/img/avatar.JPG&quot;
    daily_pic: &quot;/img/daily_pic.jpg&quot;
    sidebar_header: &quot;/img/sidebar_header.jpg&quot;
    random_thumbnail: &quot;/img/random/material-&quot;
    footer_image:
        #upyun_logo:
            #link: &quot;https://www.upyun.com/&quot;
            #src: &quot;/img/upyun_logo.svg&quot;

# Custom Fonts
#   family: the font-family which will be used in the theme
#   host: uri of fonts host.
#       Available value of &quot;host&quot;: google | baomitu | ustc | custom
fonts:
    family: Roboto, &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;微软雅黑&quot;, Arial, sans-serif
    use: baomitu
    custom_font_host:

# Card Elevation Level
card_elevation: 2

# Code highlight#代码高亮提示
# You can only enable one of them to avoid issues.
# Also you need to disable highlight option in hexo&#39;s _config.yml.
#
#    Prettify
#        theme: # Available value in /source/css/prettify/[theme].min.css
prettify:
    enable: false
    theme: &quot;github-v2&quot;

#    Hanabi (https://github.com/egoist/hanabi)
#        line_number: [true/false] # Show line number for code block
#        includeDefaultColors: [true/false] # Use default hanabi colors
#        customColors: This value accept a string or am array to setting for hanabi colors.
#                    - If `includeDefaultColors` is true, this will append colors to the color pool
#                    - If `includeDefaultColors` is false, this will instead default color pool
hanabi:
    enable: true
    line_number: true
    includeDefaultColors: true
    customColors: 

# Copyright
# Specify the date when the site was setup.
#   For example, if you set it as 2015, then footer will show &#39;© 2015 - 2017&#39;
copyright_since: 2017

# Qrcode for redirect at other device
#   use: choose which method to generate the qrcode for each posts.
#       Available value of &quot;use&quot;: plugin | online
#           - When use &quot;plugin&quot;, you need to install the hexo-helper-qrcode.
#           - When use &quot;online&quot;, the qrcode will be generated by &#39;pan.baidu.com&#39; in China.
qrcode:
    enable: true
    use: plugin

# ---------------------------------------------------------------
# Menu Settings
# ---------------------------------------------------------------

# TOC Button

toc:
#   use: choose whether the line_number of toc will show or not.
#       Available value of &quot;linenumber&quot;: true | false
    linenumber: true

# SNS Menu
sns:
    email: xxx@email.com
    facebook: 
    twitter: 
    googleplus: 
    weibo:
    instagram:
    tumblr:
    github: &quot;https://www.github.com/xxx&quot;
    linkedin: &quot;https://www.linkedin.com/in/xxx/&quot;
    zhihu: &quot;https://www.zhihu.com/people/xxx&quot;
    bilibili:
    telegram:

# SNS Share Switch
sns_share:
    twitter: true
    facebook: true
    googleplus: true
    weibo: true
    linkedin: true
    qq: true
    telegram: false

# Sidebar Customize
sidebar:
    dropdown:
        Email Me:
            link: &quot;mailto:xxx@email.com&quot;
            icon: email
    homepage:
        use: true
        icon: home
        divider: false
    categories:
        use: true
        icon: chrome_reader_mode
        divider: false
    tags:
        use: true
        icon: chrome_reader_mode
        divider: false
    archives:
        use: true
        icon: timeline
        divider: false
    pages:
        标签云:
            link: &quot;/tags&quot;
            icon: cloud_circle
            divider: true
        Timeline:
            link: &quot;/timeline&quot;
            icon: send
            divider: false
        Gallery:
            link: &quot;/gallery&quot;
            icon: photo_library
            divider: false
        About Me:
            link: &quot;/test&quot;
            icon: person_pin
            divider: true
    article_num:
        use: true
        divider: false
    footer:
        divider: false
        theme: false
        support: false
        feedback: false
        material: false
</code></pre><h4 id="code-highlight"><a href="#code-highlight" class="headerlink" title="code highlight"></a>code highlight</h4><p>代码高亮提示，有两种方法，pretify和hanbi，推荐hanbi，彩色的代码提示，很美观<br> <img src="https://ws2.sinaimg.cn/large/006tNc79gy1fjtty8bs0aj30lh07jt8v.jpg" alt=""><br> <img src="https://ws2.sinaimg.cn/large/006tNc79gy1fjttythnfsj30is0e70t7.jpg" alt=""></p>
<h4 id="sidebar-—-侧边栏"><a href="#sidebar-—-侧边栏" class="headerlink" title="sidebar — 侧边栏"></a>sidebar — 侧边栏</h4><p>关于侧边栏的一些相关配置这里有些部分我需要说明一下: 图标选择网站是<a href="https://link.juejin.im?target=https%3A%2F%2Fmaterial.io%2Ficons%2F" target="_blank" rel="noopener">这个</a>(需要翻墙),只需要向下面一样把 icon 对应的配置项换掉就可以切换图标.</p>
<ul>
<li><code>homepage</code>: 主页</li>
<li><code>catagories</code>: 文章分类</li>
<li><code>tags</code>: 文章打上的标签</li>
<li><code>archives</code>: 文章按时间归档</li>
<li><code>pages</code>: 用于设置一些独立页面的<strong>入口</strong>(相关页面需要自己开启,后面后有相关说明),格式如下:</li>
</ul>
<pre><code>链接名称:
    link: &quot;/xxx&quot; //url 地址
    icon: xxxx   // 图标样式
    divider: true/false //是否显示下划线
</code></pre><ul>
<li><code>article_num</code>: 是否显示文章数目统计</li>
<li><code>footer</code>: 配置侧边栏的底部</li>
</ul>
<pre><code># ---------------------------------------------------------------
# Integrated Services
# ---------------------------------------------------------------

# MaterialCDN
# When you set &#39;use&#39; as true, the needed css, js, font file will have a new src.
# The new src will have the base domain you configured in &#39;base&#39;.
materialcdn: 
    use: false 
    base: xxxx

# Comment Systems
# Available value of &quot;use&quot;:
#     disqus | disqus_click | changyan | livere | gitment | valine
# If you want to use gitment,you should get the client_id and client_secret form https://github.com/settings/applications/new
# If you want to use valine,you should get the app_id and app_key form https://leancloud.cn ,more setting please see https://github.com/xCss/Valine
comment:
    use: changyan
    shortname: # duoshuo or disqus shortname
    changyan_appid: xxxxxxx
    changyan_conf: xxxxxxxxxx
    changyan_thread_key_type: path
    livere_data_uid:
    gitment_repo:   # git repo of the hexo
    gitment_owner:  # git repo&#39;s owner
    gitment_client_id:  # github app client id 
    gitment_client_secret :  # github app client secret 
    valine_leancloud_appId: # leancloud application app id
    valine_leancloud_appKey: # leancloud application app key

# Search Systems
# Available value:
#     swiftype | google | local
search:
    use: swiftype
    swiftype_key: xxxxxxxxx

# Analytics Systems
# Available value:
#     baidu | google | cnzz
analytics:
    google_site_id: 
    baidu_site_id: xxxxxxxxxx
    cnzz_site_id:

# Leancloud Views
leancloud:
    enable: false
    app_id: #你的 app_id
    app_key: #你的 app_key
    av_core_mini: &quot;xxxxxxxxxxxxxxxxxxx&quot;

# Busuanzi 不蒜子 Views
busuanzi:
    enable: true
    all_site_uv: true
    post_pv: true
    busuanzi_pure_mini_js: &quot;xxxxxxxxxxxx&quot;

sitemap: 
  path: sitemap.xml
baidusitemap:
  path: baidusitemap.xml
</code></pre><h4 id="集成服务"><a href="#集成服务" class="headerlink" title="集成服务"></a>集成服务</h4><ul>
<li><code>materialcdn</code>: 使用 cdn 来加速 Material 主题需要使用到的一些静态资源,例如 jq 等,但我感觉效果不是很明显,所以没有使用.</li>
<li><p><code>comment</code>: 文章使用的评论系统,内置的目前有四种</p>
<ul>
<li><code>Disqus/Disqus_click</code>: 这两个区别不是很大,后者需要点击才显示评论,但在国内环境下,<strong>加载速度很慢</strong>,不建议使用<ul>
<li><code>changyan</code>: 畅言,推荐使用。唯一缺点就是<em>国内使用需要域名提前备案<strong>,</strong></em>但是备案的话可以随便先填一个正规的（百度搜）等通过审核了，再把域名改成自己的**，是不是很机智～</li>
<li><del><code>163gentie</code>: 网易云跟帖,这个配置起来很简单,不关风格还是功能都比较完善,推荐使用,只需要去注册一下<a href="https://link.juejin.im?target=https%3A%2F%2Fgentie.163.com%2F" target="_blank" rel="noopener">网易云跟帖</a>,然后设置好自己的评论格式,再在<code>gentie_productKey</code>这一栏当中填入你的 key 就行.这个 key 在<code>获取代码</code>中的 <code>WEB 代码</code>当中,如下图:</del><strong>网易跟贴不幸被封了</strong>～<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/177c5e346a95cf5d2118b83cec24cb51?imageView2/0/w/1280/h/960" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><code>search</code>: 推荐使用swiftype，搜索界面比百度谷歌搜索美观，搜索速度很快，且配置简单。<br>¬去swiftype官网注册账号，创建引擎，按照步骤把域名填入，swiftype的爬虫会自动抓取你当前域名下的页面，点击安装搜索，在代码中找到图下这段代码，填入主题配置文件中的swiftype_key中，如下。即可配置成功。<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fjttehawrtj30hb05ct8u.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fjttflowokj30ob04l0sw.jpg" alt=""><br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fjttgg2l7hj309g05j0sp.jpg" alt="效果图"></li>
<li><p><code>analytics</code>: 网站的数据统计与分析,关于这一块推荐使用国内的<code>baidu</code>,百度在这一方面确实做得更加符合国情一些,而且我们还可以绑定微信公众号,随时了解自己网站的相关统计数据.</p>
</li>
<li><p>百度统计: 只需要登录<a href="https://link.juejin.im?target=http%3A%2F%2Ftongji.baidu.com%2F" target="_blank" rel="noopener">百度统计</a>,在站点的代码获取页面复制<code>hm.js?</code>后面那串统计脚本id,填入<code>site_id</code>即可.<br><img src="https://user-gold-cdn.xitu.io/2017/7/12/516434ae0998dc249bf5b2e14dcafc9b?imageView2/0/w/1280/h/960" alt=""></p>
</li>
<li><code>Leancloud</code>/<code>busuanzi</code>: <code>Pv&amp;amp;UV</code>统计,这里我偷懒直接使用的不蒜子的服务,使用不蒜子仅需在<strong>主题配置文件</strong>中将<code>busuanzi: enable:</code> 的值设置为 <code>true</code><ul>
<li>enable: 默认为 false。</li>
<li>all_site_uv: 默认为 false,可统计全站的独立访客人数，即可在 <code>blog_info</code> 模块的 <code>Menu</code> 菜单中看到</li>
<li>post_pv: 默认为 false,统计每篇文章的页面浏览次数，在文章页的 <strong>分享按钮</strong> 菜单中可看到</li>
<li>busuanzi_pure_mini_js: 统计 <code>js</code>,调用不蒜子统计<code>js</code>文件，可将该文件保存至你的 WebServer 或 CDN 中，然后在这里填入 URL</li>
</ul>
</li>
<li><code>sitemap</code>/<code>baidusitemap</code>: 关于搜索引擎优化,会在下面进行说明.<br>以下页面配置好后只是已经存在于你的博客里面了,可以直接输入相应地址查看,但是要想在侧边栏新建快捷入口,<strong>请参考该文<code>侧边栏</code>中<code>pages</code>的相关配置.</strong></li>
</ul>
<h4 id="创建友情链接页面"><a href="#创建友情链接页面" class="headerlink" title="创建友情链接页面"></a>创建<code>友情链接</code>页面</h4><h5 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h5><p>在 hexo 目录下的 <code>source</code> 文件夹中内创建一个名为 <code>links</code>的文件夹。</p>
<p>然后在文件内创建一个名为 <code>index.md</code> 的 Markdown 文件。</p>
<p>最后在 <code>index.md</code> 文件内写入如下内容即可。</p>
<pre><code>    ---
    title: links
    date:
    layout: links
    ---
</code></pre><p>这里要注意的是<code>title</code>(对应的链接名称) 可修改，<code>layout</code> 不可修改。</p>
<h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5><p>只需我们同样在 hexo 目录下的 <code>source</code> 文件夹内创建一个名为 <code>_data</code>（禁止改名）的文件夹。</p>
<p>然后在文件内创建一个名为 <code>links.yml</code> 的文件,在其中添加相关数据即可。</p>
<p>这里单个友情链接的格式为：</p>
<pre><code>    Name:
        link: http://example.com
        avatar: http://example.com/avatar.png
        descr: &quot;这是一个描述&quot;
</code></pre><p>添加多个友情链接，我们只需要根据上面的格式重复填写即可。</p>
<ul>
<li>将 <code>Name</code> 改为友情链接的名字，例如 <code>Viosey</code>。</li>
<li><code>http://example.com</code> 为友情链接的地址。</li>
<li><code>http://example.com/avatar.png</code> 为友情链接的头像。</li>
<li><code>这是一个描述</code> 为友情链接描述。</li>
</ul>
<h4 id="创建「图库」页面"><a href="#创建「图库」页面" class="headerlink" title="创建「图库」页面"></a>创建「图库」页面</h4><h5 id="创建页面-1"><a href="#创建页面-1" class="headerlink" title="创建页面"></a>创建页面</h5><p>在 hexo 目录下的 <code>source</code> 文件夹内创建一个名为 <code>gallery</code>的文件夹。</p>
<p>然后在文件内创建一个名为 <code>index.md</code> 的 Markdown 文件。</p>
<p>在 <code>index.md</code> 文件内写入如下内容即可。</p>
<pre><code>    ---
    title: gallery
    date:
    layout: gallery
    ---
</code></pre><p><code>title</code> 可修改，<code>layout</code> 不可修改(同上)。</p>
<h5 id="添加数据-1"><a href="#添加数据-1" class="headerlink" title="添加数据"></a>添加数据</h5><p>在 hexo 目录下的 <code>source</code> 文件夹内创建一个名为 <code>_data</code>（禁止改名）的文件夹。</p>
<p>然后在文件内创建一个名为 <code>gallery.yml</code> 的文件,在其中添加如下格式的数据即可。</p>
<p>其中单个图片的格式为：</p>
<pre><code>    Name:
        full_link: http://example.com/full-image.png
        thumb_link: http://example.com/thumb-image.png
        descr: &quot;这是一个描述&quot;
</code></pre><p>添加多张图片，只需要根据上面的格式重复填写即可。</p>
<ul>
<li>将 <code>Name</code> 改为图片名字，例如 <code>Material</code>。</li>
<li><code>http://example.com/full-image.png</code> 为完整图片的地址。</li>
<li><code>http://example.com/thumb-image.png</code> 为图片缩略图的地址，如果没有缩略图也可使用完整图片的地址。</li>
<li><code>这是一个描述</code> 为图片描述。</li>
</ul>
<h4 id="创建「标签云」页面"><a href="#创建「标签云」页面" class="headerlink" title="创建「标签云」页面"></a>创建「标签云」页面</h4><h5 id="创建页面-2"><a href="#创建页面-2" class="headerlink" title="创建页面"></a>创建页面</h5><p>在 hexo 目录下的 <code>source</code> 文件夹内创建一个名为 <code>tags</code>（只是建议，可根据自己喜好修改）的文件夹。</p>
<p>然后在文件内创建一个名为 <code>index.md</code> 的 Markdown 文件。</p>
<p>在 <code>index.md</code> 文件内写入如下内容。</p>
<pre><code>    ---
    title: tags
    date:
    layout: tags
    ---
</code></pre><p><code>title</code> 可修改，<code>layout</code> 不可修改。</p>
<h4 id="创建「时间轴」页面"><a href="#创建「时间轴」页面" class="headerlink" title="创建「时间轴」页面"></a>创建「时间轴」页面</h4><h5 id="创建页面-3"><a href="#创建页面-3" class="headerlink" title="创建页面"></a>创建页面</h5><p>在 hexo 目录下的 <code>source</code> 文件夹内创建一个名为 <code>timeline</code>（只是建议，可根据自己喜好修改）的文件夹。</p>
<p>然后在文件内创建一个名为 <code>index.md</code> 的 Markdown 文件。</p>
<p>在 <code>index.md</code> 文件内写入如下内容即可。</p>
<pre><code>    ---
    title: timeline
    date:
    layout: timeline
    ---
</code></pre><p><code>title</code> 可修改，<code>layout</code> 不可修改。</p>
<p>到此,关于<code>Material</code>主题的相关配置我觉得已经说得算是比较清楚了,至于上面提到的blog网站的seo优化在我的另一篇博客中有详细阐述.<a href="http://pancakeawesome.ink/2017/09/23/%E7%BD%91%E7%AB%99%20SEO%20%E4%BC%98%E5%8C%96/">传送门</a></p>
<h2 id="如何操作该博客"><a href="#如何操作该博客" class="headerlink" title="如何操作该博客"></a>如何操作该博客</h2><p>相信应该有部分童鞋看完前面所有的配置估计已经被绕的云里雾里的,但不要担心不要害怕,当你配置好后接下来的使用简便.这里我简单的说下按照我这个流程配置完后,日常的使用操作吧.</p>
<h3 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h3><ol>
<li><del><code>hexo g</code>: 生成当前博客</del> 重新编写后的 gulp 任务可以直接生成完成<code>public</code>文件夹中的生成以及压缩.</li>
<li><code>gulp build~~</code>: 生成文件后再压缩已生成的代码,图片等</li>
<li><code>hexo d</code>: 将最终代码推送上去</li>
</ol>
<h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><h4 id="使用命令行"><a href="#使用命令行" class="headerlink" title="使用命令行"></a>使用命令行</h4><pre><code>    hexo new &lt;你的文章名&gt;
</code></pre><h4 id="手动创建"><a href="#手动创建" class="headerlink" title="手动创建"></a>手动创建</h4><p>在 hexo 主目录下 <code>source／_posts</code> 新建以 <code>.md</code> 为后缀的文件。</p>
<h4 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h4><p>Front-matter 是文件最上方以 <code>---</code> 分隔的一块区域,主要用于指定个别文件的变量来设置我们的相关文章等页面,具体位置如下</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fhexo.io%2Fzh-cn%2Fdocs%2Ffront-matter.html" target="_blank" rel="noopener">Front-matter - 官方介绍</a></p>
<table><br>    <thead><br>        <tr><br>            <th>参数</th><br>            <th>描述</th><br>            <th>默认值</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td><code>layout</code></td><br>            <td>布局</td><br>            <td>post</td><br>        </tr><br>        <tr><br>            <td><code>title</code></td><br>            <td>标题</td><br>            <td>文件名</td><br>        </tr><br>        <tr><br>            <td><code>date</code></td><br>            <td>建立日期</td><br>            <td>文件建立日期</td><br>        </tr><br>        <tr><br>            <td><code>updated</code></td><br>            <td>更新日期</td><br>            <td>文件更新日期</td><br>        </tr><br>        <tr><br>            <td><code>tags</code></td><br>            <td>标签（不适用于分页）</td><br>            <td></td><br>        </tr><br>        <tr><br>            <td><code>categories</code></td><br>            <td>分类（不适用于分页）</td><br>            <td></td><br>        </tr><br>        <tr><br>            <td><code>permalink</code></td><br>            <td>覆盖文章网址</td><br>            <td></td><br>        </tr><br>        <tr><br>            <td><code>thumbnail</code></td><br>            <td>缩略图地址</td><br>            <td></td><br>        </tr><br>        <tr><br>            <td><code>toc</code></td><br>            <td>显示 TOC 按钮</td><br>            <td>true</td><br>        </tr><br>        <tr><br>            <td><code>comment</code></td><br>            <td>显示评论</td><br>            <td>true</td><br>        </tr><br>        <tr><br>            <td><code>notag</code></td><br>            <td>不生成标签按钮</td><br>            <td>false</td><br>        </tr><br>        <tr><br>            <td><code>top</code></td><br>            <td>置顶</td><br>            <td>false</td><br>        </tr><br>        <tr><br>            <td><code>mathJax</code></td><br>            <td>启用 Mathjax</td><br>            <td>false</td><br>        </tr><br>        <tr><br>            <td><strong>description</strong></td><br>            <td><strong>每篇文章在搜索结果中显示的链接描述</strong></td><br>            <td>站点配置文件中的 description</td><br>        </tr><br>    </tbody><br></table>

<h4 id="缩略图功能"><a href="#缩略图功能" class="headerlink" title="缩略图功能"></a>缩略图功能</h4><p>在 Material 主题中，每个 Scheme 都有缩略图功能。<br>    只需要在 <code>Front-matter</code> 中添加参数 <code>thumbnail:</code>，然后填入缩略图地址即可。</p>
<h3 id="修改你的文章模板"><a href="#修改你的文章模板" class="headerlink" title="修改你的文章模板"></a>修改你的文章模板</h3><p>当你每次使用<code>hexo new 你的文章名</code>时,默认生成的模板是这个样子的</p>
<pre><code>    ---
    title: XXXX
    tag: XXXX
    date: XXXX
    ---
</code></pre><p>但这种这种文章模板没有一大堆描述属性,例如<code>description</code>,<code>thumbnail</code>等,明显不能满足我们的日常需求,所以我们这是一般会去修改我们的默认模板来满足我们的需求.这是我们只需修改<code>/scaffolds/</code>下相应的文件即可.</p>
<pre><code>    post.md  =&gt;  对应hexo new 生成的md模板
    page.md  =&gt;  对应hexo new page生成的categories模板
</code></pre><p>例如我修改的就是<code>/scaffolds/post.md</code>:</p>
<pre><code>    ---
    title: {{ title }} //文章标题
    tags: [] //文章的标签
    categories: 文章的分类
    description: 文章的搜索结果描述
    thumbnail: &#39;文章缩略图位置&#39;
    date: {{ date }} //时间
    ---
</code></pre><p>这里还可以添加一些文章公共的开头等文字</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后,关于我自己这篇博客的折腾过程基本上是说清楚了,如果那里有写的不够清楚或者有问题的地方,欢迎大家来邮箱或者qq（<a href="http://pancakeawesome.ink/">博客网站首页</a>有)交流指正.</p>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[系统入门sass（语法篇）]]></title>
      <url>/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8sass(%E8%AF%AD%E6%B3%95%E7%AF%87).html</url>
      <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>定义变量的语法：<br>在有些编程语言中（如，JavaScript）声明变量都是使用关键词“var”开头，但是在 Sass 不使用这个关键词，而是使用大家都喜欢的美元符号<code>“$”</code>开头。我想用一张图来解释，我一直坚信，一图胜千言万语：<br><img src="http://img.mukewang.com/551e065c0001435e07870307.jpg" alt=""><br>上图非常清楚告诉了大家，Sass 的变量包括三个部分：</p>
<ul>
<li>声明变量的符号“$”</li>
<li>变量名称</li>
<li>赋予变量的值<br>来看一个简单的示例，假设你的按钮颜色可以给其声明几个变量：<pre><code>$brand-primary : darken(#428bca, 6.5%) !default; // #337ab7
$btn-primary-color : #fff !default;
$btn-primary-bg : $brand-primary !default;
$btn-primary-border : darken($btn-primary-bg, 5%) !default;
</code></pre>如果值后面加上!default则表示默认值。<br>注：了解 Bootstrap 的 Sass 版本的同学，就一眼能看出，上面的示例代码是 Bootstrap 定义 primarybutton 的颜色。</li>
</ul>
<h4 id="如果变量需要镶嵌在字符串之中，就必须需要写在-之中。"><a href="#如果变量需要镶嵌在字符串之中，就必须需要写在-之中。" class="headerlink" title="如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。"></a>如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。</h4><pre><code> $side : left;

 　　.rounded {

 　　　　border-#{$side}-radius: 5px;

 　　}
</code></pre><h3 id="计算功能"><a href="#计算功能" class="headerlink" title="计算功能"></a>计算功能</h3><p>SASS允许在代码中使用算式：</p>
<pre><code> body {

 　　　　margin: (14px/2);

 　　　　top: 50px + 100px;

 　　　　right: $var  * 10%;

 　　}
</code></pre><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a><strong>嵌套</strong></h3><p>SASS允许选择器嵌套。比如，下面的CSS代码：</p>
<pre><code> div h1 {

 　　　　color : red;

 　　}
</code></pre><p>可以写成：</p>
<pre><code> div {

 　　　　hi {

 　　　　　　color:red;

 　　　　}

 　　}
</code></pre><p>属性也可以嵌套，比如border-color属性，可以写成：</p>
<pre><code> p {

 　　　　border: {

 　　　　　　color: red;

 　　　　}

 　　}
</code></pre><p><strong>注意，border后面必须加上冒号。</strong></p>
<p>在嵌套的代码块内，可以使用<code>&amp;</code>引用父元素。比如<code>a:hover</code>伪类，可以写成：</p>
<pre><code> a {

　\&amp;:hover { color: #ffb3ff; }

　}
</code></pre><p><strong>注意&amp;后面的<code>:</code>后面不能加空格</strong></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h3><p>SASS共有两种注释风格。</p>
<ul>
<li>标准的CSS注释 <code>/* comment */</code>，会保留到编译后的文件。</li>
<li>单行注释<code>// comment</code>，只保留在<code>SASS源文件</code>中，编译后被省略。</li>
</ul>
<p>在<code>/*</code>后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。</p>
<pre><code> /*! 

 　　　　重要注释！

 　　*/
</code></pre><h2 id="代码的重用"><a href="#代码的重用" class="headerlink" title="代码的重用"></a><strong>代码的重用</strong></h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><p>SASS允许一个选择器，继承另一个选择器。比如，现有<code>class1</code>：</p>
<pre><code> .class1 {

 　　　　border: 1px solid #ddd;

 　　}
</code></pre><p>class2要继承class1，就要使用<code>@extend</code>命令：</p>
<pre><code> .class2 {

 　　　　@extend .class1;

 　　　　font-size:120%;

 　　}
</code></pre><p><strong>注意：</strong></p>
<ul>
<li>sass不支持嵌套选择器的继承，比如:</li>
</ul>
<pre><code>.b .c {
    color: red;
}

.a {
    @extend .b .c;
}
</code></pre><p><strong>这样写是错误的❌,sass不会编译成功</strong></p>
<ul>
<li>如果你只想让某个样式只用来继承给别的样式，而不想让这个样式输出到css文件中（就像接口一样），可以使用%去修饰样式，这样这个样式就只能用来继承，不能输出到css文件中<pre><code>%error {
  color: red;
}
.serious-error {
  @extend %error;
}
</code></pre></li>
</ul>
<h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h3><p>Mixin有点像C语言的宏<code>（macro）</code>，是可以重用的代码块。</p>
<p>使用<code>@mixin</code>命令，定义一个代码块。</p>
<pre><code> @mixin left {

 　　　　float: left;

 　　　　margin-left: 10px;

 　　}
</code></pre><p>使用<code>@include</code>命令，调用这个mixin。</p>
<pre><code> div {

 　　　　@include left;

 　　}
</code></pre><p>mixin的强大之处，在于可以指定参数和缺省值。</p>
<pre><code> @mixin left($value: 10px) {

 　　　　float: left;

 　　　　margin-right: $value;

 　　}
</code></pre><p>使用的时候，根据需要加入参数：</p>
<pre><code> div {

 　　　　@include left(20px);

 　　}
</code></pre><p>下面是一个mixin的实例，用来生成浏览器前缀。</p>
<pre><code> @mixin rounded($vert, $horz, $radius: 10px) {

 　　　　border-#{$vert}-#{$horz}-radius: $radius;

 　　　　-moz-border-radius-#{$vert}#{$horz}: $radius;

 　　　　-webkit-border-#{$vert}-#{$horz}-radius: $radius;

 　　}
</code></pre><p>使用的时候，可以像下面这样调用：</p>
<pre><code> #navbar li { @include rounded(top, left); }

 　　#footer { @include rounded(top, left, 5px); }
</code></pre><h3 id="颜色函数"><a href="#颜色函数" class="headerlink" title="颜色函数"></a><strong>颜色函数</strong></h3><p>SASS提供了一些内置的颜色函数，以便生成系列颜色。</p>
<pre><code> lighten(#cc3, 10%)  // #d6d65c

 　　darken(#cc3, 10%)  //  #a3a329

 　　grayscale(#cc3) // #808080

 　　complement(#cc3) // #33c
</code></pre><h3 id="插入文件"><a href="#插入文件" class="headerlink" title="插入文件"></a><strong>插入文件</strong></h3><p><code>@import</code>命令，用来插入外部文件。</p>
<pre><code> @import &quot;path/filename.scss&quot;;
</code></pre><p>如果插入的是<code>.css</code>文件，则等同于css的<code>import</code>命令。</p>
<pre><code> @import &quot;foo.css&quot;;
</code></pre><h2 id="五、高级用法"><a href="#五、高级用法" class="headerlink" title="五、高级用法"></a><strong>五、高级用法</strong></h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a><strong>条件语句</strong></h3><p><code>@if</code>可以用来判断：</p>
<pre><code> p {

 　　　　@if 1 + 1 == 2 { border: 1px solid; }

 　　　　@if 5 &amp;lt; 3 { border: 2px dotted; }

 　　}
</code></pre><p>配套的还有<code>@else</code>命令：</p>
<pre><code> @if lightness($color) &amp;gt; 30% {

 　　　　background-color: #000;

 　　} @else {

 　　　　background-color: #fff;

 　　}
</code></pre><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a><strong>循环语句</strong></h3><p>SASS支持<code>for循环</code>：</p>
<pre><code> @for $i from 1 to 10 {

 　　　　.border-#{$i} {

 　　　　　　border: #{$i}px solid blue;

 　　　　}

 　　}
</code></pre><p>也支持<code>while循环</code>：</p>
<pre><code> $i: 6;

 　　@while $i &amp;gt; 0 {

 　　　　.item-#{$i} { width: 2em * $i; }

 　　　　$i: $i - 2;

 　　}
</code></pre><p><code>each</code>命令，作用与<code>for</code>类似：</p>
<pre><code> @each $member in a, b, c, d {

 　　　　.#{$member} {

 　　　　　　background-image: url(&quot;/image/#{$member}.jpg&quot;);

 　　　　}

 　　}
</code></pre><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a><strong>自定义函数</strong></h3><p>SASS允许用户编写自己的函数。</p>
<pre><code> @function double($n) {

 　　　　@return $n * 2;

 　　}

 　　#sidebar {

 　　　　width: double(5px);

 　　}
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[系统入门sass（基础篇）]]></title>
      <url>/%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8sass(%E5%9F%BA%E7%A1%80%E7%AF%87).html</url>
      <content type="html"><![CDATA[<h2 id="什么是-CSS-预处理器？"><a href="#什么是-CSS-预处理器？" class="headerlink" title="什么是 CSS 预处理器？"></a>什么是 CSS 预处理器？</h2><p>定义：<br>CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。<br>通俗的说，“CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题”，例如你可以在 <strong>CSS 中使用变量、简单的逻辑程序、函数</strong>（如右侧代码编辑器中就使用了变量<code>$color</code>）等等在编程语言中的一些基本特性，<strong>可以让你的 CSS 更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处</strong>。<br>其它 CSS 预处理器语言：<br>CSS 预处理器技术已经非常的成熟，而且也涌现出了很多种不同的 <strong>CSS 预处理器语言</strong>，比如说：</p>
<ul>
<li>Sass（SCSS）</li>
<li>LESS</li>
<li>Stylus</li>
<li>Turbine</li>
<li>Swithch CSS</li>
<li>CSS Cacheer</li>
<li>DT CSS<br>如此之多的 CSS 预处理器，那么<code>“我应该选择哪种 CSS 预处理器？”</code>也相应成了最近网上的一大热门话题，在 Linkedin、Twitter、CSS-Trick、知乎以及各大技术论坛上，很多人为此争论不休。相比过去我们对是否应该使用 CSS 预处理器的话题而言，这已经是很大的进步了。<br>到目前为止，在众多优秀的 CSS 预处理器语言中就属 Sass、LESS 和 Stylus 最优秀，讨论的也多，对比的也多。<h2 id="Sass-和-SCSS-有什么区别？"><a href="#Sass-和-SCSS-有什么区别？" class="headerlink" title="Sass 和 SCSS 有什么区别？"></a>Sass 和 SCSS 有什么区别？</h2>Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass，两者之间不同之处有以下两点：</li>
</ul>
<ol>
<li>文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名</li>
<li>语法书写方式不同，Sass 是以严格的<span style="color:#B22222;">缩进式</span>语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。</li>
</ol>
<p>先来看一个示例：</p>
<p><strong>Sass 语法</strong></p>
<pre><code class="sass">$font-stack: Helvetica, sans-serif  //定义变量
$primary-color: #333 //定义变量

body
  font: 100% $font-stack
  color: $primary-color
</code></pre>
<p><strong>SCSS 语法</strong></p>
<pre><code class="scss">$font-stack: Helvetica, sans-serif;
$primary-color: #333;

body {
  font: 100% $font-stack;
  color: $primary-color;
  }
</code></pre>
<p><strong>编译出来的 CSS</strong></p>
<pre><code class="css">body {
  font: 100% Helvetica, sans-serif;
  color: #333;
}
</code></pre>
<h2 id="Sass-编译"><a href="#Sass-编译" class="headerlink" title="Sass 编译"></a>Sass 编译</h2><p>常常有人会问，使用 Sass 进行开发，那么是不是直接通过<code>“&lt;link&gt;”</code>引用<code>“.scss”</code>或<code>“.sass</code>”文件呢？</p>
<p>那么这里告诉大家，在项目中还是引用“.css”文件，Sass 只不过是做为一个预处理工具，提前帮你做事情，只有你需要时候，他才有攻效。</p>
<p>这样一来，也就有了这章需要介绍的内容—— Sass 的编译。因为 Sass 开发之后，要让 Web 页面能调用 Sass 写好的东西，就得有这么一个过程，这个过程就称之为 Sass 编译过程。Sass 的编译有多种方法：</p>
<ul>
<li>命令编译</li>
<li>GUI工具编译</li>
<li>自动化编译</li>
</ul>
<h3 id="命令编译"><a href="#命令编译" class="headerlink" title="命令编译"></a>命令编译</h3><p>命令编译是指使用你电脑中的命令终端，通过输入 Sass 指令来编译 Sass。这种编译方式是最直接也是最简单的一种方式。因为只需要在你的命令终端输入：</p>
<p><strong>单文件编译：</strong></p><br><code>bash
sass &lt;要编译的Sass文件路径&gt;/style.scss:&lt;要输出CSS文件路径&gt;/style.css</code><br><p>这是对一个单文件进行编译，如果想对整个项目所有 Sass 文件编译成 CSS 文件，可以这样操作：</p>

<p><strong>多文件编译：</strong></p><br><code>bash
sass sass/:css/</code><br><p>上面的命令表示将项目中“sass”文件夹中所有“.scss”(“.sass”)文件编译成“.css”文件，并且将这些 CSS 文件都放在项目中“css”文件夹中。</p>

<p><strong>缺点及解决方法：</strong></p>

<p>在实际编译过程中，你会发现上面的命令，只能一次性编译。每次个性保存“.scss”文件之后，都得重新执行一次这样的命令。如此操作太麻烦，其实还有一种方法，就是在编译 Sass 时，<span style="color:#B22222;">开启“<strong>watch</strong>”功能，这样只要你的代码进行任保修改，都能自动监测到代码的变化，并且给你直接编译出来：</span></p><br><code>bash
sass --watch &amp;lt;要编译的Sass文件路径&amp;gt;/style.scss:&amp;lt;要输出CSS文件路径&amp;gt;/style.css</code><br><p>当然，使用 sass 命令编译时，可以带很多的参数：</p>

<p><a href="http://img.mukewang.com/54f54b7a00014d3006690586.jpg" target="_blank" rel="noopener"><img alt="" src="http://img.mukewang.com/54f54b7a00014d3006690586.jpg" style="width: 355px;"></a></p>

<p><strong>watch 举例：</strong></p>

<p></p><p>来看一个简单的示例，假设我本地有一个项目，我要把项目中“bootstrap.scss”编译出“bootstrap.css”文件，并且将编译出来的文件放在“css”文件夹中，我就可以在我的命令终端中执行：</p><p></p>
<pre><code class="bash">sass --watch sass/bootstrap.scss:css/bootstrap.css
</code></pre>
<p></p><p>一旦我的 bootstrap.scss 文件有任何修改，只要我重新保存了修改的文件，命令终端就能监测，并重新编译出文件：<br><img src="http://img.mukewang.com/54f54bcb00016b1005680288.jpg" alt=""></p>
<h3 id="GUI-界面工具编译"><a href="#GUI-界面工具编译" class="headerlink" title="GUI 界面工具编译"></a>GUI 界面工具编译</h3><p>或许你会说，我一直讨厌使用命令来做事情，我喜欢那种能看得到的界面操作。那么你可以考虑使用 GUI 界面工具来对 Sass 进行编译。当然不同的 GUI 工具操作方法略有不同。</p>
<p>我比较推荐使用以下两个:<br><a href="http://www.w3cplus.com/preprocessor/sass-gui-tool-koala.html" target="_blank" rel="noopener">Koala</a><br><a href="http://www.w3cplus.com/preprocessor/sass-gui-tool-codekit.html" target="_blank" rel="noopener">CodeKit</a></p>
<h3 id="自动化编译"><a href="#自动化编译" class="headerlink" title="自动化编译"></a>自动化编译</h3><p>喜欢自动化研究的同学，应该都知道 <span style="color:#B22222;"><strong>Grunt </strong></span>和 <span style="color:#B22222;"><strong>Gulp </strong></span>这两个东东。如果您正在使用其中的任何一种，那么你也可以通过他们来配置 Sass 的编译。这里仅列出两个示例代码（具体情况要根据您的项目环境来做一定的修改，不建议生搬硬套，容易发生命案，呵呵。</p>
<p><strong>1、<span style="color:#B22222;">Grunt </span>配置 Sass 编译的示例代码</strong></p>
<pre class="code">module.exports = function(grunt) {
    grunt.initConfig({
        pkg: grunt.file.readJSON('package.json'),
        sass: {
            dist: {
                files: {
                    'style/style.css' : 'sass/style.scss'
                }
            }
        },
        watch: {
            css: {
                files: '**/*.scss',
                tasks: ['sass']
            }
        }
    });
    grunt.loadNpmTasks('grunt-contrib-sass');
    grunt.loadNpmTasks('grunt-contrib-watch');
    grunt.registerTask('default',['watch']);
}</pre>

<p><strong>2、<span style="color:#B22222;">Gulp </span>配置 Sass 编译的示例代码</strong></p>
<pre class="code">var gulp = require('gulp');
var sass = require('gulp-sass');

gulp.task('sass', function () {
    gulp.src('./scss/*.scss')
        .pipe(sass())
        .pipe(gulp.dest('./css'));
});

gulp.task('watch', function() {
    gulp.watch('scss/*.scss', ['sass']);
});

gulp.task('default', ['sass','watch']);</pre>

<h2 id="常见的编译错误"><a href="#常见的编译错误" class="headerlink" title="常见的编译错误"></a>常见的编译错误</h2><p>在编译 Sass 代码时常常会碰到一些错误，让编译失败。这样的错误有系统造成的也有人为造成的，但大部分都是人为过失引起编译失败。<br>而最为常见的一个错误就是<strong>字符编译</strong>引起的。在Sass的编译的过程中，是不是支持“GBK”编码的。所以在创建 Sass 文件时，就需要将文件编码设置为“utf-8”。<br>另外一个错误就是路径中的<strong>中文字符</strong>引起的。建议在项目中文件命名或者文件目录命名不要使用中文字符。而至于人为失误造成的编译失败，在编译过程中都会有具体的说明，大家可以根据编译器提供的错误信息进行对应的修改。</p>
<h2 id="不同样式风格的输出方法"><a href="#不同样式风格的输出方法" class="headerlink" title="不同样式风格的输出方法"></a>不同样式风格的输出方法</h2><p>众所周知，每个人编写的 CSS 样式风格都不一样，有的喜欢将所有样式代码都写在同一行，而有的喜欢将样式分行书写。在 Sass 中编译出来的样式风格也可以按不同的样式风格显示。其主要包括以下几种样式风格：</p>
<ul>
<li>嵌套输出方式 nested</li>
<li>展开输出方式 expanded  </li>
<li>紧凑输出方式 compact </li>
<li>压缩输出方式 compressed<h3 id="嵌套输出方式-nested"><a href="#嵌套输出方式-nested" class="headerlink" title="嵌套输出方式 nested"></a>嵌套输出方式 nested</h3><h4 id="嵌套输出方式-nested-1"><a href="#嵌套输出方式-nested-1" class="headerlink" title="嵌套输出方式 nested"></a>嵌套输出方式 nested</h4>Sass 提供了一种嵌套显示 CSS 文件的方式。例如</li>
</ul>
<pre><code>nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}
</code></pre><p>在编译的时候带上参数“ <code>--style nested</code>”:<br><code>sass --watch test.scss:test.css --style nested</code><br>编译出来的 CSS 样式风格：</p>
<pre><code>nav ul {
  margin: 0;
  padding: 0;
  list-style: none; }
nav li {
  display: inline-block; }
nav a {
  display: block;
  padding: 6px 12px;
  text-decoration: none; }
</code></pre><p>如下图所示：<br><img src="http://img.mukewang.com/54f54dab00019a0504880296.jpg" alt=""></p>
<h3 id="展开输出方式-expanded"><a href="#展开输出方式-expanded" class="headerlink" title="展开输出方式 expanded"></a>展开输出方式 expanded</h3><h4 id="嵌套输出方式-expanded"><a href="#嵌套输出方式-expanded" class="headerlink" title="嵌套输出方式 expanded"></a>嵌套输出方式 expanded</h4><pre><code>nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}
</code></pre><p>在编译的时候带上参数<code>“ --style expanded”:
sass --watch test.scss:test.css --style expanded</code><br>这个输出的 CSS 样式风格和 nested 类似，<strong>只是大括号在另起一行</strong>，同样上面的代码，编译出来：</p>
<pre><code>nav ul {
  margin: 0;
  padding: 0;
  list-style: none;
}
nav li {
  display: inline-block;
}
nav a {
  display: block;
  padding: 6px 12px;
  text-decoration: none;
}
</code></pre><p><img src="http://img.mukewang.com/54f54e2c0001c2c004850281.jpg" alt=""></p>
<h3 id="紧凑输出方式-compact"><a href="#紧凑输出方式-compact" class="headerlink" title="紧凑输出方式 compact"></a>紧凑输出方式 compact</h3><h4 id="嵌套输出方式-compact"><a href="#嵌套输出方式-compact" class="headerlink" title="嵌套输出方式 compact"></a>嵌套输出方式 compact</h4><pre><code>nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}
</code></pre><p>在编译的时候带上参数<code>“ --style compact”:
sass --watch test.scss:test.css --style compact</code><br>该方式适合那些喜欢单行 CSS 样式格式的朋友，编译后的代码如下：</p>
<pre><code>nav ul { margin: 0; padding: 0; list-style: none; }
nav li { display: inline-block; }
nav a { display: block; padding: 6px 12px; text-decoration: none; }
</code></pre><p><img src="http://img.mukewang.com/54f7b4bb00014f9908020299.jpg" alt=""></p>
<h3 id="压缩输出方式-compressed"><a href="#压缩输出方式-compressed" class="headerlink" title="压缩输出方式 compressed"></a>压缩输出方式 compressed</h3><h4 id="压缩输出方式-compressed-1"><a href="#压缩输出方式-compressed-1" class="headerlink" title="压缩输出方式 compressed"></a>压缩输出方式 compressed</h4><pre><code>nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}
</code></pre><p>在编译的时候带上参数<code>“ --style compressed”:
sass --watch test.scss:test.css --style compressed</code><br>压缩输出方式会去掉标准的 Sass 和 CSS 注释及空格。也就是压缩好的 CSS 代码样式风格：</p>
<pre><code>nav ul{margin:0;padding:0;list-style:none}nav li{display:inline-block}nav a{display:block;padding:6px 12px;text-decoration:none}
</code></pre><p><img src="http://img.mukewang.com/54f5511d0001b5c206660401.jpg" alt=""></p>
<p>编译出来的CSS样式风格的选择完全是个人喜好问题，可以根据自己喜欢的风格选择参数。<br><strong>一段时间之后，你实际上就不再需要写 CSS 代码了，只用写 Sass 代码。在这种情况下，你只需要设定输出格式为压缩格式，知道输出的 CSS 代码可以直接使用即可。</strong></p>
<h2 id="Sass-的调试"><a href="#Sass-的调试" class="headerlink" title="Sass 的调试"></a>Sass 的调试</h2><p><img src="http://img.mukewang.com/54f7b71d0001bb0b05050268.jpg" alt=""></p>
<ul>
<li>Sass 调试一直以来都是一件头痛的事情，使用 Sass 的同学都希望能在浏览器中直接调试 Sass 文件，能找到对应的行数。值得庆幸的是，现在实现并不是一件难事，只要你的浏览器支持“<code>sourcemap</code>”功能即可。早一点的版本，需要在编译的时候添加<code>“--sourcemap”</code>  参数：<pre><code>sass --watch --scss --sourcemap style.scss:style.css
</code></pre>在 Sass3.3 版本之上（我测试使用的版本是 3.4.7），不需要添加这个参数也可以：<pre><code>sass --watch style.scss:style.css
</code></pre>在命令终端，你将看到一个信息：<pre><code>&gt;&gt;&gt; Change detected to: style.scss
write style.css
write style.css.map
</code></pre></li>
<li>在 chrome://flags/ 中启用 Developer Tools Experiments (开发者工具实验)</li>
<li>在 Developer tools 设置 Experiments 选项下开启File system folders in Sources Panel，再重启Developer tools，就会多出Workspace选项。</li>
</ul>
<p><em>这时你就可以像前面展示的 gif 图一样，调试你的 Sass 代码。</em></p>
]]></content>
      
        <categories>
            
            <category> 前端技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[三分钟入门markdown]]></title>
      <url>/%E4%B8%89%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8markdown.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>经常会用markdown来编写博客，这些语法你需要知道</strong></p>
<h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><p><code>wiki释义:</code></p>
<blockquote>
<p><code>Markdown</code> 是一种轻量级<code>标记语言</code>，创始人为约翰·格鲁伯（John Gruber）和亚伦·斯沃茨（Aaron Swartz）。<br>它允许人们“使用易读易写的纯文本格式编写文档，然后<strong>转换成有效的XHTML(或者HTML)文档</strong>”。<br>这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>
</blockquote>
<p>Markdown的优点包括但不限于以下几点:</p>
<ul>
<li>纯文本，所以兼容性极强，可以用所有文本编辑器打开。</li>
<li>让你专注于文字而不是排版。</li>
<li>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。</li>
<li>Markdown 的标记语法有极好的可读性。</li>
</ul>
<h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a><a href="#Markdown_u8BED_u6CD5" title="Markdown语法"></a>Markdown语法</h2><p>Markdown语法简洁明了、容易学习，下面一一介绍。</p>
<h3 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a><a href="#u57FA_u672C_u7B26_u53F7" title="基本符号"></a>基本符号</h3><ul>
<li><code>*</code>, <code>-</code> , <code>+</code>： 这3个符号的效果都一样， 被称为Markdown符号</li>
<li><code>空白行</code> : 表示另起一个段落,对应HTML中的 <code>&lt;p&gt;</code> 元素</li>
<li><code>`</code>  表示 <code>内联代码</code>， <code>tab</code>是用来标记<code>代码段</code>，分别对应HTML的 <code>code</code> ， <code>pre</code> 元素</li>
</ul>
<h3 id="段落换行"><a href="#段落换行" class="headerlink" title="段落换行"></a><a href="#u6BB5_u843D_u6362_u884C" title="段落换行"></a>段落换行</h3><ul>
<li><code>单个回车</code>会被解释为<code>空格</code></li>
<li>一个空白行(即<code>两个回车</code>)变成单一段落<code>&amp;lt;p&amp;gt;</code></li>
<li>连续3个Markdown符号，然后回车，表示<code>&amp;lt;hr&amp;gt;</code>横线</li>
<li><strong>连续多个空格会被解释为单个空格</strong><br><a id="more"></a></li>
</ul>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a><a href="#u6807_u9898" title="标题"></a>标题</h3><ul>
<li>在文字前面加上1-6个<code>#</code>来实现, 代表HTML中的六级标题 <code>h1</code>-<code>h6</code></li>
<li>在文字左右各加1-3各符号，可本别实现斜体<code>&lt;i&gt;</code>、加粗<code>&lt;&gt;</code>和斜体加粗</li>
</ul>
<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题

*斜体*

**加粗**

***加粗斜体***


### 引用

*   在第一行加上 `&gt;` 和一个`空格`，表示引用，还可以嵌套, 对应HTML中的`&lt;blockquote&gt;`标签

### [](#u5217_u8868 &quot;列表&quot;)列表

*   使用*,+,-加上一个空格来表示,对应HTML中的`&lt;ul&gt;`标签
*   可以支持嵌套
*   有序列表用 `数字`+`.`+`空格` 来表示,对应HTML中的`&lt;ol&gt;`标签
*   如果列表内容很长，不需要手工输入换行符，css控制段落的宽度，会自动的缩放的
</code></pre><p><strong>无序列表:</strong></p>
<pre><code>- 无序列表 1
- 无序列表 2
- 无序列表 3
</code></pre><p><strong>有序列表:</strong></p>
<pre><code>1. 有序列表 1
2. 有序列表 2
3. 有序列表 3
</code></pre><p><strong>列表嵌套:</strong></p>
<pre><code>- One
    + What
    + Why
    + How
- Two
- Three
</code></pre><p><strong>或者每级列表前面加上两个空格 表示向下一级缩进</strong></p>
<pre><code>- One
    - waht
    - why
    - how        
- Two
- Three
</code></pre><p><strong>效果如下</strong></p>
<p><strong>无序列表:</strong></p>
<ul>
<li>无序列表 1</li>
<li>无序列表 2</li>
<li>无序列表 3</li>
</ul>
<p><strong>有序列表:</strong></p>
<ol>
<li>有序列表 1</li>
<li>有序列表 2</li>
<li>有序列表 3</li>
</ol>
<p><strong>列表嵌套:</strong></p>
<ul>
<li>One<ul>
<li>What</li>
<li>Why</li>
<li>How</li>
</ul>
</li>
<li>Two</li>
<li>Three<br><strong>或者每级列表前面加上两个空格 表示向下一级缩进</strong></li>
<li>One<ul>
<li>What</li>
<li>Why</li>
<li>How</li>
</ul>
</li>
<li>Two</li>
<li>Three</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="#u94FE_u63A5" title="链接"></a>链接</h3><p>在 Markdown 中，插入链接只需要使用 <code>[显示文本](连接地址)</code>这种格式，<br>插入图片只需要使用<code>![图片描述](图片链接地址)</code>这种格式即可,其中前者对应于<br>HTML中的<code>a</code>标签，后者对应<code>img</code>标签，方括号中的图片描述为img标签的的<code>alt</code>属性值</p>
<p>还有一种建立链接的方式，称为<code>参考式</code>, 参考式的链接是在链接文字的括号后面再接上另一个方括号， 而在第二个方括号里面要填入用以辨识链接的标记: <code>[显示文本][id]</code>或<code>![图片描述][id]</code>. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来：<code>[id]: http://example.com/</code></p>
<p>示例:</p>
<pre><code>个人信息:

[Wentong](http://pancakeawesome.com/)

- [GitHub][1]
- [Facebook][]
- [Twitter][Weblog]

[1]: https://github.com/pancakeawesome/
[Facebook]: https://facebook.com/pancakeawesome/
[Weblog]: https://twitter.com/pancakeawesome/
</code></pre><p><strong>效果如下:</strong></p>
<p>个人信息:</p>
<p><a href="http://www.fangwentong.com/" target="_blank" rel="noopener">Wentong</a></p>
<ul>
<li><a href="https://github.com/fangwentong/" target="_blank" rel="noopener">GitHub</a></li>
<li><a href="https://facebook.com/fangwentong/" target="_blank" rel="noopener">Facebook</a></li>
<li><a href="https://twitter.com/fangwentong/" target="_blank" rel="noopener">Twitter</a></li>
</ul>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a><a href="#u8868_u683C" title="表格"></a>表格</h3><table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:right">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td>col 3 is</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符<code>$$</code>包裹 <code>TeX</code> 或 <code>LaTeX</code> 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 <code>Mathjax</code>对数学公式进行渲染。如：</p>
<pre><code>$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $$
$$
x \href{why-equal.html}{=} y^2 + 1
$$
</code></pre><p>同时也支持 HTML 属性，如：</p>
<pre><code>$$ (x+1)^2 = \class{hidden}{(x+1)(x+1)} $$
$$
(x+1)^2 = \cssId{step1}{\style{visibility:hidden}{(x+1)(x+1)}}
$$
</code></pre><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a><a href="#u7279_u6B8A_u7B26_u53F7" title="特殊符号"></a>特殊符号</h3><ul>
<li>用<code>\</code> 来转义，表示文本中的markdown符号</li>
</ul>
<h3 id="兼容HTML语法"><a href="#兼容HTML语法" class="headerlink" title="兼容HTML语法"></a><a href="#u517C_u5BB9HTML_u8BED_u6CD5" title="兼容HTML语法"></a>兼容HTML语法</h3><p>我们知道，Markdown最终要通过Markdown解释器转换为HTML文档, 而Markdown是一种书写的格式，它的语法种类很少，只对应HTML标记中的一小部分, 不在Markdown涵盖范围内的标签， 可以直接在文档中用HTML书写.</p>
<h3 id="自定义Markdown样式"><a href="#自定义Markdown样式" class="headerlink" title="自定义Markdown样式"></a><a href="#u81EA_u5B9A_u4E49Markdown_u6837_u5F0F" title="自定义Markdown样式"></a>自定义Markdown样式</h3><p>注意到，Markdown解释器将Markdown文本转换为HTML文档，我们编写CSS，并在生成的HTML文档中引用这个样式表, 可以达到自定义Markdown显示风格的效果.</p>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo+githubio+material搭建你的个人博客（基础篇）]]></title>
      <url>/hexo+githubio+material%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(%E5%9F%BA%E7%A1%80%E7%AF%87).html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><del><em>本帖为更新贴</em></del><br>之前用的是csdn的blog，经常写一些学习笔记📒和it相关的技术，但是总觉得自己是做前端的，总用第三方的blog平台感觉不是很合适。于是狠下心来花了两三天终于通过githubio和hexo把静态博客网站给搭起来了，参照了一些网上blog的教程，但是因为环境和版本的愿意还是有很多坑，走了很多弯路，但还好最终都一步一步淌过来了，今天才把blog给完善好，但是收获很多：资源部署，域名解析，seo，资源打包📦压缩等等技术，让我受益匪浅。<br><del><strong>今天实在太累，加上还在公司实习，没时间把blog相关的技术分享给大家，之后两三天之类会发出来～</strong></del><br><img src="https://raw.githubusercontent.com/jeasonstudio/images/8b550fd8d102bf7625f47511b35489612626636d/20160526/gitlogo.jpg" alt="GitHub Logo"></p>
<p><img src="https://raw.githubusercontent.com/jeasonstudio/images/8b550fd8d102bf7625f47511b35489612626636d/20160526/Hexologo.gif" alt="Hexo Logo"></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a><a href="#环境配置" title="环境配置"></a><strong>环境配置</strong></h2><p><a href="https://hexo.io/docs" target="_blank" rel="noopener">Hexo官网</a>上本就有对Hexo安装及使用的详细介绍，墙裂推荐。这里来讲述自己安装的亲身步骤，或有区别。</p>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a><a href="#Node-js" title="Node.js"></a>Node.js</h3><p>用来生成静态页面。移步<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js官网</a>，下载v5.5.0 Stable 一路安装即可。</p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a><a href="#Git" title="Git"></a>Git</h3><p>用来将本地Hexo内容提交到Github上。Xcode自带Git，这里不再赘述。如果没有Xcode可以参考<a href="https://hexo.io/docs" target="_blank" rel="noopener">Hexo官网</a>上的安装方法。    </p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><a href="#安装Hexo" title="安装Hexo"></a><strong>安装Hexo</strong></h2><p>当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：</p>
<pre><code>$ sudo npm install -g hexo
</code></pre><p>输入管理员密码（Mac登录密码）即开始安装 (<code>sudo</code>:linux系统管理指令  <code>-g</code>:全局安装)</p>
<blockquote>
<p>注意坑一：<a href="https://hexo.io/docs" target="_blank" rel="noopener">Hexo官网</a>上的安装命令是<code>$ npm install -g hexo-cli</code>，安装时不要忘记前面加上<code>sudo</code>，否则会因为权限问题报错。</p>
</blockquote>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><a href="#初始化" title="初始化"></a>初始化</h3><p>终端cd到一个你选定的目录，执行<code>hexo init</code>命令：</p>
<pre><code>$ hexo init blog
</code></pre><p><code>blog</code>是你建立的文件夹名称。cd到<code>blog</code>文件夹下，执行如下命令，安装npm：</p>
<pre><code>$ npm install
</code></pre><p>执行如下命令，开启hexo服务器：</p>
<pre><code>$ hexo s
</code></pre><p>此时，浏览器中打开网址<a href="http://0.0.0.0:4000" target="_blank" rel="noopener">http://localhost:4000</a>，能看到如下页面：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fjo3tmedk7j30m00cn3z1.jpg" alt=""></p>
<p>本地设置好后，接下来开始关联Github。</p>
<h2 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a><a href="#关联Github" title="关联Github"></a><strong>关联Github</strong></h2><h3 id="添加ssh-key到Github"><a href="#添加ssh-key到Github" class="headerlink" title="添加ssh key到Github"></a><a href="#添加ssh-key到Github" title="添加ssh key到Github"></a>添加ssh key到Github</h3><h4 id="检查SSH-keys是否存在Github"><a href="#检查SSH-keys是否存在Github" class="headerlink" title="检查SSH keys是否存在Github"></a><a href="#检查SSH-keys是否存在Github" title="检查SSH keys是否存在Github"></a>检查SSH keys是否存在Github</h4><p>执行如下命令，检查SSH keys是否存在。如果有文件<code>id_rsa.pub</code>或<code>id_dsa.pub</code>，则直接进入步骤1.3将SSH key添加到Github中，否则进入下一步生成SSH key。</p>
<pre><code>$ ls -al ~/.ssh
</code></pre><h4 id="生成新的ssh-key"><a href="#生成新的ssh-key" class="headerlink" title="生成新的ssh key"></a><a href="#生成新的ssh-key" title="生成新的ssh key"></a>生成新的ssh key</h4><p>执行如下命令生成public/private rsa key pair，注意将<code>your_email@example.com</code>换成你自己注册Github的邮箱地址。</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;
</code></pre><p>默认会在相应路径下（<code>~/.ssh/id_rsa.pub</code>）生成<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件。</p>
<h4 id="将ssh-key添加到Github中"><a href="#将ssh-key添加到Github中" class="headerlink" title="将ssh key添加到Github中"></a><a href="#将ssh-key添加到Github中" title="将ssh key添加到Github中"></a>将ssh key添加到Github中</h4><p>Find前往文件夹<code>~/.ssh/id_rsa.pub</code>打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。</p>
<p>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:</p>
<p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方<code>Add key</code>绿色按钮即可。</p>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a><a href="#创建仓库" title="创建仓库"></a>创建仓库</h3><p>登录你的Github帐号，新建仓库，名为<code>用户名.github.io</code>固定写法，如<code>pancakeawesome.github.io</code>,如下图所示：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fjnv225vpoj30ro0gkjsn.jpg" alt="exam"></p>
<p>本地的<code>blog</code>文件夹下内容为：</p>
<table>
<thead>
<tr>
<th style="text-align:left">1</th>
<th style="text-align:left">config.yml</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">db.json</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">node_modules</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">package.json</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">scaffolds</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">source</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">themes</td>
</tr>
</tbody>
</table>
<p>终端cd到<code>blog</code>文件夹下，<code>vim</code>打开<code>_config.yml</code>，命令如下：</p>
<pre><code>$ vim _config.yml
</code></pre><p>打开后往下滑到最后，修改成下边的样子：</p>
<pre><code>deploy:
    type: git
    repository: https://github.com/pancakeawesome/pancakeawesome.github.io.git
   branch: master
</code></pre><p>   你需要将<code>repository</code>后<code>pancakeawesome</code>换成你自己的用户名，地址在上图<code>2</code>位置获取。hexo 3.1.1版本后<code>type:</code>值为<code>git</code>。</p>
<p>注意坑二：在配置所有的<code>_config.yml</code>文件时（包括theme中的），在所有的冒号<code>:</code>后边都要加一个空格，否则执行hexo命令会报错，切记 切记</p>
<p>在<code>blog</code>文件夹目录下执行生成静态页面命令：</p>
<pre><code>   $ hexo generate        或者：hexo g
</code></pre><p>此时若出现如下报错：</p>
<pre><code>ERROR Local hexo not found in ~/blog
ERROR Try runing: &#39;npm install hexo --save&#39;
</code></pre><p>则执行命令：</p>
<pre><code>npm install hexo --save
</code></pre><p>若无报错，自行忽略此步骤。</p>
<p>再执行配置命令：</p>
<pre><code>$ hexo deploy            或者：hexo d
</code></pre><blockquote>
<p>注意坑三：若执行命令<code>hexo deploy</code>仍然报错：无法连接git，则执行如下命令来安装<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>：</p>
<pre><code>$ npm install hexo-developer-git --save
</code></pre></blockquote>
<p>再次执行<code>hexo generate</code>和<code>hexo deploy</code>命令</p>
<p>此时，浏览器中打开网址<a href="http://pancakeawesome.github.io" target="_blank" rel="noopener">http://pancakeawesome.github.io</a>（将<code>pancakeawesome</code>换成你的用户名）能看到和打开<code>http://localhost:4000</code>时一样的页面。</p>
<h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a><a href="#发布文章" title="发布文章"></a>发布文章</h3><p>终端cd到<code>blog</code>文件夹下，执行如下命令新建文章：</p>
<pre><code>hexo new &quot;postName&quot;
</code></pre><p>名为<code>postName.md</code>的文件会建在目录<code>/blog/source/_posts</code>下。你当然可以用vim来编辑文章。</p>
<blockquote>
<p>在此说明一下，我一直都在用微软的 VSCode编辑器来编写MarkDown，如果你有什么更好的建议，我会非常感激的。<br>另外MarkDown格式的语法教程，前面的博文里有，但我知道你懒，<a href="http://pancakeawesome.ink/2017/09/18/%E4%B8%89%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8markdown/">传送门</a>。</p>
</blockquote>
<p>文章编辑完成后，终端cd到<code>blog</code>文件夹下，执行如下命令来发布：</p>
<pre><code>hexo generate             //生成静态页面
hexo deploy            //将文章部署到Github&amp;lt;/pre&amp;gt;
</code></pre><hr>
<p><strong>至此，Mac上搭建基于Github的Hexo博客就完成了。下面的内容是介绍安装theme，添加评论功能和绑定个人域名，如果有兴趣且还有耐心的话，请继续吧。</strong></p>
<h2 id="安装theme"><a href="#安装theme" class="headerlink" title="安装theme"></a><a href="#安装theme" title="安装theme"></a><strong>安装theme</strong></h2><p>你可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网主题页</a>去搜寻自己喜欢的theme。这里以<a href="https://material.viosey.com/" target="_blank" rel="noopener">hexo-theme-material</a>为例</p>
<p>终端cd到 <code>blog</code> 目录下执行如下命令：</p>
<pre><code>$ git clone https://github.com/viosey/hexo-theme-material themes/material
</code></pre><p>将<code>blog</code>目录下<code>_config.yml</code>里<code>theme</code>的名称<code>landscape</code>修改为<code>material</code></p>
<p>终端cd到<code>blog</code>目录下执行如下命令(每次部署文章的步骤)：</p>
<pre><code>$ hexo clean           //清除缓存文件 (db.json) 和已生成的静态文件 (public)
$ hexo g             //生成缓存和静态文件
hexo d             //重新部署到服务器
</code></pre><p>至于更改theme内容，比如名称，描述，头像等去修改<code>blog/_config.yml</code>文件和<code>blog/themes/material/_config.yml</code>文件中对应的属性名称即可， 不要忘记冒号<code>:</code>后加空格。  <a href="https://material.viosey.com/" target="_blank" rel="noopener"> Material 使用文档</a>里有极详细的介绍。</p>
<h2 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a><a href="#绑定个人域名" title="绑定个人域名"></a><strong>绑定个人域名</strong></h2><p>现在使用的域名是Github提供的二级域名，也可以绑定为自己的个性域名。购买域名，可以到<a href="https://sg.godaddy.com/zh/" target="_blank" rel="noopener">GoDaddy官网</a>，网友亲切称呼为：狗爹，也可以到<a href="http://wanwang.aliyun.com/" target="_blank" rel="noopener">阿里万网</a>购买。</p>
<h3 id="Github端"><a href="#Github端" class="headerlink" title="Github端"></a><a href="#Github端" title="Github端"></a>Github端</h3><p>在<code>/blog/themes/landscape/source</code>目录下新建文件名为：<code>CNAME</code>文件，注意没有后缀名！直接将自己的域名如：<code>pancakeawesome.com</code>写入。</p>
<p>终端cd到<code>blog</code>目录下执行如下命令重新部署：</p>
<pre><code>$ hexo clean
$ hexo g
$ hexo d
</code></pre><blockquote>
<p>注意坑四：网上许多都是说在Github上直接新建<code>CNAME</code>文件，如果这样的话，在你下一次执行<code>hexo d</code>部署命令后<code>CNAME</code>文件就消失了，因为本地没有此文件嘛。</p>
</blockquote>
<h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a><a href="#域名解析" title="域名解析"></a>域名解析</h3><p>如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。</p>
<p>登录你注册域名的网站，比如万网，在你购买的域名后边点击：解析 –&gt; 添加解析</p>
<p>记录类型：CNAME</p>
<p>主机记录：将域名解析为example.com（不带www），填写@或者不填写</p>
<p>记录值：pancakeawesome.github.io.    (不要忘记最后的<code>.</code>，<code>pancakeawesome</code>改为你自己的用户名)，点击保存即可。</p>
<p>此时，大功告成！</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a><a href="#后记" title="后记"></a><strong>后记</strong></h2><p>参考<a href="http://pancakeawesome.ink/">pancakeawesome博客：pancakeawesome</a>，希望对大家有所帮助，欢迎吐槽～</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><a href="#参考链接" title="参考链接"></a><strong>参考链接</strong></h2><ul>
<li><a href="https://hexo.io/docs" target="_blank" rel="noopener">Hexo官网</a></li>
<li><a href="http://leopardpan.github.io/2015/08/12/hexo/" target="_blank" rel="noopener">HEXO</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动态规划迷思]]></title>
      <url>/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%BF%B7%E6%80%9D.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在刷leetcode发现很多线性表的算法题都都可以用<strong><code>dp（dynamic programming）</code></strong>去做，如果你了解dp的思想，其实很多复杂的问题都能化为简单的问题，非常棒～<br><em>let’s start~</em></p>
<h2 id="动态规划中递推式的求解方法不是动态规划的本质。"><a href="#动态规划中递推式的求解方法不是动态规划的本质。" class="headerlink" title="动态规划中递推式的求解方法不是动态规划的本质。"></a>动态规划中递推式的求解方法不是动态规划的本质。</h2><ol>
<li>动态规划的本质，是对问题<strong>_状态的定义_</strong>和<strong>_状态转移方程_的定义</strong>。<br>引自维基百科<blockquote>
<p><strong>dynamic programming</strong> is a method for solving a complex problem by <strong>breaking it down into a collection of simpler subproblems</strong>.</p>
</blockquote>
</li>
</ol>
<p>动态规划是通过<strong>拆分问题，</strong>定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。<br>本题下的其他答案，大多都是在说递推的求解方法，但<strong>如何拆分问题</strong>，才是动态规划的核心。<br>而<strong>拆分问题</strong>，靠的就是<strong>_状态的定义_</strong>和<strong>_状态转移方程_的定义</strong>。</p>
<h2 id="什么是状态的定义？"><a href="#什么是状态的定义？" class="headerlink" title="什么是状态的定义？"></a>什么是<strong>状态的定义？</strong></h2><p><strong><br>首先想说大家千万不要被下面的数学式吓到，这里只涉及到了函数相关的知识。</strong><br>我们先来看一个动态规划的教学必备题：</p>
<blockquote>
<p>给定一个数列，长度为N，<br>求这个数列的最长上升（递增）子数列（LIS）的长度.<br>以<br>1 7 2 8 3 4<br>为例。<br>这个数列的最长递增子数列是 1 2 3 4，长度为4；<br>次长的长度为3， 包括 1 7 8; 1 2 3 等.</p>
</blockquote>
<p>要解决这个问题，我们首先要<strong>定义这个问题</strong>和这个问题的子问题。<br>有人可能会问了，题目都已经在这了，我们还需定义这个问题吗？需要，原因就是这个问题在字面上看，找不出子问题，而没有子问题，这个题目就没办法解决。<br>所以我们来重新定义这个问题：</p>
<blockquote>
<p>给定一个数列，长度为N，<br>设<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">为：以数列中第k项结尾的最长递增子序列的长度.<br>求<img src="https://www.zhihu.com/equation?tex=F_%7B1%7D..F_%7BN%7D" alt="F_{1}..F_{N}"> 中的最大值.</p>
</blockquote>
<p>显然，这个新问题与原问题等价。<br>而对于<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">来讲，<img src="https://www.zhihu.com/equation?tex=F_%7B1%7D+..+F_%7Bk-1%7D" alt="F_{1} .. F_{k-1}">都是<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">的子问题：因为以第k项结尾的最长递增子序列（下称LIS），包含着以第<img src="https://www.zhihu.com/equation?tex=1..k-1" alt="1..k-1">中某项结尾的LIS。</p>
<p>上述的新问题<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">也可以叫做状态，定义中的“<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">为数列中第k项结尾的LIS的长度”，就叫做对状态的定义。<br>之所以把<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">做“状态”而不是“问题” ，一是因为避免跟原问题中“问题”混淆，二是因为这个新问题是数学化定义的。</p>
<p>对状态的定义只有一种吗？_当然不是_。<br>我们甚至可以二维的，以完全不同的视角定义这个问题：</p>
<blockquote>
<p>给定一个数列，长度为N，<br>设<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D" alt="F_{i, k}">为：<br>在前i项中的，长度为k的最长递增子序列中，最后一位的最小值. <img src="https://www.zhihu.com/equation?tex=1%5Cleq+k%5Cleq+N" alt="1\leq k\leq N">.<br>若在前i项中，不存在长度为k的最长递增子序列，则<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D" alt="F_{i, k}">为正无穷.<br>求最大的x，使得<img src="https://www.zhihu.com/equation?tex=F_%7BN%2Cx%7D" alt="F_{N,x}">不为正无穷。</p>
</blockquote>
<p>这个新定义与原问题的等价性也不难证明，请读者体会一下。<br>上述的<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D" alt="F_{i, k}">就是状态，定义中的“<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D" alt="F_{i, k}">为：在前i项中，长度为k的最长递增子序列中，最后一位的最小值”就是对状态的定义。</p>
<h2 id="什么是状态转移方程？"><a href="#什么是状态转移方程？" class="headerlink" title="什么是状态转移方程？"></a>什么是<strong>状态转移方程</strong>？</h2><p>上述状态定义好之后，状态和状态之间的关系式，就叫做<strong>状态转移方程。</strong><br>比如，对于LIS问题，我们的第一种定义：</p>
<blockquote>
<p>设<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">为：以数列中第k项结尾的最长递增子序列的长度.设A为题中数列，状态转移方程为：<br><img src="https://www.zhihu.com/equation?tex=F_%7B1%7D+%3D+1" alt="F_{1} = 1"> （根据状态定义导出边界情况）<br><img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D%3Dmax%28F_%7Bi%7D%2B1+%7C+A_%7Bk%7D%3EA_%7Bi%7D%2C+i%5Cin+%281..k-1%29%29+" alt="F_{k}=max(F_{i}+1 | A_{k}"><img src="https://www.zhihu.com/equation?tex=%28k%3E1%29" alt="(k"></p>
</blockquote>
<p>用文字解释一下是：<br>以第k项结尾的LIS的长度是：保证第i项比第k项小的情况下，以第i项结尾的LIS长度加一的最大值，取遍i的所有值（i小于k）。<br>第二种定义：</p>
<blockquote>
<p>设<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D" alt="F_{i, k}">为：在数列前i项中，长度为k的递增子序列中，最后一位的最小值设A为题中数列，状态转移方程为：<br>若<img src="https://www.zhihu.com/equation?tex=A_%7Bi%7D%3EF_%7Bi-1%2Ck-1%7D" alt="A_{i}">则<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2Ck%7D%3Dmin%28A_%7Bi%7D%2CF_%7Bi-1%2Ck%7D%29+" alt="F_{i,k}=min(A_{i},F_{i-1,k}) "><br>否则：<img src="https://www.zhihu.com/equation?tex=F_%7Bi%2Ck%7D%3DF_%7Bi-1%2Ck%7D+" alt="F_{i,k}=F_{i-1,k} "></p>
</blockquote>
<p>（边界情况需要分类讨论较多，在此不列出，需要根据状态定义导出边界情况。）<br>大家套着定义读一下公式就可以了，应该不难理解，就是有点绕。</p>
<p>这里可以看出，这里的状态转移方程，就是定义了问题和子问题之间的关系。<br>可以看出，状态转移方程就是带有条件的递推式。</p>
<h2 id="动态规划迷思"><a href="#动态规划迷思" class="headerlink" title="动态规划迷思"></a>动态规划迷思</h2><h3 id="“缓存”，“重叠子问题”，“记忆化”："><a href="#“缓存”，“重叠子问题”，“记忆化”：" class="headerlink" title="“缓存”，“重叠子问题”，“记忆化”："></a>“缓存”，“重叠子问题”，“记忆化”：</h3><p>这三个名词，都是在阐述递推式求解的技巧。以Fibonacci数列为例，计算第100项的时候，需要计算<u>第99项</u>和98项；在计算第101项的时候，需要第100项和<u>第99项</u>，这时候你还需要重新计算第99项吗？不需要，你只需要在第一次计算的时候把它记下来就可以了。<br>上述的需要再次计算的“第99项”，就叫“重叠子问题”。如果没有计算过，就按照递推式计算，如果计算过，直接使用，就像“缓存”一样，这种方法，叫做“记忆化”，这是递推式求解的技巧。这种技巧，通俗的说叫“花费空间来节省时间”。<strong>都不是动态规划的本质，**</strong>不是动态规划的核心。**</p>
<h3 id="“递归”："><a href="#“递归”：" class="headerlink" title="“递归”："></a>“递归”：</h3><p>递归是递推式求解的方法，连技巧都算不上。</p>
<h3 id="“无后效性”，“最优子结构”："><a href="#“无后效性”，“最优子结构”：" class="headerlink" title="“无后效性”，“最优子结构”："></a>“无后效性”，“最优子结构”：</h3><p>上述的状态转移方程中，等式右边不会用到下标大于左边i或者k的值，这是”无后效性”的通俗上的数学定义，符合这种定义的状态定义，我们可以说它具有“最优子结构”的性质，在动态规划中我们要做的，就是找到这种“最优子结构”。<br><strong>在对状态和状态转移方程的定义过程中，满足“最优子结构”是一个隐含的条件（否则根本定义不出来）。对状态和“最优子结构”的关系的进一步解释，<a href="http://www.zhihu.com/question/23995189/answer/35429905" target="_blank" rel="noopener">什么是动态规划？动态规划的意义是什么？ - 王勐的回答</a> 写的很好，大家可以去读一下。</strong></p>
<p>需要注意的是，一个问题可能有多种不同的状态定义和状态转移方程定义，存在一个有后效性的定义，_<strong>不代表该问题不适用动态规划</strong>_。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>动态规划方法要寻找符合“最优子结构“的状态和状态转移方程的定义<em>，</em>在找到之后，这个问题就可以以“记忆化地求解递推式”的方法来解决。而寻找到的定义，才是动态规划的本质。</strong></p>
]]></content>
      
        <categories>
            
            <category> 算法思想 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法思想 </tag>
            
            <tag> 知乎 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[入门Webpack，看这篇就够了]]></title>
      <url>/%E5%85%A5%E9%97%A8Webpack%EF%BC%8C%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>webpack</code>是现在一款非常流行的<strong>模块化管理工具🔧</strong>，<strong><code>react+webpack+es6</code></strong>是很火的项目构建组合。</p>
<p><img src="https://img.funteas.com/e54cfd22c67adc465dff62272b905fc7?imageView2/2/w/800" alt=""></p>
<blockquote>
<p><code>webpack</code>会将有依赖关系的文件都视为一个模块，比如<code>scss</code>,<code>sass</code>,<code>less</code>,<code>css</code>结尾的文件，这样会产生一个模块群，<code>webpack</code>处理过后会产生可以被浏览器识别的一些文件，比如<code>Js</code>,<code>css</code>,<code>html</code>等。</p>
<p><a href="https://webpack.github.io/" target="_blank" rel="noopener">Webpack</a>在面对大型工程项目时，非常有优势，它最大的特点是很轻，不会加载打包冗余的文件，只会打包项目中用的到的模块。这是<code>webpack</code>的<strong>代码分割</strong>特性～</p>
<p><code>webpack</code>的<strong>模块热更新</strong>特性：当项目文件发生变化时，不需要开发人员手动刷新浏览器，<code>webpack</code>会自动刷新页面，极大地提高了开发效率，是不是很神奇！</p>
</blockquote>
<p><strong>注意：本文的webpack环境是<code>3.5.5</code>由于webpack的更新很快，每次更新都会更新新的语法，所以学习webpack的本质就可以</strong>，具体语法可以看webpack官网：<strong><a href="https://webpack.github.io/" target="_blank" rel="noopener">https://webpack.github.io/</a></strong></p>
<p>那么让我们快速以一个webpack demo的形式开始我们的webpack的学习吧～</p>
<h2 id="webpack处理资源文件：webpack版本：3-5-5"><a href="#webpack处理资源文件：webpack版本：3-5-5" class="headerlink" title="webpack处理资源文件：webpack版本：3.5.5"></a>webpack处理资源文件：webpack版本：3.5.5</h2><p><strong>因为每个版本的文档都会变化所以坑很多，请注意自己的版本</strong></p>
<h2 id="如何在terminal中安装webpack"><a href="#如何在terminal中安装webpack" class="headerlink" title="如何在terminal中安装webpack"></a>如何在terminal中安装webpack</h2><ul>
<li>新建project目录</li>
<li>初始化npm:<pre><code>npm init
</code></pre></li>
<li>安装webpack<pre><code>npm install webpack --save-dev
</code></pre></li>
<li>注意:dev参数是安装到本地项目文件夹下，并将webpack写入到package.json配置文件中的devdependecies参数中。</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fkp0uuy0zxj30di04vwek.jpg" alt=""></p>
<ul>
<li>直接对js文件执行打包：<pre><code>webpack [source.file] [target.file]
</code></pre></li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fkp16i9tk2j30l905u74n.jpg" alt=""></p>
<p><strong>打包执行结果在命令行中的参数：</strong></p>
<ul>
<li><code>hash</code>:这次打包结果文件的hash值。</li>
<li><code>version</code>:webpack的版本。</li>
<li><code>time</code>：这次打包的所耗时间。</li>
<li><code>asset</code>：打包的结果文件。</li>
<li><code>size</code>：打包文件的大小。</li>
<li><code>chunks</code>：打包的入口文件的分块。</li>
<li><code>chunk names</code>：分块的名称。</li>
</ul>
<p>看一下打包结果文件hello.bundle.js的结构：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fkp19bxi7uj30s40bb3yt.jpg" alt=""></p>
<pre><code>/* 2 */
/***/ (function(module, exports, __webpack_require__) {
</code></pre><p>这段代码其实是webpack利用内置的<code>__webpack_require__</code>函数来代替源代码中的require方法来引用相关的文件并插入到bundle文件中：</p>
<p>hello.js入口文件：</p>
<pre><code>require(&#39;./world.js&#39;);
require(&#39;./style.css&#39;);

function function_name(argument) {
    // body...
    alert(argument);
}

function_name(&#39;hello!&#39;);
</code></pre><h2 id="建立项目的webpack配置文件"><a href="#建立项目的webpack配置文件" class="headerlink" title="建立项目的webpack配置文件"></a>建立项目的webpack配置文件</h2><p>新建项目初始目录：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fkp1lrxcrkj304d084glk.jpg" alt=""></p>
<ul>
<li>src：项目源代码目录。<ul>
<li>app.js:打包的入口文件。</li>
<li>components：项目组件目录。</li>
<li>assets:静态资源（图片）目录。</li>
<li>css：css资源目录。</li>
</ul>
</li>
<li>dist：打包后的静态资源目录。</li>
<li><strong>webpack.config.js:webpack的配置文件。</strong><br>以commonjs的模块化方式建立配置文件的框架,添加入口出口文件：</li>
</ul>
<pre><code>module.exports = {
  entry: __dirname + &#39;/src/app.js&#39;;
  output: {
      path: __dirname + &#39;/dist&#39;,
      filename: &#39;js/[name].bundle.js&#39;
  }
}
</code></pre><h3 id="webpack命令方式"><a href="#webpack命令方式" class="headerlink" title="webpack命令方式"></a>webpack命令方式</h3><p><code>npm run webpack</code>命令行运行参数：<br><code>npm run webpack --config webpack.config.js --progress  --colors --display-reasons --watch</code><br><em>这些参数具体的作用后文有写</em></p>
<h3 id="npm脚本执行方式"><a href="#npm脚本执行方式" class="headerlink" title="npm脚本执行方式"></a>npm脚本执行方式</h3><p>在npm的配置文件package.json中的scripts参数配置webpack：</p>
<pre><code>&quot;scripts&quot;: {
    &quot;webpack&quot;: &quot;webpack --config webpack.config.js --progress --colors&quot;
  }
</code></pre><p><em>常用的webpack执行参数：</em></p>
<pre><code>webpack --config webpack.config.js --progress  --colors --display-reasons --watch
</code></pre><ul>
<li><code>--config &lt;指定的webpack配置文件名称&gt;</code>: 指定webpack配置文件来执行webpack命令。</li>
<li><code>progress</code>:打包的过程。</li>
<li><code>--colors</code>:结果输出在命令行是彩色的。</li>
<li><code>--display-reasons</code>:打包的原因。</li>
<li><code>--watch</code>:自动监听项目代码文件的变化，自动执行webpack命令。</li>
</ul>
<h2 id="webpack的打包入口和出口文件配置"><a href="#webpack的打包入口和出口文件配置" class="headerlink" title="webpack的打包入口和出口文件配置"></a>webpack的打包入口和出口文件配置</h2><p>打包文件的路径设置在<em>webpack.config.js</em>文件中的output参数。</p>
<ul>
<li>entry:打包入口文件；<ul>
<li>string:单个入口文件路径。</li>
<li>array:多个入口文件路径。</li>
<li>object:多页面应用中的多个入口文件<ul>
<li>key: 不同页面的代号。</li>
<li>value: 和上面的value规定一样，可以是数组也可以是string。</li>
</ul>
</li>
</ul>
</li>
<li>output:打包出口文件。<ul>
<li><code>path</code>:生成出口文件的存储路径。</li>
<li><code>filename</code>:打包文件的名称（使用相对路径，不要使用绝对路径）</li>
<li><code>publicPath</code>:上线之后的项目路径。一旦配置了这个路径，所有路径都以这种路径为主。<br>具体配置如下：<pre><code>entry: __dirname + &#39;src/app.js&#39;,
output: {
  /**
   * __dirname: absolute file path
   * @type {[type]}
   */
  path:__dirname + &#39;/dist&#39;,
  /**
   * [name]: entry&#39;s chunck&#39;s key
   * [chunkhash]: file&#39;s md5 value(file version)
   * @type {String}
   */
  filename: &#39;js/[name].bundle.js&#39;,
  publicPath: &#39;http://cdn.com/&#39;
}
</code></pre><strong><code>path</code>之前要加<code>__dirname</code>，否则会报错，这是个坑，<code>__dirname</code>在nodejs语法中代表文件所在目录的绝对路径。</strong></li>
</ul>
</li>
</ul>
<h2 id="Webpack如何在项目自动生成html文件"><a href="#Webpack如何在项目自动生成html文件" class="headerlink" title="Webpack如何在项目自动生成html文件"></a>Webpack如何在项目自动生成html文件</h2><p>由于我们index页面中1引用的js文件有可能会带hash（每次打包都会变化）。这样我们每次都得手动改变INDEX页面中引用js的代码，非常麻烦。</p>
<p>那么如何在html中使用动态生成的打包后的文件呢？</p>
<ul>
<li>通过<code>html-webpack-plugin</code>这个插件自定义<code>html</code>，并且通过模版和其参数，使用外联的方式传入<code>scirpt</code>动态文件；<ul>
<li>我们可以使用WEbpakc的另一个核心的功能：<strong><code>plugins</code></strong><br>在webpack配置文件中配置<code>plugins</code>参数：</li>
</ul>
</li>
</ul>
<pre><code>plugins: [
        new htmlWebpackPlugin()
    ]
</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fkp2oj1rzvj30oi03474i.jpg" alt="打包效果：生成了相应的INDEX.html"><br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fkp2pvnon8j30v801tq2y.jpg" alt="dist打包目录下index页面中引入了相应的出口文件:bundle.js"></p>
<ul>
<li><p>通过向上述插件的模版中传入参数：</p>
<ul>
<li>一个对象：<ul>
<li><code>filename</code>:生成html文件的名称</li>
<li><code>template</code>:模版文件的相对路径（<strong>上下文环境是webpack.config.js文件的路径</strong>）</li>
<li><code>injecet</code>:script文件嵌入到html文件的哪个部分。</li>
<li><code>chunks</code>:</li>
<li><code>minify</code>:压缩选项。<ul>
<li><code>removeComments</code>:删除注释</li>
<li><code>collapseWhitespace</code>：删除空格<pre><code>plugins: [
new htmlWebpackPlugin({
filename: &#39;index.html&#39;,
template: &#39;index.html&#39;,
injecet: &#39;body&#39;,
chunks: [&#39;main&#39;],
minify: {
  removeComments: true,
  collapseWhitespace: true
}
})
]
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>同时htmlwebpackplugin也支持从WEbpack.config.js文件中向html页面中传入参数，支持ejs的语法形式，比如我们在htmlwebpackplugin传入相应参数：</p>
<pre><code>plugins: [
      new htmlWebpackPlugin({
          filename: &#39;index.html&#39;,
          template: &#39;index.html&#39;,
          // the position of script file to the html
          inject: &#39;body&#39;,
          title: &#39;this is c.html&#39;,
          date: new Date(),
      })
  ]
</code></pre><p>在模版文件中加入下列测试代码来引用传入的title和date变量：</p>
<pre><code>&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title%&gt;&lt;/title&gt;
</code></pre></li>
</ul>
<ul>
<li>如何通过上述插件<code>inline</code>的形式引用出口<code>js</code>文件：<ul>
<li>我们可以通过webpack暴露给我们的引用变量去获取相应的js文件。<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
  &lt;%= compilation.assets[htmlWebpackPlugin.files.chunks.main.entry.substr(htmlWebpackPlugin.files.publicPath.length)].source() %&gt;
&lt;/script&gt;
</code></pre><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fkp41iss8ej30v80ifwg3.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fkp48exje5j30ni0cc74p.jpg" alt="这样也会将相应的出口打包js文件引入进html文件中"></li>
</ul>
</li>
<li>我们也可以通过外链的形式在模版文件中自定义引入特定的js文件。<pre><code>&lt;% for(var k in htmlWebpackPlugin.files.chunks) { %&gt;
      &lt;% if(k != &#39;main&#39;) { %&gt;
          &lt;script type=&quot;text/javascript&quot; src=&#39;&lt;%= htmlWebpackPlugin.files.chunks[k].entry%&gt;&#39;&gt;&lt;/script&gt;
      &lt;% }%&gt;
  &lt;% }%&gt;
</code></pre><strong>以上代码可以实现main的js文件以内联的形式引入到html文件中，而其他js文件以外链的形式引入到html文件。</strong></li>
</ul>
<h3 id="多页面应用的配置"><a href="#多页面应用的配置" class="headerlink" title="多页面应用的配置"></a>多页面应用的配置</h3><p>多页面应用环境下，需要配置多个入口文件，配置多个htmlwebpackplugin插件从而生成多个html文件。<br>配置如下：</p>
<pre><code>module.exports = {
    entry: {
        main: &#39;./src/script/main.js&#39;,
        a: &#39;./src/script/a.js&#39;,
        b: &#39;./src/script/b.js&#39;,
        c: &#39;./src/script/c.js&#39;,
    },
    plugins: [
        new htmlWebpackPlugin({
            filename: &#39;a.html&#39;,
            template: &#39;index.html&#39;,
            // the position of script file to the html
            inject: false,
            title: &#39;this is a.html&#39;,
            // param can be got in html
            date: new Date(),
            chunks: [&#39;main&#39;,&#39;a&#39;]
        }),
        new htmlWebpackPlugin({
            filename: &#39;b.html&#39;,
            template: &#39;index.html&#39;,
            // the position of script file to the html
            inject: false,
            title: &#39;this is b.html&#39;,
            date: new Date(),
            chunks: [&#39;b&#39;]
        }),
        new htmlWebpackPlugin({
            filename: &#39;c.html&#39;,
            template: &#39;index.html&#39;,
            // the position of script file to the html
            inject: false,
            title: &#39;this is c.html&#39;,
            date: new Date(),
            excludeChunks: [&#39;c&#39;]
        })
    ]
}
</code></pre><p><em><code>chunks</code>:定义引入的chunk文件。</em><br><em><code>excludeChunks</code>:定义不引入的chunk文件。</em></p>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>loader和plugins无疑是<code>webpack</code>重要的两个概念。</p>
<h3 id="什么是Loader？"><a href="#什么是Loader？" class="headerlink" title="什么是Loader？"></a>什么是Loader？</h3><p>loader可以用来处理资源文件，接受资源文件作为参数，loader处理之后返回一个新的文件。</p>
<h3 id="Loader的特性"><a href="#Loader的特性" class="headerlink" title="Loader的特性"></a>Loader的特性</h3><ul>
<li>可串联</li>
<li>同步和异步的</li>
<li>可以接受参数</li>
<li>可以根据文件的正则表达式来处理特定文件</li>
<li>可以根据<code>npm</code>安装</li>
<li>获取webpack config的配置</li>
<li>loader可以生成额外的文件</li>
</ul>
<h3 id="使用loader的方式"><a href="#使用loader的方式" class="headerlink" title="使用loader的方式"></a>使用loader的方式</h3><ul>
<li>在require声明的路径前面配置。</li>
<li><strong>配置文件中配置（webpack.config.js）</strong></li>
<li>cli：在命令行中通过参数指定loader。</li>
</ul>
<h3 id="使用babel-loader转换es6语法"><a href="#使用babel-loader转换es6语法" class="headerlink" title="使用babel-loader转换es6语法"></a>使用babel-loader转换es6语法</h3><ul>
<li>安装babel-loader<br><em>命令行安装<code>babel-loader</code></em>：<pre><code>npm install babel-loader babel-core webpack --save-dev
</code></pre></li>
<li>配置babel-loader：<ul>
<li>配置test属性<br>test属性是一个正则表达式，loader会处理相应后缀的文件。</li>
<li>配置options属性<br>给options添加一个presets对象，值是一个数组，数组里面的值是指定loader如何去处理js文件，如果参数是<code>env</code>，代表用最新的es6语法去处理js文件。<ul>
<li>需要安装<code>presets</code>插件:<pre><code>npm install babel-preset-env --save-dev
</code></pre></li>
<li>配置presets属性<pre><code>      options: {
          // set the version of es6
          presets: [&#39;env&#39;]
      }
</code></pre></li>
</ul>
</li>
<li>配置<code>exclude</code>和<code>include</code>属性<br>配置exclude 和 include属性可以指定babel-loader处理的文件范围。<br><strong>注意⚠️：include和exclude属性必须是绝对路径，且使用绝对路径会加快loader找到相应文件的速度。</strong><br><strong>我们可以使用nodejs自带的api–path将相对路径解析相应的绝对路径：</strong><pre><code>var path = require(&#39;path&#39;);
path.resolve(__dirname, &#39;./node_modules&#39;);
</code></pre><em><code>__dirname</code>是<code>nodejs</code>中的绝对路径变量。</em></li>
</ul>
</li>
</ul>
<h3 id="使用loader处理css文件"><a href="#使用loader处理css文件" class="headerlink" title="使用loader处理css文件"></a>使用loader处理css文件</h3><ul>
<li>处理css文件<ul>
<li>安装<code>css-loader</code>,<code>style-loader</code>,<code>postcss-loader</code><pre><code>npm install --save-dev css-loader style-loader postcss-loader
</code></pre></li>
<li>入口文件app.js中引入css文件<pre><code>import &#39;./css/common.css&#39;;
</code></pre></li>
<li>配置对css文件的处理设置：<ul>
<li>use属性：loader数组。<br>使用多个loader对css文件处理。<br><strong>注意：⚠️loader处理方式是从右到左，数组的话就是从下往上。</strong></li>
</ul>
</li>
<li><code>postcss-loader</code>处理css文件<br><code>postcss-loader</code>是处理css文件的后处理器，可以实现加浏览器前缀等等功能。<code>postcss-loader</code>应该最先处理css文件。<br><strong>plugins属性是一个函数，这个函数会返回一个引入的插件的数组</strong><ul>
<li>配置<code>postcss-loader</code><ul>
<li>安装<code>autoprefixer</code>插件。<br><code>autoprefixer</code>插件可以自动根据浏览器版本种类添加前缀。<pre><code>npm install autoprefixer --save-dev
</code></pre></li>
<li>配置相应的plugins参数:<br><code>root</code>参数：表明插件处理文件的路径的根路径（从哪开始解析）</li>
<li>安装<code>postcss-import</code>    插件<br>处理在css文件中通过<code>@import</code>进来的资源文件。        </li>
<li>配置相应的plugins参数：<br><code>broswers</code>参数是处理浏览器版本的列表。<code>&#39;last 5 versions&#39;</code>代表支持最新的五个版本的浏览器。<pre><code>options: {
plugins: function () {
    return [
        require(&#39;postcss-import&#39;)({
        // this represent loader variable
            root:this.resourcePath
        }),
        require(&#39;autoprefixer&#39;)({
            broswers: [&#39;last 5 versions&#39;]
        })
      ]
}
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>注意postcss-loader预处理器的配置</em><br><strong><code>css-loader</code>保证webpack可以打包css模块</strong><br><strong><code>style-loader</code>保证可以在<code>js</code>文件中引入<code>css</code>代码，以<code>&lt;style&gt;</code>标签的形式加入到<code>html</code>中并显示其效果</strong></p>
<h3 id="使用less-loader，sass-loader处理css易处理语言"><a href="#使用less-loader，sass-loader处理css易处理语言" class="headerlink" title="使用less-loader，sass-loader处理css易处理语言"></a>使用less-loader，sass-loader处理css易处理语言</h3><p><strong>步骤</strong>：先用<code>less-loader</code>去处理<code>less</code>文件转换成<code>css</code>文件，再将<code>css</code>文件用<code>postcss-loader</code>预处理<code>css</code>文件，加上前缀等之类的功能，再用<code>css-loader</code>处理<code>css</code>文件中的<code>url</code>引用表达式，然后解析相关引用资源，最后使用<code>style-loader</code>处理<code>css</code>文件，将<code>css</code>代码插入到页面上。</p>
<ul>
<li>安装<code>less-loader</code>和<code>sass-loader</code><pre><code>npm install --save-dev less-loader sass-loader
</code></pre></li>
<li>配置<code>loader</code><pre><code>// less loader
    {
      test: /\.less$/,
      use: [
          {
          loader: &quot;style-loader&quot; // creates style nodes from JS strings 
        }, 
        {
            loader: &quot;css-loader&quot; // translates CSS into CommonJS 
              },
              { 
                loader: &#39;postcss-loader&#39;,
                // some plugins of postcss-loader:some options
                options: {
                    plugins: function () {
                        return [
                            require(&#39;postcss-import&#39;)({
                                root:this.resourcePath
                            }),
                            require(&#39;autoprefixer&#39;)({
                                broswers: [&#39;last 5 versions&#39;]
                            })
                        ]
                    }
                  }
              },
              {
               loader: &quot;less-loader&quot; // compiles Less to CSS 
             }
         ]
    },
    // sass loader
    {
      test: /\.scss$/,
      use: [
          {
          loader: &quot;style-loader&quot; // creates style nodes from JS strings 
        }, 
        {
            loader: &quot;css-loader&quot; // translates CSS into CommonJS 
              },
              { 
                loader: &#39;postcss-loader&#39;,
                // some plugins of postcss-loader:some options
                options: {
                    plugins: function () {
                        return [
                            require(&#39;postcss-import&#39;)({
                                root:this.resourcePath
                            }),
                            require(&#39;autoprefixer&#39;)({
                                broswers: [&#39;last 5 versions&#39;]
                            })
                        ]
                    }
                  }
              },
              {
               loader: &quot;sass-loader&quot; // compiles Less to CSS 
             }
         ]
    }
</code></pre></li>
</ul>
<h3 id="loader处理模版文件"><a href="#loader处理模版文件" class="headerlink" title="loader处理模版文件"></a>loader处理模版文件</h3><p>模版文件通常是生成html文件的模版。webpack有很多loader处理这些模版文件，包括ejs，jade或者html等等编写的模版。</p>
<h4 id="html-loader"><a href="#html-loader" class="headerlink" title="html-loader"></a><code>html-loader</code></h4><p><code>html-loader</code>会将html模版文件当成<strong>字符串</strong>来处理。<br>安装<code>html-loader</code></p>
<pre><code>npm install --save-dev html-loader
</code></pre><ul>
<li>html格式的模版文件<pre><code>&lt;div class=&quot;layer&quot;&gt;
  &lt;div&gt;this is html template file&lt;/div&gt;
&lt;/div&gt;
</code></pre></li>
<li>在js文件中引入tpl模版文件<pre><code>import tpl from &#39;./layer.tpl&#39;;
function layer() {
  return {
      name: &#39;layer&#39;,
      tpl: tpl 
  }
}
export default layer;
</code></pre><em>layer.js</em></li>
<li>在入口文件中引用<pre><code>import Layer from &#39;./components/layer/layer.js&#39;;
const App = function () {
  let dom = document.getElementById(&#39;app&#39;);
  let layer = Layer();
  // layer is a function
  dom.innerHTML = layer.tpl;
}
new App();
</code></pre><em>app.js</em><h4 id="ejs-loader"><a href="#ejs-loader" class="headerlink" title="ejs-loader"></a><code>ejs-loader</code></h4><code>ejs-loader</code>可以处理<code>ejs</code>,<code>tpl</code>格式的模版文件。</li>
<li>用ejs语法编写tpl文件<pre><code>&lt;div class=&quot;layer&quot;&gt;
  &lt;div&gt;this is &lt;%= name%&gt; layer&lt;/div&gt;
  &lt;% for(let i = 0;i &lt; arr.length; i ++) { %&gt;
      &lt;%= arr[i] %&gt;
  &lt;% }%&gt;
&lt;/div&gt;
</code></pre></li>
<li><p>在js文件中引入tpl模版文件。</p>
<pre><code>import tpl from &#39;./layer.tpl&#39;;
function layer() {
  return {
      name: &#39;layer&#39;,
      tpl: tpl 
  }
}
export default layer;
</code></pre><p><em>layer.js</em></p>
</li>
<li><p>在入口文件中引用</p>
<pre><code>import Layer from &#39;./components/layer/layer.js&#39;;
const App = function () {
  let dom = document.getElementById(&#39;app&#39;);
  let layer = Layer();
  // layer is a function
  dom.innerHTML = layer.tpl({
      name: &#39;Jobs&#39;,
      arr: [&#39;apple&#39;,&#39;xiaomi&#39;,&#39;oppo&#39;]
  });
}
new App();
</code></pre><p><em><code>app.js</code></em></p>
</li>
</ul>
<h3 id="loader处理图片资源文件"><a href="#loader处理图片资源文件" class="headerlink" title="loader处理图片资源文件"></a>loader处理图片资源文件</h3><p>图片往往是影响网页加载速度的罪魁祸首，<code>webpack</code>可以在项目上线之前通过loader处理大量的资源文件，优化网页加载速度。</p>
<h4 id="项目中通常三个地方会用到图片"><a href="#项目中通常三个地方会用到图片" class="headerlink" title="项目中通常三个地方会用到图片"></a>项目中通常三个地方会用到图片</h4><ul>
<li>根目录的<code>index.html</code>入口文件里使用；</li>
<li><code>less</code>,<code>sass</code>,<code>css</code>样式文件中引用图片；</li>
<li>模版文件中引用图片；<br><strong> 注意 ：</strong>如果在模版文件中如果要使用相对路径引用文件，<strong>则必须使用<code>require</code>引用文件</strong><pre><code>    &lt;img src=&quot;${ require(&#39;../../assets/logo36x36.png&#39;) }&quot;&gt;
</code></pre><em>模版文件中的图片引用</em></li>
</ul>
<h4 id="处理图片文件的loader通常有"><a href="#处理图片文件的loader通常有" class="headerlink" title="处理图片文件的loader通常有"></a>处理图片文件的loader通常有</h4><ul>
<li><code>file-loader</code>：可以处理引用本地图片文件。</li>
<li><code>url-loader</code>：可以按情况处理图片或者其他文件,通常处理重复性不高的http请求的小文件。当文件大小大于指定<code>limit</code>参数（byte为单位），则交给<code>file-loader</code>处理，如果小于这个<code>limit</code>则将图片和文件转位<a href="https://www.baidu.com/link?url=nBogYLNyNQjNiBpP1-dQPajqi7kfFr7JQIidMwG3Df2kmrGeX3sRBICHh3YWgg3uFUxAzTWAERCqc8Jf17ogTq&amp;wd=&amp;eqid=b931441300012bda0000000659ef4dd4" target="_blank" rel="noopener">BASE64</a>编码。</li>
<li><code>image-webpack-loader</code>: 压缩http请求的图片。</li>
</ul>
<h4 id="使用上述三个loader处理图片文件"><a href="#使用上述三个loader处理图片文件" class="headerlink" title="使用上述三个loader处理图片文件"></a>使用上述三个loader处理图片文件</h4><p><em><code>loader</code>配置</em></p>
<pre><code>// picture loader
            {
                test: /\.(png|jpg|gif|svg)$/,
                use: [
                    {
                        loader: &#39;file-loader&#39;,
                        options: {
                            name: &#39;assets/[name]-[hash:5].[ext]&#39;
                        }
                    },
                    // {
                    //     loader: &#39;url-loader&#39;,
                    //     options: {
                    //         limit: 200000,
                    //         name: `assets/[name]-[hash:5].[ext]`
                    //     }
                    // },
                    {
                        loader: &#39;image-webpack-loader&#39;
                    }
                ]
            },
</code></pre><ul>
<li><strong>重复性大的图片推荐通过http请求，这样会有缓存，优化加载速度</strong></li>
<li><strong>小的图片重复性不大的图片可以用base64编码，使用<code>url-loader</code>去处理</strong></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个webpack的demo工程我都亲自在Mac环境下测试并运行成功，上传到了github，这里是地址：<br><a href="https://github.com/PancakeAwesome/webpack-demo-test" target="_blank" rel="noopener">demo1传送门</a><br><a href="https://github.com/PancakeAwesome/PancakeAwesome.github.io" target="_blank" rel="noopener">demo2传送门</a><br>下面贴下我完整的<code>webpack.config.js</code>和<code>pacakge.json</code>的代码：<strong>由于webpack版本更新很快情注意自己的版本，最新语法去<a href="https://webpack.github.io/" target="_blank" rel="noopener">官网查看</a></strong></p>
<p><code>webpack.config.js</code></p>
<pre><code>var htmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
var path = require(&#39;path&#39;);

module.exports = {    
    // the door file of webpack packaging
    // entry: &#39;./src/script/main.js&#39;,
    // entry: [&#39;./src/script/main.js&#39;,&#39;./src/script/a.js&#39;],
    entry: __dirname + &#39;/src/app.js&#39;,
    output: {
        /**
         * __dirname: absolute file path
         * @type {[type]}
         */
        path:__dirname + &#39;/dist&#39;,
        /**
         * [name]: entry&#39;s chunck&#39;s key
         * [chunkhash]: file&#39;s md5 value(file version)
         * @type {String}
         */
        filename: &#39;js/[name].bundle.js&#39;,
    },
    /**
     * webpack loader param
     * @type {Object}
     */
    module: {
        loaders: [
            // html loader
            {
                test: /\.html$/,
                loader: &#39;html-loader&#39;
            },
            // ejs loader (template loader)
            {
                test: /\.tpl$/,
                loader: &#39;ejs-loader&#39;
            },
            // js loader(babel loader)
            {
                test: /\.js$/,
                loader: &#39;babel-loader&#39;,
                include: path.resolve(__dirname,&#39;src&#39;),
                // exclude: __dirname + &#39;./node_modules/&#39;,
                exclude: path.resolve(__dirname,&#39;node_modules&#39;),
                // param of loader
                options: {
                    // set the version of es6
                    presets: [&#39;env&#39;]
                }
            },
            // css loader : postcss-loader,css-loader,style-loader
            {
        test: /\.css$/,
        use: [
            {
                  loader:&#39;style-loader&#39;
              },
              {
                loader:&#39;css-loader&#39;
              },
              { 
                  loader: &#39;postcss-loader&#39;,
                  // some plugins of postcss-loader:some options
                  options: {
                      plugins: (loader) =&gt; [
                          require(&#39;postcss-import&#39;)({
                              // this represent loader variable
                              root:loader.resourcePath
                          }),
                          require(&#39;autoprefixer&#39;)({
                              broswers: [&#39;last 5 versions&#39;]
                          })
                      ]
                    }
                }
            ]    
            },
          // less loader
          {
            test: /\.less$/,
            use: [
                {
                loader: &quot;style-loader&quot; // creates style nodes from JS strings 
              }, 
              {
              loader: &quot;css-loader&quot; // translates CSS into CommonJS 
                },
                { 
                  loader: &#39;postcss-loader&#39;,
                  // some plugins of postcss-loader:some options
                  options: {
                      plugins: function () {
                          return [
                              require(&#39;postcss-import&#39;)({
                                  root:this.resourcePath
                              }),
                              require(&#39;autoprefixer&#39;)({
                                  broswers: [&#39;last 5 versions&#39;]
                              })
                              ]
                      }
                    }
                },
                {
                 loader: &quot;less-loader&quot; // compiles Less to CSS 
               }
               ]
          },
          // sass loader
          {
            test: /\.scss$/,
            use: [
                {
                loader: &quot;style-loader&quot; // creates style nodes from JS strings 
              }, 
              {
                  loader: &quot;css-loader&quot; // translates CSS into CommonJS 
                },
                { 
                  loader: &#39;postcss-loader&#39;,
                  // some plugins of postcss-loader:some options
                  options: {
                      plugins: function () {
                          return [
                              require(&#39;postcss-import&#39;)({
                                  root:this.resourcePath
                              }),
                              require(&#39;autoprefixer&#39;)({
                                  broswers: [&#39;last 5 versions&#39;]
                              })
                              ]
                      }
                    }
                },
                {
                 loader: &quot;sass-loader&quot; // compiles sess to CSS 
               }
               ]
          },
            // picture loader
            {
                test: /\.(png|jpg|gif|svg)$/,
                // loaders: [
                //     // &#39;file-loader?name=assets/[name]-[hash:5].[ext]&#39;,
                //     &#39;url-loader?limit=200000&amp;name=assets/[name]-[hash:5].[ext]&#39;,
                //     &#39;image-webpack-loader&#39;
                // ]
                use: [
                    {
                        loader: &#39;file-loader&#39;,
                        options: {
                            name: &#39;assets/[name]-[hash:5].[ext]&#39;
                        }
                    },
                    // {
                    //     loader: &#39;url-loader&#39;,
                    //     options: {
                    //         limit: 200000,
                    //         name: `assets/[name]-[hash:5].[ext]`
                    //     }
                    // },
                    {
                        loader: &#39;image-webpack-loader&#39;
                    }
                ]
            },
        ]
    },
    plugins: [
        new htmlWebpackPlugin({
            filename: &#39;index.html&#39;,
            template: &#39;index.html&#39;,
            injecet: &#39;body&#39;
        })
    ]
}
</code></pre><p><code>pacage.json</code></p>
<pre><code>{
  &quot;name&quot;: &quot;webpack-demo&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;webpack&quot;: &quot;webpack --config webpack.config.js --progress  --colors&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;autoprefix&quot;: &quot;^1.0.1&quot;,
    &quot;babel-core&quot;: &quot;^6.26.0&quot;,
    &quot;babel-loader&quot;: &quot;^7.1.2&quot;,
    &quot;babel-preset-env&quot;: &quot;^1.6.0&quot;,
    &quot;babel-preset-latest&quot;: &quot;^6.24.1&quot;,
    &quot;css-loader&quot;: &quot;^0.28.7&quot;,
    &quot;ejs-loader&quot;: &quot;^0.3.0&quot;,
    &quot;file-loader&quot;: &quot;^0.11.2&quot;,
    &quot;html-loader&quot;: &quot;^0.5.1&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;,
    &quot;image-webpack-loader&quot;: &quot;^3.4.2&quot;,
    &quot;less&quot;: &quot;^2.7.2&quot;,
    &quot;less-loader&quot;: &quot;^4.0.5&quot;,
    &quot;node-sass&quot;: &quot;^4.5.3&quot;,
    &quot;postcss-import&quot;: &quot;^10.0.0&quot;,
    &quot;postcss-loader&quot;: &quot;^2.0.6&quot;,
    &quot;sass&quot;: &quot;^1.0.0-beta.2&quot;,
    &quot;sass-loader&quot;: &quot;^6.0.6&quot;,
    &quot;style-loader&quot;: &quot;^0.18.2&quot;,
    &quot;url-loader&quot;: &quot;^0.5.9&quot;,
    &quot;webpack&quot;: &quot;^3.5.5&quot;
  }
}
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端技术 </tag>
            
            <tag> 前端工具 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
